
obj/user/graphics:     file format elf64-x86-64


Disassembly of section .text:

0000000000800000 <__text_start>:
.globl _start
_start:
    # See if we were started with arguments on the stack

#ifndef CONFIG_KSPACE
    movabs $USER_STACK_TOP, %rax
  800000:	48 b8 00 70 ff ff 7f 	movabs $0x7fffff7000,%rax
  800007:	00 00 00 
    cmpq %rax, %rsp
  80000a:	48 39 c4             	cmp    %rax,%rsp
    jne args_exist
  80000d:	75 04                	jne    800013 <args_exist>

    # If not, push dummy argc/argv arguments.
    # This happens when we are loaded by the kernel,
    # because the kernel does not know about passing arguments.
    # Marking argc and argv as zero.
    pushq $0
  80000f:	6a 00                	push   $0x0
    pushq $0
  800011:	6a 00                	push   $0x0

0000000000800013 <args_exist>:

args_exist:
    movq 8(%rsp), %rsi
  800013:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    movq (%rsp), %rdi
  800018:	48 8b 3c 24          	mov    (%rsp),%rdi
    xorl %ebp, %ebp
  80001c:	31 ed                	xor    %ebp,%ebp
    call libmain
  80001e:	e8 c6 02 00 00       	call   8002e9 <libmain>
    jmp .
  800023:	eb fe                	jmp    800023 <args_exist+0x10>

0000000000800025 <draw_pixel>:

int DISPLAY_WIDTH = 0;
int DISPLAY_HEIGHT = 0;

void draw_pixel(char *buf, int x, int y, int color) {
   buf[y * DISPLAY_WIDTH + x] = color;  
  800025:	48 b8 04 50 81 00 00 	movabs $0x815004,%rax
  80002c:	00 00 00 
  80002f:	0f af 10             	imul   (%rax),%edx
  800032:	01 f2                	add    %esi,%edx
  800034:	48 63 d2             	movslq %edx,%rdx
  800037:	88 0c 17             	mov    %cl,(%rdi,%rdx,1)
}
  80003a:	c3                   	ret    

000000000080003b <draw_line>:

void draw_line(char* buf, int x0, int y0, int x1, int y1, int color)
{
  80003b:	55                   	push   %rbp
  80003c:	48 89 e5             	mov    %rsp,%rbp
  80003f:	53                   	push   %rbx
    int dx, dy, p, x, y;
 
	dx = x1 - x0;
  800040:	89 cb                	mov    %ecx,%ebx
  800042:	29 f3                	sub    %esi,%ebx
	dy = y1 - y0;
  800044:	41 29 d0             	sub    %edx,%r8d
 
	x = x0;
	y = y0;
 
	p = 2 * dy - dx;
  800047:	45 01 c0             	add    %r8d,%r8d
  80004a:	44 89 c0             	mov    %r8d,%eax
  80004d:	29 d8                	sub    %ebx,%eax
 
	while(x < x1)
  80004f:	39 f1                	cmp    %esi,%ecx
  800051:	7e 49                	jle    80009c <draw_line+0x61>
  800053:	49 89 fa             	mov    %rdi,%r10
  800056:	89 d7                	mov    %edx,%edi
	{
		if(p >= 0)
		{
			draw_pixel(buf, x, y, color);
			y = y + 1;
			p= p + 2 * dy - 2 * dx;
  800058:	01 db                	add    %ebx,%ebx
   buf[y * DISPLAY_WIDTH + x] = color;  
  80005a:	49 bb 04 50 81 00 00 	movabs $0x815004,%r11
  800061:	00 00 00 
  800064:	eb 1e                	jmp    800084 <draw_line+0x49>
  800066:	89 fa                	mov    %edi,%edx
  800068:	41 0f af 13          	imul   (%r11),%edx
  80006c:	01 f2                	add    %esi,%edx
  80006e:	48 63 d2             	movslq %edx,%rdx
  800071:	45 88 0c 12          	mov    %r9b,(%r10,%rdx,1)
			y = y + 1;
  800075:	83 c7 01             	add    $0x1,%edi
			p= p + 2 * dy - 2 * dx;
  800078:	44 01 c0             	add    %r8d,%eax
  80007b:	29 d8                	sub    %ebx,%eax
		else
		{
			draw_pixel(buf, x, y, color);
			p = p + 2 * dy;
		}
		x = x + 1;
  80007d:	83 c6 01             	add    $0x1,%esi
	while(x < x1)
  800080:	39 f1                	cmp    %esi,%ecx
  800082:	74 18                	je     80009c <draw_line+0x61>
		if(p >= 0)
  800084:	85 c0                	test   %eax,%eax
  800086:	79 de                	jns    800066 <draw_line+0x2b>
   buf[y * DISPLAY_WIDTH + x] = color;  
  800088:	89 fa                	mov    %edi,%edx
  80008a:	41 0f af 13          	imul   (%r11),%edx
  80008e:	01 f2                	add    %esi,%edx
  800090:	48 63 d2             	movslq %edx,%rdx
  800093:	45 88 0c 12          	mov    %r9b,(%r10,%rdx,1)
			p = p + 2 * dy;
  800097:	44 01 c0             	add    %r8d,%eax
  80009a:	eb e1                	jmp    80007d <draw_line+0x42>
	}
}
  80009c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8000a0:	c9                   	leave  
  8000a1:	c3                   	ret    

00000000008000a2 <draw_rectangle>:


//position of upper left corner x, y
void draw_rectangle(char *buf, int x, int y, int width, int height, int color) {
  8000a2:	55                   	push   %rbp
  8000a3:	48 89 e5             	mov    %rsp,%rbp
  8000a6:	41 57                	push   %r15
  8000a8:	41 56                	push   %r14
  8000aa:	41 55                	push   %r13
  8000ac:	41 54                	push   %r12
  8000ae:	53                   	push   %rbx
  8000af:	48 83 ec 18          	sub    $0x18,%rsp
  8000b3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8000b7:	44 89 4d c4          	mov    %r9d,-0x3c(%rbp)
    if (x + width > DISPLAY_WIDTH || y + height > DISPLAY_HEIGHT)
  8000bb:	44 8d 2c 0e          	lea    (%rsi,%rcx,1),%r13d
  8000bf:	48 b8 04 50 81 00 00 	movabs $0x815004,%rax
  8000c6:	00 00 00 
  8000c9:	44 3b 28             	cmp    (%rax),%r13d
  8000cc:	7f 46                	jg     800114 <draw_rectangle+0x72>
  8000ce:	41 89 f6             	mov    %esi,%r14d
  8000d1:	89 d3                	mov    %edx,%ebx
  8000d3:	44 01 c2             	add    %r8d,%edx
  8000d6:	48 b8 00 50 81 00 00 	movabs $0x815000,%rax
  8000dd:	00 00 00 
  8000e0:	3b 10                	cmp    (%rax),%edx
  8000e2:	7f 30                	jg     800114 <draw_rectangle+0x72>
        return;
    for (int i = 0; i < height; ++i) {
  8000e4:	45 85 c0             	test   %r8d,%r8d
  8000e7:	7e 2b                	jle    800114 <draw_rectangle+0x72>
  8000e9:	41 89 d4             	mov    %edx,%r12d
        draw_line(buf, x, y, x + width, y, color);
  8000ec:	49 bf 3b 00 80 00 00 	movabs $0x80003b,%r15
  8000f3:	00 00 00 
  8000f6:	44 8b 4d c4          	mov    -0x3c(%rbp),%r9d
  8000fa:	41 89 d8             	mov    %ebx,%r8d
  8000fd:	44 89 e9             	mov    %r13d,%ecx
  800100:	89 da                	mov    %ebx,%edx
  800102:	44 89 f6             	mov    %r14d,%esi
  800105:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  800109:	41 ff d7             	call   *%r15
        ++y;
  80010c:	83 c3 01             	add    $0x1,%ebx
    for (int i = 0; i < height; ++i) {
  80010f:	41 39 dc             	cmp    %ebx,%r12d
  800112:	75 e2                	jne    8000f6 <draw_rectangle+0x54>
    }
        
        
}
  800114:	48 83 c4 18          	add    $0x18,%rsp
  800118:	5b                   	pop    %rbx
  800119:	41 5c                	pop    %r12
  80011b:	41 5d                	pop    %r13
  80011d:	41 5e                	pop    %r14
  80011f:	41 5f                	pop    %r15
  800121:	5d                   	pop    %rbp
  800122:	c3                   	ret    

0000000000800123 <umain>:

void umain(int argc, char **argv) {
  800123:	55                   	push   %rbp
  800124:	48 89 e5             	mov    %rsp,%rbp
  800127:	53                   	push   %rbx
  800128:	48 83 ec 48          	sub    $0x48,%rsp
   
    binaryname = "graphics";
  80012c:	48 b8 10 14 81 00 00 	movabs $0x811410,%rax
  800133:	00 00 00 
  800136:	48 a3 00 40 81 00 00 	movabs %rax,0x814000
  80013d:	00 00 00 
    FRAMEBUFFER_CONTEXT context;
    int res = FramebufferInit(&context);
  800140:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  800144:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  80014b:	00 00 00 
  80014e:	ff d0                	call   *%rax
    if (res < 0) {
  800150:	85 c0                	test   %eax,%eax
  800152:	0f 88 e2 00 00 00    	js     80023a <umain+0x117>
        cprintf("error %i\n", res);
        exit();
    }
    DISPLAY_WIDTH = context.width;
  800158:	8b 75 c8             	mov    -0x38(%rbp),%esi
  80015b:	89 f0                	mov    %esi,%eax
  80015d:	a3 04 50 81 00 00 00 	movabs %eax,0x815004
  800164:	00 00 
    DISPLAY_HEIGHT = context.height;
  800166:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800169:	89 d0                	mov    %edx,%eax
  80016b:	a3 00 50 81 00 00 00 	movabs %eax,0x815000
  800172:	00 00 
    cprintf("width: %d, height: %d, bpp: %d framebuffer_size: %d\n", context.width, 
  800174:	44 8b 45 d8          	mov    -0x28(%rbp),%r8d
  800178:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  80017b:	48 bf 78 14 81 00 00 	movabs $0x811478,%rdi
  800182:	00 00 00 
  800185:	b8 00 00 00 00       	mov    $0x0,%eax
  80018a:	48 bb 67 04 80 00 00 	movabs $0x800467,%rbx
  800191:	00 00 00 
  800194:	ff d3                	call   *%rbx
                                                                    context.height, 
                                                                    context.bits_per_pixel,
                                                                    context.size);
    cprintf("front: %p, back: %p\n", context.front, context.back);
  800196:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80019a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  80019e:	48 bf 23 14 81 00 00 	movabs $0x811423,%rdi
  8001a5:	00 00 00 
  8001a8:	b8 00 00 00 00       	mov    $0x0,%eax
  8001ad:	ff d3                	call   *%rbx
    memset(context.back, 255, context.size);
  8001af:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8001b2:	be ff 00 00 00       	mov    $0xff,%esi
  8001b7:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8001bb:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  8001c2:	00 00 00 
  8001c5:	ff d0                	call   *%rax
  	unsigned error;
  	uint8_t * image;
  	unsigned width, height;
  	const char* filename =  "spaceship.png";
  	error = lodepng_decode32_file(&image, &width, &height, filename);
  8001c7:	48 b9 38 14 81 00 00 	movabs $0x811438,%rcx
  8001ce:	00 00 00 
  8001d1:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8001d5:	48 8d 75 bc          	lea    -0x44(%rbp),%rsi
  8001d9:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
  8001dd:	48 b8 e7 07 81 00 00 	movabs $0x8107e7,%rax
  8001e4:	00 00 00 
  8001e7:	ff d0                	call   *%rax
  8001e9:	89 c3                	mov    %eax,%ebx
  	if(error) cprintf("decoder error %u: %s\n", error, lodepng_error_text(error));
  8001eb:	85 c0                	test   %eax,%eax
  8001ed:	75 79                	jne    800268 <umain+0x145>
  	/* use image here */
	cprintf("width: %u, height: %u\n", width, height);
  8001ef:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8001f2:	8b 75 bc             	mov    -0x44(%rbp),%esi
  8001f5:	48 bf 5c 14 81 00 00 	movabs $0x81145c,%rdi
  8001fc:	00 00 00 
  8001ff:	b8 00 00 00 00       	mov    $0x0,%eax
  800204:	48 b9 67 04 80 00 00 	movabs $0x800467,%rcx
  80020b:	00 00 00 
  80020e:	ff d1                	call   *%rcx
	
    uint8_t *buf = context.back;
  800210:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
    for (int i = 0; i  < height; ++i) {
  800214:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80021a:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  80021e:	0f 85 b1 00 00 00    	jne    8002d5 <umain+0x1b2>
        for (int j = 0 ; j < width * 4; ++j) {
            buf[i * 4 *  context.width + j] = image[width * 4 * i + j];
        }
    }
    FramebufferFlip(&context);
  800224:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  800228:	48 b8 8e 28 80 00 00 	movabs $0x80288e,%rax
  80022f:	00 00 00 
  800232:	ff d0                	call   *%rax
}
  800234:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  800238:	c9                   	leave  
  800239:	c3                   	ret    
        cprintf("error %i\n", res);
  80023a:	89 c6                	mov    %eax,%esi
  80023c:	48 bf 19 14 81 00 00 	movabs $0x811419,%rdi
  800243:	00 00 00 
  800246:	b8 00 00 00 00       	mov    $0x0,%eax
  80024b:	48 ba 67 04 80 00 00 	movabs $0x800467,%rdx
  800252:	00 00 00 
  800255:	ff d2                	call   *%rdx
        exit();
  800257:	48 b8 97 03 80 00 00 	movabs $0x800397,%rax
  80025e:	00 00 00 
  800261:	ff d0                	call   *%rax
  800263:	e9 f0 fe ff ff       	jmp    800158 <umain+0x35>
  	if(error) cprintf("decoder error %u: %s\n", error, lodepng_error_text(error));
  800268:	89 c7                	mov    %eax,%edi
  80026a:	48 b8 c0 09 81 00 00 	movabs $0x8109c0,%rax
  800271:	00 00 00 
  800274:	ff d0                	call   *%rax
  800276:	48 89 c2             	mov    %rax,%rdx
  800279:	89 de                	mov    %ebx,%esi
  80027b:	48 bf 46 14 81 00 00 	movabs $0x811446,%rdi
  800282:	00 00 00 
  800285:	b8 00 00 00 00       	mov    $0x0,%eax
  80028a:	48 b9 67 04 80 00 00 	movabs $0x800467,%rcx
  800291:	00 00 00 
  800294:	ff d1                	call   *%rcx
  800296:	e9 54 ff ff ff       	jmp    8001ef <umain+0xcc>
            buf[i * 4 *  context.width + j] = image[width * 4 * i + j];
  80029b:	0f af c1             	imul   %ecx,%eax
  80029e:	8d 04 82             	lea    (%rdx,%rax,4),%eax
  8002a1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8002a5:	0f b6 34 06          	movzbl (%rsi,%rax,1),%esi
  8002a9:	89 c8                	mov    %ecx,%eax
  8002ab:	0f af 45 c8          	imul   -0x38(%rbp),%eax
  8002af:	8d 04 82             	lea    (%rdx,%rax,4),%eax
  8002b2:	40 88 34 07          	mov    %sil,(%rdi,%rax,1)
        for (int j = 0 ; j < width * 4; ++j) {
  8002b6:	83 c2 01             	add    $0x1,%edx
  8002b9:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8002bc:	8d 34 85 00 00 00 00 	lea    0x0(,%rax,4),%esi
  8002c3:	39 d6                	cmp    %edx,%esi
  8002c5:	77 d4                	ja     80029b <umain+0x178>
    for (int i = 0; i  < height; ++i) {
  8002c7:	41 83 c0 01          	add    $0x1,%r8d
  8002cb:	44 39 45 b8          	cmp    %r8d,-0x48(%rbp)
  8002cf:	0f 86 4f ff ff ff    	jbe    800224 <umain+0x101>
  8002d5:	44 89 c1             	mov    %r8d,%ecx
        for (int j = 0 ; j < width * 4; ++j) {
  8002d8:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8002db:	ba 00 00 00 00       	mov    $0x0,%edx
  8002e0:	89 c3                	mov    %eax,%ebx
  8002e2:	c1 e3 02             	shl    $0x2,%ebx
  8002e5:	75 b4                	jne    80029b <umain+0x178>
  8002e7:	eb de                	jmp    8002c7 <umain+0x1a4>

00000000008002e9 <libmain>:
#ifdef JOS_PROG
void (*volatile sys_exit)(void);
#endif

void
libmain(int argc, char **argv) {
  8002e9:	55                   	push   %rbp
  8002ea:	48 89 e5             	mov    %rsp,%rbp
  8002ed:	41 56                	push   %r14
  8002ef:	41 55                	push   %r13
  8002f1:	41 54                	push   %r12
  8002f3:	53                   	push   %rbx
  8002f4:	41 89 fd             	mov    %edi,%r13d
  8002f7:	49 89 f6             	mov    %rsi,%r14
    /* Perform global constructor initialisation (e.g. asan)
    * This must be done as early as possible */
    extern void (*__ctors_start)(), (*__ctors_end)();
    void (**ctor)() = &__ctors_start;
    while (ctor < &__ctors_end) (*ctor++)();
  8002fa:	48 ba f8 40 81 00 00 	movabs $0x8140f8,%rdx
  800301:	00 00 00 
  800304:	48 b8 f8 40 81 00 00 	movabs $0x8140f8,%rax
  80030b:	00 00 00 
  80030e:	48 39 c2             	cmp    %rax,%rdx
  800311:	73 17                	jae    80032a <libmain+0x41>
    void (**ctor)() = &__ctors_start;
  800313:	48 89 d3             	mov    %rdx,%rbx
    while (ctor < &__ctors_end) (*ctor++)();
  800316:	49 89 c4             	mov    %rax,%r12
  800319:	48 83 c3 08          	add    $0x8,%rbx
  80031d:	b8 00 00 00 00       	mov    $0x0,%eax
  800322:	ff 53 f8             	call   *-0x8(%rbx)
  800325:	4c 39 e3             	cmp    %r12,%rbx
  800328:	72 ef                	jb     800319 <libmain+0x30>

    /* Set thisenv to point at our Env structure in envs[]. */
    // LAB 8: Your code here
    thisenv = &envs[ENVX(sys_getenvid())];
  80032a:	48 b8 a2 12 80 00 00 	movabs $0x8012a2,%rax
  800331:	00 00 00 
  800334:	ff d0                	call   *%rax
  800336:	25 ff 03 00 00       	and    $0x3ff,%eax
  80033b:	48 8d 14 c0          	lea    (%rax,%rax,8),%rdx
  80033f:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
  800343:	48 c1 e0 04          	shl    $0x4,%rax
  800347:	48 ba 00 00 c0 1f 80 	movabs $0x801fc00000,%rdx
  80034e:	00 00 00 
  800351:	48 01 d0             	add    %rdx,%rax
  800354:	48 a3 08 50 81 00 00 	movabs %rax,0x815008
  80035b:	00 00 00 
    /* Save the name of the program so that panic() can use it */
    if (argc > 0) binaryname = argv[0];
  80035e:	45 85 ed             	test   %r13d,%r13d
  800361:	7e 0d                	jle    800370 <libmain+0x87>
  800363:	49 8b 06             	mov    (%r14),%rax
  800366:	48 a3 00 40 81 00 00 	movabs %rax,0x814000
  80036d:	00 00 00 

    /* Call user main routine */
    umain(argc, argv);
  800370:	4c 89 f6             	mov    %r14,%rsi
  800373:	44 89 ef             	mov    %r13d,%edi
  800376:	48 b8 23 01 80 00 00 	movabs $0x800123,%rax
  80037d:	00 00 00 
  800380:	ff d0                	call   *%rax

#ifdef JOS_PROG
    sys_exit();
#else
    exit();
  800382:	48 b8 97 03 80 00 00 	movabs $0x800397,%rax
  800389:	00 00 00 
  80038c:	ff d0                	call   *%rax
#endif
}
  80038e:	5b                   	pop    %rbx
  80038f:	41 5c                	pop    %r12
  800391:	41 5d                	pop    %r13
  800393:	41 5e                	pop    %r14
  800395:	5d                   	pop    %rbp
  800396:	c3                   	ret    

0000000000800397 <exit>:

#include <inc/lib.h>

void
exit(void) {
  800397:	55                   	push   %rbp
  800398:	48 89 e5             	mov    %rsp,%rbp
    close_all();
  80039b:	48 b8 f2 18 80 00 00 	movabs $0x8018f2,%rax
  8003a2:	00 00 00 
  8003a5:	ff d0                	call   *%rax
    sys_env_destroy(0);
  8003a7:	bf 00 00 00 00       	mov    $0x0,%edi
  8003ac:	48 b8 37 12 80 00 00 	movabs $0x801237,%rax
  8003b3:	00 00 00 
  8003b6:	ff d0                	call   *%rax
}
  8003b8:	5d                   	pop    %rbp
  8003b9:	c3                   	ret    

00000000008003ba <putch>:
    int count;  /* total bytes printed so far */
    char buf[PRINTBUFSZ];
};

static void
putch(int ch, struct printbuf *state) {
  8003ba:	55                   	push   %rbp
  8003bb:	48 89 e5             	mov    %rsp,%rbp
  8003be:	53                   	push   %rbx
  8003bf:	48 83 ec 08          	sub    $0x8,%rsp
  8003c3:	48 89 f3             	mov    %rsi,%rbx
    state->buf[state->offset++] = (char)ch;
  8003c6:	8b 06                	mov    (%rsi),%eax
  8003c8:	8d 50 01             	lea    0x1(%rax),%edx
  8003cb:	89 16                	mov    %edx,(%rsi)
  8003cd:	48 98                	cltq   
  8003cf:	40 88 7c 06 08       	mov    %dil,0x8(%rsi,%rax,1)
    if (state->offset == PRINTBUFSZ - 1) {
  8003d4:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  8003da:	74 0a                	je     8003e6 <putch+0x2c>
        sys_cputs(state->buf, state->offset);
        state->offset = 0;
    }
    state->count++;
  8003dc:	83 43 04 01          	addl   $0x1,0x4(%rbx)
}
  8003e0:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8003e4:	c9                   	leave  
  8003e5:	c3                   	ret    
        sys_cputs(state->buf, state->offset);
  8003e6:	48 8d 7e 08          	lea    0x8(%rsi),%rdi
  8003ea:	be ff 00 00 00       	mov    $0xff,%esi
  8003ef:	48 b8 d9 11 80 00 00 	movabs $0x8011d9,%rax
  8003f6:	00 00 00 
  8003f9:	ff d0                	call   *%rax
        state->offset = 0;
  8003fb:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
  800401:	eb d9                	jmp    8003dc <putch+0x22>

0000000000800403 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap) {
  800403:	55                   	push   %rbp
  800404:	48 89 e5             	mov    %rsp,%rbp
  800407:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  80040e:	48 89 fa             	mov    %rdi,%rdx
    struct printbuf state = {0};
  800411:	48 8d bd f8 fe ff ff 	lea    -0x108(%rbp),%rdi
  800418:	b9 21 00 00 00       	mov    $0x21,%ecx
  80041d:	b8 00 00 00 00       	mov    $0x0,%eax
  800422:	f3 48 ab             	rep stos %rax,%es:(%rdi)

    vprintfmt((void *)putch, &state, fmt, ap);
  800425:	48 89 f1             	mov    %rsi,%rcx
  800428:	48 8d b5 f8 fe ff ff 	lea    -0x108(%rbp),%rsi
  80042f:	48 bf ba 03 80 00 00 	movabs $0x8003ba,%rdi
  800436:	00 00 00 
  800439:	48 b8 b7 05 80 00 00 	movabs $0x8005b7,%rax
  800440:	00 00 00 
  800443:	ff d0                	call   *%rax
    sys_cputs(state.buf, state.offset);
  800445:	48 63 b5 f8 fe ff ff 	movslq -0x108(%rbp),%rsi
  80044c:	48 8d bd 00 ff ff ff 	lea    -0x100(%rbp),%rdi
  800453:	48 b8 d9 11 80 00 00 	movabs $0x8011d9,%rax
  80045a:	00 00 00 
  80045d:	ff d0                	call   *%rax

    return state.count;
}
  80045f:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
  800465:	c9                   	leave  
  800466:	c3                   	ret    

0000000000800467 <cprintf>:

int
cprintf(const char *fmt, ...) {
  800467:	55                   	push   %rbp
  800468:	48 89 e5             	mov    %rsp,%rbp
  80046b:	48 83 ec 50          	sub    $0x50,%rsp
  80046f:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  800473:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  800477:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  80047b:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  80047f:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_list ap;
    int count;

    va_start(ap, fmt);
  800483:	c7 45 b8 08 00 00 00 	movl   $0x8,-0x48(%rbp)
  80048a:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80048e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800492:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800496:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    count = vcprintf(fmt, ap);
  80049a:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
  80049e:	48 b8 03 04 80 00 00 	movabs $0x800403,%rax
  8004a5:	00 00 00 
  8004a8:	ff d0                	call   *%rax
    va_end(ap);

    return count;
}
  8004aa:	c9                   	leave  
  8004ab:	c3                   	ret    

00000000008004ac <print_num>:
 * Print a number (base <= 16) in reverse order,
 * using specified putch function and associated pointer putdat.
 */
static void
print_num(void (*putch)(int, void *), void *put_arg,
          uintmax_t num, unsigned base, int width, char padc, bool capital) {
  8004ac:	55                   	push   %rbp
  8004ad:	48 89 e5             	mov    %rsp,%rbp
  8004b0:	41 57                	push   %r15
  8004b2:	41 56                	push   %r14
  8004b4:	41 55                	push   %r13
  8004b6:	41 54                	push   %r12
  8004b8:	53                   	push   %rbx
  8004b9:	48 83 ec 18          	sub    $0x18,%rsp
  8004bd:	49 89 fc             	mov    %rdi,%r12
  8004c0:	49 89 f5             	mov    %rsi,%r13
  8004c3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004c7:	8b 45 10             	mov    0x10(%rbp),%eax
  8004ca:	89 45 c4             	mov    %eax,-0x3c(%rbp)
    /* First recursively print all preceding (more significant) digits */
    if (num >= base) {
  8004cd:	41 89 cf             	mov    %ecx,%r15d
  8004d0:	49 39 d7             	cmp    %rdx,%r15
  8004d3:	76 5b                	jbe    800530 <print_num+0x84>
        print_num(putch, put_arg, num / base, base, width - 1, padc, capital);
    } else {
        /* Print any needed pad characters before first digit */
        while (--width > 0) {
  8004d5:	41 8d 58 ff          	lea    -0x1(%r8),%ebx
            putch(padc, put_arg);
  8004d9:	45 0f be f1          	movsbl %r9b,%r14d
        while (--width > 0) {
  8004dd:	85 db                	test   %ebx,%ebx
  8004df:	7e 0e                	jle    8004ef <print_num+0x43>
            putch(padc, put_arg);
  8004e1:	4c 89 ee             	mov    %r13,%rsi
  8004e4:	44 89 f7             	mov    %r14d,%edi
  8004e7:	41 ff d4             	call   *%r12
        while (--width > 0) {
  8004ea:	83 eb 01             	sub    $0x1,%ebx
  8004ed:	75 f2                	jne    8004e1 <print_num+0x35>
        }
    }

    const char *dig = capital ? "0123456789ABCDEF" : "0123456789abcdef";
  8004ef:	80 7d c4 00          	cmpb   $0x0,-0x3c(%rbp)
  8004f3:	48 b9 b7 14 81 00 00 	movabs $0x8114b7,%rcx
  8004fa:	00 00 00 
  8004fd:	48 b8 c8 14 81 00 00 	movabs $0x8114c8,%rax
  800504:	00 00 00 
  800507:	48 0f 44 c8          	cmove  %rax,%rcx

    /* Then print this (the least significant) digit */
    putch(dig[num % base], put_arg);
  80050b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80050f:	ba 00 00 00 00       	mov    $0x0,%edx
  800514:	49 f7 f7             	div    %r15
  800517:	0f be 3c 11          	movsbl (%rcx,%rdx,1),%edi
  80051b:	4c 89 ee             	mov    %r13,%rsi
  80051e:	41 ff d4             	call   *%r12
}
  800521:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  800525:	5b                   	pop    %rbx
  800526:	41 5c                	pop    %r12
  800528:	41 5d                	pop    %r13
  80052a:	41 5e                	pop    %r14
  80052c:	41 5f                	pop    %r15
  80052e:	5d                   	pop    %rbp
  80052f:	c3                   	ret    
        print_num(putch, put_arg, num / base, base, width - 1, padc, capital);
  800530:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800534:	ba 00 00 00 00       	mov    $0x0,%edx
  800539:	49 f7 f7             	div    %r15
  80053c:	48 83 ec 08          	sub    $0x8,%rsp
  800540:	0f b6 55 c4          	movzbl -0x3c(%rbp),%edx
  800544:	52                   	push   %rdx
  800545:	45 0f be c9          	movsbl %r9b,%r9d
  800549:	45 8d 40 ff          	lea    -0x1(%r8),%r8d
  80054d:	48 89 c2             	mov    %rax,%rdx
  800550:	48 b8 ac 04 80 00 00 	movabs $0x8004ac,%rax
  800557:	00 00 00 
  80055a:	ff d0                	call   *%rax
  80055c:	48 83 c4 10          	add    $0x10,%rsp
  800560:	eb 8d                	jmp    8004ef <print_num+0x43>

0000000000800562 <sprintputch>:
    int count;
};

static void
sprintputch(int ch, struct sprintbuf *state) {
    state->count++;
  800562:	83 46 10 01          	addl   $0x1,0x10(%rsi)
    if (state->start < state->end) {
  800566:	48 8b 06             	mov    (%rsi),%rax
  800569:	48 3b 46 08          	cmp    0x8(%rsi),%rax
  80056d:	73 0a                	jae    800579 <sprintputch+0x17>
        *state->start++ = ch;
  80056f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800573:	48 89 16             	mov    %rdx,(%rsi)
  800576:	40 88 38             	mov    %dil,(%rax)
    }
}
  800579:	c3                   	ret    

000000000080057a <printfmt>:
printfmt(void (*putch)(int, void *), void *putdat, const char *fmt, ...) {
  80057a:	55                   	push   %rbp
  80057b:	48 89 e5             	mov    %rsp,%rbp
  80057e:	48 83 ec 50          	sub    $0x50,%rsp
  800582:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  800586:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  80058a:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_start(ap, fmt);
  80058e:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
  800595:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800599:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80059d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8005a1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    vprintfmt(putch, putdat, fmt, ap);
  8005a5:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  8005a9:	48 b8 b7 05 80 00 00 	movabs $0x8005b7,%rax
  8005b0:	00 00 00 
  8005b3:	ff d0                	call   *%rax
}
  8005b5:	c9                   	leave  
  8005b6:	c3                   	ret    

00000000008005b7 <vprintfmt>:
vprintfmt(void (*putch)(int, void *), void *put_arg, const char *fmt, va_list ap) {
  8005b7:	55                   	push   %rbp
  8005b8:	48 89 e5             	mov    %rsp,%rbp
  8005bb:	41 57                	push   %r15
  8005bd:	41 56                	push   %r14
  8005bf:	41 55                	push   %r13
  8005c1:	41 54                	push   %r12
  8005c3:	53                   	push   %rbx
  8005c4:	48 83 ec 48          	sub    $0x48,%rsp
  8005c8:	49 89 fc             	mov    %rdi,%r12
  8005cb:	49 89 f6             	mov    %rsi,%r14
  8005ce:	49 89 d7             	mov    %rdx,%r15
    va_copy(aq, ap);
  8005d1:	48 8b 01             	mov    (%rcx),%rax
  8005d4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8005d8:	48 8b 41 08          	mov    0x8(%rcx),%rax
  8005dc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8005e0:	48 8b 41 10          	mov    0x10(%rcx),%rax
  8005e4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        while ((ch = *ufmt++) != '%') {
  8005e8:	49 8d 5f 01          	lea    0x1(%r15),%rbx
  8005ec:	41 0f b6 3f          	movzbl (%r15),%edi
  8005f0:	40 80 ff 25          	cmp    $0x25,%dil
  8005f4:	74 18                	je     80060e <vprintfmt+0x57>
            if (!ch) return;
  8005f6:	40 84 ff             	test   %dil,%dil
  8005f9:	0f 84 d1 06 00 00    	je     800cd0 <vprintfmt+0x719>
            putch(ch, put_arg);
  8005ff:	40 0f b6 ff          	movzbl %dil,%edi
  800603:	4c 89 f6             	mov    %r14,%rsi
  800606:	41 ff d4             	call   *%r12
        while ((ch = *ufmt++) != '%') {
  800609:	49 89 df             	mov    %rbx,%r15
  80060c:	eb da                	jmp    8005e8 <vprintfmt+0x31>
            precision = va_arg(aq, int);
  80060e:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
        bool altflag = 0, zflag = 0;
  800612:	b9 00 00 00 00       	mov    $0x0,%ecx
  800617:	c6 45 98 00          	movb   $0x0,-0x68(%rbp)
        unsigned lflag = 0, base = 10;
  80061b:	ba 00 00 00 00       	mov    $0x0,%edx
        int width = -1, precision = -1;
  800620:	41 bd ff ff ff ff    	mov    $0xffffffff,%r13d
  800626:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,-0x54(%rbp)
        char padc = ' ';
  80062d:	c6 45 a0 20          	movb   $0x20,-0x60(%rbp)
            width = MAX(0, width);
  800631:	bf 00 00 00 00       	mov    $0x0,%edi
        switch (ch = *ufmt++) {
  800636:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80063c:	4c 8d 7b 01          	lea    0x1(%rbx),%r15
  800640:	44 0f b6 0b          	movzbl (%rbx),%r9d
  800644:	41 8d 41 dd          	lea    -0x23(%r9),%eax
  800648:	3c 57                	cmp    $0x57,%al
  80064a:	0f 87 65 06 00 00    	ja     800cb5 <vprintfmt+0x6fe>
  800650:	0f b6 c0             	movzbl %al,%eax
  800653:	49 ba 60 16 81 00 00 	movabs $0x811660,%r10
  80065a:	00 00 00 
  80065d:	41 ff 24 c2          	jmp    *(%r10,%rax,8)
  800661:	4c 89 fb             	mov    %r15,%rbx
            altflag = 1;
  800664:	44 88 45 98          	mov    %r8b,-0x68(%rbp)
  800668:	eb d2                	jmp    80063c <vprintfmt+0x85>
        switch (ch = *ufmt++) {
  80066a:	4c 89 fb             	mov    %r15,%rbx
  80066d:	44 89 c1             	mov    %r8d,%ecx
  800670:	eb ca                	jmp    80063c <vprintfmt+0x85>
            padc = ch;
  800672:	44 88 4d a0          	mov    %r9b,-0x60(%rbp)
        switch (ch = *ufmt++) {
  800676:	4c 89 fb             	mov    %r15,%rbx
            goto reswitch;
  800679:	eb c1                	jmp    80063c <vprintfmt+0x85>
            precision = va_arg(aq, int);
  80067b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80067e:	83 f8 2f             	cmp    $0x2f,%eax
  800681:	77 24                	ja     8006a7 <vprintfmt+0xf0>
  800683:	41 89 c1             	mov    %eax,%r9d
  800686:	49 01 f1             	add    %rsi,%r9
  800689:	83 c0 08             	add    $0x8,%eax
  80068c:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80068f:	45 8b 29             	mov    (%r9),%r13d
        switch (ch = *ufmt++) {
  800692:	4c 89 fb             	mov    %r15,%rbx
            if (width < 0) {
  800695:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800699:	79 a1                	jns    80063c <vprintfmt+0x85>
                width = precision;
  80069b:	44 89 6d ac          	mov    %r13d,-0x54(%rbp)
                precision = -1;
  80069f:	41 bd ff ff ff ff    	mov    $0xffffffff,%r13d
  8006a5:	eb 95                	jmp    80063c <vprintfmt+0x85>
            precision = va_arg(aq, int);
  8006a7:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
  8006ab:	49 8d 41 08          	lea    0x8(%r9),%rax
  8006af:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8006b3:	eb da                	jmp    80068f <vprintfmt+0xd8>
        switch (ch = *ufmt++) {
  8006b5:	45 0f b6 c9          	movzbl %r9b,%r9d
                precision = precision * 10 + ch - '0';
  8006b9:	45 8d 69 d0          	lea    -0x30(%r9),%r13d
                if ((ch = *ufmt) - '0' > 9) break;
  8006bd:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
  8006c1:	3c 39                	cmp    $0x39,%al
  8006c3:	77 1e                	ja     8006e3 <vprintfmt+0x12c>
            for (precision = 0;; ++ufmt) {
  8006c5:	49 83 c7 01          	add    $0x1,%r15
                precision = precision * 10 + ch - '0';
  8006c9:	47 8d 4c ad 00       	lea    0x0(%r13,%r13,4),%r9d
  8006ce:	0f b6 c0             	movzbl %al,%eax
  8006d1:	46 8d 6c 48 d0       	lea    -0x30(%rax,%r9,2),%r13d
                if ((ch = *ufmt) - '0' > 9) break;
  8006d6:	41 0f b6 07          	movzbl (%r15),%eax
  8006da:	3c 39                	cmp    $0x39,%al
  8006dc:	76 e7                	jbe    8006c5 <vprintfmt+0x10e>
            for (precision = 0;; ++ufmt) {
  8006de:	4c 89 fb             	mov    %r15,%rbx
        process_precision:
  8006e1:	eb b2                	jmp    800695 <vprintfmt+0xde>
        switch (ch = *ufmt++) {
  8006e3:	4c 89 fb             	mov    %r15,%rbx
  8006e6:	eb ad                	jmp    800695 <vprintfmt+0xde>
            width = MAX(0, width);
  8006e8:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8006eb:	85 c0                	test   %eax,%eax
  8006ed:	0f 48 c7             	cmovs  %edi,%eax
  8006f0:	89 45 ac             	mov    %eax,-0x54(%rbp)
        switch (ch = *ufmt++) {
  8006f3:	4c 89 fb             	mov    %r15,%rbx
            goto reswitch;
  8006f6:	e9 41 ff ff ff       	jmp    80063c <vprintfmt+0x85>
            lflag++;
  8006fb:	83 c2 01             	add    $0x1,%edx
        switch (ch = *ufmt++) {
  8006fe:	4c 89 fb             	mov    %r15,%rbx
            goto reswitch;
  800701:	e9 36 ff ff ff       	jmp    80063c <vprintfmt+0x85>
            putch(va_arg(aq, int), put_arg);
  800706:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800709:	83 f8 2f             	cmp    $0x2f,%eax
  80070c:	77 18                	ja     800726 <vprintfmt+0x16f>
  80070e:	89 c2                	mov    %eax,%edx
  800710:	48 01 f2             	add    %rsi,%rdx
  800713:	83 c0 08             	add    $0x8,%eax
  800716:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800719:	4c 89 f6             	mov    %r14,%rsi
  80071c:	8b 3a                	mov    (%rdx),%edi
  80071e:	41 ff d4             	call   *%r12
            break;
  800721:	e9 c2 fe ff ff       	jmp    8005e8 <vprintfmt+0x31>
            putch(va_arg(aq, int), put_arg);
  800726:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80072a:	48 8d 42 08          	lea    0x8(%rdx),%rax
  80072e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800732:	eb e5                	jmp    800719 <vprintfmt+0x162>
            int err = va_arg(aq, int);
  800734:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800737:	83 f8 2f             	cmp    $0x2f,%eax
  80073a:	77 5b                	ja     800797 <vprintfmt+0x1e0>
  80073c:	89 c2                	mov    %eax,%edx
  80073e:	48 01 d6             	add    %rdx,%rsi
  800741:	83 c0 08             	add    $0x8,%eax
  800744:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800747:	8b 0e                	mov    (%rsi),%ecx
            if (err < 0) err = -err;
  800749:	89 c8                	mov    %ecx,%eax
  80074b:	c1 f8 1f             	sar    $0x1f,%eax
  80074e:	31 c1                	xor    %eax,%ecx
  800750:	29 c1                	sub    %eax,%ecx
            if (err >= MAXERROR || !(strerr = error_string[err])) {
  800752:	83 f9 13             	cmp    $0x13,%ecx
  800755:	7f 4e                	jg     8007a5 <vprintfmt+0x1ee>
  800757:	48 63 c1             	movslq %ecx,%rax
  80075a:	48 ba 20 19 81 00 00 	movabs $0x811920,%rdx
  800761:	00 00 00 
  800764:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  800768:	48 85 c0             	test   %rax,%rax
  80076b:	74 38                	je     8007a5 <vprintfmt+0x1ee>
                printfmt(putch, put_arg, "%s", strerr);
  80076d:	48 89 c1             	mov    %rax,%rcx
  800770:	48 ba d9 1a 81 00 00 	movabs $0x811ad9,%rdx
  800777:	00 00 00 
  80077a:	4c 89 f6             	mov    %r14,%rsi
  80077d:	4c 89 e7             	mov    %r12,%rdi
  800780:	b8 00 00 00 00       	mov    $0x0,%eax
  800785:	49 b8 7a 05 80 00 00 	movabs $0x80057a,%r8
  80078c:	00 00 00 
  80078f:	41 ff d0             	call   *%r8
  800792:	e9 51 fe ff ff       	jmp    8005e8 <vprintfmt+0x31>
            int err = va_arg(aq, int);
  800797:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80079b:	48 8d 46 08          	lea    0x8(%rsi),%rax
  80079f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8007a3:	eb a2                	jmp    800747 <vprintfmt+0x190>
                printfmt(putch, put_arg, "error %d", err);
  8007a5:	48 ba e0 14 81 00 00 	movabs $0x8114e0,%rdx
  8007ac:	00 00 00 
  8007af:	4c 89 f6             	mov    %r14,%rsi
  8007b2:	4c 89 e7             	mov    %r12,%rdi
  8007b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8007ba:	49 b8 7a 05 80 00 00 	movabs $0x80057a,%r8
  8007c1:	00 00 00 
  8007c4:	41 ff d0             	call   *%r8
  8007c7:	e9 1c fe ff ff       	jmp    8005e8 <vprintfmt+0x31>
            const char *ptr = va_arg(aq, char *);
  8007cc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8007cf:	83 f8 2f             	cmp    $0x2f,%eax
  8007d2:	77 55                	ja     800829 <vprintfmt+0x272>
  8007d4:	89 c2                	mov    %eax,%edx
  8007d6:	48 01 d6             	add    %rdx,%rsi
  8007d9:	83 c0 08             	add    $0x8,%eax
  8007dc:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8007df:	48 8b 16             	mov    (%rsi),%rdx
            if (!ptr) ptr = "(null)";
  8007e2:	48 85 d2             	test   %rdx,%rdx
  8007e5:	48 b8 d9 14 81 00 00 	movabs $0x8114d9,%rax
  8007ec:	00 00 00 
  8007ef:	48 0f 45 c2          	cmovne %rdx,%rax
  8007f3:	48 89 45 90          	mov    %rax,-0x70(%rbp)
            if (width > 0 && padc != '-') {
  8007f7:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8007fb:	7e 06                	jle    800803 <vprintfmt+0x24c>
  8007fd:	80 7d a0 2d          	cmpb   $0x2d,-0x60(%rbp)
  800801:	75 34                	jne    800837 <vprintfmt+0x280>
            for (; (ch = *ptr++) && (precision < 0 || --precision >= 0); width--) {
  800803:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800807:	48 8d 58 01          	lea    0x1(%rax),%rbx
  80080b:	0f b6 00             	movzbl (%rax),%eax
  80080e:	84 c0                	test   %al,%al
  800810:	0f 84 b2 00 00 00    	je     8008c8 <vprintfmt+0x311>
  800816:	4c 89 75 a0          	mov    %r14,-0x60(%rbp)
  80081a:	44 0f b6 75 98       	movzbl -0x68(%rbp),%r14d
  80081f:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  800823:	44 8b 7d ac          	mov    -0x54(%rbp),%r15d
  800827:	eb 74                	jmp    80089d <vprintfmt+0x2e6>
            const char *ptr = va_arg(aq, char *);
  800829:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80082d:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800831:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800835:	eb a8                	jmp    8007df <vprintfmt+0x228>
                width -= strnlen(ptr, precision);
  800837:	49 63 f5             	movslq %r13d,%rsi
  80083a:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  80083e:	48 b8 8a 0d 80 00 00 	movabs $0x800d8a,%rax
  800845:	00 00 00 
  800848:	ff d0                	call   *%rax
  80084a:	48 89 c2             	mov    %rax,%rdx
  80084d:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800850:	29 d0                	sub    %edx,%eax
                while (width-- > 0) putch(padc, put_arg);
  800852:	8d 48 ff             	lea    -0x1(%rax),%ecx
  800855:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  800858:	85 c0                	test   %eax,%eax
  80085a:	7e a7                	jle    800803 <vprintfmt+0x24c>
  80085c:	0f be 5d a0          	movsbl -0x60(%rbp),%ebx
  800860:	44 89 6d a0          	mov    %r13d,-0x60(%rbp)
  800864:	41 89 cd             	mov    %ecx,%r13d
  800867:	4c 89 f6             	mov    %r14,%rsi
  80086a:	89 df                	mov    %ebx,%edi
  80086c:	41 ff d4             	call   *%r12
  80086f:	41 83 ed 01          	sub    $0x1,%r13d
  800873:	41 83 fd ff          	cmp    $0xffffffff,%r13d
  800877:	75 ee                	jne    800867 <vprintfmt+0x2b0>
  800879:	44 89 6d ac          	mov    %r13d,-0x54(%rbp)
  80087d:	44 8b 6d a0          	mov    -0x60(%rbp),%r13d
  800881:	eb 80                	jmp    800803 <vprintfmt+0x24c>
                putch(altflag && (ch < ' ' || ch > '~') ? '?' : ch, put_arg);
  800883:	0f b6 f8             	movzbl %al,%edi
  800886:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80088a:	41 ff d4             	call   *%r12
            for (; (ch = *ptr++) && (precision < 0 || --precision >= 0); width--) {
  80088d:	41 83 ef 01          	sub    $0x1,%r15d
  800891:	48 83 c3 01          	add    $0x1,%rbx
  800895:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  800899:	84 c0                	test   %al,%al
  80089b:	74 1f                	je     8008bc <vprintfmt+0x305>
  80089d:	45 85 ed             	test   %r13d,%r13d
  8008a0:	78 06                	js     8008a8 <vprintfmt+0x2f1>
  8008a2:	41 83 ed 01          	sub    $0x1,%r13d
  8008a6:	78 46                	js     8008ee <vprintfmt+0x337>
                putch(altflag && (ch < ' ' || ch > '~') ? '?' : ch, put_arg);
  8008a8:	45 84 f6             	test   %r14b,%r14b
  8008ab:	74 d6                	je     800883 <vprintfmt+0x2cc>
  8008ad:	8d 50 e0             	lea    -0x20(%rax),%edx
  8008b0:	bf 3f 00 00 00       	mov    $0x3f,%edi
  8008b5:	80 fa 5e             	cmp    $0x5e,%dl
  8008b8:	77 cc                	ja     800886 <vprintfmt+0x2cf>
  8008ba:	eb c7                	jmp    800883 <vprintfmt+0x2cc>
  8008bc:	44 89 7d ac          	mov    %r15d,-0x54(%rbp)
  8008c0:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
  8008c4:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
            while (width-- > 0) putch(' ', put_arg);
  8008c8:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8008cb:	8d 58 ff             	lea    -0x1(%rax),%ebx
  8008ce:	85 c0                	test   %eax,%eax
  8008d0:	0f 8e 12 fd ff ff    	jle    8005e8 <vprintfmt+0x31>
  8008d6:	4c 89 f6             	mov    %r14,%rsi
  8008d9:	bf 20 00 00 00       	mov    $0x20,%edi
  8008de:	41 ff d4             	call   *%r12
  8008e1:	83 eb 01             	sub    $0x1,%ebx
  8008e4:	83 fb ff             	cmp    $0xffffffff,%ebx
  8008e7:	75 ed                	jne    8008d6 <vprintfmt+0x31f>
  8008e9:	e9 fa fc ff ff       	jmp    8005e8 <vprintfmt+0x31>
  8008ee:	44 89 7d ac          	mov    %r15d,-0x54(%rbp)
  8008f2:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
  8008f6:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
  8008fa:	eb cc                	jmp    8008c8 <vprintfmt+0x311>
    if (zflag) return va_arg(*ap, size_t);
  8008fc:	45 89 cd             	mov    %r9d,%r13d
  8008ff:	84 c9                	test   %cl,%cl
  800901:	75 25                	jne    800928 <vprintfmt+0x371>
    switch (lflag) {
  800903:	85 d2                	test   %edx,%edx
  800905:	74 57                	je     80095e <vprintfmt+0x3a7>
  800907:	83 fa 01             	cmp    $0x1,%edx
  80090a:	74 78                	je     800984 <vprintfmt+0x3cd>
        return va_arg(*ap, long long);
  80090c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80090f:	83 f8 2f             	cmp    $0x2f,%eax
  800912:	0f 87 92 00 00 00    	ja     8009aa <vprintfmt+0x3f3>
  800918:	89 c2                	mov    %eax,%edx
  80091a:	48 01 d6             	add    %rdx,%rsi
  80091d:	83 c0 08             	add    $0x8,%eax
  800920:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800923:	48 8b 1e             	mov    (%rsi),%rbx
  800926:	eb 16                	jmp    80093e <vprintfmt+0x387>
    if (zflag) return va_arg(*ap, size_t);
  800928:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80092b:	83 f8 2f             	cmp    $0x2f,%eax
  80092e:	77 20                	ja     800950 <vprintfmt+0x399>
  800930:	89 c2                	mov    %eax,%edx
  800932:	48 01 d6             	add    %rdx,%rsi
  800935:	83 c0 08             	add    $0x8,%eax
  800938:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80093b:	48 8b 1e             	mov    (%rsi),%rbx
            if (i < 0) {
  80093e:	48 85 db             	test   %rbx,%rbx
  800941:	78 78                	js     8009bb <vprintfmt+0x404>
            num = i;
  800943:	48 89 da             	mov    %rbx,%rdx
        unsigned lflag = 0, base = 10;
  800946:	b9 0a 00 00 00       	mov    $0xa,%ecx
            goto number;
  80094b:	e9 49 02 00 00       	jmp    800b99 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  800950:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800954:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800958:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80095c:	eb dd                	jmp    80093b <vprintfmt+0x384>
        return va_arg(*ap, int);
  80095e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800961:	83 f8 2f             	cmp    $0x2f,%eax
  800964:	77 10                	ja     800976 <vprintfmt+0x3bf>
  800966:	89 c2                	mov    %eax,%edx
  800968:	48 01 d6             	add    %rdx,%rsi
  80096b:	83 c0 08             	add    $0x8,%eax
  80096e:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800971:	48 63 1e             	movslq (%rsi),%rbx
  800974:	eb c8                	jmp    80093e <vprintfmt+0x387>
  800976:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80097a:	48 8d 46 08          	lea    0x8(%rsi),%rax
  80097e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800982:	eb ed                	jmp    800971 <vprintfmt+0x3ba>
        return va_arg(*ap, long);
  800984:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800987:	83 f8 2f             	cmp    $0x2f,%eax
  80098a:	77 10                	ja     80099c <vprintfmt+0x3e5>
  80098c:	89 c2                	mov    %eax,%edx
  80098e:	48 01 d6             	add    %rdx,%rsi
  800991:	83 c0 08             	add    $0x8,%eax
  800994:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800997:	48 8b 1e             	mov    (%rsi),%rbx
  80099a:	eb a2                	jmp    80093e <vprintfmt+0x387>
  80099c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8009a0:	48 8d 46 08          	lea    0x8(%rsi),%rax
  8009a4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8009a8:	eb ed                	jmp    800997 <vprintfmt+0x3e0>
        return va_arg(*ap, long long);
  8009aa:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8009ae:	48 8d 46 08          	lea    0x8(%rsi),%rax
  8009b2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8009b6:	e9 68 ff ff ff       	jmp    800923 <vprintfmt+0x36c>
                putch('-', put_arg);
  8009bb:	4c 89 f6             	mov    %r14,%rsi
  8009be:	bf 2d 00 00 00       	mov    $0x2d,%edi
  8009c3:	41 ff d4             	call   *%r12
                i = -i;
  8009c6:	48 f7 db             	neg    %rbx
  8009c9:	e9 75 ff ff ff       	jmp    800943 <vprintfmt+0x38c>
    if (zflag) return va_arg(*ap, size_t);
  8009ce:	45 89 cd             	mov    %r9d,%r13d
  8009d1:	84 c9                	test   %cl,%cl
  8009d3:	75 2d                	jne    800a02 <vprintfmt+0x44b>
    switch (lflag) {
  8009d5:	85 d2                	test   %edx,%edx
  8009d7:	74 57                	je     800a30 <vprintfmt+0x479>
  8009d9:	83 fa 01             	cmp    $0x1,%edx
  8009dc:	74 7f                	je     800a5d <vprintfmt+0x4a6>
        return va_arg(*ap, unsigned long long);
  8009de:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8009e1:	83 f8 2f             	cmp    $0x2f,%eax
  8009e4:	0f 87 a1 00 00 00    	ja     800a8b <vprintfmt+0x4d4>
  8009ea:	89 c2                	mov    %eax,%edx
  8009ec:	48 01 d6             	add    %rdx,%rsi
  8009ef:	83 c0 08             	add    $0x8,%eax
  8009f2:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8009f5:	48 8b 16             	mov    (%rsi),%rdx
        unsigned lflag = 0, base = 10;
  8009f8:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned long long);
  8009fd:	e9 97 01 00 00       	jmp    800b99 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  800a02:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800a05:	83 f8 2f             	cmp    $0x2f,%eax
  800a08:	77 18                	ja     800a22 <vprintfmt+0x46b>
  800a0a:	89 c2                	mov    %eax,%edx
  800a0c:	48 01 d6             	add    %rdx,%rsi
  800a0f:	83 c0 08             	add    $0x8,%eax
  800a12:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800a15:	48 8b 16             	mov    (%rsi),%rdx
        unsigned lflag = 0, base = 10;
  800a18:	b9 0a 00 00 00       	mov    $0xa,%ecx
    if (zflag) return va_arg(*ap, size_t);
  800a1d:	e9 77 01 00 00       	jmp    800b99 <vprintfmt+0x5e2>
  800a22:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800a26:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800a2a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800a2e:	eb e5                	jmp    800a15 <vprintfmt+0x45e>
        return va_arg(*ap, unsigned int);
  800a30:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800a33:	83 f8 2f             	cmp    $0x2f,%eax
  800a36:	77 17                	ja     800a4f <vprintfmt+0x498>
  800a38:	89 c2                	mov    %eax,%edx
  800a3a:	48 01 d6             	add    %rdx,%rsi
  800a3d:	83 c0 08             	add    $0x8,%eax
  800a40:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800a43:	8b 16                	mov    (%rsi),%edx
        unsigned lflag = 0, base = 10;
  800a45:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned int);
  800a4a:	e9 4a 01 00 00       	jmp    800b99 <vprintfmt+0x5e2>
  800a4f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800a53:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800a57:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800a5b:	eb e6                	jmp    800a43 <vprintfmt+0x48c>
        return va_arg(*ap, unsigned long);
  800a5d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800a60:	83 f8 2f             	cmp    $0x2f,%eax
  800a63:	77 18                	ja     800a7d <vprintfmt+0x4c6>
  800a65:	89 c2                	mov    %eax,%edx
  800a67:	48 01 d6             	add    %rdx,%rsi
  800a6a:	83 c0 08             	add    $0x8,%eax
  800a6d:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800a70:	48 8b 16             	mov    (%rsi),%rdx
        unsigned lflag = 0, base = 10;
  800a73:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned long);
  800a78:	e9 1c 01 00 00       	jmp    800b99 <vprintfmt+0x5e2>
  800a7d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800a81:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800a85:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800a89:	eb e5                	jmp    800a70 <vprintfmt+0x4b9>
        return va_arg(*ap, unsigned long long);
  800a8b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800a8f:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800a93:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800a97:	e9 59 ff ff ff       	jmp    8009f5 <vprintfmt+0x43e>
    if (zflag) return va_arg(*ap, size_t);
  800a9c:	45 89 cd             	mov    %r9d,%r13d
  800a9f:	84 c9                	test   %cl,%cl
  800aa1:	75 2d                	jne    800ad0 <vprintfmt+0x519>
    switch (lflag) {
  800aa3:	85 d2                	test   %edx,%edx
  800aa5:	74 57                	je     800afe <vprintfmt+0x547>
  800aa7:	83 fa 01             	cmp    $0x1,%edx
  800aaa:	74 7c                	je     800b28 <vprintfmt+0x571>
        return va_arg(*ap, unsigned long long);
  800aac:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800aaf:	83 f8 2f             	cmp    $0x2f,%eax
  800ab2:	0f 87 9b 00 00 00    	ja     800b53 <vprintfmt+0x59c>
  800ab8:	89 c2                	mov    %eax,%edx
  800aba:	48 01 d6             	add    %rdx,%rsi
  800abd:	83 c0 08             	add    $0x8,%eax
  800ac0:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800ac3:	48 8b 16             	mov    (%rsi),%rdx
            base = 8;
  800ac6:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned long long);
  800acb:	e9 c9 00 00 00       	jmp    800b99 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  800ad0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800ad3:	83 f8 2f             	cmp    $0x2f,%eax
  800ad6:	77 18                	ja     800af0 <vprintfmt+0x539>
  800ad8:	89 c2                	mov    %eax,%edx
  800ada:	48 01 d6             	add    %rdx,%rsi
  800add:	83 c0 08             	add    $0x8,%eax
  800ae0:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800ae3:	48 8b 16             	mov    (%rsi),%rdx
            base = 8;
  800ae6:	b9 08 00 00 00       	mov    $0x8,%ecx
    if (zflag) return va_arg(*ap, size_t);
  800aeb:	e9 a9 00 00 00       	jmp    800b99 <vprintfmt+0x5e2>
  800af0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800af4:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800af8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800afc:	eb e5                	jmp    800ae3 <vprintfmt+0x52c>
        return va_arg(*ap, unsigned int);
  800afe:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800b01:	83 f8 2f             	cmp    $0x2f,%eax
  800b04:	77 14                	ja     800b1a <vprintfmt+0x563>
  800b06:	89 c2                	mov    %eax,%edx
  800b08:	48 01 d6             	add    %rdx,%rsi
  800b0b:	83 c0 08             	add    $0x8,%eax
  800b0e:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800b11:	8b 16                	mov    (%rsi),%edx
            base = 8;
  800b13:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned int);
  800b18:	eb 7f                	jmp    800b99 <vprintfmt+0x5e2>
  800b1a:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800b1e:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800b22:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800b26:	eb e9                	jmp    800b11 <vprintfmt+0x55a>
        return va_arg(*ap, unsigned long);
  800b28:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800b2b:	83 f8 2f             	cmp    $0x2f,%eax
  800b2e:	77 15                	ja     800b45 <vprintfmt+0x58e>
  800b30:	89 c2                	mov    %eax,%edx
  800b32:	48 01 d6             	add    %rdx,%rsi
  800b35:	83 c0 08             	add    $0x8,%eax
  800b38:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800b3b:	48 8b 16             	mov    (%rsi),%rdx
            base = 8;
  800b3e:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned long);
  800b43:	eb 54                	jmp    800b99 <vprintfmt+0x5e2>
  800b45:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800b49:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800b4d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800b51:	eb e8                	jmp    800b3b <vprintfmt+0x584>
        return va_arg(*ap, unsigned long long);
  800b53:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800b57:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800b5b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800b5f:	e9 5f ff ff ff       	jmp    800ac3 <vprintfmt+0x50c>
            putch('0', put_arg);
  800b64:	45 89 cd             	mov    %r9d,%r13d
  800b67:	4c 89 f6             	mov    %r14,%rsi
  800b6a:	bf 30 00 00 00       	mov    $0x30,%edi
  800b6f:	41 ff d4             	call   *%r12
            putch('x', put_arg);
  800b72:	4c 89 f6             	mov    %r14,%rsi
  800b75:	bf 78 00 00 00       	mov    $0x78,%edi
  800b7a:	41 ff d4             	call   *%r12
            num = (uintptr_t)va_arg(aq, void *);
  800b7d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800b80:	83 f8 2f             	cmp    $0x2f,%eax
  800b83:	77 47                	ja     800bcc <vprintfmt+0x615>
  800b85:	89 c2                	mov    %eax,%edx
  800b87:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  800b8b:	83 c0 08             	add    $0x8,%eax
  800b8e:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800b91:	48 8b 12             	mov    (%rdx),%rdx
            base = 16;
  800b94:	b9 10 00 00 00       	mov    $0x10,%ecx
            print_num(putch, put_arg, num, base, width, padc, ch == 'X');
  800b99:	48 83 ec 08          	sub    $0x8,%rsp
  800b9d:	41 80 fd 58          	cmp    $0x58,%r13b
  800ba1:	0f 94 c0             	sete   %al
  800ba4:	0f b6 c0             	movzbl %al,%eax
  800ba7:	50                   	push   %rax
  800ba8:	44 0f be 4d a0       	movsbl -0x60(%rbp),%r9d
  800bad:	44 8b 45 ac          	mov    -0x54(%rbp),%r8d
  800bb1:	4c 89 f6             	mov    %r14,%rsi
  800bb4:	4c 89 e7             	mov    %r12,%rdi
  800bb7:	48 b8 ac 04 80 00 00 	movabs $0x8004ac,%rax
  800bbe:	00 00 00 
  800bc1:	ff d0                	call   *%rax
            break;
  800bc3:	48 83 c4 10          	add    $0x10,%rsp
  800bc7:	e9 1c fa ff ff       	jmp    8005e8 <vprintfmt+0x31>
            num = (uintptr_t)va_arg(aq, void *);
  800bcc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800bd0:	48 8d 42 08          	lea    0x8(%rdx),%rax
  800bd4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800bd8:	eb b7                	jmp    800b91 <vprintfmt+0x5da>
    if (zflag) return va_arg(*ap, size_t);
  800bda:	45 89 cd             	mov    %r9d,%r13d
  800bdd:	84 c9                	test   %cl,%cl
  800bdf:	75 2a                	jne    800c0b <vprintfmt+0x654>
    switch (lflag) {
  800be1:	85 d2                	test   %edx,%edx
  800be3:	74 54                	je     800c39 <vprintfmt+0x682>
  800be5:	83 fa 01             	cmp    $0x1,%edx
  800be8:	74 7c                	je     800c66 <vprintfmt+0x6af>
        return va_arg(*ap, unsigned long long);
  800bea:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800bed:	83 f8 2f             	cmp    $0x2f,%eax
  800bf0:	0f 87 9e 00 00 00    	ja     800c94 <vprintfmt+0x6dd>
  800bf6:	89 c2                	mov    %eax,%edx
  800bf8:	48 01 d6             	add    %rdx,%rsi
  800bfb:	83 c0 08             	add    $0x8,%eax
  800bfe:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800c01:	48 8b 16             	mov    (%rsi),%rdx
            base = 16;
  800c04:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned long long);
  800c09:	eb 8e                	jmp    800b99 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  800c0b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800c0e:	83 f8 2f             	cmp    $0x2f,%eax
  800c11:	77 18                	ja     800c2b <vprintfmt+0x674>
  800c13:	89 c2                	mov    %eax,%edx
  800c15:	48 01 d6             	add    %rdx,%rsi
  800c18:	83 c0 08             	add    $0x8,%eax
  800c1b:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800c1e:	48 8b 16             	mov    (%rsi),%rdx
            base = 16;
  800c21:	b9 10 00 00 00       	mov    $0x10,%ecx
    if (zflag) return va_arg(*ap, size_t);
  800c26:	e9 6e ff ff ff       	jmp    800b99 <vprintfmt+0x5e2>
  800c2b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800c2f:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800c33:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800c37:	eb e5                	jmp    800c1e <vprintfmt+0x667>
        return va_arg(*ap, unsigned int);
  800c39:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800c3c:	83 f8 2f             	cmp    $0x2f,%eax
  800c3f:	77 17                	ja     800c58 <vprintfmt+0x6a1>
  800c41:	89 c2                	mov    %eax,%edx
  800c43:	48 01 d6             	add    %rdx,%rsi
  800c46:	83 c0 08             	add    $0x8,%eax
  800c49:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800c4c:	8b 16                	mov    (%rsi),%edx
            base = 16;
  800c4e:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned int);
  800c53:	e9 41 ff ff ff       	jmp    800b99 <vprintfmt+0x5e2>
  800c58:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800c5c:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800c60:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800c64:	eb e6                	jmp    800c4c <vprintfmt+0x695>
        return va_arg(*ap, unsigned long);
  800c66:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800c69:	83 f8 2f             	cmp    $0x2f,%eax
  800c6c:	77 18                	ja     800c86 <vprintfmt+0x6cf>
  800c6e:	89 c2                	mov    %eax,%edx
  800c70:	48 01 d6             	add    %rdx,%rsi
  800c73:	83 c0 08             	add    $0x8,%eax
  800c76:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800c79:	48 8b 16             	mov    (%rsi),%rdx
            base = 16;
  800c7c:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned long);
  800c81:	e9 13 ff ff ff       	jmp    800b99 <vprintfmt+0x5e2>
  800c86:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800c8a:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800c8e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800c92:	eb e5                	jmp    800c79 <vprintfmt+0x6c2>
        return va_arg(*ap, unsigned long long);
  800c94:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800c98:	48 8d 46 08          	lea    0x8(%rsi),%rax
  800c9c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800ca0:	e9 5c ff ff ff       	jmp    800c01 <vprintfmt+0x64a>
            putch(ch, put_arg);
  800ca5:	4c 89 f6             	mov    %r14,%rsi
  800ca8:	bf 25 00 00 00       	mov    $0x25,%edi
  800cad:	41 ff d4             	call   *%r12
            break;
  800cb0:	e9 33 f9 ff ff       	jmp    8005e8 <vprintfmt+0x31>
            putch('%', put_arg);
  800cb5:	4c 89 f6             	mov    %r14,%rsi
  800cb8:	bf 25 00 00 00       	mov    $0x25,%edi
  800cbd:	41 ff d4             	call   *%r12
            while ((--ufmt)[-1] != '%') /* nothing */
  800cc0:	49 83 ef 01          	sub    $0x1,%r15
  800cc4:	41 80 7f ff 25       	cmpb   $0x25,-0x1(%r15)
  800cc9:	75 f5                	jne    800cc0 <vprintfmt+0x709>
  800ccb:	e9 18 f9 ff ff       	jmp    8005e8 <vprintfmt+0x31>
}
  800cd0:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  800cd4:	5b                   	pop    %rbx
  800cd5:	41 5c                	pop    %r12
  800cd7:	41 5d                	pop    %r13
  800cd9:	41 5e                	pop    %r14
  800cdb:	41 5f                	pop    %r15
  800cdd:	5d                   	pop    %rbp
  800cde:	c3                   	ret    

0000000000800cdf <vsnprintf>:

int
vsnprintf(char *buf, size_t n, const char *fmt, va_list ap) {
  800cdf:	55                   	push   %rbp
  800ce0:	48 89 e5             	mov    %rsp,%rbp
  800ce3:	48 83 ec 20          	sub    $0x20,%rsp
    struct sprintbuf state = {buf, buf + n - 1, 0};
  800ce7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800ceb:	48 8d 44 37 ff       	lea    -0x1(%rdi,%rsi,1),%rax
  800cf0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800cf4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

    if (!buf || n < 1) return -E_INVAL;
  800cfb:	48 85 ff             	test   %rdi,%rdi
  800cfe:	74 2b                	je     800d2b <vsnprintf+0x4c>
  800d00:	48 85 f6             	test   %rsi,%rsi
  800d03:	74 26                	je     800d2b <vsnprintf+0x4c>

    /* Print the string to the buffer */
    vprintfmt((void *)sprintputch, &state, fmt, ap);
  800d05:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800d09:	48 bf 62 05 80 00 00 	movabs $0x800562,%rdi
  800d10:	00 00 00 
  800d13:	48 b8 b7 05 80 00 00 	movabs $0x8005b7,%rax
  800d1a:	00 00 00 
  800d1d:	ff d0                	call   *%rax

    /* Null terminate the buffer */
    *state.start = '\0';
  800d1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800d23:	c6 00 00             	movb   $0x0,(%rax)

    return state.count;
  800d26:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  800d29:	c9                   	leave  
  800d2a:	c3                   	ret    
    if (!buf || n < 1) return -E_INVAL;
  800d2b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800d30:	eb f7                	jmp    800d29 <vsnprintf+0x4a>

0000000000800d32 <snprintf>:

int
snprintf(char *buf, size_t n, const char *fmt, ...) {
  800d32:	55                   	push   %rbp
  800d33:	48 89 e5             	mov    %rsp,%rbp
  800d36:	48 83 ec 50          	sub    $0x50,%rsp
  800d3a:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  800d3e:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  800d42:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_list ap;

    va_start(ap, fmt);
  800d46:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
  800d4d:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800d51:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800d55:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800d59:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int rc = vsnprintf(buf, n, fmt, ap);
  800d5d:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  800d61:	48 b8 df 0c 80 00 00 	movabs $0x800cdf,%rax
  800d68:	00 00 00 
  800d6b:	ff d0                	call   *%rax
    va_end(ap);

    return rc;
}
  800d6d:	c9                   	leave  
  800d6e:	c3                   	ret    

0000000000800d6f <strlen>:
#define ASM 1

size_t
strlen(const char *s) {
    size_t n = 0;
    while (*s++) n++;
  800d6f:	80 3f 00             	cmpb   $0x0,(%rdi)
  800d72:	74 10                	je     800d84 <strlen+0x15>
    size_t n = 0;
  800d74:	b8 00 00 00 00       	mov    $0x0,%eax
    while (*s++) n++;
  800d79:	48 83 c0 01          	add    $0x1,%rax
  800d7d:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  800d81:	75 f6                	jne    800d79 <strlen+0xa>
  800d83:	c3                   	ret    
    size_t n = 0;
  800d84:	b8 00 00 00 00       	mov    $0x0,%eax
    return n;
}
  800d89:	c3                   	ret    

0000000000800d8a <strnlen>:

size_t
strnlen(const char *s, size_t size) {
    size_t n = 0;
  800d8a:	b8 00 00 00 00       	mov    $0x0,%eax
    while (n < size && *s++) n++;
  800d8f:	48 85 f6             	test   %rsi,%rsi
  800d92:	74 10                	je     800da4 <strnlen+0x1a>
  800d94:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  800d98:	74 09                	je     800da3 <strnlen+0x19>
  800d9a:	48 83 c0 01          	add    $0x1,%rax
  800d9e:	48 39 c6             	cmp    %rax,%rsi
  800da1:	75 f1                	jne    800d94 <strnlen+0xa>
    return n;
}
  800da3:	c3                   	ret    
    size_t n = 0;
  800da4:	48 89 f0             	mov    %rsi,%rax
  800da7:	c3                   	ret    

0000000000800da8 <strcpy>:

char *
strcpy(char *dst, const char *src) {
    char *res = dst;
    while ((*dst++ = *src++)) /* nothing */
  800da8:	b8 00 00 00 00       	mov    $0x0,%eax
  800dad:	0f b6 14 06          	movzbl (%rsi,%rax,1),%edx
  800db1:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  800db4:	48 83 c0 01          	add    $0x1,%rax
  800db8:	84 d2                	test   %dl,%dl
  800dba:	75 f1                	jne    800dad <strcpy+0x5>
        ;
    return res;
}
  800dbc:	48 89 f8             	mov    %rdi,%rax
  800dbf:	c3                   	ret    

0000000000800dc0 <strcat>:

char *
strcat(char *dst, const char *src) {
  800dc0:	55                   	push   %rbp
  800dc1:	48 89 e5             	mov    %rsp,%rbp
  800dc4:	41 54                	push   %r12
  800dc6:	53                   	push   %rbx
  800dc7:	48 89 fb             	mov    %rdi,%rbx
  800dca:	49 89 f4             	mov    %rsi,%r12
    size_t len = strlen(dst);
  800dcd:	48 b8 6f 0d 80 00 00 	movabs $0x800d6f,%rax
  800dd4:	00 00 00 
  800dd7:	ff d0                	call   *%rax
    strcpy(dst + len, src);
  800dd9:	48 8d 3c 03          	lea    (%rbx,%rax,1),%rdi
  800ddd:	4c 89 e6             	mov    %r12,%rsi
  800de0:	48 b8 a8 0d 80 00 00 	movabs $0x800da8,%rax
  800de7:	00 00 00 
  800dea:	ff d0                	call   *%rax
    return dst;
}
  800dec:	48 89 d8             	mov    %rbx,%rax
  800def:	5b                   	pop    %rbx
  800df0:	41 5c                	pop    %r12
  800df2:	5d                   	pop    %rbp
  800df3:	c3                   	ret    

0000000000800df4 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
    char *ret = dst;
    while (size-- > 0) {
  800df4:	48 85 d2             	test   %rdx,%rdx
  800df7:	74 1d                	je     800e16 <strncpy+0x22>
  800df9:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
  800dfd:	48 89 f8             	mov    %rdi,%rax
        *dst++ = *src;
  800e00:	48 83 c0 01          	add    $0x1,%rax
  800e04:	0f b6 16             	movzbl (%rsi),%edx
  800e07:	88 50 ff             	mov    %dl,-0x1(%rax)
        /* If strlen(src) < size, null-pad
         * 'dst' out to 'size' chars */
        if (*src) src++;
  800e0a:	80 fa 01             	cmp    $0x1,%dl
  800e0d:	48 83 de ff          	sbb    $0xffffffffffffffff,%rsi
    while (size-- > 0) {
  800e11:	48 39 c1             	cmp    %rax,%rcx
  800e14:	75 ea                	jne    800e00 <strncpy+0xc>
    }
    return ret;
}
  800e16:	48 89 f8             	mov    %rdi,%rax
  800e19:	c3                   	ret    

0000000000800e1a <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size) {
    char *dst_in = dst;
    if (size) {
  800e1a:	48 89 f8             	mov    %rdi,%rax
  800e1d:	48 85 d2             	test   %rdx,%rdx
  800e20:	74 24                	je     800e46 <strlcpy+0x2c>
        while (--size > 0 && *src)
  800e22:	48 83 ea 01          	sub    $0x1,%rdx
  800e26:	74 1b                	je     800e43 <strlcpy+0x29>
  800e28:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
  800e2c:	0f b6 16             	movzbl (%rsi),%edx
  800e2f:	84 d2                	test   %dl,%dl
  800e31:	74 10                	je     800e43 <strlcpy+0x29>
            *dst++ = *src++;
  800e33:	48 83 c6 01          	add    $0x1,%rsi
  800e37:	48 83 c0 01          	add    $0x1,%rax
  800e3b:	88 50 ff             	mov    %dl,-0x1(%rax)
        while (--size > 0 && *src)
  800e3e:	48 39 c8             	cmp    %rcx,%rax
  800e41:	75 e9                	jne    800e2c <strlcpy+0x12>
        *dst = '\0';
  800e43:	c6 00 00             	movb   $0x0,(%rax)
    }
    return dst - dst_in;
  800e46:	48 29 f8             	sub    %rdi,%rax
}
  800e49:	c3                   	ret    

0000000000800e4a <strcmp>:
    return dstlen + srclen;
}

int
strcmp(const char *p, const char *q) {
    while (*p && *p == *q) p++, q++;
  800e4a:	0f b6 07             	movzbl (%rdi),%eax
  800e4d:	84 c0                	test   %al,%al
  800e4f:	74 13                	je     800e64 <strcmp+0x1a>
  800e51:	38 06                	cmp    %al,(%rsi)
  800e53:	75 0f                	jne    800e64 <strcmp+0x1a>
  800e55:	48 83 c7 01          	add    $0x1,%rdi
  800e59:	48 83 c6 01          	add    $0x1,%rsi
  800e5d:	0f b6 07             	movzbl (%rdi),%eax
  800e60:	84 c0                	test   %al,%al
  800e62:	75 ed                	jne    800e51 <strcmp+0x7>
    return (int)((unsigned char)*p - (unsigned char)*q);
  800e64:	0f b6 c0             	movzbl %al,%eax
  800e67:	0f b6 16             	movzbl (%rsi),%edx
  800e6a:	29 d0                	sub    %edx,%eax
}
  800e6c:	c3                   	ret    

0000000000800e6d <strncmp>:

int
strncmp(const char *p, const char *q, size_t n) {
    while (n && *p && *p == *q) n--, p++, q++;
  800e6d:	48 85 d2             	test   %rdx,%rdx
  800e70:	74 1f                	je     800e91 <strncmp+0x24>
  800e72:	0f b6 07             	movzbl (%rdi),%eax
  800e75:	84 c0                	test   %al,%al
  800e77:	74 1e                	je     800e97 <strncmp+0x2a>
  800e79:	3a 06                	cmp    (%rsi),%al
  800e7b:	75 1a                	jne    800e97 <strncmp+0x2a>
  800e7d:	48 83 c7 01          	add    $0x1,%rdi
  800e81:	48 83 c6 01          	add    $0x1,%rsi
  800e85:	48 83 ea 01          	sub    $0x1,%rdx
  800e89:	75 e7                	jne    800e72 <strncmp+0x5>

    if (!n) return 0;
  800e8b:	b8 00 00 00 00       	mov    $0x0,%eax
  800e90:	c3                   	ret    
  800e91:	b8 00 00 00 00       	mov    $0x0,%eax
  800e96:	c3                   	ret    
  800e97:	48 85 d2             	test   %rdx,%rdx
  800e9a:	74 09                	je     800ea5 <strncmp+0x38>

    return (int)((unsigned char)*p - (unsigned char)*q);
  800e9c:	0f b6 07             	movzbl (%rdi),%eax
  800e9f:	0f b6 16             	movzbl (%rsi),%edx
  800ea2:	29 d0                	sub    %edx,%eax
  800ea4:	c3                   	ret    
    if (!n) return 0;
  800ea5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800eaa:	c3                   	ret    

0000000000800eab <strchr>:

/* Return a pointer to the first occurrence of 'c' in 's',
 *  * or a null pointer if the string has no 'c' */
char *
strchr(const char *str, int c) {
    for (; *str; str++) {
  800eab:	0f b6 07             	movzbl (%rdi),%eax
  800eae:	84 c0                	test   %al,%al
  800eb0:	74 18                	je     800eca <strchr+0x1f>
        if (*str == c) {
  800eb2:	0f be c0             	movsbl %al,%eax
  800eb5:	39 f0                	cmp    %esi,%eax
  800eb7:	74 17                	je     800ed0 <strchr+0x25>
    for (; *str; str++) {
  800eb9:	48 83 c7 01          	add    $0x1,%rdi
  800ebd:	0f b6 07             	movzbl (%rdi),%eax
  800ec0:	84 c0                	test   %al,%al
  800ec2:	75 ee                	jne    800eb2 <strchr+0x7>
            return (char *)str;
        }
    }
    return NULL;
  800ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  800ec9:	c3                   	ret    
  800eca:	b8 00 00 00 00       	mov    $0x0,%eax
  800ecf:	c3                   	ret    
  800ed0:	48 89 f8             	mov    %rdi,%rax
}
  800ed3:	c3                   	ret    

0000000000800ed4 <strfind>:

/* Return a pointer to the first occurrence of 'c' in 's',
 *  * or a pointer to the string-ending null character if the string has no 'c' */
char *
strfind(const char *str, int ch) {
    for (; *str && *str != ch; str++) /* nothing */
  800ed4:	0f b6 07             	movzbl (%rdi),%eax
  800ed7:	84 c0                	test   %al,%al
  800ed9:	74 16                	je     800ef1 <strfind+0x1d>
  800edb:	0f be c0             	movsbl %al,%eax
  800ede:	39 f0                	cmp    %esi,%eax
  800ee0:	74 13                	je     800ef5 <strfind+0x21>
  800ee2:	48 83 c7 01          	add    $0x1,%rdi
  800ee6:	0f b6 07             	movzbl (%rdi),%eax
  800ee9:	84 c0                	test   %al,%al
  800eeb:	75 ee                	jne    800edb <strfind+0x7>
  800eed:	48 89 f8             	mov    %rdi,%rax
        ;
    return (char *)str;
}
  800ef0:	c3                   	ret    
    for (; *str && *str != ch; str++) /* nothing */
  800ef1:	48 89 f8             	mov    %rdi,%rax
  800ef4:	c3                   	ret    
  800ef5:	48 89 f8             	mov    %rdi,%rax
  800ef8:	c3                   	ret    

0000000000800ef9 <memset>:


#if ASM
void *
memset(void *v, int c, size_t n) {
  800ef9:	49 89 f8             	mov    %rdi,%r8
    uint8_t *ptr = v;
    ssize_t ni = n;

    if (__builtin_expect((ni -= ((8 - ((uintptr_t)v & 7))) & 7) < 0, 0)) {
  800efc:	48 89 f8             	mov    %rdi,%rax
  800eff:	48 f7 d8             	neg    %rax
  800f02:	83 e0 07             	and    $0x7,%eax
  800f05:	49 89 d1             	mov    %rdx,%r9
  800f08:	49 29 c1             	sub    %rax,%r9
  800f0b:	78 32                	js     800f3f <memset+0x46>
        while (n-- > 0) *ptr++ = c;
        return v;
    }

    uint64_t k = 0x101010101010101ULL * (c & 0xFFU);
  800f0d:	40 0f b6 c6          	movzbl %sil,%eax
  800f11:	48 be 01 01 01 01 01 	movabs $0x101010101010101,%rsi
  800f18:	01 01 01 
  800f1b:	48 0f af c6          	imul   %rsi,%rax

    if (__builtin_expect((uintptr_t)ptr & 7, 0)) {
  800f1f:	40 f6 c7 07          	test   $0x7,%dil
  800f23:	75 34                	jne    800f59 <memset+0x60>
        if ((uintptr_t)ptr & 1) *ptr = k, ptr += 1;
        if ((uintptr_t)ptr & 2) *(uint16_t *)ptr = k, ptr += 2;
        if ((uintptr_t)ptr & 4) *(uint32_t *)ptr = k, ptr += 4;
    }

    if (__builtin_expect(ni >> 3, 1)) {
  800f25:	4c 89 c9             	mov    %r9,%rcx
  800f28:	48 c1 f9 03          	sar    $0x3,%rcx
  800f2c:	74 08                	je     800f36 <memset+0x3d>
        asm volatile("cld; rep stosq\n" ::"D"(ptr), "a"(k), "c"(ni >> 3)
  800f2e:	fc                   	cld    
  800f2f:	f3 48 ab             	rep stos %rax,%es:(%rdi)
                     : "cc", "memory");
        ni &= 7;
  800f32:	41 83 e1 07          	and    $0x7,%r9d
    }

    if (__builtin_expect(ni, 0)) {
  800f36:	4d 85 c9             	test   %r9,%r9
  800f39:	75 45                	jne    800f80 <memset+0x87>
        if (ni & 2) *(uint16_t *)ptr = k, ptr += 2;
        if (ni & 1) *ptr = k;
    }

    return v;
}
  800f3b:	4c 89 c0             	mov    %r8,%rax
  800f3e:	c3                   	ret    
        while (n-- > 0) *ptr++ = c;
  800f3f:	48 85 d2             	test   %rdx,%rdx
  800f42:	74 f7                	je     800f3b <memset+0x42>
  800f44:	48 01 fa             	add    %rdi,%rdx
    uint8_t *ptr = v;
  800f47:	48 89 f8             	mov    %rdi,%rax
        while (n-- > 0) *ptr++ = c;
  800f4a:	48 83 c0 01          	add    $0x1,%rax
  800f4e:	40 88 70 ff          	mov    %sil,-0x1(%rax)
  800f52:	48 39 c2             	cmp    %rax,%rdx
  800f55:	75 f3                	jne    800f4a <memset+0x51>
  800f57:	eb e2                	jmp    800f3b <memset+0x42>
        if ((uintptr_t)ptr & 1) *ptr = k, ptr += 1;
  800f59:	40 f6 c7 01          	test   $0x1,%dil
  800f5d:	74 06                	je     800f65 <memset+0x6c>
  800f5f:	88 07                	mov    %al,(%rdi)
  800f61:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
        if ((uintptr_t)ptr & 2) *(uint16_t *)ptr = k, ptr += 2;
  800f65:	40 f6 c7 02          	test   $0x2,%dil
  800f69:	74 07                	je     800f72 <memset+0x79>
  800f6b:	66 89 07             	mov    %ax,(%rdi)
  800f6e:	48 83 c7 02          	add    $0x2,%rdi
        if ((uintptr_t)ptr & 4) *(uint32_t *)ptr = k, ptr += 4;
  800f72:	40 f6 c7 04          	test   $0x4,%dil
  800f76:	74 ad                	je     800f25 <memset+0x2c>
  800f78:	89 07                	mov    %eax,(%rdi)
  800f7a:	48 83 c7 04          	add    $0x4,%rdi
  800f7e:	eb a5                	jmp    800f25 <memset+0x2c>
        if (ni & 4) *(uint32_t *)ptr = k, ptr += 4;
  800f80:	41 f6 c1 04          	test   $0x4,%r9b
  800f84:	74 06                	je     800f8c <memset+0x93>
  800f86:	89 07                	mov    %eax,(%rdi)
  800f88:	48 83 c7 04          	add    $0x4,%rdi
        if (ni & 2) *(uint16_t *)ptr = k, ptr += 2;
  800f8c:	41 f6 c1 02          	test   $0x2,%r9b
  800f90:	74 07                	je     800f99 <memset+0xa0>
  800f92:	66 89 07             	mov    %ax,(%rdi)
  800f95:	48 83 c7 02          	add    $0x2,%rdi
        if (ni & 1) *ptr = k;
  800f99:	41 f6 c1 01          	test   $0x1,%r9b
  800f9d:	74 9c                	je     800f3b <memset+0x42>
  800f9f:	88 07                	mov    %al,(%rdi)
  800fa1:	eb 98                	jmp    800f3b <memset+0x42>

0000000000800fa3 <memmove>:

void *
memmove(void *dst, const void *src, size_t n) {
  800fa3:	48 89 f8             	mov    %rdi,%rax
  800fa6:	48 89 d1             	mov    %rdx,%rcx
    const char *s = src;
    char *d = dst;

    if (s < d && s + n > d) {
  800fa9:	48 39 fe             	cmp    %rdi,%rsi
  800fac:	73 39                	jae    800fe7 <memmove+0x44>
  800fae:	48 01 f2             	add    %rsi,%rdx
  800fb1:	48 39 fa             	cmp    %rdi,%rdx
  800fb4:	76 31                	jbe    800fe7 <memmove+0x44>
        s += n;
        d += n;
  800fb6:	48 01 cf             	add    %rcx,%rdi
        if (!(((intptr_t)s & 7) | ((intptr_t)d & 7) | (n & 7))) {
  800fb9:	48 89 d6             	mov    %rdx,%rsi
  800fbc:	48 09 fe             	or     %rdi,%rsi
  800fbf:	48 09 ce             	or     %rcx,%rsi
  800fc2:	40 f6 c6 07          	test   $0x7,%sil
  800fc6:	75 12                	jne    800fda <memmove+0x37>
            asm volatile("std; rep movsq\n" ::"D"(d - 8), "S"(s - 8), "c"(n / 8)
  800fc8:	48 83 ef 08          	sub    $0x8,%rdi
  800fcc:	48 8d 72 f8          	lea    -0x8(%rdx),%rsi
  800fd0:	48 c1 e9 03          	shr    $0x3,%rcx
  800fd4:	fd                   	std    
  800fd5:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        } else {
            asm volatile("std; rep movsb\n" ::"D"(d - 1), "S"(s - 1), "c"(n)
                         : "cc", "memory");
        }
        /* Some versions of GCC rely on DF being clear */
        asm volatile("cld" ::
  800fd8:	fc                   	cld    
  800fd9:	c3                   	ret    
            asm volatile("std; rep movsb\n" ::"D"(d - 1), "S"(s - 1), "c"(n)
  800fda:	48 83 ef 01          	sub    $0x1,%rdi
  800fde:	48 8d 72 ff          	lea    -0x1(%rdx),%rsi
  800fe2:	fd                   	std    
  800fe3:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
  800fe5:	eb f1                	jmp    800fd8 <memmove+0x35>
                             : "cc");
    } else {
        if (!(((intptr_t)s & 7) | ((intptr_t)d & 7) | (n & 7))) {
  800fe7:	48 89 f2             	mov    %rsi,%rdx
  800fea:	48 09 c2             	or     %rax,%rdx
  800fed:	48 09 ca             	or     %rcx,%rdx
  800ff0:	f6 c2 07             	test   $0x7,%dl
  800ff3:	75 0c                	jne    801001 <memmove+0x5e>
            asm volatile("cld; rep movsq\n" ::"D"(d), "S"(s), "c"(n / 8)
  800ff5:	48 c1 e9 03          	shr    $0x3,%rcx
  800ff9:	48 89 c7             	mov    %rax,%rdi
  800ffc:	fc                   	cld    
  800ffd:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
  801000:	c3                   	ret    
                         : "cc", "memory");
        } else {
            asm volatile("cld; rep movsb\n" ::"D"(d), "S"(s), "c"(n)
  801001:	48 89 c7             	mov    %rax,%rdi
  801004:	fc                   	cld    
  801005:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
                         : "cc", "memory");
        }
    }
    return dst;
}
  801007:	c3                   	ret    

0000000000801008 <memcpy>:
    return dst;
}
#endif

void *
memcpy(void *dst, const void *src, size_t n) {
  801008:	55                   	push   %rbp
  801009:	48 89 e5             	mov    %rsp,%rbp
    return memmove(dst, src, n);
  80100c:	48 b8 a3 0f 80 00 00 	movabs $0x800fa3,%rax
  801013:	00 00 00 
  801016:	ff d0                	call   *%rax
}
  801018:	5d                   	pop    %rbp
  801019:	c3                   	ret    

000000000080101a <strlcat>:
strlcat(char *restrict dst, const char *restrict src, size_t maxlen) {
  80101a:	55                   	push   %rbp
  80101b:	48 89 e5             	mov    %rsp,%rbp
  80101e:	41 57                	push   %r15
  801020:	41 56                	push   %r14
  801022:	41 55                	push   %r13
  801024:	41 54                	push   %r12
  801026:	53                   	push   %rbx
  801027:	48 83 ec 08          	sub    $0x8,%rsp
  80102b:	49 89 fe             	mov    %rdi,%r14
  80102e:	49 89 f7             	mov    %rsi,%r15
  801031:	48 89 d3             	mov    %rdx,%rbx
    const size_t srclen = strlen(src);
  801034:	48 89 f7             	mov    %rsi,%rdi
  801037:	48 b8 6f 0d 80 00 00 	movabs $0x800d6f,%rax
  80103e:	00 00 00 
  801041:	ff d0                	call   *%rax
  801043:	49 89 c4             	mov    %rax,%r12
    const size_t dstlen = strnlen(dst, maxlen);
  801046:	48 89 de             	mov    %rbx,%rsi
  801049:	4c 89 f7             	mov    %r14,%rdi
  80104c:	48 b8 8a 0d 80 00 00 	movabs $0x800d8a,%rax
  801053:	00 00 00 
  801056:	ff d0                	call   *%rax
  801058:	49 89 c5             	mov    %rax,%r13
    if (dstlen == maxlen) return maxlen + srclen;
  80105b:	48 39 c3             	cmp    %rax,%rbx
  80105e:	74 36                	je     801096 <strlcat+0x7c>
    if (srclen < maxlen - dstlen) {
  801060:	48 89 d8             	mov    %rbx,%rax
  801063:	4c 29 e8             	sub    %r13,%rax
  801066:	4c 39 e0             	cmp    %r12,%rax
  801069:	76 30                	jbe    80109b <strlcat+0x81>
        memcpy(dst + dstlen, src, srclen + 1);
  80106b:	49 8d 54 24 01       	lea    0x1(%r12),%rdx
  801070:	4b 8d 3c 2e          	lea    (%r14,%r13,1),%rdi
  801074:	4c 89 fe             	mov    %r15,%rsi
  801077:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  80107e:	00 00 00 
  801081:	ff d0                	call   *%rax
    return dstlen + srclen;
  801083:	4b 8d 04 2c          	lea    (%r12,%r13,1),%rax
}
  801087:	48 83 c4 08          	add    $0x8,%rsp
  80108b:	5b                   	pop    %rbx
  80108c:	41 5c                	pop    %r12
  80108e:	41 5d                	pop    %r13
  801090:	41 5e                	pop    %r14
  801092:	41 5f                	pop    %r15
  801094:	5d                   	pop    %rbp
  801095:	c3                   	ret    
    if (dstlen == maxlen) return maxlen + srclen;
  801096:	4c 01 e0             	add    %r12,%rax
  801099:	eb ec                	jmp    801087 <strlcat+0x6d>
        memcpy(dst + dstlen, src, maxlen - 1);
  80109b:	48 83 eb 01          	sub    $0x1,%rbx
  80109f:	4b 8d 3c 2e          	lea    (%r14,%r13,1),%rdi
  8010a3:	48 89 da             	mov    %rbx,%rdx
  8010a6:	4c 89 fe             	mov    %r15,%rsi
  8010a9:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  8010b0:	00 00 00 
  8010b3:	ff d0                	call   *%rax
        dst[dstlen + maxlen - 1] = '\0';
  8010b5:	49 01 de             	add    %rbx,%r14
  8010b8:	43 c6 04 2e 00       	movb   $0x0,(%r14,%r13,1)
  8010bd:	eb c4                	jmp    801083 <strlcat+0x69>

00000000008010bf <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n) {
  8010bf:	49 89 f0             	mov    %rsi,%r8
  8010c2:	48 89 d6             	mov    %rdx,%rsi
    const uint8_t *s1 = (const uint8_t *)v1;
    const uint8_t *s2 = (const uint8_t *)v2;

    while (n-- > 0) {
  8010c5:	48 85 d2             	test   %rdx,%rdx
  8010c8:	74 2a                	je     8010f4 <memcmp+0x35>
  8010ca:	b8 00 00 00 00       	mov    $0x0,%eax
        if (*s1 != *s2) {
  8010cf:	0f b6 14 07          	movzbl (%rdi,%rax,1),%edx
  8010d3:	41 0f b6 0c 00       	movzbl (%r8,%rax,1),%ecx
  8010d8:	38 ca                	cmp    %cl,%dl
  8010da:	75 0f                	jne    8010eb <memcmp+0x2c>
    while (n-- > 0) {
  8010dc:	48 83 c0 01          	add    $0x1,%rax
  8010e0:	48 39 c6             	cmp    %rax,%rsi
  8010e3:	75 ea                	jne    8010cf <memcmp+0x10>
            return (int)*s1 - (int)*s2;
        }
        s1++, s2++;
    }

    return 0;
  8010e5:	b8 00 00 00 00       	mov    $0x0,%eax
  8010ea:	c3                   	ret    
            return (int)*s1 - (int)*s2;
  8010eb:	0f b6 c2             	movzbl %dl,%eax
  8010ee:	0f b6 c9             	movzbl %cl,%ecx
  8010f1:	29 c8                	sub    %ecx,%eax
  8010f3:	c3                   	ret    
    return 0;
  8010f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8010f9:	c3                   	ret    

00000000008010fa <memfind>:

void *
memfind(const void *src, int c, size_t n) {
    const void *end = (const char *)src + n;
  8010fa:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
    for (; src < end; src++) {
  8010fe:	48 39 c7             	cmp    %rax,%rdi
  801101:	73 0f                	jae    801112 <memfind+0x18>
        if (*(const unsigned char *)src == (unsigned char)c) break;
  801103:	40 38 37             	cmp    %sil,(%rdi)
  801106:	74 0e                	je     801116 <memfind+0x1c>
    for (; src < end; src++) {
  801108:	48 83 c7 01          	add    $0x1,%rdi
  80110c:	48 39 f8             	cmp    %rdi,%rax
  80110f:	75 f2                	jne    801103 <memfind+0x9>
  801111:	c3                   	ret    
  801112:	48 89 f8             	mov    %rdi,%rax
  801115:	c3                   	ret    
  801116:	48 89 f8             	mov    %rdi,%rax
    }
    return (void *)src;
}
  801119:	c3                   	ret    

000000000080111a <strtol>:

long
strtol(const char *s, char **endptr, int base) {
  80111a:	49 89 f2             	mov    %rsi,%r10
  80111d:	41 89 d0             	mov    %edx,%r8d
    /* Gobble initial whitespace */
    while (*s == ' ' || *s == '\t') s++;
  801120:	0f b6 37             	movzbl (%rdi),%esi
  801123:	40 80 fe 20          	cmp    $0x20,%sil
  801127:	74 06                	je     80112f <strtol+0x15>
  801129:	40 80 fe 09          	cmp    $0x9,%sil
  80112d:	75 13                	jne    801142 <strtol+0x28>
  80112f:	48 83 c7 01          	add    $0x1,%rdi
  801133:	0f b6 37             	movzbl (%rdi),%esi
  801136:	40 80 fe 20          	cmp    $0x20,%sil
  80113a:	74 f3                	je     80112f <strtol+0x15>
  80113c:	40 80 fe 09          	cmp    $0x9,%sil
  801140:	74 ed                	je     80112f <strtol+0x15>

    bool neg = *s == '-';

    /* Plus/minus sign */
    if (*s == '+' || *s == '-') s++;
  801142:	8d 46 d5             	lea    -0x2b(%rsi),%eax
  801145:	83 e0 fd             	and    $0xfffffffd,%eax
  801148:	3c 01                	cmp    $0x1,%al
  80114a:	48 83 d7 00          	adc    $0x0,%rdi

    /* Hex or octal base prefix */
    if ((!base || base == 16) && (s[0] == '0' && s[1] == 'x')) {
  80114e:	41 f7 c0 ef ff ff ff 	test   $0xffffffef,%r8d
  801155:	75 11                	jne    801168 <strtol+0x4e>
  801157:	80 3f 30             	cmpb   $0x30,(%rdi)
  80115a:	74 16                	je     801172 <strtol+0x58>
        s += 2;
    } else if (!base && s[0] == '0') {
        base = 8;
        s++;
    } else if (!base) {
        base = 10;
  80115c:	45 85 c0             	test   %r8d,%r8d
  80115f:	b8 0a 00 00 00       	mov    $0xa,%eax
  801164:	44 0f 44 c0          	cmove  %eax,%r8d
    }

    /* Digits */
    long val = 0;
  801168:	ba 00 00 00 00       	mov    $0x0,%edx
            break;

        if (dig >= base) break;

        /* We don't properly detect overflow! */
        val = val * base + dig;
  80116d:	4d 63 c8             	movslq %r8d,%r9
  801170:	eb 38                	jmp    8011aa <strtol+0x90>
    if ((!base || base == 16) && (s[0] == '0' && s[1] == 'x')) {
  801172:	80 7f 01 78          	cmpb   $0x78,0x1(%rdi)
  801176:	74 11                	je     801189 <strtol+0x6f>
    } else if (!base && s[0] == '0') {
  801178:	45 85 c0             	test   %r8d,%r8d
  80117b:	75 eb                	jne    801168 <strtol+0x4e>
        s++;
  80117d:	48 83 c7 01          	add    $0x1,%rdi
        base = 8;
  801181:	41 b8 08 00 00 00    	mov    $0x8,%r8d
        s++;
  801187:	eb df                	jmp    801168 <strtol+0x4e>
        s += 2;
  801189:	48 83 c7 02          	add    $0x2,%rdi
        base = 16;
  80118d:	41 b8 10 00 00 00    	mov    $0x10,%r8d
        s += 2;
  801193:	eb d3                	jmp    801168 <strtol+0x4e>
            dig -= '0';
  801195:	83 e8 30             	sub    $0x30,%eax
        if (dig >= base) break;
  801198:	0f b6 c8             	movzbl %al,%ecx
  80119b:	44 39 c1             	cmp    %r8d,%ecx
  80119e:	7d 1f                	jge    8011bf <strtol+0xa5>
        val = val * base + dig;
  8011a0:	49 0f af d1          	imul   %r9,%rdx
  8011a4:	0f b6 c0             	movzbl %al,%eax
  8011a7:	48 01 c2             	add    %rax,%rdx
        uint8_t dig = *s++;
  8011aa:	48 83 c7 01          	add    $0x1,%rdi
  8011ae:	0f b6 47 ff          	movzbl -0x1(%rdi),%eax
        if (dig - '0' < 10)
  8011b2:	3c 39                	cmp    $0x39,%al
  8011b4:	76 df                	jbe    801195 <strtol+0x7b>
        else if (dig - 'a' < 27)
  8011b6:	3c 7b                	cmp    $0x7b,%al
  8011b8:	77 05                	ja     8011bf <strtol+0xa5>
            dig -= 'a' - 10;
  8011ba:	83 e8 57             	sub    $0x57,%eax
  8011bd:	eb d9                	jmp    801198 <strtol+0x7e>
    }

    if (endptr) *endptr = (char *)s;
  8011bf:	4d 85 d2             	test   %r10,%r10
  8011c2:	74 03                	je     8011c7 <strtol+0xad>
  8011c4:	49 89 3a             	mov    %rdi,(%r10)

    return (neg ? -val : val);
  8011c7:	48 89 d0             	mov    %rdx,%rax
  8011ca:	48 f7 d8             	neg    %rax
  8011cd:	40 80 fe 2d          	cmp    $0x2d,%sil
  8011d1:	48 0f 44 d0          	cmove  %rax,%rdx
}
  8011d5:	48 89 d0             	mov    %rdx,%rax
  8011d8:	c3                   	ret    

00000000008011d9 <sys_cputs>:

    return ret;
}

void
sys_cputs(const char *s, size_t len) {
  8011d9:	55                   	push   %rbp
  8011da:	48 89 e5             	mov    %rsp,%rbp
  8011dd:	53                   	push   %rbx
  8011de:	48 89 fa             	mov    %rdi,%rdx
  8011e1:	48 89 f1             	mov    %rsi,%rcx
    register uintptr_t _a0 asm("rax") = num,
  8011e4:	b8 00 00 00 00       	mov    $0x0,%eax
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  8011e9:	bb 00 00 00 00       	mov    $0x0,%ebx
  8011ee:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  8011f3:	be 00 00 00 00       	mov    $0x0,%esi
  8011f8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  8011fe:	cd 30                	int    $0x30
    syscall(SYS_cputs, 0, (uintptr_t)s, len, 0, 0, 0, 0);
}
  801200:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801204:	c9                   	leave  
  801205:	c3                   	ret    

0000000000801206 <sys_cgetc>:

int
sys_cgetc(void) {
  801206:	55                   	push   %rbp
  801207:	48 89 e5             	mov    %rsp,%rbp
  80120a:	53                   	push   %rbx
    register uintptr_t _a0 asm("rax") = num,
  80120b:	b8 01 00 00 00       	mov    $0x1,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  801210:	ba 00 00 00 00       	mov    $0x0,%edx
  801215:	b9 00 00 00 00       	mov    $0x0,%ecx
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  80121a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80121f:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  801224:	be 00 00 00 00       	mov    $0x0,%esi
  801229:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  80122f:	cd 30                	int    $0x30
    return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0, 0);
}
  801231:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801235:	c9                   	leave  
  801236:	c3                   	ret    

0000000000801237 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid) {
  801237:	55                   	push   %rbp
  801238:	48 89 e5             	mov    %rsp,%rbp
  80123b:	53                   	push   %rbx
  80123c:	48 83 ec 08          	sub    $0x8,%rsp
    return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0, 0);
  801240:	48 63 d7             	movslq %edi,%rdx
    register uintptr_t _a0 asm("rax") = num,
  801243:	b8 03 00 00 00       	mov    $0x3,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  801248:	b9 00 00 00 00       	mov    $0x0,%ecx
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  80124d:	bb 00 00 00 00       	mov    $0x0,%ebx
  801252:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  801257:	be 00 00 00 00       	mov    $0x0,%esi
  80125c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  801262:	cd 30                	int    $0x30
    if (check && ret > 0) {
  801264:	48 85 c0             	test   %rax,%rax
  801267:	7f 06                	jg     80126f <sys_env_destroy+0x38>
}
  801269:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80126d:	c9                   	leave  
  80126e:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  80126f:	49 89 c0             	mov    %rax,%r8
  801272:	b9 03 00 00 00       	mov    $0x3,%ecx
  801277:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  80127e:	00 00 00 
  801281:	be 26 00 00 00       	mov    $0x26,%esi
  801286:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  80128d:	00 00 00 
  801290:	b8 00 00 00 00       	mov    $0x0,%eax
  801295:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  80129c:	00 00 00 
  80129f:	41 ff d1             	call   *%r9

00000000008012a2 <sys_getenvid>:

envid_t
sys_getenvid(void) {
  8012a2:	55                   	push   %rbp
  8012a3:	48 89 e5             	mov    %rsp,%rbp
  8012a6:	53                   	push   %rbx
    register uintptr_t _a0 asm("rax") = num,
  8012a7:	b8 02 00 00 00       	mov    $0x2,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  8012ac:	ba 00 00 00 00       	mov    $0x0,%edx
  8012b1:	b9 00 00 00 00       	mov    $0x0,%ecx
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  8012b6:	bb 00 00 00 00       	mov    $0x0,%ebx
  8012bb:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  8012c0:	be 00 00 00 00       	mov    $0x0,%esi
  8012c5:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  8012cb:	cd 30                	int    $0x30
    return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0, 0);
}
  8012cd:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8012d1:	c9                   	leave  
  8012d2:	c3                   	ret    

00000000008012d3 <sys_yield>:

void
sys_yield(void) {
  8012d3:	55                   	push   %rbp
  8012d4:	48 89 e5             	mov    %rsp,%rbp
  8012d7:	53                   	push   %rbx
    register uintptr_t _a0 asm("rax") = num,
  8012d8:	b8 0c 00 00 00       	mov    $0xc,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  8012dd:	ba 00 00 00 00       	mov    $0x0,%edx
  8012e2:	b9 00 00 00 00       	mov    $0x0,%ecx
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  8012e7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8012ec:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  8012f1:	be 00 00 00 00       	mov    $0x0,%esi
  8012f6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  8012fc:	cd 30                	int    $0x30
    syscall(SYS_yield, 0, 0, 0, 0, 0, 0, 0);
}
  8012fe:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801302:	c9                   	leave  
  801303:	c3                   	ret    

0000000000801304 <sys_region_refs>:

int
sys_region_refs(void *va, size_t size) {
  801304:	55                   	push   %rbp
  801305:	48 89 e5             	mov    %rsp,%rbp
  801308:	53                   	push   %rbx
  801309:	48 89 fa             	mov    %rdi,%rdx
  80130c:	48 89 f1             	mov    %rsi,%rcx
    register uintptr_t _a0 asm("rax") = num,
  80130f:	b8 07 00 00 00       	mov    $0x7,%eax
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  801314:	48 bb 00 00 00 00 80 	movabs $0x8000000000,%rbx
  80131b:	00 00 00 
  80131e:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  801323:	be 00 00 00 00       	mov    $0x0,%esi
  801328:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  80132e:	cd 30                	int    $0x30
    return syscall(SYS_region_refs, 0, (uintptr_t)va, size, MAX_USER_ADDRESS, 0, 0, 0);
}
  801330:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801334:	c9                   	leave  
  801335:	c3                   	ret    

0000000000801336 <sys_region_refs2>:

int
sys_region_refs2(void *va, size_t size, void *va2, size_t size2) {
  801336:	55                   	push   %rbp
  801337:	48 89 e5             	mov    %rsp,%rbp
  80133a:	53                   	push   %rbx
  80133b:	49 89 f8             	mov    %rdi,%r8
  80133e:	48 89 d3             	mov    %rdx,%rbx
  801341:	48 89 cf             	mov    %rcx,%rdi
    register uintptr_t _a0 asm("rax") = num,
  801344:	b8 07 00 00 00       	mov    $0x7,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  801349:	4c 89 c2             	mov    %r8,%rdx
  80134c:	48 89 f1             	mov    %rsi,%rcx
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  80134f:	be 00 00 00 00       	mov    $0x0,%esi
  801354:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  80135a:	cd 30                	int    $0x30
    return syscall(SYS_region_refs, 0, (uintptr_t)va, size, (uintptr_t)va2, size2, 0, 0);
}
  80135c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801360:	c9                   	leave  
  801361:	c3                   	ret    

0000000000801362 <sys_alloc_region>:

int
sys_alloc_region(envid_t envid, void *va, size_t size, int perm) {
  801362:	55                   	push   %rbp
  801363:	48 89 e5             	mov    %rsp,%rbp
  801366:	53                   	push   %rbx
  801367:	48 83 ec 08          	sub    $0x8,%rsp
  80136b:	89 f8                	mov    %edi,%eax
  80136d:	48 89 d3             	mov    %rdx,%rbx
    int res = syscall(SYS_alloc_region, 1, envid, (uintptr_t)va, size, perm, 0, 0);
  801370:	48 63 f9             	movslq %ecx,%rdi
  801373:	48 63 d0             	movslq %eax,%rdx
    register uintptr_t _a0 asm("rax") = num,
  801376:	b8 04 00 00 00       	mov    $0x4,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  80137b:	48 89 f1             	mov    %rsi,%rcx
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  80137e:	be 00 00 00 00       	mov    $0x0,%esi
  801383:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  801389:	cd 30                	int    $0x30
    if (check && ret > 0) {
  80138b:	48 85 c0             	test   %rax,%rax
  80138e:	7f 06                	jg     801396 <sys_alloc_region+0x34>
        platform_asan_unpoison(va, size);
    }
#endif

    return res;
}
  801390:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801394:	c9                   	leave  
  801395:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  801396:	49 89 c0             	mov    %rax,%r8
  801399:	b9 04 00 00 00       	mov    $0x4,%ecx
  80139e:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  8013a5:	00 00 00 
  8013a8:	be 26 00 00 00       	mov    $0x26,%esi
  8013ad:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  8013b4:	00 00 00 
  8013b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8013bc:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  8013c3:	00 00 00 
  8013c6:	41 ff d1             	call   *%r9

00000000008013c9 <sys_map_region>:

int
sys_map_region(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, size_t size, int perm) {
  8013c9:	55                   	push   %rbp
  8013ca:	48 89 e5             	mov    %rsp,%rbp
  8013cd:	53                   	push   %rbx
  8013ce:	48 83 ec 08          	sub    $0x8,%rsp
  8013d2:	89 f8                	mov    %edi,%eax
  8013d4:	49 89 f2             	mov    %rsi,%r10
  8013d7:	48 89 cf             	mov    %rcx,%rdi
  8013da:	4c 89 c6             	mov    %r8,%rsi
    int res = syscall(SYS_map_region, 1, srcenv, (uintptr_t)srcva, dstenv, (uintptr_t)dstva, size, perm);
  8013dd:	48 63 da             	movslq %edx,%rbx
  8013e0:	48 63 d0             	movslq %eax,%rdx
    register uintptr_t _a0 asm("rax") = num,
  8013e3:	b8 05 00 00 00       	mov    $0x5,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  8013e8:	4c 89 d1             	mov    %r10,%rcx
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  8013eb:	4d 63 c1             	movslq %r9d,%r8
    asm volatile("int %1\n"
  8013ee:	cd 30                	int    $0x30
    if (check && ret > 0) {
  8013f0:	48 85 c0             	test   %rax,%rax
  8013f3:	7f 06                	jg     8013fb <sys_map_region+0x32>
#ifdef SANITIZE_USER_SHADOW_BASE
    if (!res && dstenv == CURENVID)
        platform_asan_unpoison(dstva, size);
#endif
    return res;
}
  8013f5:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8013f9:	c9                   	leave  
  8013fa:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  8013fb:	49 89 c0             	mov    %rax,%r8
  8013fe:	b9 05 00 00 00       	mov    $0x5,%ecx
  801403:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  80140a:	00 00 00 
  80140d:	be 26 00 00 00       	mov    $0x26,%esi
  801412:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  801419:	00 00 00 
  80141c:	b8 00 00 00 00       	mov    $0x0,%eax
  801421:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  801428:	00 00 00 
  80142b:	41 ff d1             	call   *%r9

000000000080142e <sys_unmap_region>:

int
sys_unmap_region(envid_t envid, void *va, size_t size) {
  80142e:	55                   	push   %rbp
  80142f:	48 89 e5             	mov    %rsp,%rbp
  801432:	53                   	push   %rbx
  801433:	48 83 ec 08          	sub    $0x8,%rsp
  801437:	48 89 f1             	mov    %rsi,%rcx
  80143a:	48 89 d3             	mov    %rdx,%rbx
    int res = syscall(SYS_unmap_region, 1, envid, (uintptr_t)va, size, 0, 0, 0);
  80143d:	48 63 d7             	movslq %edi,%rdx
    register uintptr_t _a0 asm("rax") = num,
  801440:	b8 06 00 00 00       	mov    $0x6,%eax
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  801445:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  80144a:	be 00 00 00 00       	mov    $0x0,%esi
  80144f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  801455:	cd 30                	int    $0x30
    if (check && ret > 0) {
  801457:	48 85 c0             	test   %rax,%rax
  80145a:	7f 06                	jg     801462 <sys_unmap_region+0x34>
                 (uintptr_t)va >= SANITIZE_USER_SHADOW_SIZE + SANITIZE_USER_SHADOW_BASE)) {
        platform_asan_poison(va, size);
    }
#endif
    return res;
}
  80145c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801460:	c9                   	leave  
  801461:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  801462:	49 89 c0             	mov    %rax,%r8
  801465:	b9 06 00 00 00       	mov    $0x6,%ecx
  80146a:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  801471:	00 00 00 
  801474:	be 26 00 00 00       	mov    $0x26,%esi
  801479:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  801480:	00 00 00 
  801483:	b8 00 00 00 00       	mov    $0x0,%eax
  801488:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  80148f:	00 00 00 
  801492:	41 ff d1             	call   *%r9

0000000000801495 <sys_env_set_status>:

/* sys_exofork is inlined in lib.h */

int
sys_env_set_status(envid_t envid, int status) {
  801495:	55                   	push   %rbp
  801496:	48 89 e5             	mov    %rsp,%rbp
  801499:	53                   	push   %rbx
  80149a:	48 83 ec 08          	sub    $0x8,%rsp
    return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0, 0);
  80149e:	48 63 ce             	movslq %esi,%rcx
  8014a1:	48 63 d7             	movslq %edi,%rdx
    register uintptr_t _a0 asm("rax") = num,
  8014a4:	b8 09 00 00 00       	mov    $0x9,%eax
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  8014a9:	bb 00 00 00 00       	mov    $0x0,%ebx
  8014ae:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  8014b3:	be 00 00 00 00       	mov    $0x0,%esi
  8014b8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  8014be:	cd 30                	int    $0x30
    if (check && ret > 0) {
  8014c0:	48 85 c0             	test   %rax,%rax
  8014c3:	7f 06                	jg     8014cb <sys_env_set_status+0x36>
}
  8014c5:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8014c9:	c9                   	leave  
  8014ca:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  8014cb:	49 89 c0             	mov    %rax,%r8
  8014ce:	b9 09 00 00 00       	mov    $0x9,%ecx
  8014d3:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  8014da:	00 00 00 
  8014dd:	be 26 00 00 00       	mov    $0x26,%esi
  8014e2:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  8014e9:	00 00 00 
  8014ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8014f1:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  8014f8:	00 00 00 
  8014fb:	41 ff d1             	call   *%r9

00000000008014fe <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf) {
  8014fe:	55                   	push   %rbp
  8014ff:	48 89 e5             	mov    %rsp,%rbp
  801502:	53                   	push   %rbx
  801503:	48 83 ec 08          	sub    $0x8,%rsp
  801507:	48 89 f1             	mov    %rsi,%rcx
    return syscall(SYS_env_set_trapframe, 1, envid, (uintptr_t)tf, 0, 0, 0, 0);
  80150a:	48 63 d7             	movslq %edi,%rdx
    register uintptr_t _a0 asm("rax") = num,
  80150d:	b8 0a 00 00 00       	mov    $0xa,%eax
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  801512:	bb 00 00 00 00       	mov    $0x0,%ebx
  801517:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  80151c:	be 00 00 00 00       	mov    $0x0,%esi
  801521:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  801527:	cd 30                	int    $0x30
    if (check && ret > 0) {
  801529:	48 85 c0             	test   %rax,%rax
  80152c:	7f 06                	jg     801534 <sys_env_set_trapframe+0x36>
}
  80152e:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801532:	c9                   	leave  
  801533:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  801534:	49 89 c0             	mov    %rax,%r8
  801537:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80153c:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  801543:	00 00 00 
  801546:	be 26 00 00 00       	mov    $0x26,%esi
  80154b:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  801552:	00 00 00 
  801555:	b8 00 00 00 00       	mov    $0x0,%eax
  80155a:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  801561:	00 00 00 
  801564:	41 ff d1             	call   *%r9

0000000000801567 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall) {
  801567:	55                   	push   %rbp
  801568:	48 89 e5             	mov    %rsp,%rbp
  80156b:	53                   	push   %rbx
  80156c:	48 83 ec 08          	sub    $0x8,%rsp
  801570:	48 89 f1             	mov    %rsi,%rcx
    return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uintptr_t)upcall, 0, 0, 0, 0);
  801573:	48 63 d7             	movslq %edi,%rdx
    register uintptr_t _a0 asm("rax") = num,
  801576:	b8 0b 00 00 00       	mov    $0xb,%eax
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  80157b:	bb 00 00 00 00       	mov    $0x0,%ebx
  801580:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  801585:	be 00 00 00 00       	mov    $0x0,%esi
  80158a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  801590:	cd 30                	int    $0x30
    if (check && ret > 0) {
  801592:	48 85 c0             	test   %rax,%rax
  801595:	7f 06                	jg     80159d <sys_env_set_pgfault_upcall+0x36>
}
  801597:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80159b:	c9                   	leave  
  80159c:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  80159d:	49 89 c0             	mov    %rax,%r8
  8015a0:	b9 0b 00 00 00       	mov    $0xb,%ecx
  8015a5:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  8015ac:	00 00 00 
  8015af:	be 26 00 00 00       	mov    $0x26,%esi
  8015b4:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  8015bb:	00 00 00 
  8015be:	b8 00 00 00 00       	mov    $0x0,%eax
  8015c3:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  8015ca:	00 00 00 
  8015cd:	41 ff d1             	call   *%r9

00000000008015d0 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uintptr_t value, void *srcva, size_t size, int perm) {
  8015d0:	55                   	push   %rbp
  8015d1:	48 89 e5             	mov    %rsp,%rbp
  8015d4:	53                   	push   %rbx
  8015d5:	89 f8                	mov    %edi,%eax
  8015d7:	49 89 f1             	mov    %rsi,%r9
  8015da:	48 89 d3             	mov    %rdx,%rbx
  8015dd:	48 89 cf             	mov    %rcx,%rdi
    return syscall(SYS_ipc_try_send, 0, envid, value, (uintptr_t)srcva, size, perm, 0);
  8015e0:	49 63 f0             	movslq %r8d,%rsi
  8015e3:	48 63 d0             	movslq %eax,%rdx
    register uintptr_t _a0 asm("rax") = num,
  8015e6:	b8 0d 00 00 00       	mov    $0xd,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  8015eb:	4c 89 c9             	mov    %r9,%rcx
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  8015ee:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  8015f4:	cd 30                	int    $0x30
}
  8015f6:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8015fa:	c9                   	leave  
  8015fb:	c3                   	ret    

00000000008015fc <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva, size_t size) {
  8015fc:	55                   	push   %rbp
  8015fd:	48 89 e5             	mov    %rsp,%rbp
  801600:	53                   	push   %rbx
  801601:	48 83 ec 08          	sub    $0x8,%rsp
  801605:	48 89 fa             	mov    %rdi,%rdx
  801608:	48 89 f1             	mov    %rsi,%rcx
    register uintptr_t _a0 asm("rax") = num,
  80160b:	b8 0e 00 00 00       	mov    $0xe,%eax
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  801610:	bb 00 00 00 00       	mov    $0x0,%ebx
  801615:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  80161a:	be 00 00 00 00       	mov    $0x0,%esi
  80161f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  801625:	cd 30                	int    $0x30
    if (check && ret > 0) {
  801627:	48 85 c0             	test   %rax,%rax
  80162a:	7f 06                	jg     801632 <sys_ipc_recv+0x36>
    int res = syscall(SYS_ipc_recv, 1, (uintptr_t)dstva, size, 0, 0, 0, 0);
#ifdef SANITIZE_USER_SHADOW_BASE
    if (!res) platform_asan_unpoison(dstva, thisenv->env_ipc_maxsz);
#endif
    return res;
}
  80162c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801630:	c9                   	leave  
  801631:	c3                   	ret    
        panic("syscall %zd returned %zd (> 0)", num, ret);
  801632:	49 89 c0             	mov    %rax,%r8
  801635:	b9 0e 00 00 00       	mov    $0xe,%ecx
  80163a:	48 ba e0 19 81 00 00 	movabs $0x8119e0,%rdx
  801641:	00 00 00 
  801644:	be 26 00 00 00       	mov    $0x26,%esi
  801649:	48 bf ff 19 81 00 00 	movabs $0x8119ff,%rdi
  801650:	00 00 00 
  801653:	b8 00 00 00 00       	mov    $0x0,%eax
  801658:	49 b9 ce 11 81 00 00 	movabs $0x8111ce,%r9
  80165f:	00 00 00 
  801662:	41 ff d1             	call   *%r9

0000000000801665 <sys_gettime>:

int
sys_gettime(void) {
  801665:	55                   	push   %rbp
  801666:	48 89 e5             	mov    %rsp,%rbp
  801669:	53                   	push   %rbx
    register uintptr_t _a0 asm("rax") = num,
  80166a:	b8 0f 00 00 00       	mov    $0xf,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  80166f:	ba 00 00 00 00       	mov    $0x0,%edx
  801674:	b9 00 00 00 00       	mov    $0x0,%ecx
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  801679:	bb 00 00 00 00       	mov    $0x0,%ebx
  80167e:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  801683:	be 00 00 00 00       	mov    $0x0,%esi
  801688:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  80168e:	cd 30                	int    $0x30
    return syscall(SYS_gettime, 0, 0, 0, 0, 0, 0, 0);
}
  801690:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801694:	c9                   	leave  
  801695:	c3                   	ret    

0000000000801696 <sys_framebuffer_init>:

int
sys_framebuffer_init(void) {
  801696:	55                   	push   %rbp
  801697:	48 89 e5             	mov    %rsp,%rbp
  80169a:	53                   	push   %rbx
    register uintptr_t _a0 asm("rax") = num,
  80169b:	b8 10 00 00 00       	mov    $0x10,%eax
                           _a1 asm("rdx") = a1, _a2 asm("rcx") = a2,
  8016a0:	ba 00 00 00 00       	mov    $0x0,%edx
  8016a5:	b9 00 00 00 00       	mov    $0x0,%ecx
                           _a3 asm("rbx") = a3, _a4 asm("rdi") = a4,
  8016aa:	bb 00 00 00 00       	mov    $0x0,%ebx
  8016af:	bf 00 00 00 00       	mov    $0x0,%edi
                           _a5 asm("rsi") = a5, _a6 asm("r8") = a6;
  8016b4:	be 00 00 00 00       	mov    $0x0,%esi
  8016b9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
    asm volatile("int %1\n"
  8016bf:	cd 30                	int    $0x30
    return syscall(SYS_framebuffer_init, 0, 0, 0, 0, 0, 0, 0);
}
  8016c1:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8016c5:	c9                   	leave  
  8016c6:	c3                   	ret    

00000000008016c7 <fd2num>:

/********************File descriptor manipulators***********************/

uint64_t
fd2num(struct Fd *fd) {
    return ((uintptr_t)fd - FDTABLE) / PAGE_SIZE;
  8016c7:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  8016ce:	ff ff ff 
  8016d1:	48 01 f8             	add    %rdi,%rax
  8016d4:	48 c1 e8 0c          	shr    $0xc,%rax
}
  8016d8:	c3                   	ret    

00000000008016d9 <fd2data>:
    return ((uintptr_t)fd - FDTABLE) / PAGE_SIZE;
  8016d9:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  8016e0:	ff ff ff 
  8016e3:	48 01 f8             	add    %rdi,%rax
  8016e6:	48 c1 e8 0c          	shr    $0xc,%rax

char *
fd2data(struct Fd *fd) {
    return INDEX2DATA(fd2num(fd));
  8016ea:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  8016f0:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8016f4:	c3                   	ret    

00000000008016f5 <fd_alloc>:
 *
 * Returns 0 on success, < 0 on error.  Errors are:
 *  -E_MAX_FD: no more file descriptors
 * On error, *fd_store is set to 0. */
int
fd_alloc(struct Fd **fd_store) {
  8016f5:	55                   	push   %rbp
  8016f6:	48 89 e5             	mov    %rsp,%rbp
  8016f9:	41 57                	push   %r15
  8016fb:	41 56                	push   %r14
  8016fd:	41 55                	push   %r13
  8016ff:	41 54                	push   %r12
  801701:	53                   	push   %rbx
  801702:	48 83 ec 08          	sub    $0x8,%rsp
  801706:	49 89 ff             	mov    %rdi,%r15
  801709:	bb 00 00 00 d0       	mov    $0xd0000000,%ebx
    for (int i = 0; i < MAXFD; i++) {
        struct Fd *fd = INDEX2FD(i);
        if (!(get_prot(fd) & PROT_R)) {
  80170e:	49 bc a3 26 80 00 00 	movabs $0x8026a3,%r12
  801715:	00 00 00 
    for (int i = 0; i < MAXFD; i++) {
  801718:	41 be 00 00 02 d0    	mov    $0xd0020000,%r14d
        if (!(get_prot(fd) & PROT_R)) {
  80171e:	48 89 df             	mov    %rbx,%rdi
  801721:	41 ff d4             	call   *%r12
  801724:	83 e0 04             	and    $0x4,%eax
  801727:	74 1a                	je     801743 <fd_alloc+0x4e>
    for (int i = 0; i < MAXFD; i++) {
  801729:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
  801730:	4c 39 f3             	cmp    %r14,%rbx
  801733:	75 e9                	jne    80171e <fd_alloc+0x29>
            *fd_store = fd;
            return 0;
        }
    }
    *fd_store = 0;
  801735:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
    return -E_MAX_OPEN;
  80173c:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  801741:	eb 03                	jmp    801746 <fd_alloc+0x51>
            *fd_store = fd;
  801743:	49 89 1f             	mov    %rbx,(%r15)
}
  801746:	48 83 c4 08          	add    $0x8,%rsp
  80174a:	5b                   	pop    %rbx
  80174b:	41 5c                	pop    %r12
  80174d:	41 5d                	pop    %r13
  80174f:	41 5e                	pop    %r14
  801751:	41 5f                	pop    %r15
  801753:	5d                   	pop    %rbp
  801754:	c3                   	ret    

0000000000801755 <fd_lookup>:
 * Returns 0 on success (the page is in range and mapped), < 0 on error.
 * Errors are:
 *  -E_INVAL: fdnum was either not in range or not mapped. */
int
fd_lookup(int fdnum, struct Fd **fd_store) {
    if (fdnum < 0 || fdnum >= MAXFD) {
  801755:	83 ff 1f             	cmp    $0x1f,%edi
  801758:	77 39                	ja     801793 <fd_lookup+0x3e>
fd_lookup(int fdnum, struct Fd **fd_store) {
  80175a:	55                   	push   %rbp
  80175b:	48 89 e5             	mov    %rsp,%rbp
  80175e:	41 54                	push   %r12
  801760:	53                   	push   %rbx
  801761:	49 89 f4             	mov    %rsi,%r12
        if (debug) cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
        return -E_INVAL;
    }

    struct Fd *fd = INDEX2FD(fdnum);
  801764:	48 63 df             	movslq %edi,%rbx
  801767:	48 81 c3 00 00 0d 00 	add    $0xd0000,%rbx
  80176e:	48 c1 e3 0c          	shl    $0xc,%rbx

    if (!(get_prot(fd) & PROT_R)) {
  801772:	48 89 df             	mov    %rbx,%rdi
  801775:	48 b8 a3 26 80 00 00 	movabs $0x8026a3,%rax
  80177c:	00 00 00 
  80177f:	ff d0                	call   *%rax
  801781:	a8 04                	test   $0x4,%al
  801783:	74 14                	je     801799 <fd_lookup+0x44>
        if (debug) cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
        return -E_INVAL;
    }

    *fd_store = fd;
  801785:	49 89 1c 24          	mov    %rbx,(%r12)
    return 0;
  801789:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80178e:	5b                   	pop    %rbx
  80178f:	41 5c                	pop    %r12
  801791:	5d                   	pop    %rbp
  801792:	c3                   	ret    
        return -E_INVAL;
  801793:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801798:	c3                   	ret    
        return -E_INVAL;
  801799:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80179e:	eb ee                	jmp    80178e <fd_lookup+0x39>

00000000008017a0 <dev_lookup>:
        &devpipe,
        &devcons,
        NULL};

int
dev_lookup(int dev_id, struct Dev **dev) {
  8017a0:	55                   	push   %rbp
  8017a1:	48 89 e5             	mov    %rsp,%rbp
  8017a4:	53                   	push   %rbx
  8017a5:	48 83 ec 08          	sub    $0x8,%rsp
  8017a9:	48 89 f3             	mov    %rsi,%rbx
    for (size_t i = 0; devtab[i]; i++) {
  8017ac:	48 ba a0 1a 81 00 00 	movabs $0x811aa0,%rdx
  8017b3:	00 00 00 
  8017b6:	48 b8 20 40 81 00 00 	movabs $0x814020,%rax
  8017bd:	00 00 00 
        if (devtab[i]->dev_id == dev_id) {
  8017c0:	39 38                	cmp    %edi,(%rax)
  8017c2:	74 4b                	je     80180f <dev_lookup+0x6f>
    for (size_t i = 0; devtab[i]; i++) {
  8017c4:	48 83 c2 08          	add    $0x8,%rdx
  8017c8:	48 8b 02             	mov    (%rdx),%rax
  8017cb:	48 85 c0             	test   %rax,%rax
  8017ce:	75 f0                	jne    8017c0 <dev_lookup+0x20>
            *dev = devtab[i];
            return 0;
        }
    }
    cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8017d0:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  8017d7:	00 00 00 
  8017da:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  8017e0:	89 fa                	mov    %edi,%edx
  8017e2:	48 bf 10 1a 81 00 00 	movabs $0x811a10,%rdi
  8017e9:	00 00 00 
  8017ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8017f1:	48 b9 67 04 80 00 00 	movabs $0x800467,%rcx
  8017f8:	00 00 00 
  8017fb:	ff d1                	call   *%rcx
    *dev = 0;
  8017fd:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    return -E_INVAL;
  801804:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801809:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80180d:	c9                   	leave  
  80180e:	c3                   	ret    
            *dev = devtab[i];
  80180f:	48 89 03             	mov    %rax,(%rbx)
            return 0;
  801812:	b8 00 00 00 00       	mov    $0x0,%eax
  801817:	eb f0                	jmp    801809 <dev_lookup+0x69>

0000000000801819 <fd_close>:
fd_close(struct Fd *fd, bool must_exist) {
  801819:	55                   	push   %rbp
  80181a:	48 89 e5             	mov    %rsp,%rbp
  80181d:	41 55                	push   %r13
  80181f:	41 54                	push   %r12
  801821:	53                   	push   %rbx
  801822:	48 83 ec 18          	sub    $0x18,%rsp
  801826:	49 89 fc             	mov    %rdi,%r12
  801829:	41 89 f5             	mov    %esi,%r13d
    return ((uintptr_t)fd - FDTABLE) / PAGE_SIZE;
  80182c:	48 bf 00 00 00 30 ff 	movabs $0xffffffff30000000,%rdi
  801833:	ff ff ff 
  801836:	4c 01 e7             	add    %r12,%rdi
  801839:	48 c1 ef 0c          	shr    $0xc,%rdi
    if ((res = fd_lookup(fd2num(fd), &fd2)) < 0 || fd != fd2) {
  80183d:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  801841:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  801848:	00 00 00 
  80184b:	ff d0                	call   *%rax
  80184d:	89 c3                	mov    %eax,%ebx
  80184f:	85 c0                	test   %eax,%eax
  801851:	78 06                	js     801859 <fd_close+0x40>
  801853:	4c 39 65 d8          	cmp    %r12,-0x28(%rbp)
  801857:	74 18                	je     801871 <fd_close+0x58>
        return (must_exist ? res : 0);
  801859:	45 84 ed             	test   %r13b,%r13b
  80185c:	b8 00 00 00 00       	mov    $0x0,%eax
  801861:	0f 44 d8             	cmove  %eax,%ebx
}
  801864:	89 d8                	mov    %ebx,%eax
  801866:	48 83 c4 18          	add    $0x18,%rsp
  80186a:	5b                   	pop    %rbx
  80186b:	41 5c                	pop    %r12
  80186d:	41 5d                	pop    %r13
  80186f:	5d                   	pop    %rbp
  801870:	c3                   	ret    
    if ((res = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  801871:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  801875:	41 8b 3c 24          	mov    (%r12),%edi
  801879:	48 b8 a0 17 80 00 00 	movabs $0x8017a0,%rax
  801880:	00 00 00 
  801883:	ff d0                	call   *%rax
  801885:	89 c3                	mov    %eax,%ebx
  801887:	85 c0                	test   %eax,%eax
  801889:	78 19                	js     8018a4 <fd_close+0x8b>
        res = dev->dev_close ? (*dev->dev_close)(fd) : 0;
  80188b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80188f:	48 8b 40 20          	mov    0x20(%rax),%rax
  801893:	bb 00 00 00 00       	mov    $0x0,%ebx
  801898:	48 85 c0             	test   %rax,%rax
  80189b:	74 07                	je     8018a4 <fd_close+0x8b>
  80189d:	4c 89 e7             	mov    %r12,%rdi
  8018a0:	ff d0                	call   *%rax
  8018a2:	89 c3                	mov    %eax,%ebx
    USED(sys_unmap_region(0, fd, PAGE_SIZE));
  8018a4:	ba 00 10 00 00       	mov    $0x1000,%edx
  8018a9:	4c 89 e6             	mov    %r12,%rsi
  8018ac:	bf 00 00 00 00       	mov    $0x0,%edi
  8018b1:	48 b8 2e 14 80 00 00 	movabs $0x80142e,%rax
  8018b8:	00 00 00 
  8018bb:	ff d0                	call   *%rax
    return res;
  8018bd:	eb a5                	jmp    801864 <fd_close+0x4b>

00000000008018bf <close>:

int
close(int fdnum) {
  8018bf:	55                   	push   %rbp
  8018c0:	48 89 e5             	mov    %rsp,%rbp
  8018c3:	48 83 ec 10          	sub    $0x10,%rsp
    struct Fd *fd;
    int res = fd_lookup(fdnum, &fd);
  8018c7:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
  8018cb:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  8018d2:	00 00 00 
  8018d5:	ff d0                	call   *%rax
    if (res < 0) return res;
  8018d7:	85 c0                	test   %eax,%eax
  8018d9:	78 15                	js     8018f0 <close+0x31>

    return fd_close(fd, 1);
  8018db:	be 01 00 00 00       	mov    $0x1,%esi
  8018e0:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8018e4:	48 b8 19 18 80 00 00 	movabs $0x801819,%rax
  8018eb:	00 00 00 
  8018ee:	ff d0                	call   *%rax
}
  8018f0:	c9                   	leave  
  8018f1:	c3                   	ret    

00000000008018f2 <close_all>:

void
close_all(void) {
  8018f2:	55                   	push   %rbp
  8018f3:	48 89 e5             	mov    %rsp,%rbp
  8018f6:	41 54                	push   %r12
  8018f8:	53                   	push   %rbx
    for (int i = 0; i < MAXFD; i++) close(i);
  8018f9:	bb 00 00 00 00       	mov    $0x0,%ebx
  8018fe:	49 bc bf 18 80 00 00 	movabs $0x8018bf,%r12
  801905:	00 00 00 
  801908:	89 df                	mov    %ebx,%edi
  80190a:	41 ff d4             	call   *%r12
  80190d:	83 c3 01             	add    $0x1,%ebx
  801910:	83 fb 20             	cmp    $0x20,%ebx
  801913:	75 f3                	jne    801908 <close_all+0x16>
}
  801915:	5b                   	pop    %rbx
  801916:	41 5c                	pop    %r12
  801918:	5d                   	pop    %rbp
  801919:	c3                   	ret    

000000000080191a <dup>:
 * For instance, writing onto either file descriptor will affect the
 * file and the file offset of the other.
 * Closes any previously open file descriptor at 'newfdnum'.
 * This is implemented using virtual memory tricks (of course!). */
int
dup(int oldfdnum, int newfdnum) {
  80191a:	55                   	push   %rbp
  80191b:	48 89 e5             	mov    %rsp,%rbp
  80191e:	41 56                	push   %r14
  801920:	41 55                	push   %r13
  801922:	41 54                	push   %r12
  801924:	53                   	push   %rbx
  801925:	48 83 ec 10          	sub    $0x10,%rsp
  801929:	41 89 f4             	mov    %esi,%r12d
    struct Fd *oldfd, *newfd;

    int res;
    if ((res = fd_lookup(oldfdnum, &oldfd)) < 0) return res;
  80192c:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  801930:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  801937:	00 00 00 
  80193a:	ff d0                	call   *%rax
  80193c:	89 c3                	mov    %eax,%ebx
  80193e:	85 c0                	test   %eax,%eax
  801940:	0f 88 b7 00 00 00    	js     8019fd <dup+0xe3>
    close(newfdnum);
  801946:	44 89 e7             	mov    %r12d,%edi
  801949:	48 b8 bf 18 80 00 00 	movabs $0x8018bf,%rax
  801950:	00 00 00 
  801953:	ff d0                	call   *%rax

    newfd = INDEX2FD(newfdnum);
  801955:	4d 63 ec             	movslq %r12d,%r13
  801958:	49 81 c5 00 00 0d 00 	add    $0xd0000,%r13
  80195f:	49 c1 e5 0c          	shl    $0xc,%r13
    char *oldva = fd2data(oldfd);
  801963:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  801967:	49 be d9 16 80 00 00 	movabs $0x8016d9,%r14
  80196e:	00 00 00 
  801971:	41 ff d6             	call   *%r14
  801974:	48 89 c3             	mov    %rax,%rbx
    char *newva = fd2data(newfd);
  801977:	4c 89 ef             	mov    %r13,%rdi
  80197a:	41 ff d6             	call   *%r14
  80197d:	49 89 c6             	mov    %rax,%r14

    int prot = get_prot(oldva);
  801980:	48 89 df             	mov    %rbx,%rdi
  801983:	48 b8 a3 26 80 00 00 	movabs $0x8026a3,%rax
  80198a:	00 00 00 
  80198d:	ff d0                	call   *%rax
    if (prot & PROT_R) {
  80198f:	a8 04                	test   $0x4,%al
  801991:	74 2b                	je     8019be <dup+0xa4>
        if ((res = sys_map_region(0, oldva, 0, newva, PAGE_SIZE, prot)) < 0) goto err;
  801993:	41 89 c1             	mov    %eax,%r9d
  801996:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  80199c:	4c 89 f1             	mov    %r14,%rcx
  80199f:	ba 00 00 00 00       	mov    $0x0,%edx
  8019a4:	48 89 de             	mov    %rbx,%rsi
  8019a7:	bf 00 00 00 00       	mov    $0x0,%edi
  8019ac:	48 b8 c9 13 80 00 00 	movabs $0x8013c9,%rax
  8019b3:	00 00 00 
  8019b6:	ff d0                	call   *%rax
  8019b8:	89 c3                	mov    %eax,%ebx
  8019ba:	85 c0                	test   %eax,%eax
  8019bc:	78 4e                	js     801a0c <dup+0xf2>
    }
    prot = get_prot(oldfd);
  8019be:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8019c2:	48 b8 a3 26 80 00 00 	movabs $0x8026a3,%rax
  8019c9:	00 00 00 
  8019cc:	ff d0                	call   *%rax
  8019ce:	41 89 c1             	mov    %eax,%r9d
    if ((res = sys_map_region(0, oldfd, 0, newfd, PAGE_SIZE, prot)) < 0) goto err;
  8019d1:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  8019d7:	4c 89 e9             	mov    %r13,%rcx
  8019da:	ba 00 00 00 00       	mov    $0x0,%edx
  8019df:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8019e3:	bf 00 00 00 00       	mov    $0x0,%edi
  8019e8:	48 b8 c9 13 80 00 00 	movabs $0x8013c9,%rax
  8019ef:	00 00 00 
  8019f2:	ff d0                	call   *%rax
  8019f4:	89 c3                	mov    %eax,%ebx
  8019f6:	85 c0                	test   %eax,%eax
  8019f8:	78 12                	js     801a0c <dup+0xf2>

    return newfdnum;
  8019fa:	44 89 e3             	mov    %r12d,%ebx

err:
    sys_unmap_region(0, newfd, PAGE_SIZE);
    sys_unmap_region(0, newva, PAGE_SIZE);
    return res;
}
  8019fd:	89 d8                	mov    %ebx,%eax
  8019ff:	48 83 c4 10          	add    $0x10,%rsp
  801a03:	5b                   	pop    %rbx
  801a04:	41 5c                	pop    %r12
  801a06:	41 5d                	pop    %r13
  801a08:	41 5e                	pop    %r14
  801a0a:	5d                   	pop    %rbp
  801a0b:	c3                   	ret    
    sys_unmap_region(0, newfd, PAGE_SIZE);
  801a0c:	ba 00 10 00 00       	mov    $0x1000,%edx
  801a11:	4c 89 ee             	mov    %r13,%rsi
  801a14:	bf 00 00 00 00       	mov    $0x0,%edi
  801a19:	49 bc 2e 14 80 00 00 	movabs $0x80142e,%r12
  801a20:	00 00 00 
  801a23:	41 ff d4             	call   *%r12
    sys_unmap_region(0, newva, PAGE_SIZE);
  801a26:	ba 00 10 00 00       	mov    $0x1000,%edx
  801a2b:	4c 89 f6             	mov    %r14,%rsi
  801a2e:	bf 00 00 00 00       	mov    $0x0,%edi
  801a33:	41 ff d4             	call   *%r12
    return res;
  801a36:	eb c5                	jmp    8019fd <dup+0xe3>

0000000000801a38 <read>:

ssize_t
read(int fdnum, void *buf, size_t n) {
  801a38:	55                   	push   %rbp
  801a39:	48 89 e5             	mov    %rsp,%rbp
  801a3c:	41 55                	push   %r13
  801a3e:	41 54                	push   %r12
  801a40:	53                   	push   %rbx
  801a41:	48 83 ec 18          	sub    $0x18,%rsp
  801a45:	89 fb                	mov    %edi,%ebx
  801a47:	49 89 f4             	mov    %rsi,%r12
  801a4a:	49 89 d5             	mov    %rdx,%r13
    int res;

    struct Fd *fd;
    if ((res = fd_lookup(fdnum, &fd)) < 0) return res;
  801a4d:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  801a51:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  801a58:	00 00 00 
  801a5b:	ff d0                	call   *%rax
  801a5d:	85 c0                	test   %eax,%eax
  801a5f:	78 49                	js     801aaa <read+0x72>

    struct Dev *dev;
    if ((res = dev_lookup(fd->fd_dev_id, &dev)) < 0) return res;
  801a61:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  801a65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  801a69:	8b 38                	mov    (%rax),%edi
  801a6b:	48 b8 a0 17 80 00 00 	movabs $0x8017a0,%rax
  801a72:	00 00 00 
  801a75:	ff d0                	call   *%rax
  801a77:	85 c0                	test   %eax,%eax
  801a79:	78 33                	js     801aae <read+0x76>

    if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  801a7b:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  801a7f:	8b 47 08             	mov    0x8(%rdi),%eax
  801a82:	83 e0 03             	and    $0x3,%eax
  801a85:	83 f8 01             	cmp    $0x1,%eax
  801a88:	74 28                	je     801ab2 <read+0x7a>
        cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
        return -E_INVAL;
    }

    if (!dev->dev_read) return -E_NOT_SUPP;
  801a8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801a8e:	48 8b 40 10          	mov    0x10(%rax),%rax
  801a92:	48 85 c0             	test   %rax,%rax
  801a95:	74 51                	je     801ae8 <read+0xb0>

    return (*dev->dev_read)(fd, buf, n);
  801a97:	4c 89 ea             	mov    %r13,%rdx
  801a9a:	4c 89 e6             	mov    %r12,%rsi
  801a9d:	ff d0                	call   *%rax
}
  801a9f:	48 83 c4 18          	add    $0x18,%rsp
  801aa3:	5b                   	pop    %rbx
  801aa4:	41 5c                	pop    %r12
  801aa6:	41 5d                	pop    %r13
  801aa8:	5d                   	pop    %rbp
  801aa9:	c3                   	ret    
    if ((res = fd_lookup(fdnum, &fd)) < 0) return res;
  801aaa:	48 98                	cltq   
  801aac:	eb f1                	jmp    801a9f <read+0x67>
    if ((res = dev_lookup(fd->fd_dev_id, &dev)) < 0) return res;
  801aae:	48 98                	cltq   
  801ab0:	eb ed                	jmp    801a9f <read+0x67>
        cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  801ab2:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  801ab9:	00 00 00 
  801abc:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  801ac2:	89 da                	mov    %ebx,%edx
  801ac4:	48 bf 51 1a 81 00 00 	movabs $0x811a51,%rdi
  801acb:	00 00 00 
  801ace:	b8 00 00 00 00       	mov    $0x0,%eax
  801ad3:	48 b9 67 04 80 00 00 	movabs $0x800467,%rcx
  801ada:	00 00 00 
  801add:	ff d1                	call   *%rcx
        return -E_INVAL;
  801adf:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
  801ae6:	eb b7                	jmp    801a9f <read+0x67>
    if (!dev->dev_read) return -E_NOT_SUPP;
  801ae8:	48 c7 c0 ed ff ff ff 	mov    $0xffffffffffffffed,%rax
  801aef:	eb ae                	jmp    801a9f <read+0x67>

0000000000801af1 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n) {
  801af1:	55                   	push   %rbp
  801af2:	48 89 e5             	mov    %rsp,%rbp
  801af5:	41 57                	push   %r15
  801af7:	41 56                	push   %r14
  801af9:	41 55                	push   %r13
  801afb:	41 54                	push   %r12
  801afd:	53                   	push   %rbx
  801afe:	48 83 ec 08          	sub    $0x8,%rsp
    int inc = 1, res = 0;
    for (; inc && res < n; res += inc) {
  801b02:	48 85 d2             	test   %rdx,%rdx
  801b05:	74 54                	je     801b5b <readn+0x6a>
  801b07:	41 89 fd             	mov    %edi,%r13d
  801b0a:	49 89 f6             	mov    %rsi,%r14
  801b0d:	49 89 d4             	mov    %rdx,%r12
    int inc = 1, res = 0;
  801b10:	bb 00 00 00 00       	mov    $0x0,%ebx
    for (; inc && res < n; res += inc) {
  801b15:	be 00 00 00 00       	mov    $0x0,%esi
        inc = read(fdnum, (char *)buf + res, n - res);
  801b1a:	49 bf 38 1a 80 00 00 	movabs $0x801a38,%r15
  801b21:	00 00 00 
  801b24:	4c 89 e2             	mov    %r12,%rdx
  801b27:	48 29 f2             	sub    %rsi,%rdx
  801b2a:	4c 01 f6             	add    %r14,%rsi
  801b2d:	44 89 ef             	mov    %r13d,%edi
  801b30:	41 ff d7             	call   *%r15
        if (inc < 0) return inc;
  801b33:	85 c0                	test   %eax,%eax
  801b35:	78 20                	js     801b57 <readn+0x66>
    for (; inc && res < n; res += inc) {
  801b37:	01 c3                	add    %eax,%ebx
  801b39:	85 c0                	test   %eax,%eax
  801b3b:	74 08                	je     801b45 <readn+0x54>
  801b3d:	48 63 f3             	movslq %ebx,%rsi
  801b40:	4c 39 e6             	cmp    %r12,%rsi
  801b43:	72 df                	jb     801b24 <readn+0x33>
    }
    return res;
  801b45:	48 63 c3             	movslq %ebx,%rax
}
  801b48:	48 83 c4 08          	add    $0x8,%rsp
  801b4c:	5b                   	pop    %rbx
  801b4d:	41 5c                	pop    %r12
  801b4f:	41 5d                	pop    %r13
  801b51:	41 5e                	pop    %r14
  801b53:	41 5f                	pop    %r15
  801b55:	5d                   	pop    %rbp
  801b56:	c3                   	ret    
        if (inc < 0) return inc;
  801b57:	48 98                	cltq   
  801b59:	eb ed                	jmp    801b48 <readn+0x57>
    int inc = 1, res = 0;
  801b5b:	bb 00 00 00 00       	mov    $0x0,%ebx
  801b60:	eb e3                	jmp    801b45 <readn+0x54>

0000000000801b62 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n) {
  801b62:	55                   	push   %rbp
  801b63:	48 89 e5             	mov    %rsp,%rbp
  801b66:	41 55                	push   %r13
  801b68:	41 54                	push   %r12
  801b6a:	53                   	push   %rbx
  801b6b:	48 83 ec 18          	sub    $0x18,%rsp
  801b6f:	89 fb                	mov    %edi,%ebx
  801b71:	49 89 f4             	mov    %rsi,%r12
  801b74:	49 89 d5             	mov    %rdx,%r13
    int res;

    struct Fd *fd;
    if ((res = fd_lookup(fdnum, &fd)) < 0) return res;
  801b77:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  801b7b:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  801b82:	00 00 00 
  801b85:	ff d0                	call   *%rax
  801b87:	85 c0                	test   %eax,%eax
  801b89:	78 44                	js     801bcf <write+0x6d>

    struct Dev *dev;
    if ((res = dev_lookup(fd->fd_dev_id, &dev)) < 0) return res;
  801b8b:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  801b8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  801b93:	8b 38                	mov    (%rax),%edi
  801b95:	48 b8 a0 17 80 00 00 	movabs $0x8017a0,%rax
  801b9c:	00 00 00 
  801b9f:	ff d0                	call   *%rax
  801ba1:	85 c0                	test   %eax,%eax
  801ba3:	78 2e                	js     801bd3 <write+0x71>

    if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  801ba5:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  801ba9:	f6 47 08 03          	testb  $0x3,0x8(%rdi)
  801bad:	74 28                	je     801bd7 <write+0x75>
    if (debug) {
        cprintf("write %d %p %lu via dev %s\n",
                fdnum, buf, (unsigned long)n, dev->dev_name);
    }

    if (!dev->dev_write) return -E_NOT_SUPP;
  801baf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801bb3:	48 8b 40 18          	mov    0x18(%rax),%rax
  801bb7:	48 85 c0             	test   %rax,%rax
  801bba:	74 51                	je     801c0d <write+0xab>

    return (*dev->dev_write)(fd, buf, n);
  801bbc:	4c 89 ea             	mov    %r13,%rdx
  801bbf:	4c 89 e6             	mov    %r12,%rsi
  801bc2:	ff d0                	call   *%rax
}
  801bc4:	48 83 c4 18          	add    $0x18,%rsp
  801bc8:	5b                   	pop    %rbx
  801bc9:	41 5c                	pop    %r12
  801bcb:	41 5d                	pop    %r13
  801bcd:	5d                   	pop    %rbp
  801bce:	c3                   	ret    
    if ((res = fd_lookup(fdnum, &fd)) < 0) return res;
  801bcf:	48 98                	cltq   
  801bd1:	eb f1                	jmp    801bc4 <write+0x62>
    if ((res = dev_lookup(fd->fd_dev_id, &dev)) < 0) return res;
  801bd3:	48 98                	cltq   
  801bd5:	eb ed                	jmp    801bc4 <write+0x62>
        cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  801bd7:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  801bde:	00 00 00 
  801be1:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  801be7:	89 da                	mov    %ebx,%edx
  801be9:	48 bf 6d 1a 81 00 00 	movabs $0x811a6d,%rdi
  801bf0:	00 00 00 
  801bf3:	b8 00 00 00 00       	mov    $0x0,%eax
  801bf8:	48 b9 67 04 80 00 00 	movabs $0x800467,%rcx
  801bff:	00 00 00 
  801c02:	ff d1                	call   *%rcx
        return -E_INVAL;
  801c04:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
  801c0b:	eb b7                	jmp    801bc4 <write+0x62>
    if (!dev->dev_write) return -E_NOT_SUPP;
  801c0d:	48 c7 c0 ed ff ff ff 	mov    $0xffffffffffffffed,%rax
  801c14:	eb ae                	jmp    801bc4 <write+0x62>

0000000000801c16 <seek>:

int
seek(int fdnum, off_t offset) {
  801c16:	55                   	push   %rbp
  801c17:	48 89 e5             	mov    %rsp,%rbp
  801c1a:	53                   	push   %rbx
  801c1b:	48 83 ec 18          	sub    $0x18,%rsp
  801c1f:	89 f3                	mov    %esi,%ebx
    int res;
    struct Fd *fd;

    if ((res = fd_lookup(fdnum, &fd)) < 0) return res;
  801c21:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  801c25:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  801c2c:	00 00 00 
  801c2f:	ff d0                	call   *%rax
  801c31:	85 c0                	test   %eax,%eax
  801c33:	78 0c                	js     801c41 <seek+0x2b>

    fd->fd_offset = offset;
  801c35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801c39:	89 58 04             	mov    %ebx,0x4(%rax)
    return 0;
  801c3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801c41:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801c45:	c9                   	leave  
  801c46:	c3                   	ret    

0000000000801c47 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize) {
  801c47:	55                   	push   %rbp
  801c48:	48 89 e5             	mov    %rsp,%rbp
  801c4b:	41 54                	push   %r12
  801c4d:	53                   	push   %rbx
  801c4e:	48 83 ec 10          	sub    $0x10,%rsp
  801c52:	89 fb                	mov    %edi,%ebx
  801c54:	41 89 f4             	mov    %esi,%r12d
    int res;

    struct Fd *fd;
    if ((res = fd_lookup(fdnum, &fd)) < 0) return res;
  801c57:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  801c5b:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  801c62:	00 00 00 
  801c65:	ff d0                	call   *%rax
  801c67:	85 c0                	test   %eax,%eax
  801c69:	78 36                	js     801ca1 <ftruncate+0x5a>

    struct Dev *dev;
    if ((res = dev_lookup(fd->fd_dev_id, &dev)) < 0) return res;
  801c6b:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  801c6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801c73:	8b 38                	mov    (%rax),%edi
  801c75:	48 b8 a0 17 80 00 00 	movabs $0x8017a0,%rax
  801c7c:	00 00 00 
  801c7f:	ff d0                	call   *%rax
  801c81:	85 c0                	test   %eax,%eax
  801c83:	78 1c                	js     801ca1 <ftruncate+0x5a>

    if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  801c85:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  801c89:	f6 47 08 03          	testb  $0x3,0x8(%rdi)
  801c8d:	74 1b                	je     801caa <ftruncate+0x63>
        cprintf("[%08x] ftruncate %d -- bad mode\n",
                thisenv->env_id, fdnum);
        return -E_INVAL;
    }

    if (!dev->dev_trunc) return -E_NOT_SUPP;
  801c8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801c93:	48 8b 40 30          	mov    0x30(%rax),%rax
  801c97:	48 85 c0             	test   %rax,%rax
  801c9a:	74 42                	je     801cde <ftruncate+0x97>

    return (*dev->dev_trunc)(fd, newsize);
  801c9c:	44 89 e6             	mov    %r12d,%esi
  801c9f:	ff d0                	call   *%rax
}
  801ca1:	48 83 c4 10          	add    $0x10,%rsp
  801ca5:	5b                   	pop    %rbx
  801ca6:	41 5c                	pop    %r12
  801ca8:	5d                   	pop    %rbp
  801ca9:	c3                   	ret    
                thisenv->env_id, fdnum);
  801caa:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  801cb1:	00 00 00 
        cprintf("[%08x] ftruncate %d -- bad mode\n",
  801cb4:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  801cba:	89 da                	mov    %ebx,%edx
  801cbc:	48 bf 30 1a 81 00 00 	movabs $0x811a30,%rdi
  801cc3:	00 00 00 
  801cc6:	b8 00 00 00 00       	mov    $0x0,%eax
  801ccb:	48 b9 67 04 80 00 00 	movabs $0x800467,%rcx
  801cd2:	00 00 00 
  801cd5:	ff d1                	call   *%rcx
        return -E_INVAL;
  801cd7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801cdc:	eb c3                	jmp    801ca1 <ftruncate+0x5a>
    if (!dev->dev_trunc) return -E_NOT_SUPP;
  801cde:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  801ce3:	eb bc                	jmp    801ca1 <ftruncate+0x5a>

0000000000801ce5 <fstat>:

int
fstat(int fdnum, struct Stat *stat) {
  801ce5:	55                   	push   %rbp
  801ce6:	48 89 e5             	mov    %rsp,%rbp
  801ce9:	53                   	push   %rbx
  801cea:	48 83 ec 18          	sub    $0x18,%rsp
  801cee:	48 89 f3             	mov    %rsi,%rbx
    int res;

    struct Fd *fd;
    if ((res = fd_lookup(fdnum, &fd)) < 0) return res;
  801cf1:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  801cf5:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  801cfc:	00 00 00 
  801cff:	ff d0                	call   *%rax
  801d01:	85 c0                	test   %eax,%eax
  801d03:	78 4d                	js     801d52 <fstat+0x6d>

    struct Dev *dev;
    if ((res = dev_lookup(fd->fd_dev_id, &dev)) < 0) return res;
  801d05:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  801d09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d0d:	8b 38                	mov    (%rax),%edi
  801d0f:	48 b8 a0 17 80 00 00 	movabs $0x8017a0,%rax
  801d16:	00 00 00 
  801d19:	ff d0                	call   *%rax
  801d1b:	85 c0                	test   %eax,%eax
  801d1d:	78 33                	js     801d52 <fstat+0x6d>

    if (!dev->dev_stat) return -E_NOT_SUPP;
  801d1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801d23:	48 83 78 28 00       	cmpq   $0x0,0x28(%rax)
  801d28:	74 2e                	je     801d58 <fstat+0x73>

    stat->st_name[0] = 0;
  801d2a:	c6 03 00             	movb   $0x0,(%rbx)
    stat->st_size = 0;
  801d2d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%rbx)
  801d34:	00 00 00 
    stat->st_isdir = 0;
  801d37:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%rbx)
  801d3e:	00 00 00 
    stat->st_dev = dev;
  801d41:	48 89 83 88 00 00 00 	mov    %rax,0x88(%rbx)

    return (*dev->dev_stat)(fd, stat);
  801d48:	48 89 de             	mov    %rbx,%rsi
  801d4b:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  801d4f:	ff 50 28             	call   *0x28(%rax)
}
  801d52:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801d56:	c9                   	leave  
  801d57:	c3                   	ret    
    if (!dev->dev_stat) return -E_NOT_SUPP;
  801d58:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  801d5d:	eb f3                	jmp    801d52 <fstat+0x6d>

0000000000801d5f <stat>:

int
stat(const char *path, struct Stat *stat) {
  801d5f:	55                   	push   %rbp
  801d60:	48 89 e5             	mov    %rsp,%rbp
  801d63:	41 54                	push   %r12
  801d65:	53                   	push   %rbx
  801d66:	49 89 f4             	mov    %rsi,%r12
    int fd = open(path, O_RDONLY);
  801d69:	be 00 00 00 00       	mov    $0x0,%esi
  801d6e:	48 b8 2a 20 80 00 00 	movabs $0x80202a,%rax
  801d75:	00 00 00 
  801d78:	ff d0                	call   *%rax
  801d7a:	89 c3                	mov    %eax,%ebx
    if (fd < 0) return fd;
  801d7c:	85 c0                	test   %eax,%eax
  801d7e:	78 25                	js     801da5 <stat+0x46>

    int res = fstat(fd, stat);
  801d80:	4c 89 e6             	mov    %r12,%rsi
  801d83:	89 c7                	mov    %eax,%edi
  801d85:	48 b8 e5 1c 80 00 00 	movabs $0x801ce5,%rax
  801d8c:	00 00 00 
  801d8f:	ff d0                	call   *%rax
  801d91:	41 89 c4             	mov    %eax,%r12d
    close(fd);
  801d94:	89 df                	mov    %ebx,%edi
  801d96:	48 b8 bf 18 80 00 00 	movabs $0x8018bf,%rax
  801d9d:	00 00 00 
  801da0:	ff d0                	call   *%rax

    return res;
  801da2:	44 89 e3             	mov    %r12d,%ebx
}
  801da5:	89 d8                	mov    %ebx,%eax
  801da7:	5b                   	pop    %rbx
  801da8:	41 5c                	pop    %r12
  801daa:	5d                   	pop    %rbp
  801dab:	c3                   	ret    

0000000000801dac <fsipc>:
 * response may be written back to fsipcbuf.
 * type: request code, passed as the simple integer IPC value.
 * dstva: virtual address at which to receive reply page, 0 if none.
 * Returns result from the file server. */
static int
fsipc(unsigned type, void *dstva) {
  801dac:	55                   	push   %rbp
  801dad:	48 89 e5             	mov    %rsp,%rbp
  801db0:	41 54                	push   %r12
  801db2:	53                   	push   %rbx
  801db3:	48 83 ec 10          	sub    $0x10,%rsp
  801db7:	41 89 fc             	mov    %edi,%r12d
  801dba:	48 89 f3             	mov    %rsi,%rbx
    static envid_t fsenv;

    if (!fsenv) fsenv = ipc_find_env(ENV_TYPE_FS);
  801dbd:	48 b8 00 70 81 00 00 	movabs $0x817000,%rax
  801dc4:	00 00 00 
  801dc7:	83 38 00             	cmpl   $0x0,(%rax)
  801dca:	74 5e                	je     801e2a <fsipc+0x7e>
    if (debug) {
        cprintf("[%08x] fsipc %d %08x\n",
                thisenv->env_id, type, *(uint32_t *)&fsipcbuf);
    }

    ipc_send(fsenv, type, &fsipcbuf, PAGE_SIZE, PROT_RW);
  801dcc:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  801dd2:	b9 00 10 00 00       	mov    $0x1000,%ecx
  801dd7:	48 ba 00 60 81 00 00 	movabs $0x816000,%rdx
  801dde:	00 00 00 
  801de1:	44 89 e6             	mov    %r12d,%esi
  801de4:	48 b8 00 70 81 00 00 	movabs $0x817000,%rax
  801deb:	00 00 00 
  801dee:	8b 38                	mov    (%rax),%edi
  801df0:	48 b8 10 13 81 00 00 	movabs $0x811310,%rax
  801df7:	00 00 00 
  801dfa:	ff d0                	call   *%rax
    size_t maxsz = PAGE_SIZE;
  801dfc:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  801e03:	00 
    return ipc_recv(NULL, dstva, &maxsz, NULL);
  801e04:	b9 00 00 00 00       	mov    $0x0,%ecx
  801e09:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  801e0d:	48 89 de             	mov    %rbx,%rsi
  801e10:	bf 00 00 00 00       	mov    $0x0,%edi
  801e15:	48 b8 71 12 81 00 00 	movabs $0x811271,%rax
  801e1c:	00 00 00 
  801e1f:	ff d0                	call   *%rax
}
  801e21:	48 83 c4 10          	add    $0x10,%rsp
  801e25:	5b                   	pop    %rbx
  801e26:	41 5c                	pop    %r12
  801e28:	5d                   	pop    %rbp
  801e29:	c3                   	ret    
    if (!fsenv) fsenv = ipc_find_env(ENV_TYPE_FS);
  801e2a:	bf 03 00 00 00       	mov    $0x3,%edi
  801e2f:	48 b8 b3 13 81 00 00 	movabs $0x8113b3,%rax
  801e36:	00 00 00 
  801e39:	ff d0                	call   *%rax
  801e3b:	a3 00 70 81 00 00 00 	movabs %eax,0x817000
  801e42:	00 00 
  801e44:	eb 86                	jmp    801dcc <fsipc+0x20>

0000000000801e46 <devfile_trunc>:
    return 0;
}

/* Truncate or extend an open file to 'size' bytes */
static int
devfile_trunc(struct Fd *fd, off_t newsize) {
  801e46:	55                   	push   %rbp
  801e47:	48 89 e5             	mov    %rsp,%rbp
    fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  801e4a:	48 b8 00 60 81 00 00 	movabs $0x816000,%rax
  801e51:	00 00 00 
  801e54:	8b 57 0c             	mov    0xc(%rdi),%edx
  801e57:	89 10                	mov    %edx,(%rax)
    fsipcbuf.set_size.req_size = newsize;
  801e59:	89 70 04             	mov    %esi,0x4(%rax)

    return fsipc(FSREQ_SET_SIZE, NULL);
  801e5c:	be 00 00 00 00       	mov    $0x0,%esi
  801e61:	bf 02 00 00 00       	mov    $0x2,%edi
  801e66:	48 b8 ac 1d 80 00 00 	movabs $0x801dac,%rax
  801e6d:	00 00 00 
  801e70:	ff d0                	call   *%rax
}
  801e72:	5d                   	pop    %rbp
  801e73:	c3                   	ret    

0000000000801e74 <devfile_flush>:
devfile_flush(struct Fd *fd) {
  801e74:	55                   	push   %rbp
  801e75:	48 89 e5             	mov    %rsp,%rbp
    fsipcbuf.flush.req_fileid = fd->fd_file.id;
  801e78:	8b 47 0c             	mov    0xc(%rdi),%eax
  801e7b:	a3 00 60 81 00 00 00 	movabs %eax,0x816000
  801e82:	00 00 
    return fsipc(FSREQ_FLUSH, NULL);
  801e84:	be 00 00 00 00       	mov    $0x0,%esi
  801e89:	bf 06 00 00 00       	mov    $0x6,%edi
  801e8e:	48 b8 ac 1d 80 00 00 	movabs $0x801dac,%rax
  801e95:	00 00 00 
  801e98:	ff d0                	call   *%rax
}
  801e9a:	5d                   	pop    %rbp
  801e9b:	c3                   	ret    

0000000000801e9c <devfile_stat>:
devfile_stat(struct Fd *fd, struct Stat *st) {
  801e9c:	55                   	push   %rbp
  801e9d:	48 89 e5             	mov    %rsp,%rbp
  801ea0:	53                   	push   %rbx
  801ea1:	48 83 ec 08          	sub    $0x8,%rsp
  801ea5:	48 89 f3             	mov    %rsi,%rbx
    fsipcbuf.stat.req_fileid = fd->fd_file.id;
  801ea8:	8b 47 0c             	mov    0xc(%rdi),%eax
  801eab:	a3 00 60 81 00 00 00 	movabs %eax,0x816000
  801eb2:	00 00 
    int res = fsipc(FSREQ_STAT, NULL);
  801eb4:	be 00 00 00 00       	mov    $0x0,%esi
  801eb9:	bf 05 00 00 00       	mov    $0x5,%edi
  801ebe:	48 b8 ac 1d 80 00 00 	movabs $0x801dac,%rax
  801ec5:	00 00 00 
  801ec8:	ff d0                	call   *%rax
    if (res < 0) return res;
  801eca:	85 c0                	test   %eax,%eax
  801ecc:	78 40                	js     801f0e <devfile_stat+0x72>
    strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  801ece:	48 be 00 60 81 00 00 	movabs $0x816000,%rsi
  801ed5:	00 00 00 
  801ed8:	48 89 df             	mov    %rbx,%rdi
  801edb:	48 b8 a8 0d 80 00 00 	movabs $0x800da8,%rax
  801ee2:	00 00 00 
  801ee5:	ff d0                	call   *%rax
    st->st_size = fsipcbuf.statRet.ret_size;
  801ee7:	48 b8 00 60 81 00 00 	movabs $0x816000,%rax
  801eee:	00 00 00 
  801ef1:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  801ef7:	89 93 80 00 00 00    	mov    %edx,0x80(%rbx)
    st->st_isdir = fsipcbuf.statRet.ret_isdir;
  801efd:	8b 80 84 00 00 00    	mov    0x84(%rax),%eax
  801f03:	89 83 84 00 00 00    	mov    %eax,0x84(%rbx)
    return 0;
  801f09:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801f0e:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  801f12:	c9                   	leave  
  801f13:	c3                   	ret    

0000000000801f14 <devfile_write>:
devfile_write(struct Fd *fd, const void *buf, size_t n) {
  801f14:	55                   	push   %rbp
  801f15:	48 89 e5             	mov    %rsp,%rbp
  801f18:	41 57                	push   %r15
  801f1a:	41 56                	push   %r14
  801f1c:	41 55                	push   %r13
  801f1e:	41 54                	push   %r12
  801f20:	53                   	push   %rbx
  801f21:	48 83 ec 18          	sub    $0x18,%rsp
    while (n) {
  801f25:	48 85 d2             	test   %rdx,%rdx
  801f28:	0f 84 91 00 00 00    	je     801fbf <devfile_write+0xab>
  801f2e:	49 89 ff             	mov    %rdi,%r15
  801f31:	49 89 f4             	mov    %rsi,%r12
  801f34:	48 89 d3             	mov    %rdx,%rbx
    int ext = 0;
  801f37:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
        fsipcbuf.write.req_fileid = fd->fd_file.id;
  801f3e:	49 be 00 60 81 00 00 	movabs $0x816000,%r14
  801f45:	00 00 00 
        size_t tmp = MIN(n, sizeof(fsipcbuf.write.req_buf));
  801f48:	48 81 fb f0 0f 00 00 	cmp    $0xff0,%rbx
  801f4f:	41 bd f0 0f 00 00    	mov    $0xff0,%r13d
  801f55:	4c 0f 46 eb          	cmovbe %rbx,%r13
        memcpy(fsipcbuf.write.req_buf, buf, tmp);
  801f59:	4c 89 ea             	mov    %r13,%rdx
  801f5c:	4c 89 e6             	mov    %r12,%rsi
  801f5f:	48 bf 10 60 81 00 00 	movabs $0x816010,%rdi
  801f66:	00 00 00 
  801f69:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  801f70:	00 00 00 
  801f73:	ff d0                	call   *%rax
        fsipcbuf.write.req_fileid = fd->fd_file.id;
  801f75:	41 8b 47 0c          	mov    0xc(%r15),%eax
  801f79:	41 89 06             	mov    %eax,(%r14)
        fsipcbuf.write.req_n = tmp;
  801f7c:	4d 89 6e 08          	mov    %r13,0x8(%r14)
        int res = fsipc(FSREQ_WRITE, NULL);
  801f80:	be 00 00 00 00       	mov    $0x0,%esi
  801f85:	bf 04 00 00 00       	mov    $0x4,%edi
  801f8a:	48 b8 ac 1d 80 00 00 	movabs $0x801dac,%rax
  801f91:	00 00 00 
  801f94:	ff d0                	call   *%rax
        if (res < 0)
  801f96:	85 c0                	test   %eax,%eax
  801f98:	78 21                	js     801fbb <devfile_write+0xa7>
        buf += res;
  801f9a:	48 63 d0             	movslq %eax,%rdx
  801f9d:	49 01 d4             	add    %rdx,%r12
        ext += res;
  801fa0:	01 45 cc             	add    %eax,-0x34(%rbp)
    while (n) {
  801fa3:	48 29 d3             	sub    %rdx,%rbx
  801fa6:	75 a0                	jne    801f48 <devfile_write+0x34>
    return ext;
  801fa8:	48 63 45 cc          	movslq -0x34(%rbp),%rax
}
  801fac:	48 83 c4 18          	add    $0x18,%rsp
  801fb0:	5b                   	pop    %rbx
  801fb1:	41 5c                	pop    %r12
  801fb3:	41 5d                	pop    %r13
  801fb5:	41 5e                	pop    %r14
  801fb7:	41 5f                	pop    %r15
  801fb9:	5d                   	pop    %rbp
  801fba:	c3                   	ret    
            return res;
  801fbb:	48 98                	cltq   
  801fbd:	eb ed                	jmp    801fac <devfile_write+0x98>
    int ext = 0;
  801fbf:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
  801fc6:	eb e0                	jmp    801fa8 <devfile_write+0x94>

0000000000801fc8 <devfile_read>:
devfile_read(struct Fd *fd, void *buf, size_t n) {
  801fc8:	55                   	push   %rbp
  801fc9:	48 89 e5             	mov    %rsp,%rbp
  801fcc:	41 54                	push   %r12
  801fce:	53                   	push   %rbx
  801fcf:	49 89 f4             	mov    %rsi,%r12
    fsipcbuf.read.req_fileid = fd->fd_file.id;
  801fd2:	48 b8 00 60 81 00 00 	movabs $0x816000,%rax
  801fd9:	00 00 00 
  801fdc:	8b 4f 0c             	mov    0xc(%rdi),%ecx
  801fdf:	89 08                	mov    %ecx,(%rax)
    fsipcbuf.read.req_n = n;
  801fe1:	48 89 50 08          	mov    %rdx,0x8(%rax)
    int read = fsipc(FSREQ_READ, NULL);
  801fe5:	be 00 00 00 00       	mov    $0x0,%esi
  801fea:	bf 03 00 00 00       	mov    $0x3,%edi
  801fef:	48 b8 ac 1d 80 00 00 	movabs $0x801dac,%rax
  801ff6:	00 00 00 
  801ff9:	ff d0                	call   *%rax
    if (read < 0) 
  801ffb:	85 c0                	test   %eax,%eax
  801ffd:	78 27                	js     802026 <devfile_read+0x5e>
    memmove(buf, fsipcbuf.readRet.ret_buf, read);
  801fff:	48 63 d8             	movslq %eax,%rbx
  802002:	48 89 da             	mov    %rbx,%rdx
  802005:	48 be 00 60 81 00 00 	movabs $0x816000,%rsi
  80200c:	00 00 00 
  80200f:	4c 89 e7             	mov    %r12,%rdi
  802012:	48 b8 a3 0f 80 00 00 	movabs $0x800fa3,%rax
  802019:	00 00 00 
  80201c:	ff d0                	call   *%rax
    return read;
  80201e:	48 89 d8             	mov    %rbx,%rax
}
  802021:	5b                   	pop    %rbx
  802022:	41 5c                	pop    %r12
  802024:	5d                   	pop    %rbp
  802025:	c3                   	ret    
		return read;
  802026:	48 98                	cltq   
  802028:	eb f7                	jmp    802021 <devfile_read+0x59>

000000000080202a <open>:
open(const char *path, int mode) {
  80202a:	55                   	push   %rbp
  80202b:	48 89 e5             	mov    %rsp,%rbp
  80202e:	41 55                	push   %r13
  802030:	41 54                	push   %r12
  802032:	53                   	push   %rbx
  802033:	48 83 ec 18          	sub    $0x18,%rsp
  802037:	49 89 fc             	mov    %rdi,%r12
  80203a:	41 89 f5             	mov    %esi,%r13d
    if (strlen(path) >= MAXPATHLEN)
  80203d:	48 b8 6f 0d 80 00 00 	movabs $0x800d6f,%rax
  802044:	00 00 00 
  802047:	ff d0                	call   *%rax
  802049:	48 3d ff 03 00 00    	cmp    $0x3ff,%rax
  80204f:	0f 87 8c 00 00 00    	ja     8020e1 <open+0xb7>
    if ((res = fd_alloc(&fd)) < 0) return res;
  802055:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  802059:	48 b8 f5 16 80 00 00 	movabs $0x8016f5,%rax
  802060:	00 00 00 
  802063:	ff d0                	call   *%rax
  802065:	89 c3                	mov    %eax,%ebx
  802067:	85 c0                	test   %eax,%eax
  802069:	78 52                	js     8020bd <open+0x93>
    strcpy(fsipcbuf.open.req_path, path);
  80206b:	4c 89 e6             	mov    %r12,%rsi
  80206e:	48 bf 00 60 81 00 00 	movabs $0x816000,%rdi
  802075:	00 00 00 
  802078:	48 b8 a8 0d 80 00 00 	movabs $0x800da8,%rax
  80207f:	00 00 00 
  802082:	ff d0                	call   *%rax
    fsipcbuf.open.req_omode = mode;
  802084:	44 89 e8             	mov    %r13d,%eax
  802087:	a3 00 64 81 00 00 00 	movabs %eax,0x816400
  80208e:	00 00 
    if ((res = fsipc(FSREQ_OPEN, fd)) < 0) {
  802090:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  802094:	bf 01 00 00 00       	mov    $0x1,%edi
  802099:	48 b8 ac 1d 80 00 00 	movabs $0x801dac,%rax
  8020a0:	00 00 00 
  8020a3:	ff d0                	call   *%rax
  8020a5:	89 c3                	mov    %eax,%ebx
  8020a7:	85 c0                	test   %eax,%eax
  8020a9:	78 1f                	js     8020ca <open+0xa0>
    return fd2num(fd);
  8020ab:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8020af:	48 b8 c7 16 80 00 00 	movabs $0x8016c7,%rax
  8020b6:	00 00 00 
  8020b9:	ff d0                	call   *%rax
  8020bb:	89 c3                	mov    %eax,%ebx
}
  8020bd:	89 d8                	mov    %ebx,%eax
  8020bf:	48 83 c4 18          	add    $0x18,%rsp
  8020c3:	5b                   	pop    %rbx
  8020c4:	41 5c                	pop    %r12
  8020c6:	41 5d                	pop    %r13
  8020c8:	5d                   	pop    %rbp
  8020c9:	c3                   	ret    
        fd_close(fd, 0);
  8020ca:	be 00 00 00 00       	mov    $0x0,%esi
  8020cf:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8020d3:	48 b8 19 18 80 00 00 	movabs $0x801819,%rax
  8020da:	00 00 00 
  8020dd:	ff d0                	call   *%rax
        return res;
  8020df:	eb dc                	jmp    8020bd <open+0x93>
        return -E_BAD_PATH;
  8020e1:	bb f0 ff ff ff       	mov    $0xfffffff0,%ebx
  8020e6:	eb d5                	jmp    8020bd <open+0x93>

00000000008020e8 <sync>:

/* Synchronize disk with buffer cache */
int
sync(void) {
  8020e8:	55                   	push   %rbp
  8020e9:	48 89 e5             	mov    %rsp,%rbp
    /* Ask the file server to update the disk
     * by writing any dirty blocks in the buffer cache. */

    return fsipc(FSREQ_SYNC, NULL);
  8020ec:	be 00 00 00 00       	mov    $0x0,%esi
  8020f1:	bf 08 00 00 00       	mov    $0x8,%edi
  8020f6:	48 b8 ac 1d 80 00 00 	movabs $0x801dac,%rax
  8020fd:	00 00 00 
  802100:	ff d0                	call   *%rax
}
  802102:	5d                   	pop    %rbp
  802103:	c3                   	ret    

0000000000802104 <devpipe_stat>:

    return n;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat) {
  802104:	55                   	push   %rbp
  802105:	48 89 e5             	mov    %rsp,%rbp
  802108:	41 54                	push   %r12
  80210a:	53                   	push   %rbx
  80210b:	48 89 f3             	mov    %rsi,%rbx
    struct Pipe *p = (struct Pipe *)fd2data(fd);
  80210e:	48 b8 d9 16 80 00 00 	movabs $0x8016d9,%rax
  802115:	00 00 00 
  802118:	ff d0                	call   *%rax
  80211a:	49 89 c4             	mov    %rax,%r12
    strcpy(stat->st_name, "<pipe>");
  80211d:	48 be c0 1a 81 00 00 	movabs $0x811ac0,%rsi
  802124:	00 00 00 
  802127:	48 89 df             	mov    %rbx,%rdi
  80212a:	48 b8 a8 0d 80 00 00 	movabs $0x800da8,%rax
  802131:	00 00 00 
  802134:	ff d0                	call   *%rax
    stat->st_size = p->p_wpos - p->p_rpos;
  802136:	41 8b 44 24 04       	mov    0x4(%r12),%eax
  80213b:	41 2b 04 24          	sub    (%r12),%eax
  80213f:	89 83 80 00 00 00    	mov    %eax,0x80(%rbx)
    stat->st_isdir = 0;
  802145:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%rbx)
  80214c:	00 00 00 
    stat->st_dev = &devpipe;
  80214f:	48 b8 60 40 81 00 00 	movabs $0x814060,%rax
  802156:	00 00 00 
  802159:	48 89 83 88 00 00 00 	mov    %rax,0x88(%rbx)
    return 0;
}
  802160:	b8 00 00 00 00       	mov    $0x0,%eax
  802165:	5b                   	pop    %rbx
  802166:	41 5c                	pop    %r12
  802168:	5d                   	pop    %rbp
  802169:	c3                   	ret    

000000000080216a <devpipe_close>:

static int
devpipe_close(struct Fd *fd) {
  80216a:	55                   	push   %rbp
  80216b:	48 89 e5             	mov    %rsp,%rbp
  80216e:	41 54                	push   %r12
  802170:	53                   	push   %rbx
  802171:	48 89 fb             	mov    %rdi,%rbx
    USED(sys_unmap_region(0, fd, PAGE_SIZE));
  802174:	ba 00 10 00 00       	mov    $0x1000,%edx
  802179:	48 89 fe             	mov    %rdi,%rsi
  80217c:	bf 00 00 00 00       	mov    $0x0,%edi
  802181:	49 bc 2e 14 80 00 00 	movabs $0x80142e,%r12
  802188:	00 00 00 
  80218b:	41 ff d4             	call   *%r12
    return sys_unmap_region(0, fd2data(fd), PAGE_SIZE);
  80218e:	48 89 df             	mov    %rbx,%rdi
  802191:	48 b8 d9 16 80 00 00 	movabs $0x8016d9,%rax
  802198:	00 00 00 
  80219b:	ff d0                	call   *%rax
  80219d:	48 89 c6             	mov    %rax,%rsi
  8021a0:	ba 00 10 00 00       	mov    $0x1000,%edx
  8021a5:	bf 00 00 00 00       	mov    $0x0,%edi
  8021aa:	41 ff d4             	call   *%r12
}
  8021ad:	5b                   	pop    %rbx
  8021ae:	41 5c                	pop    %r12
  8021b0:	5d                   	pop    %rbp
  8021b1:	c3                   	ret    

00000000008021b2 <devpipe_write>:
devpipe_write(struct Fd *fd, const void *vbuf, size_t n) {
  8021b2:	55                   	push   %rbp
  8021b3:	48 89 e5             	mov    %rsp,%rbp
  8021b6:	41 57                	push   %r15
  8021b8:	41 56                	push   %r14
  8021ba:	41 55                	push   %r13
  8021bc:	41 54                	push   %r12
  8021be:	53                   	push   %rbx
  8021bf:	48 83 ec 18          	sub    $0x18,%rsp
  8021c3:	49 89 fc             	mov    %rdi,%r12
  8021c6:	49 89 f5             	mov    %rsi,%r13
  8021c9:	49 89 d7             	mov    %rdx,%r15
  8021cc:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    struct Pipe *p = (struct Pipe *)fd2data(fd);
  8021d0:	48 b8 d9 16 80 00 00 	movabs $0x8016d9,%rax
  8021d7:	00 00 00 
  8021da:	ff d0                	call   *%rax
    for (size_t i = 0; i < n; i++) {
  8021dc:	4d 85 ff             	test   %r15,%r15
  8021df:	0f 84 ac 00 00 00    	je     802291 <devpipe_write+0xdf>
  8021e5:	48 89 c3             	mov    %rax,%rbx
  8021e8:	4c 89 f8             	mov    %r15,%rax
  8021eb:	4d 89 ef             	mov    %r13,%r15
  8021ee:	49 01 c5             	add    %rax,%r13
  8021f1:	4c 89 6d c8          	mov    %r13,-0x38(%rbp)
    return !sys_region_refs2(fd, PAGE_SIZE, p, PAGE_SIZE);
  8021f5:	49 bd 36 13 80 00 00 	movabs $0x801336,%r13
  8021fc:	00 00 00 
            sys_yield();
  8021ff:	49 be d3 12 80 00 00 	movabs $0x8012d3,%r14
  802206:	00 00 00 
        while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) /* pipe is full */ {
  802209:	8b 73 04             	mov    0x4(%rbx),%esi
  80220c:	48 63 ce             	movslq %esi,%rcx
  80220f:	48 63 03             	movslq (%rbx),%rax
  802212:	48 05 f8 0f 00 00    	add    $0xff8,%rax
  802218:	48 39 c1             	cmp    %rax,%rcx
  80221b:	72 2e                	jb     80224b <devpipe_write+0x99>
    return !sys_region_refs2(fd, PAGE_SIZE, p, PAGE_SIZE);
  80221d:	b9 00 10 00 00       	mov    $0x1000,%ecx
  802222:	48 89 da             	mov    %rbx,%rdx
  802225:	be 00 10 00 00       	mov    $0x1000,%esi
  80222a:	4c 89 e7             	mov    %r12,%rdi
  80222d:	41 ff d5             	call   *%r13
            if (_pipeisclosed(fd, p)) return 0;
  802230:	85 c0                	test   %eax,%eax
  802232:	74 63                	je     802297 <devpipe_write+0xe5>
            sys_yield();
  802234:	41 ff d6             	call   *%r14
        while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) /* pipe is full */ {
  802237:	8b 73 04             	mov    0x4(%rbx),%esi
  80223a:	48 63 ce             	movslq %esi,%rcx
  80223d:	48 63 03             	movslq (%rbx),%rax
  802240:	48 05 f8 0f 00 00    	add    $0xff8,%rax
  802246:	48 39 c1             	cmp    %rax,%rcx
  802249:	73 d2                	jae    80221d <devpipe_write+0x6b>
        p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  80224b:	41 0f b6 3f          	movzbl (%r15),%edi
  80224f:	48 89 ca             	mov    %rcx,%rdx
  802252:	48 c1 ea 03          	shr    $0x3,%rdx
  802256:	48 b8 81 00 01 02 04 	movabs $0x2010080402010081,%rax
  80225d:	08 10 20 
  802260:	48 f7 e2             	mul    %rdx
  802263:	48 c1 ea 06          	shr    $0x6,%rdx
  802267:	48 89 d0             	mov    %rdx,%rax
  80226a:	48 c1 e0 09          	shl    $0x9,%rax
  80226e:	48 29 d0             	sub    %rdx,%rax
  802271:	48 c1 e0 03          	shl    $0x3,%rax
  802275:	48 29 c1             	sub    %rax,%rcx
  802278:	40 88 7c 0b 08       	mov    %dil,0x8(%rbx,%rcx,1)
        p->p_wpos++;
  80227d:	83 c6 01             	add    $0x1,%esi
  802280:	89 73 04             	mov    %esi,0x4(%rbx)
    for (size_t i = 0; i < n; i++) {
  802283:	49 83 c7 01          	add    $0x1,%r15
  802287:	4c 3b 7d c8          	cmp    -0x38(%rbp),%r15
  80228b:	0f 85 78 ff ff ff    	jne    802209 <devpipe_write+0x57>
    return n;
  802291:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  802295:	eb 05                	jmp    80229c <devpipe_write+0xea>
            if (_pipeisclosed(fd, p)) return 0;
  802297:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80229c:	48 83 c4 18          	add    $0x18,%rsp
  8022a0:	5b                   	pop    %rbx
  8022a1:	41 5c                	pop    %r12
  8022a3:	41 5d                	pop    %r13
  8022a5:	41 5e                	pop    %r14
  8022a7:	41 5f                	pop    %r15
  8022a9:	5d                   	pop    %rbp
  8022aa:	c3                   	ret    

00000000008022ab <devpipe_read>:
devpipe_read(struct Fd *fd, void *vbuf, size_t n) {
  8022ab:	55                   	push   %rbp
  8022ac:	48 89 e5             	mov    %rsp,%rbp
  8022af:	41 57                	push   %r15
  8022b1:	41 56                	push   %r14
  8022b3:	41 55                	push   %r13
  8022b5:	41 54                	push   %r12
  8022b7:	53                   	push   %rbx
  8022b8:	48 83 ec 18          	sub    $0x18,%rsp
  8022bc:	49 89 fc             	mov    %rdi,%r12
  8022bf:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8022c3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    struct Pipe *p = (struct Pipe *)fd2data(fd);
  8022c7:	48 b8 d9 16 80 00 00 	movabs $0x8016d9,%rax
  8022ce:	00 00 00 
  8022d1:	ff d0                	call   *%rax
  8022d3:	48 89 c3             	mov    %rax,%rbx
    for (size_t i = 0; i < n; i++) {
  8022d6:	41 bf 00 00 00 00    	mov    $0x0,%r15d
    return !sys_region_refs2(fd, PAGE_SIZE, p, PAGE_SIZE);
  8022dc:	49 bd 36 13 80 00 00 	movabs $0x801336,%r13
  8022e3:	00 00 00 
            sys_yield();
  8022e6:	49 be d3 12 80 00 00 	movabs $0x8012d3,%r14
  8022ed:	00 00 00 
    for (size_t i = 0; i < n; i++) {
  8022f0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8022f5:	74 7a                	je     802371 <devpipe_read+0xc6>
        while (p->p_rpos == p->p_wpos) /* pipe is empty */ {
  8022f7:	8b 03                	mov    (%rbx),%eax
  8022f9:	3b 43 04             	cmp    0x4(%rbx),%eax
  8022fc:	75 26                	jne    802324 <devpipe_read+0x79>
            if (i > 0) return i;
  8022fe:	4d 85 ff             	test   %r15,%r15
  802301:	75 74                	jne    802377 <devpipe_read+0xcc>
    return !sys_region_refs2(fd, PAGE_SIZE, p, PAGE_SIZE);
  802303:	b9 00 10 00 00       	mov    $0x1000,%ecx
  802308:	48 89 da             	mov    %rbx,%rdx
  80230b:	be 00 10 00 00       	mov    $0x1000,%esi
  802310:	4c 89 e7             	mov    %r12,%rdi
  802313:	41 ff d5             	call   *%r13
            if (_pipeisclosed(fd, p)) return 0;
  802316:	85 c0                	test   %eax,%eax
  802318:	74 6f                	je     802389 <devpipe_read+0xde>
            sys_yield();
  80231a:	41 ff d6             	call   *%r14
        while (p->p_rpos == p->p_wpos) /* pipe is empty */ {
  80231d:	8b 03                	mov    (%rbx),%eax
  80231f:	3b 43 04             	cmp    0x4(%rbx),%eax
  802322:	74 df                	je     802303 <devpipe_read+0x58>
        buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  802324:	48 63 c8             	movslq %eax,%rcx
  802327:	48 89 ca             	mov    %rcx,%rdx
  80232a:	48 c1 ea 03          	shr    $0x3,%rdx
  80232e:	48 b8 81 00 01 02 04 	movabs $0x2010080402010081,%rax
  802335:	08 10 20 
  802338:	48 f7 e2             	mul    %rdx
  80233b:	48 c1 ea 06          	shr    $0x6,%rdx
  80233f:	48 89 d0             	mov    %rdx,%rax
  802342:	48 c1 e0 09          	shl    $0x9,%rax
  802346:	48 29 d0             	sub    %rdx,%rax
  802349:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  802350:	00 
  802351:	48 89 c8             	mov    %rcx,%rax
  802354:	48 29 d0             	sub    %rdx,%rax
  802357:	0f b6 44 03 08       	movzbl 0x8(%rbx,%rax,1),%eax
  80235c:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  802360:	42 88 04 39          	mov    %al,(%rcx,%r15,1)
        p->p_rpos++;
  802364:	83 03 01             	addl   $0x1,(%rbx)
    for (size_t i = 0; i < n; i++) {
  802367:	49 83 c7 01          	add    $0x1,%r15
  80236b:	4c 39 7d c8          	cmp    %r15,-0x38(%rbp)
  80236f:	75 86                	jne    8022f7 <devpipe_read+0x4c>
    return n;
  802371:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  802375:	eb 03                	jmp    80237a <devpipe_read+0xcf>
            if (i > 0) return i;
  802377:	4c 89 f8             	mov    %r15,%rax
}
  80237a:	48 83 c4 18          	add    $0x18,%rsp
  80237e:	5b                   	pop    %rbx
  80237f:	41 5c                	pop    %r12
  802381:	41 5d                	pop    %r13
  802383:	41 5e                	pop    %r14
  802385:	41 5f                	pop    %r15
  802387:	5d                   	pop    %rbp
  802388:	c3                   	ret    
            if (_pipeisclosed(fd, p)) return 0;
  802389:	b8 00 00 00 00       	mov    $0x0,%eax
  80238e:	eb ea                	jmp    80237a <devpipe_read+0xcf>

0000000000802390 <pipe>:
pipe(int pfd[2]) {
  802390:	55                   	push   %rbp
  802391:	48 89 e5             	mov    %rsp,%rbp
  802394:	41 55                	push   %r13
  802396:	41 54                	push   %r12
  802398:	53                   	push   %rbx
  802399:	48 83 ec 18          	sub    $0x18,%rsp
  80239d:	49 89 fc             	mov    %rdi,%r12
    if ((res = fd_alloc(&fd0)) < 0 ||
  8023a0:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8023a4:	48 b8 f5 16 80 00 00 	movabs $0x8016f5,%rax
  8023ab:	00 00 00 
  8023ae:	ff d0                	call   *%rax
  8023b0:	89 c3                	mov    %eax,%ebx
  8023b2:	85 c0                	test   %eax,%eax
  8023b4:	0f 88 a0 01 00 00    	js     80255a <pipe+0x1ca>
        (res = sys_alloc_region(0, fd0, PAGE_SIZE, PROT_RW | PROT_SHARE)) < 0) goto err;
  8023ba:	b9 46 00 00 00       	mov    $0x46,%ecx
  8023bf:	ba 00 10 00 00       	mov    $0x1000,%edx
  8023c4:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8023c8:	bf 00 00 00 00       	mov    $0x0,%edi
  8023cd:	48 b8 62 13 80 00 00 	movabs $0x801362,%rax
  8023d4:	00 00 00 
  8023d7:	ff d0                	call   *%rax
  8023d9:	89 c3                	mov    %eax,%ebx
    if ((res = fd_alloc(&fd0)) < 0 ||
  8023db:	85 c0                	test   %eax,%eax
  8023dd:	0f 88 77 01 00 00    	js     80255a <pipe+0x1ca>
    if ((res = fd_alloc(&fd1)) < 0 ||
  8023e3:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8023e7:	48 b8 f5 16 80 00 00 	movabs $0x8016f5,%rax
  8023ee:	00 00 00 
  8023f1:	ff d0                	call   *%rax
  8023f3:	89 c3                	mov    %eax,%ebx
  8023f5:	85 c0                	test   %eax,%eax
  8023f7:	0f 88 43 01 00 00    	js     802540 <pipe+0x1b0>
        (res = sys_alloc_region(0, fd1, PAGE_SIZE, PROT_RW | PROT_SHARE)) < 0) goto err1;
  8023fd:	b9 46 00 00 00       	mov    $0x46,%ecx
  802402:	ba 00 10 00 00       	mov    $0x1000,%edx
  802407:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80240b:	bf 00 00 00 00       	mov    $0x0,%edi
  802410:	48 b8 62 13 80 00 00 	movabs $0x801362,%rax
  802417:	00 00 00 
  80241a:	ff d0                	call   *%rax
  80241c:	89 c3                	mov    %eax,%ebx
    if ((res = fd_alloc(&fd1)) < 0 ||
  80241e:	85 c0                	test   %eax,%eax
  802420:	0f 88 1a 01 00 00    	js     802540 <pipe+0x1b0>
    va = fd2data(fd0);
  802426:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  80242a:	48 b8 d9 16 80 00 00 	movabs $0x8016d9,%rax
  802431:	00 00 00 
  802434:	ff d0                	call   *%rax
  802436:	49 89 c5             	mov    %rax,%r13
    if ((res = sys_alloc_region(0, va, PAGE_SIZE, PROT_RW | PROT_SHARE)) < 0) goto err2;
  802439:	b9 46 00 00 00       	mov    $0x46,%ecx
  80243e:	ba 00 10 00 00       	mov    $0x1000,%edx
  802443:	48 89 c6             	mov    %rax,%rsi
  802446:	bf 00 00 00 00       	mov    $0x0,%edi
  80244b:	48 b8 62 13 80 00 00 	movabs $0x801362,%rax
  802452:	00 00 00 
  802455:	ff d0                	call   *%rax
  802457:	89 c3                	mov    %eax,%ebx
  802459:	85 c0                	test   %eax,%eax
  80245b:	0f 88 c5 00 00 00    	js     802526 <pipe+0x196>
    if ((res = sys_map_region(0, va, 0, fd2data(fd1), PAGE_SIZE, PROT_RW | PROT_SHARE)) < 0) goto err3;
  802461:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  802465:	48 b8 d9 16 80 00 00 	movabs $0x8016d9,%rax
  80246c:	00 00 00 
  80246f:	ff d0                	call   *%rax
  802471:	48 89 c1             	mov    %rax,%rcx
  802474:	41 b9 46 00 00 00    	mov    $0x46,%r9d
  80247a:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  802480:	ba 00 00 00 00       	mov    $0x0,%edx
  802485:	4c 89 ee             	mov    %r13,%rsi
  802488:	bf 00 00 00 00       	mov    $0x0,%edi
  80248d:	48 b8 c9 13 80 00 00 	movabs $0x8013c9,%rax
  802494:	00 00 00 
  802497:	ff d0                	call   *%rax
  802499:	89 c3                	mov    %eax,%ebx
  80249b:	85 c0                	test   %eax,%eax
  80249d:	78 6e                	js     80250d <pipe+0x17d>
    assert(sys_region_refs(va, PAGE_SIZE) == 2);
  80249f:	be 00 10 00 00       	mov    $0x1000,%esi
  8024a4:	4c 89 ef             	mov    %r13,%rdi
  8024a7:	48 b8 04 13 80 00 00 	movabs $0x801304,%rax
  8024ae:	00 00 00 
  8024b1:	ff d0                	call   *%rax
  8024b3:	83 f8 02             	cmp    $0x2,%eax
  8024b6:	0f 85 ab 00 00 00    	jne    802567 <pipe+0x1d7>
    fd0->fd_dev_id = devpipe.dev_id;
  8024bc:	a1 60 40 81 00 00 00 	movabs 0x814060,%eax
  8024c3:	00 00 
  8024c5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8024c9:	89 02                	mov    %eax,(%rdx)
    fd0->fd_omode = O_RDONLY;
  8024cb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8024cf:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%rdx)
    fd1->fd_dev_id = devpipe.dev_id;
  8024d6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8024da:	89 02                	mov    %eax,(%rdx)
    fd1->fd_omode = O_WRONLY;
  8024dc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8024e0:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
    pfd[0] = fd2num(fd0);
  8024e7:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8024eb:	48 bb c7 16 80 00 00 	movabs $0x8016c7,%rbx
  8024f2:	00 00 00 
  8024f5:	ff d3                	call   *%rbx
  8024f7:	41 89 04 24          	mov    %eax,(%r12)
    pfd[1] = fd2num(fd1);
  8024fb:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  8024ff:	ff d3                	call   *%rbx
  802501:	41 89 44 24 04       	mov    %eax,0x4(%r12)
    return 0;
  802506:	bb 00 00 00 00       	mov    $0x0,%ebx
  80250b:	eb 4d                	jmp    80255a <pipe+0x1ca>
    sys_unmap_region(0, va, PAGE_SIZE);
  80250d:	ba 00 10 00 00       	mov    $0x1000,%edx
  802512:	4c 89 ee             	mov    %r13,%rsi
  802515:	bf 00 00 00 00       	mov    $0x0,%edi
  80251a:	48 b8 2e 14 80 00 00 	movabs $0x80142e,%rax
  802521:	00 00 00 
  802524:	ff d0                	call   *%rax
    sys_unmap_region(0, fd1, PAGE_SIZE);
  802526:	ba 00 10 00 00       	mov    $0x1000,%edx
  80252b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80252f:	bf 00 00 00 00       	mov    $0x0,%edi
  802534:	48 b8 2e 14 80 00 00 	movabs $0x80142e,%rax
  80253b:	00 00 00 
  80253e:	ff d0                	call   *%rax
    sys_unmap_region(0, fd0, PAGE_SIZE);
  802540:	ba 00 10 00 00       	mov    $0x1000,%edx
  802545:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  802549:	bf 00 00 00 00       	mov    $0x0,%edi
  80254e:	48 b8 2e 14 80 00 00 	movabs $0x80142e,%rax
  802555:	00 00 00 
  802558:	ff d0                	call   *%rax
}
  80255a:	89 d8                	mov    %ebx,%eax
  80255c:	48 83 c4 18          	add    $0x18,%rsp
  802560:	5b                   	pop    %rbx
  802561:	41 5c                	pop    %r12
  802563:	41 5d                	pop    %r13
  802565:	5d                   	pop    %rbp
  802566:	c3                   	ret    
    assert(sys_region_refs(va, PAGE_SIZE) == 2);
  802567:	48 b9 f0 1a 81 00 00 	movabs $0x811af0,%rcx
  80256e:	00 00 00 
  802571:	48 ba c7 1a 81 00 00 	movabs $0x811ac7,%rdx
  802578:	00 00 00 
  80257b:	be 2e 00 00 00       	mov    $0x2e,%esi
  802580:	48 bf dc 1a 81 00 00 	movabs $0x811adc,%rdi
  802587:	00 00 00 
  80258a:	b8 00 00 00 00       	mov    $0x0,%eax
  80258f:	49 b8 ce 11 81 00 00 	movabs $0x8111ce,%r8
  802596:	00 00 00 
  802599:	41 ff d0             	call   *%r8

000000000080259c <pipeisclosed>:
pipeisclosed(int fdnum) {
  80259c:	55                   	push   %rbp
  80259d:	48 89 e5             	mov    %rsp,%rbp
  8025a0:	48 83 ec 10          	sub    $0x10,%rsp
    int res = fd_lookup(fdnum, &fd);
  8025a4:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
  8025a8:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  8025af:	00 00 00 
  8025b2:	ff d0                	call   *%rax
    if (res < 0) return res;
  8025b4:	85 c0                	test   %eax,%eax
  8025b6:	78 35                	js     8025ed <pipeisclosed+0x51>
    struct Pipe *pip = (struct Pipe *)fd2data(fd);
  8025b8:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8025bc:	48 b8 d9 16 80 00 00 	movabs $0x8016d9,%rax
  8025c3:	00 00 00 
  8025c6:	ff d0                	call   *%rax
  8025c8:	48 89 c2             	mov    %rax,%rdx
    return !sys_region_refs2(fd, PAGE_SIZE, p, PAGE_SIZE);
  8025cb:	b9 00 10 00 00       	mov    $0x1000,%ecx
  8025d0:	be 00 10 00 00       	mov    $0x1000,%esi
  8025d5:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8025d9:	48 b8 36 13 80 00 00 	movabs $0x801336,%rax
  8025e0:	00 00 00 
  8025e3:	ff d0                	call   *%rax
  8025e5:	85 c0                	test   %eax,%eax
  8025e7:	0f 94 c0             	sete   %al
  8025ea:	0f b6 c0             	movzbl %al,%eax
}
  8025ed:	c9                   	leave  
  8025ee:	c3                   	ret    

00000000008025ef <get_uvpt_entry>:
extern volatile pdpe_t uvpdp[];   /* VA of current page directory pointer */
extern volatile pml4e_t uvpml4[]; /* VA of current page map level 4 */

pte_t
get_uvpt_entry(void *va) {
    if (!(uvpml4[VPML4(va)] & PTE_P)) return uvpml4[VPML4(va)];
  8025ef:	48 89 f8             	mov    %rdi,%rax
  8025f2:	48 c1 e8 27          	shr    $0x27,%rax
  8025f6:	48 ba 00 20 40 80 00 	movabs $0x10080402000,%rdx
  8025fd:	01 00 00 
  802600:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  802604:	f6 c2 01             	test   $0x1,%dl
  802607:	74 6d                	je     802676 <get_uvpt_entry+0x87>
    if (!(uvpdp[VPDP(va)] & PTE_P) || (uvpdp[VPDP(va)] & PTE_PS)) return uvpdp[VPDP(va)];
  802609:	48 89 f8             	mov    %rdi,%rax
  80260c:	48 c1 e8 1e          	shr    $0x1e,%rax
  802610:	48 ba 00 00 40 80 00 	movabs $0x10080400000,%rdx
  802617:	01 00 00 
  80261a:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  80261e:	f6 c2 01             	test   $0x1,%dl
  802621:	74 62                	je     802685 <get_uvpt_entry+0x96>
  802623:	48 ba 00 00 40 80 00 	movabs $0x10080400000,%rdx
  80262a:	01 00 00 
  80262d:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  802631:	f6 c2 80             	test   $0x80,%dl
  802634:	75 4f                	jne    802685 <get_uvpt_entry+0x96>
    if (!(uvpd[VPD(va)] & PTE_P) || (uvpd[VPD(va)] & PTE_PS)) return uvpd[VPD(va)];
  802636:	48 89 f8             	mov    %rdi,%rax
  802639:	48 c1 e8 15          	shr    $0x15,%rax
  80263d:	48 ba 00 00 00 80 00 	movabs $0x10080000000,%rdx
  802644:	01 00 00 
  802647:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  80264b:	f6 c2 01             	test   $0x1,%dl
  80264e:	74 44                	je     802694 <get_uvpt_entry+0xa5>
  802650:	48 ba 00 00 00 80 00 	movabs $0x10080000000,%rdx
  802657:	01 00 00 
  80265a:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  80265e:	f6 c2 80             	test   $0x80,%dl
  802661:	75 31                	jne    802694 <get_uvpt_entry+0xa5>
    return uvpt[VPT(va)];
  802663:	48 c1 ef 0c          	shr    $0xc,%rdi
  802667:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80266e:	01 00 00 
  802671:	48 8b 04 f8          	mov    (%rax,%rdi,8),%rax
}
  802675:	c3                   	ret    
    if (!(uvpml4[VPML4(va)] & PTE_P)) return uvpml4[VPML4(va)];
  802676:	48 ba 00 20 40 80 00 	movabs $0x10080402000,%rdx
  80267d:	01 00 00 
  802680:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  802684:	c3                   	ret    
    if (!(uvpdp[VPDP(va)] & PTE_P) || (uvpdp[VPDP(va)] & PTE_PS)) return uvpdp[VPDP(va)];
  802685:	48 ba 00 00 40 80 00 	movabs $0x10080400000,%rdx
  80268c:	01 00 00 
  80268f:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  802693:	c3                   	ret    
    if (!(uvpd[VPD(va)] & PTE_P) || (uvpd[VPD(va)] & PTE_PS)) return uvpd[VPD(va)];
  802694:	48 ba 00 00 00 80 00 	movabs $0x10080000000,%rdx
  80269b:	01 00 00 
  80269e:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  8026a2:	c3                   	ret    

00000000008026a3 <get_prot>:

int
get_prot(void *va) {
  8026a3:	55                   	push   %rbp
  8026a4:	48 89 e5             	mov    %rsp,%rbp
    pte_t pte = get_uvpt_entry(va);
  8026a7:	48 b8 ef 25 80 00 00 	movabs $0x8025ef,%rax
  8026ae:	00 00 00 
  8026b1:	ff d0                	call   *%rax
  8026b3:	48 89 c2             	mov    %rax,%rdx
    int prot = pte & PTE_AVAIL & ~PTE_SHARE;
  8026b6:	25 00 0a 00 00       	and    $0xa00,%eax
    if (pte & PTE_P) prot |= PROT_R;
  8026bb:	89 c1                	mov    %eax,%ecx
  8026bd:	83 c9 04             	or     $0x4,%ecx
  8026c0:	f6 c2 01             	test   $0x1,%dl
  8026c3:	0f 45 c1             	cmovne %ecx,%eax
    if (pte & PTE_W) prot |= PROT_W;
  8026c6:	89 c1                	mov    %eax,%ecx
  8026c8:	83 c9 02             	or     $0x2,%ecx
  8026cb:	f6 c2 02             	test   $0x2,%dl
  8026ce:	0f 45 c1             	cmovne %ecx,%eax
    if (!(pte & PTE_NX)) prot |= PROT_X;
  8026d1:	89 c1                	mov    %eax,%ecx
  8026d3:	83 c9 01             	or     $0x1,%ecx
  8026d6:	48 85 d2             	test   %rdx,%rdx
  8026d9:	0f 49 c1             	cmovns %ecx,%eax
    if (pte & PTE_SHARE) prot |= PROT_SHARE;
  8026dc:	89 c1                	mov    %eax,%ecx
  8026de:	83 c9 40             	or     $0x40,%ecx
  8026e1:	f6 c6 04             	test   $0x4,%dh
  8026e4:	0f 45 c1             	cmovne %ecx,%eax
    return prot;
}
  8026e7:	5d                   	pop    %rbp
  8026e8:	c3                   	ret    

00000000008026e9 <is_page_dirty>:

bool
is_page_dirty(void *va) {
  8026e9:	55                   	push   %rbp
  8026ea:	48 89 e5             	mov    %rsp,%rbp
    pte_t pte = get_uvpt_entry(va);
  8026ed:	48 b8 ef 25 80 00 00 	movabs $0x8025ef,%rax
  8026f4:	00 00 00 
  8026f7:	ff d0                	call   *%rax
    return pte & PTE_D;
  8026f9:	48 c1 e8 06          	shr    $0x6,%rax
  8026fd:	83 e0 01             	and    $0x1,%eax
}
  802700:	5d                   	pop    %rbp
  802701:	c3                   	ret    

0000000000802702 <is_page_present>:

bool
is_page_present(void *va) {
  802702:	55                   	push   %rbp
  802703:	48 89 e5             	mov    %rsp,%rbp
    return get_uvpt_entry(va) & PTE_P;
  802706:	48 b8 ef 25 80 00 00 	movabs $0x8025ef,%rax
  80270d:	00 00 00 
  802710:	ff d0                	call   *%rax
  802712:	83 e0 01             	and    $0x1,%eax
}
  802715:	5d                   	pop    %rbp
  802716:	c3                   	ret    

0000000000802717 <foreach_shared_region>:

int
foreach_shared_region(int (*fun)(void *start, void *end, void *arg), void *arg) {
  802717:	55                   	push   %rbp
  802718:	48 89 e5             	mov    %rsp,%rbp
  80271b:	41 57                	push   %r15
  80271d:	41 56                	push   %r14
  80271f:	41 55                	push   %r13
  802721:	41 54                	push   %r12
  802723:	53                   	push   %rbx
  802724:	48 83 ec 28          	sub    $0x28,%rsp
  802728:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  80272c:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    /* Calls fun() for every shared region */
    // LAB 11: Your code here
    int res;

    for (uintptr_t i = 0; i < MAX_USER_ADDRESS; ) {
  802730:	bb 00 00 00 00       	mov    $0x0,%ebx
        
        if (!(uvpml4[VPML4(i)] & PTE_P) || !(uvpdp[VPDP(i)] & PTE_P) || !(uvpd[VPD(i)] & PTE_P)) {
  802735:	49 bc 00 20 40 80 00 	movabs $0x10080402000,%r12
  80273c:	01 00 00 
  80273f:	49 bd 00 00 40 80 00 	movabs $0x10080400000,%r13
  802746:	01 00 00 
  802749:	49 be 00 00 00 80 00 	movabs $0x10080000000,%r14
  802750:	01 00 00 
           i += HUGE_PAGE_SIZE;  
           continue;
        } 
        void *start = (void*)i;
        if (get_prot(start) & PROT_SHARE && is_page_present(start))  {
  802753:	49 bf a3 26 80 00 00 	movabs $0x8026a3,%r15
  80275a:	00 00 00 
  80275d:	eb 16                	jmp    802775 <foreach_shared_region+0x5e>
           i += HUGE_PAGE_SIZE;  
  80275f:	48 81 c3 00 00 20 00 	add    $0x200000,%rbx
    for (uintptr_t i = 0; i < MAX_USER_ADDRESS; ) {
  802766:	48 b8 ff ff ff ff 7f 	movabs $0x7fffffffff,%rax
  80276d:	00 00 00 
  802770:	48 39 c3             	cmp    %rax,%rbx
  802773:	77 73                	ja     8027e8 <foreach_shared_region+0xd1>
        if (!(uvpml4[VPML4(i)] & PTE_P) || !(uvpdp[VPDP(i)] & PTE_P) || !(uvpd[VPD(i)] & PTE_P)) {
  802775:	48 89 d8             	mov    %rbx,%rax
  802778:	48 c1 e8 27          	shr    $0x27,%rax
  80277c:	49 8b 04 c4          	mov    (%r12,%rax,8),%rax
  802780:	a8 01                	test   $0x1,%al
  802782:	74 db                	je     80275f <foreach_shared_region+0x48>
  802784:	48 89 d8             	mov    %rbx,%rax
  802787:	48 c1 e8 1e          	shr    $0x1e,%rax
  80278b:	49 8b 44 c5 00       	mov    0x0(%r13,%rax,8),%rax
  802790:	a8 01                	test   $0x1,%al
  802792:	74 cb                	je     80275f <foreach_shared_region+0x48>
  802794:	48 89 d8             	mov    %rbx,%rax
  802797:	48 c1 e8 15          	shr    $0x15,%rax
  80279b:	49 8b 04 c6          	mov    (%r14,%rax,8),%rax
  80279f:	a8 01                	test   $0x1,%al
  8027a1:	74 bc                	je     80275f <foreach_shared_region+0x48>
        void *start = (void*)i;
  8027a3:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
        if (get_prot(start) & PROT_SHARE && is_page_present(start))  {
  8027a7:	48 89 df             	mov    %rbx,%rdi
  8027aa:	41 ff d7             	call   *%r15
  8027ad:	a8 40                	test   $0x40,%al
  8027af:	75 09                	jne    8027ba <foreach_shared_region+0xa3>
            void *end = (void*)(i + PAGE_SIZE);
            if ((res = fun(start, end, arg)) < 0)
                return res;
        }
        i += PAGE_SIZE;
  8027b1:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
  8027b8:	eb ac                	jmp    802766 <foreach_shared_region+0x4f>
        if (get_prot(start) & PROT_SHARE && is_page_present(start))  {
  8027ba:	48 89 df             	mov    %rbx,%rdi
  8027bd:	48 b8 02 27 80 00 00 	movabs $0x802702,%rax
  8027c4:	00 00 00 
  8027c7:	ff d0                	call   *%rax
  8027c9:	84 c0                	test   %al,%al
  8027cb:	74 e4                	je     8027b1 <foreach_shared_region+0x9a>
            void *end = (void*)(i + PAGE_SIZE);
  8027cd:	48 8d b3 00 10 00 00 	lea    0x1000(%rbx),%rsi
            if ((res = fun(start, end, arg)) < 0)
  8027d4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8027d8:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8027dc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8027e0:	ff d0                	call   *%rax
  8027e2:	85 c0                	test   %eax,%eax
  8027e4:	79 cb                	jns    8027b1 <foreach_shared_region+0x9a>
  8027e6:	eb 05                	jmp    8027ed <foreach_shared_region+0xd6>
    }
    return 0;
  8027e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8027ed:	48 83 c4 28          	add    $0x28,%rsp
  8027f1:	5b                   	pop    %rbx
  8027f2:	41 5c                	pop    %r12
  8027f4:	41 5d                	pop    %r13
  8027f6:	41 5e                	pop    %r14
  8027f8:	41 5f                	pop    %r15
  8027fa:	5d                   	pop    %rbp
  8027fb:	c3                   	ret    

00000000008027fc <FramebufferInit>:
#include <inc/lib.h>


//returns 0 on success

int FramebufferInit(FRAMEBUFFER_CONTEXT *context) {
  8027fc:	55                   	push   %rbp
  8027fd:	48 89 e5             	mov    %rsp,%rbp
  802800:	53                   	push   %rbx
  802801:	48 83 ec 08          	sub    $0x8,%rsp
  802805:	48 89 fb             	mov    %rdi,%rbx
   context->width = vsys_getframebuffer_width();
  802808:	48 b8 b5 28 80 00 00 	movabs $0x8028b5,%rax
  80280f:	00 00 00 
  802812:	ff d0                	call   *%rax
  802814:	89 03                	mov    %eax,(%rbx)
   context->height = vsys_getframebuffer_height();
  802816:	48 b8 bf 28 80 00 00 	movabs $0x8028bf,%rax
  80281d:	00 00 00 
  802820:	ff d0                	call   *%rax
  802822:	89 43 04             	mov    %eax,0x4(%rbx)
   context->bits_per_pixel = vsys_getframebuffer_bpp();
  802825:	48 b8 c9 28 80 00 00 	movabs $0x8028c9,%rax
  80282c:	00 00 00 
  80282f:	ff d0                	call   *%rax
  802831:	89 43 0c             	mov    %eax,0xc(%rbx)
   context->size = context->width * context->height * (context->bits_per_pixel / 8);
  802834:	8b 13                	mov    (%rbx),%edx
  802836:	0f af 53 04          	imul   0x4(%rbx),%edx
  80283a:	c1 e8 03             	shr    $0x3,%eax
  80283d:	0f af d0             	imul   %eax,%edx
  802840:	89 53 10             	mov    %edx,0x10(%rbx)
   //graphics convention
   context->front = UTEMP - context->size;
  802843:	89 d2                	mov    %edx,%edx
  802845:	b8 00 00 40 00       	mov    $0x400000,%eax
  80284a:	48 29 d0             	sub    %rdx,%rax
  80284d:	48 89 43 18          	mov    %rax,0x18(%rbx)
   int res = sys_alloc_region(thisenv->env_id, UTEMP, context->size, PROT_R | PROT_W);
  802851:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  802858:	00 00 00 
  80285b:	8b b8 c8 00 00 00    	mov    0xc8(%rax),%edi
  802861:	b9 06 00 00 00       	mov    $0x6,%ecx
  802866:	be 00 00 40 00       	mov    $0x400000,%esi
  80286b:	48 b8 62 13 80 00 00 	movabs $0x801362,%rax
  802872:	00 00 00 
  802875:	ff d0                	call   *%rax
   if (res < 0)
  802877:	85 c0                	test   %eax,%eax
  802879:	78 0d                	js     802888 <FramebufferInit+0x8c>
       return res;
   context->back = UTEMP;
  80287b:	48 c7 43 20 00 00 40 	movq   $0x400000,0x20(%rbx)
  802882:	00 
   return 0;
  802883:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802888:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80288c:	c9                   	leave  
  80288d:	c3                   	ret    

000000000080288e <FramebufferFlip>:


void FramebufferFlip(FRAMEBUFFER_CONTEXT *context) {
  80288e:	55                   	push   %rbp
  80288f:	48 89 e5             	mov    %rsp,%rbp
    memcpy(context->front, context->back, context->size);
  802892:	8b 57 10             	mov    0x10(%rdi),%edx
  802895:	48 8b 77 20          	mov    0x20(%rdi),%rsi
  802899:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  80289d:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  8028a4:	00 00 00 
  8028a7:	ff d0                	call   *%rax
}
  8028a9:	5d                   	pop    %rbp
  8028aa:	c3                   	ret    

00000000008028ab <vsys_gettime>:
#include <inc/lib.h>

static inline uint64_t
vsyscall(int num) {
    // LAB 12: Your code here
    return vsys[num];
  8028ab:	a1 00 f0 bf 1f 80 00 	movabs 0x801fbff000,%eax
  8028b2:	00 00 
}

int
vsys_gettime(void) {
    return vsyscall(VSYS_gettime);
}
  8028b4:	c3                   	ret    

00000000008028b5 <vsys_getframebuffer_width>:
    return vsys[num];
  8028b5:	a1 04 f0 bf 1f 80 00 	movabs 0x801fbff004,%eax
  8028bc:	00 00 

uint32_t vsys_getframebuffer_width(void) {
    return vsyscall(VSYS_getframebuffer_width);
}
  8028be:	c3                   	ret    

00000000008028bf <vsys_getframebuffer_height>:
    return vsys[num];
  8028bf:	a1 08 f0 bf 1f 80 00 	movabs 0x801fbff008,%eax
  8028c6:	00 00 
uint32_t vsys_getframebuffer_height(void) {
    return vsyscall(VSYS_getframebuffer_height);

}
  8028c8:	c3                   	ret    

00000000008028c9 <vsys_getframebuffer_bpp>:
    return vsys[num];
  8028c9:	a1 0c f0 bf 1f 80 00 	movabs 0x801fbff00c,%eax
  8028d0:	00 00 
uint32_t vsys_getframebuffer_bpp(void) {
    return vsyscall(VSYS_getframebuffer_bpp);
}
  8028d2:	c3                   	ret    

00000000008028d3 <lodepng_strlen>:
/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
  const char* orig = a;
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
  8028d3:	80 3f 00             	cmpb   $0x0,(%rdi)
  8028d6:	74 10                	je     8028e8 <lodepng_strlen+0x15>
  8028d8:	48 89 f8             	mov    %rdi,%rax
  8028db:	48 83 c0 01          	add    $0x1,%rax
  8028df:	80 38 00             	cmpb   $0x0,(%rax)
  8028e2:	75 f7                	jne    8028db <lodepng_strlen+0x8>
  return (size_t)(a - orig);
  8028e4:	48 29 f8             	sub    %rdi,%rax
}
  8028e7:	c3                   	ret    
  while(*a) a++;
  8028e8:	48 89 f8             	mov    %rdi,%rax
  8028eb:	eb f7                	jmp    8028e4 <lodepng_strlen+0x11>

00000000008028ed <lodepng_read32bitInt>:

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
  8028ed:	0f b6 07             	movzbl (%rdi),%eax
  8028f0:	c1 e0 18             	shl    $0x18,%eax
  8028f3:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
  8028f7:	c1 e2 10             	shl    $0x10,%edx
  8028fa:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
  8028fc:	0f b6 57 03          	movzbl 0x3(%rdi),%edx
  802900:	09 d0                	or     %edx,%eax
  802902:	0f b6 57 02          	movzbl 0x2(%rdi),%edx
  802906:	c1 e2 08             	shl    $0x8,%edx
  802909:	09 d0                	or     %edx,%eax
}
  80290b:	c3                   	ret    

000000000080290c <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
  80290c:	89 f0                	mov    %esi,%eax
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
  80290e:	89 f2                	mov    %esi,%edx
  802910:	c1 ea 18             	shr    $0x18,%edx
  802913:	88 17                	mov    %dl,(%rdi)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
  802915:	89 f2                	mov    %esi,%edx
  802917:	c1 ea 10             	shr    $0x10,%edx
  80291a:	88 57 01             	mov    %dl,0x1(%rdi)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
  80291d:	0f b6 cc             	movzbl %ah,%ecx
  802920:	88 4f 02             	mov    %cl,0x2(%rdi)
  buffer[3] = (unsigned char)((value      ) & 0xff);
  802923:	40 88 77 03          	mov    %sil,0x3(%rdi)
}
  802927:	c3                   	ret    

0000000000802928 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
  802928:	48 89 f0             	mov    %rsi,%rax
  size_t start = reader->bp >> 3u;
  80292b:	48 8b 77 18          	mov    0x18(%rdi),%rsi
  80292f:	48 89 f2             	mov    %rsi,%rdx
  802932:	48 c1 ea 03          	shr    $0x3,%rdx
  size_t size = reader->size;
  802936:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
  if(start + 1u < size) {
  80293a:	4c 8d 42 01          	lea    0x1(%rdx),%r8
  80293e:	49 39 c8             	cmp    %rcx,%r8
  802941:	73 21                	jae    802964 <ensureBits9+0x3c>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
  802943:	48 8b 0f             	mov    (%rdi),%rcx
  802946:	0f b6 44 11 01       	movzbl 0x1(%rcx,%rdx,1),%eax
  80294b:	c1 e0 08             	shl    $0x8,%eax
  80294e:	0f b6 14 11          	movzbl (%rcx,%rdx,1),%edx
  802952:	09 d0                	or     %edx,%eax
    reader->buffer >>= (reader->bp & 7u);
  802954:	89 f1                	mov    %esi,%ecx
  802956:	83 e1 07             	and    $0x7,%ecx
  802959:	d3 e8                	shr    %cl,%eax
  80295b:	89 47 20             	mov    %eax,0x20(%rdi)
    return 1;
  80295e:	b8 01 00 00 00       	mov    $0x1,%eax
  802963:	c3                   	ret    
  } else {
    reader->buffer = 0;
  802964:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%rdi)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
  80296b:	48 39 ca             	cmp    %rcx,%rdx
  80296e:	73 0a                	jae    80297a <ensureBits9+0x52>
  802970:	48 8b 0f             	mov    (%rdi),%rcx
  802973:	0f b6 14 11          	movzbl (%rcx,%rdx,1),%edx
  802977:	89 57 20             	mov    %edx,0x20(%rdi)
    reader->buffer >>= (reader->bp & 7u);
  80297a:	89 f1                	mov    %esi,%ecx
  80297c:	83 e1 07             	and    $0x7,%ecx
  80297f:	d3 6f 20             	shrl   %cl,0x20(%rdi)
    return reader->bp + nbits <= reader->bitsize;
  802982:	48 01 c6             	add    %rax,%rsi
  802985:	48 3b 77 10          	cmp    0x10(%rdi),%rsi
  802989:	0f 96 c0             	setbe  %al
  80298c:	0f b6 c0             	movzbl %al,%eax
  }
}
  80298f:	c3                   	ret    

0000000000802990 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  802990:	48 89 f2             	mov    %rsi,%rdx
  size_t start = reader->bp >> 3u;
  802993:	48 8b 77 18          	mov    0x18(%rdi),%rsi
  802997:	48 89 f0             	mov    %rsi,%rax
  80299a:	48 c1 e8 03          	shr    $0x3,%rax
  size_t size = reader->size;
  80299e:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
  if(start + 2u < size) {
  8029a2:	4c 8d 40 02          	lea    0x2(%rax),%r8
  8029a6:	49 39 c8             	cmp    %rcx,%r8
  8029a9:	73 2e                	jae    8029d9 <ensureBits17+0x49>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  8029ab:	48 8b 0f             	mov    (%rdi),%rcx
  8029ae:	0f b6 54 01 01       	movzbl 0x1(%rcx,%rax,1),%edx
  8029b3:	c1 e2 08             	shl    $0x8,%edx
                     ((unsigned)reader->data[start + 2] << 16u);
  8029b6:	44 0f b6 44 01 02    	movzbl 0x2(%rcx,%rax,1),%r8d
  8029bc:	41 c1 e0 10          	shl    $0x10,%r8d
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  8029c0:	44 09 c2             	or     %r8d,%edx
  8029c3:	0f b6 04 01          	movzbl (%rcx,%rax,1),%eax
  8029c7:	09 d0                	or     %edx,%eax
    reader->buffer >>= (reader->bp & 7u);
  8029c9:	89 f1                	mov    %esi,%ecx
  8029cb:	83 e1 07             	and    $0x7,%ecx
  8029ce:	d3 e8                	shr    %cl,%eax
  8029d0:	89 47 20             	mov    %eax,0x20(%rdi)
    return 1;
  8029d3:	b8 01 00 00 00       	mov    $0x1,%eax
  8029d8:	c3                   	ret    
  } else {
    reader->buffer = 0;
  8029d9:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%rdi)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
  8029e0:	48 39 c8             	cmp    %rcx,%rax
  8029e3:	73 0c                	jae    8029f1 <ensureBits17+0x61>
  8029e5:	4c 8b 07             	mov    (%rdi),%r8
  8029e8:	45 0f b6 04 00       	movzbl (%r8,%rax,1),%r8d
  8029ed:	44 89 47 20          	mov    %r8d,0x20(%rdi)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
  8029f1:	4c 8d 40 01          	lea    0x1(%rax),%r8
  8029f5:	49 39 c8             	cmp    %rcx,%r8
  8029f8:	73 0e                	jae    802a08 <ensureBits17+0x78>
  8029fa:	48 8b 0f             	mov    (%rdi),%rcx
  8029fd:	0f b6 44 01 01       	movzbl 0x1(%rcx,%rax,1),%eax
  802a02:	c1 e0 08             	shl    $0x8,%eax
  802a05:	09 47 20             	or     %eax,0x20(%rdi)
    reader->buffer >>= (reader->bp & 7u);
  802a08:	89 f1                	mov    %esi,%ecx
  802a0a:	83 e1 07             	and    $0x7,%ecx
  802a0d:	d3 6f 20             	shrl   %cl,0x20(%rdi)
    return reader->bp + nbits <= reader->bitsize;
  802a10:	48 01 d6             	add    %rdx,%rsi
  802a13:	48 3b 77 10          	cmp    0x10(%rdi),%rsi
  802a17:	0f 96 c0             	setbe  %al
  802a1a:	0f b6 c0             	movzbl %al,%eax
  }
}
  802a1d:	c3                   	ret    

0000000000802a1e <readBits>:
  reader->buffer >>= nbits;
  reader->bp += nbits;
}

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
  802a1e:	48 89 f1             	mov    %rsi,%rcx
  return reader->buffer & ((1u << nbits) - 1u);
  802a21:	8b 57 20             	mov    0x20(%rdi),%edx
  reader->buffer >>= nbits;
  802a24:	89 d0                	mov    %edx,%eax
  802a26:	d3 e8                	shr    %cl,%eax
  802a28:	89 47 20             	mov    %eax,0x20(%rdi)
  reader->bp += nbits;
  802a2b:	48 01 77 18          	add    %rsi,0x18(%rdi)
  return reader->buffer & ((1u << nbits) - 1u);
  802a2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802a34:	d3 e0                	shl    %cl,%eax
  802a36:	f7 d0                	not    %eax
  802a38:	21 d0                	and    %edx,%eax
  unsigned result = peekBits(reader, nbits);
  advanceBits(reader, nbits);
  return result;
}
  802a3a:	c3                   	ret    

0000000000802a3b <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
  802a3b:	41 89 d0             	mov    %edx,%r8d
  802a3e:	49 89 c9             	mov    %rcx,%r9
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
  802a41:	8b 47 10             	mov    0x10(%rdi),%eax
  802a44:	39 47 14             	cmp    %eax,0x14(%rdi)
  802a47:	0f 82 c1 00 00 00    	jb     802b0e <bpmnode_create+0xd3>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
  802a4d:	83 3f 00             	cmpl   $0x0,(%rdi)
  802a50:	74 21                	je     802a73 <bpmnode_create+0x38>
  802a52:	ba 00 00 00 00       	mov    $0x0,%edx
  802a57:	89 d0                	mov    %edx,%eax
  802a59:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  802a5d:	48 c1 e0 03          	shl    $0x3,%rax
  802a61:	48 03 47 08          	add    0x8(%rdi),%rax
  802a65:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  802a6c:	83 c2 01             	add    $0x1,%edx
  802a6f:	39 17                	cmp    %edx,(%rdi)
  802a71:	75 e4                	jne    802a57 <bpmnode_create+0x1c>
    for(i = 0; i != lists->listsize; ++i) {
  802a73:	83 7f 20 00          	cmpl   $0x0,0x20(%rdi)
  802a77:	74 49                	je     802ac2 <bpmnode_create+0x87>
  802a79:	ba 00 00 00 00       	mov    $0x0,%edx
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
  802a7e:	89 d1                	mov    %edx,%ecx
  802a80:	48 8b 47 28          	mov    0x28(%rdi),%rax
  802a84:	48 8b 04 c8          	mov    (%rax,%rcx,8),%rax
  802a88:	48 85 c0             	test   %rax,%rax
  802a8b:	74 10                	je     802a9d <bpmnode_create+0x62>
  802a8d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%rax)
  802a94:	48 8b 40 08          	mov    0x8(%rax),%rax
  802a98:	48 85 c0             	test   %rax,%rax
  802a9b:	75 f0                	jne    802a8d <bpmnode_create+0x52>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
  802a9d:	48 8b 47 30          	mov    0x30(%rdi),%rax
  802aa1:	48 8b 04 c8          	mov    (%rax,%rcx,8),%rax
  802aa5:	48 85 c0             	test   %rax,%rax
  802aa8:	74 10                	je     802aba <bpmnode_create+0x7f>
  802aaa:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%rax)
  802ab1:	48 8b 40 08          	mov    0x8(%rax),%rax
  802ab5:	48 85 c0             	test   %rax,%rax
  802ab8:	75 f0                	jne    802aaa <bpmnode_create+0x6f>
    for(i = 0; i != lists->listsize; ++i) {
  802aba:	83 c2 01             	add    $0x1,%edx
  802abd:	39 57 20             	cmp    %edx,0x20(%rdi)
  802ac0:	75 bc                	jne    802a7e <bpmnode_create+0x43>
    }
    /*collect those that are free*/
    lists->numfree = 0;
  802ac2:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%rdi)
    for(i = 0; i != lists->memsize; ++i) {
  802ac9:	83 3f 00             	cmpl   $0x0,(%rdi)
  802acc:	74 39                	je     802b07 <bpmnode_create+0xcc>
  802ace:	b8 00 00 00 00       	mov    $0x0,%eax
  802ad3:	eb 07                	jmp    802adc <bpmnode_create+0xa1>
  802ad5:	83 c0 01             	add    $0x1,%eax
  802ad8:	39 07                	cmp    %eax,(%rdi)
  802ada:	74 2b                	je     802b07 <bpmnode_create+0xcc>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
  802adc:	89 c2                	mov    %eax,%edx
  802ade:	48 8d 0c 52          	lea    (%rdx,%rdx,2),%rcx
  802ae2:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  802ae6:	48 8d 0c ca          	lea    (%rdx,%rcx,8),%rcx
  802aea:	83 79 10 00          	cmpl   $0x0,0x10(%rcx)
  802aee:	75 e5                	jne    802ad5 <bpmnode_create+0x9a>
  802af0:	4c 8b 57 18          	mov    0x18(%rdi),%r10
  802af4:	8b 57 10             	mov    0x10(%rdi),%edx
  802af7:	44 8d 5a 01          	lea    0x1(%rdx),%r11d
  802afb:	44 89 5f 10          	mov    %r11d,0x10(%rdi)
  802aff:	89 d2                	mov    %edx,%edx
  802b01:	49 89 0c d2          	mov    %rcx,(%r10,%rdx,8)
  802b05:	eb ce                	jmp    802ad5 <bpmnode_create+0x9a>
    }
    lists->nextfree = 0;
  802b07:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%rdi)
  }

  result = lists->freelist[lists->nextfree++];
  802b0e:	48 8b 57 18          	mov    0x18(%rdi),%rdx
  802b12:	8b 47 14             	mov    0x14(%rdi),%eax
  802b15:	8d 48 01             	lea    0x1(%rax),%ecx
  802b18:	89 4f 14             	mov    %ecx,0x14(%rdi)
  802b1b:	89 c0                	mov    %eax,%eax
  802b1d:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  result->weight = weight;
  802b21:	89 30                	mov    %esi,(%rax)
  result->index = index;
  802b23:	44 89 40 04          	mov    %r8d,0x4(%rax)
  result->tail = tail;
  802b27:	4c 89 48 08          	mov    %r9,0x8(%rax)
  return result;
}
  802b2b:	c3                   	ret    

0000000000802b2c <boundaryPM>:
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
  lodepng_free(mem);
}

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  802b2c:	55                   	push   %rbp
  802b2d:	48 89 e5             	mov    %rsp,%rbp
  802b30:	41 57                	push   %r15
  802b32:	41 56                	push   %r14
  802b34:	41 55                	push   %r13
  802b36:	41 54                	push   %r12
  802b38:	53                   	push   %rbx
  802b39:	48 83 ec 18          	sub    $0x18,%rsp
  802b3d:	48 89 fb             	mov    %rdi,%rbx
  802b40:	49 89 f6             	mov    %rsi,%r14
  802b43:	49 89 d5             	mov    %rdx,%r13
  802b46:	41 89 cc             	mov    %ecx,%r12d
  802b49:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
  unsigned lastindex = lists->chains1[c]->index;
  802b4d:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
  802b51:	48 63 d1             	movslq %ecx,%rdx
  802b54:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  802b5b:	00 
  802b5c:	48 8b 0c d7          	mov    (%rdi,%rdx,8),%rcx
  802b60:	8b 71 04             	mov    0x4(%rcx),%esi

  if(c == 0) {
  802b63:	45 85 e4             	test   %r12d,%r12d
  802b66:	75 3f                	jne    802ba7 <boundaryPM+0x7b>
    if(lastindex >= numpresent) return;
  802b68:	89 f7                	mov    %esi,%edi
  802b6a:	4c 39 ef             	cmp    %r13,%rdi
  802b6d:	0f 83 91 00 00 00    	jae    802c04 <boundaryPM+0xd8>
    lists->chains0[c] = lists->chains1[c];
  802b73:	4c 8b 43 28          	mov    0x28(%rbx),%r8
  802b77:	49 89 0c d0          	mov    %rcx,(%r8,%rdx,8)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
  802b7b:	48 03 43 30          	add    0x30(%rbx),%rax
  802b7f:	49 89 c4             	mov    %rax,%r12
  802b82:	8d 56 01             	lea    0x1(%rsi),%edx
  802b85:	48 8d 04 7f          	lea    (%rdi,%rdi,2),%rax
  802b89:	b9 00 00 00 00       	mov    $0x0,%ecx
  802b8e:	41 8b 34 c6          	mov    (%r14,%rax,8),%esi
  802b92:	48 89 df             	mov    %rbx,%rdi
  802b95:	48 b8 3b 2a 80 00 00 	movabs $0x802a3b,%rax
  802b9c:	00 00 00 
  802b9f:	ff d0                	call   *%rax
  802ba1:	49 89 04 24          	mov    %rax,(%r12)
  802ba5:	eb 5d                	jmp    802c04 <boundaryPM+0xd8>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
  802ba7:	4c 8b 43 28          	mov    0x28(%rbx),%r8
  802bab:	4d 8b 4c 00 f8       	mov    -0x8(%r8,%rax,1),%r9
  802bb0:	48 8b 7c 07 f8       	mov    -0x8(%rdi,%rax,1),%rdi
  802bb5:	8b 3f                	mov    (%rdi),%edi
  802bb7:	41 03 39             	add    (%r9),%edi
    lists->chains0[c] = lists->chains1[c];
  802bba:	49 89 0c d0          	mov    %rcx,(%r8,%rdx,8)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
  802bbe:	89 f2                	mov    %esi,%edx
  802bc0:	4c 39 ea             	cmp    %r13,%rdx
  802bc3:	73 0d                	jae    802bd2 <boundaryPM+0xa6>
  802bc5:	48 8d 14 52          	lea    (%rdx,%rdx,2),%rdx
  802bc9:	45 8b 04 d6          	mov    (%r14,%rdx,8),%r8d
  802bcd:	41 39 f8             	cmp    %edi,%r8d
  802bd0:	7c 41                	jl     802c13 <boundaryPM+0xe7>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
      return;
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
  802bd2:	48 8b 53 30          	mov    0x30(%rbx),%rdx
  802bd6:	4c 8d 3c 02          	lea    (%rdx,%rax,1),%r15
  802bda:	48 8b 4c 02 f8       	mov    -0x8(%rdx,%rax,1),%rcx
  802bdf:	89 f2                	mov    %esi,%edx
  802be1:	89 fe                	mov    %edi,%esi
  802be3:	48 89 df             	mov    %rbx,%rdi
  802be6:	48 b8 3b 2a 80 00 00 	movabs $0x802a3b,%rax
  802bed:	00 00 00 
  802bf0:	ff d0                	call   *%rax
  802bf2:	49 89 07             	mov    %rax,(%r15)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
  802bf5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  802bf8:	8d 50 01             	lea    0x1(%rax),%edx
  802bfb:	43 8d 44 2d fe       	lea    -0x2(%r13,%r13,1),%eax
  802c00:	39 c2                	cmp    %eax,%edx
  802c02:	7c 38                	jl     802c3c <boundaryPM+0x110>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
  802c04:	48 83 c4 18          	add    $0x18,%rsp
  802c08:	5b                   	pop    %rbx
  802c09:	41 5c                	pop    %r12
  802c0b:	41 5d                	pop    %r13
  802c0d:	41 5e                	pop    %r14
  802c0f:	41 5f                	pop    %r15
  802c11:	5d                   	pop    %rbp
  802c12:	c3                   	ret    
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
  802c13:	48 03 43 30          	add    0x30(%rbx),%rax
  802c17:	49 89 c4             	mov    %rax,%r12
  802c1a:	48 8b 00             	mov    (%rax),%rax
  802c1d:	48 8b 48 08          	mov    0x8(%rax),%rcx
  802c21:	8d 56 01             	lea    0x1(%rsi),%edx
  802c24:	44 89 c6             	mov    %r8d,%esi
  802c27:	48 89 df             	mov    %rbx,%rdi
  802c2a:	48 b8 3b 2a 80 00 00 	movabs $0x802a3b,%rax
  802c31:	00 00 00 
  802c34:	ff d0                	call   *%rax
  802c36:	49 89 04 24          	mov    %rax,(%r12)
      return;
  802c3a:	eb c8                	jmp    802c04 <boundaryPM+0xd8>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
  802c3c:	45 8d 7c 24 ff       	lea    -0x1(%r12),%r15d
  802c41:	44 8b 45 cc          	mov    -0x34(%rbp),%r8d
  802c45:	44 89 f9             	mov    %r15d,%ecx
  802c48:	4c 89 ea             	mov    %r13,%rdx
  802c4b:	4c 89 f6             	mov    %r14,%rsi
  802c4e:	48 89 df             	mov    %rbx,%rdi
  802c51:	49 bc 2c 2b 80 00 00 	movabs $0x802b2c,%r12
  802c58:	00 00 00 
  802c5b:	41 ff d4             	call   *%r12
      boundaryPM(lists, leaves, numpresent, c - 1, num);
  802c5e:	44 8b 45 cc          	mov    -0x34(%rbp),%r8d
  802c62:	44 89 f9             	mov    %r15d,%ecx
  802c65:	4c 89 ea             	mov    %r13,%rdx
  802c68:	4c 89 f6             	mov    %r14,%rsi
  802c6b:	48 89 df             	mov    %rbx,%rdi
  802c6e:	41 ff d4             	call   *%r12
  802c71:	eb 91                	jmp    802c04 <boundaryPM+0xd8>

0000000000802c73 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  802c73:	49 89 f8             	mov    %rdi,%r8
  802c76:	49 89 f1             	mov    %rsi,%r9
  802c79:	48 89 d7             	mov    %rdx,%rdi
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
  802c7c:	48 89 f1             	mov    %rsi,%rcx
  802c7f:	48 83 e9 01          	sub    $0x1,%rcx
  802c83:	74 3c                	je     802cc1 <searchCodeIndex+0x4e>
  size_t left = 1;
  802c85:	ba 01 00 00 00       	mov    $0x1,%edx
  802c8a:	eb 09                	jmp    802c95 <searchCodeIndex+0x22>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  802c8c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  while(left <= right) {
  802c90:	48 39 d1             	cmp    %rdx,%rcx
  802c93:	72 16                	jb     802cab <searchCodeIndex+0x38>
    size_t mid = (left + right) >> 1;
  802c95:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
  802c99:	48 d1 e8             	shr    %rax
    if(array[mid] >= value) right = mid - 1;
  802c9c:	41 8b 34 80          	mov    (%r8,%rax,4),%esi
  802ca0:	48 39 fe             	cmp    %rdi,%rsi
  802ca3:	72 e7                	jb     802c8c <searchCodeIndex+0x19>
  802ca5:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
  802ca9:	eb e5                	jmp    802c90 <searchCodeIndex+0x1d>
  }
  if(left >= array_size || array[left] > value) left--;
  802cab:	49 39 d1             	cmp    %rdx,%r9
  802cae:	76 09                	jbe    802cb9 <searchCodeIndex+0x46>
  802cb0:	41 8b 04 90          	mov    (%r8,%rdx,4),%eax
  802cb4:	48 39 f8             	cmp    %rdi,%rax
  802cb7:	76 04                	jbe    802cbd <searchCodeIndex+0x4a>
  802cb9:	48 83 ea 01          	sub    $0x1,%rdx
  return left;
}
  802cbd:	48 89 d0             	mov    %rdx,%rax
  802cc0:	c3                   	ret    
  size_t left = 1;
  802cc1:	ba 01 00 00 00       	mov    $0x1,%edx
  802cc6:	eb f1                	jmp    802cb9 <searchCodeIndex+0x46>

0000000000802cc8 <getHash>:
  lodepng_free(hash->chainz);
}



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
  802cc8:	49 89 f8             	mov    %rdi,%r8
  802ccb:	48 89 f7             	mov    %rsi,%rdi
  802cce:	48 89 d1             	mov    %rdx,%rcx
  unsigned result = 0;
  if(pos + 2 < size) {
  802cd1:	48 8d 42 02          	lea    0x2(%rdx),%rax
  802cd5:	48 39 f0             	cmp    %rsi,%rax
  802cd8:	73 1f                	jae    802cf9 <getHash+0x31>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    result ^= ((unsigned)data[pos + 1] << 4u);
  802cda:	41 0f b6 54 10 01    	movzbl 0x1(%r8,%rdx,1),%edx
  802ce0:	c1 e2 04             	shl    $0x4,%edx
    result ^= ((unsigned)data[pos + 2] << 8u);
  802ce3:	41 0f b6 44 08 02    	movzbl 0x2(%r8,%rcx,1),%eax
  802ce9:	c1 e0 08             	shl    $0x8,%eax
  802cec:	31 c2                	xor    %eax,%edx
    result ^= ((unsigned)data[pos + 0] << 0u);
  802cee:	41 0f b6 04 08       	movzbl (%r8,%rcx,1),%eax
    result ^= ((unsigned)data[pos + 2] << 8u);
  802cf3:	31 c2                	xor    %eax,%edx
    size_t amount, i;
    if(pos >= size) return 0;
    amount = size - pos;
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
  }
  return result & HASH_BIT_MASK;
  802cf5:	0f b7 c2             	movzwl %dx,%eax
}
  802cf8:	c3                   	ret    
    if(pos >= size) return 0;
  802cf9:	b8 00 00 00 00       	mov    $0x0,%eax
  802cfe:	48 39 f2             	cmp    %rsi,%rdx
  802d01:	73 f5                	jae    802cf8 <getHash+0x30>
    amount = size - pos;
  802d03:	48 29 d7             	sub    %rdx,%rdi
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
  802d06:	b8 00 00 00 00       	mov    $0x0,%eax
  unsigned result = 0;
  802d0b:	ba 00 00 00 00       	mov    $0x0,%edx
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
  802d10:	49 01 c8             	add    %rcx,%r8
  802d13:	41 0f b6 34 00       	movzbl (%r8,%rax,1),%esi
  802d18:	8d 0c c5 00 00 00 00 	lea    0x0(,%rax,8),%ecx
  802d1f:	d3 e6                	shl    %cl,%esi
  802d21:	31 f2                	xor    %esi,%edx
  802d23:	48 83 c0 01          	add    $0x1,%rax
  802d27:	48 39 c7             	cmp    %rax,%rdi
  802d2a:	75 e7                	jne    802d13 <getHash+0x4b>
  802d2c:	eb c7                	jmp    802cf5 <getHash+0x2d>

0000000000802d2e <updateHashChain>:
  return (unsigned)(data - start);
}

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
  hash->val[wpos] = (int)hashval;
  802d2e:	48 8b 47 10          	mov    0x10(%rdi),%rax
  802d32:	89 14 b0             	mov    %edx,(%rax,%rsi,4)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
  802d35:	89 d2                	mov    %edx,%edx
  802d37:	48 8b 07             	mov    (%rdi),%rax
  802d3a:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  802d3d:	83 f8 ff             	cmp    $0xffffffff,%eax
  802d40:	74 09                	je     802d4b <updateHashChain+0x1d>
  802d42:	4c 8b 47 08          	mov    0x8(%rdi),%r8
  802d46:	66 41 89 04 70       	mov    %ax,(%r8,%rsi,2)
  hash->head[hashval] = (int)wpos;
  802d4b:	48 8b 07             	mov    (%rdi),%rax
  802d4e:	89 34 90             	mov    %esi,(%rax,%rdx,4)

  hash->zeros[wpos] = numzeros;
  802d51:	48 8b 47 28          	mov    0x28(%rdi),%rax
  802d55:	66 89 0c 70          	mov    %cx,(%rax,%rsi,2)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
  802d59:	0f b7 c9             	movzwl %cx,%ecx
  802d5c:	48 8b 47 18          	mov    0x18(%rdi),%rax
  802d60:	8b 04 88             	mov    (%rax,%rcx,4),%eax
  802d63:	83 f8 ff             	cmp    $0xffffffff,%eax
  802d66:	74 08                	je     802d70 <updateHashChain+0x42>
  802d68:	48 8b 57 20          	mov    0x20(%rdi),%rdx
  802d6c:	66 89 04 72          	mov    %ax,(%rdx,%rsi,2)
  hash->headz[numzeros] = (int)wpos;
  802d70:	48 8b 47 18          	mov    0x18(%rdi),%rax
  802d74:	89 34 88             	mov    %esi,(%rax,%rcx,4)
}
  802d77:	c3                   	ret    

0000000000802d78 <readBitFromReversedStream>:

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
  802d78:	48 8b 17             	mov    (%rdi),%rdx
  802d7b:	48 89 d0             	mov    %rdx,%rax
  802d7e:	48 c1 e8 03          	shr    $0x3,%rax
  802d82:	0f b6 04 06          	movzbl (%rsi,%rax,1),%eax
  802d86:	89 d1                	mov    %edx,%ecx
  802d88:	f7 d1                	not    %ecx
  802d8a:	83 e1 07             	and    $0x7,%ecx
  802d8d:	d3 f8                	sar    %cl,%eax
  802d8f:	83 e0 01             	and    $0x1,%eax
  ++(*bitpointer);
  802d92:	48 83 c2 01          	add    $0x1,%rdx
  802d96:	48 89 17             	mov    %rdx,(%rdi)
  return result;
}
  802d99:	c3                   	ret    

0000000000802d9a <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  802d9a:	55                   	push   %rbp
  802d9b:	48 89 e5             	mov    %rsp,%rbp
  802d9e:	41 57                	push   %r15
  802da0:	41 56                	push   %r14
  802da2:	41 55                	push   %r13
  802da4:	41 54                	push   %r12
  802da6:	53                   	push   %rbx
  802da7:	48 83 ec 18          	sub    $0x18,%rsp
  802dab:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
  802daf:	48 85 d2             	test   %rdx,%rdx
  802db2:	74 45                	je     802df9 <readBitsFromReversedStream+0x5f>
  802db4:	49 89 f6             	mov    %rsi,%r14
  802db7:	49 89 d5             	mov    %rdx,%r13
  802dba:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  unsigned result = 0;
  802dc0:	b8 00 00 00 00       	mov    $0x0,%eax
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  802dc5:	49 bf 78 2d 80 00 00 	movabs $0x802d78,%r15
  802dcc:	00 00 00 
    result <<= 1u;
  802dcf:	8d 1c 00             	lea    (%rax,%rax,1),%ebx
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  802dd2:	4c 89 f6             	mov    %r14,%rsi
  802dd5:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  802dd9:	41 ff d7             	call   *%r15
  802ddc:	0f b6 c0             	movzbl %al,%eax
  802ddf:	09 d8                	or     %ebx,%eax
  for(i = 0 ; i < nbits; ++i) {
  802de1:	49 83 c4 01          	add    $0x1,%r12
  802de5:	4d 39 e5             	cmp    %r12,%r13
  802de8:	75 e5                	jne    802dcf <readBitsFromReversedStream+0x35>
  }
  return result;
}
  802dea:	48 83 c4 18          	add    $0x18,%rsp
  802dee:	5b                   	pop    %rbx
  802def:	41 5c                	pop    %r12
  802df1:	41 5d                	pop    %r13
  802df3:	41 5e                	pop    %r14
  802df5:	41 5f                	pop    %r15
  802df7:	5d                   	pop    %rbp
  802df8:	c3                   	ret    
  unsigned result = 0;
  802df9:	b8 00 00 00 00       	mov    $0x0,%eax
  return result;
  802dfe:	eb ea                	jmp    802dea <readBitsFromReversedStream+0x50>

0000000000802e00 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
  802e00:	84 d2                	test   %dl,%dl
  802e02:	75 20                	jne    802e24 <setBitOfReversedStream+0x24>
  802e04:	48 8b 0f             	mov    (%rdi),%rcx
  802e07:	48 89 ca             	mov    %rcx,%rdx
  802e0a:	48 c1 ea 03          	shr    $0x3,%rdx
  802e0e:	f7 d1                	not    %ecx
  802e10:	83 e1 07             	and    $0x7,%ecx
  802e13:	b8 01 00 00 00       	mov    $0x1,%eax
  802e18:	d3 e0                	shl    %cl,%eax
  802e1a:	f7 d0                	not    %eax
  802e1c:	20 04 16             	and    %al,(%rsi,%rdx,1)
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
  ++(*bitpointer);
  802e1f:	48 83 07 01          	addq   $0x1,(%rdi)
}
  802e23:	c3                   	ret    
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
  802e24:	48 8b 0f             	mov    (%rdi),%rcx
  802e27:	48 89 ca             	mov    %rcx,%rdx
  802e2a:	48 c1 ea 03          	shr    $0x3,%rdx
  802e2e:	f7 d1                	not    %ecx
  802e30:	83 e1 07             	and    $0x7,%ecx
  802e33:	b8 01 00 00 00       	mov    $0x1,%eax
  802e38:	d3 e0                	shl    %cl,%eax
  802e3a:	08 04 16             	or     %al,(%rsi,%rdx,1)
  802e3d:	eb e0                	jmp    802e1f <setBitOfReversedStream+0x1f>

0000000000802e3f <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  802e3f:	89 f1                	mov    %esi,%ecx
  switch(colortype) {
  802e41:	83 ff 06             	cmp    $0x6,%edi
  802e44:	77 77                	ja     802ebd <checkColorValidity+0x7e>
  802e46:	89 f8                	mov    %edi,%eax
  802e48:	48 ba 20 1b 81 00 00 	movabs $0x811b20,%rdx
  802e4f:	00 00 00 
  802e52:	ff 24 c2             	jmp    *(%rdx,%rax,8)
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
  802e55:	b8 25 00 00 00       	mov    $0x25,%eax
  802e5a:	83 fe 10             	cmp    $0x10,%esi
  802e5d:	77 39                	ja     802e98 <checkColorValidity+0x59>
  802e5f:	b8 16 01 01 00       	mov    $0x10116,%eax
  802e64:	48 d3 e8             	shr    %cl,%rax
  802e67:	a8 01                	test   $0x1,%al
  802e69:	b8 25 00 00 00       	mov    $0x25,%eax
  802e6e:	0f 45 c7             	cmovne %edi,%eax
  802e71:	c3                   	ret    
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
  802e72:	8d 46 f8             	lea    -0x8(%rsi),%eax
  802e75:	83 e0 f7             	and    $0xfffffff7,%eax
  802e78:	ba 25 00 00 00       	mov    $0x25,%edx
  802e7d:	0f 45 c2             	cmovne %edx,%eax
  802e80:	c3                   	ret    
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
  802e81:	8d 46 fc             	lea    -0x4(%rsi),%eax
  802e84:	a9 fb ff ff ff       	test   $0xfffffffb,%eax
  802e89:	74 08                	je     802e93 <checkColorValidity+0x54>
  802e8b:	8d 46 ff             	lea    -0x1(%rsi),%eax
  802e8e:	83 f8 01             	cmp    $0x1,%eax
  802e91:	77 06                	ja     802e99 <checkColorValidity+0x5a>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
  802e93:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802e98:	c3                   	ret    
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
  802e99:	b8 25 00 00 00       	mov    $0x25,%eax
  802e9e:	c3                   	ret    
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
  802e9f:	8d 46 f8             	lea    -0x8(%rsi),%eax
  802ea2:	83 e0 f7             	and    $0xfffffff7,%eax
  802ea5:	ba 25 00 00 00       	mov    $0x25,%edx
  802eaa:	0f 45 c2             	cmovne %edx,%eax
  802ead:	c3                   	ret    
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
  802eae:	8d 46 f8             	lea    -0x8(%rsi),%eax
  802eb1:	83 e0 f7             	and    $0xfffffff7,%eax
  802eb4:	ba 25 00 00 00       	mov    $0x25,%edx
  802eb9:	0f 45 c2             	cmovne %edx,%eax
  802ebc:	c3                   	ret    
  switch(colortype) {
  802ebd:	b8 1f 00 00 00       	mov    $0x1f,%eax
  802ec2:	c3                   	ret    

0000000000802ec3 <getNumColorChannels>:
    case LCT_RGB: return 3;
    case LCT_PALETTE: return 1;
    case LCT_GREY_ALPHA: return 2;
    case LCT_RGBA: return 4;
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    default: return 0; /*invalid color type*/
  802ec3:	b8 00 00 00 00       	mov    $0x0,%eax
  switch(colortype) {
  802ec8:	83 ff 06             	cmp    $0x6,%edi
  802ecb:	77 2e                	ja     802efb <getNumColorChannels+0x38>
  802ecd:	77 21                	ja     802ef0 <getNumColorChannels+0x2d>
  802ecf:	89 ff                	mov    %edi,%edi
  802ed1:	48 b8 58 1b 81 00 00 	movabs $0x811b58,%rax
  802ed8:	00 00 00 
  802edb:	ff 24 f8             	jmp    *(%rax,%rdi,8)
  802ede:	b8 03 00 00 00       	mov    $0x3,%eax
  802ee3:	c3                   	ret    
    case LCT_GREY_ALPHA: return 2;
  802ee4:	b8 02 00 00 00       	mov    $0x2,%eax
  802ee9:	c3                   	ret    
    case LCT_RGBA: return 4;
  802eea:	b8 04 00 00 00       	mov    $0x4,%eax
  802eef:	c3                   	ret    
    default: return 0; /*invalid color type*/
  802ef0:	b8 00 00 00 00       	mov    $0x0,%eax
  802ef5:	c3                   	ret    
    case LCT_GREY: return 1;
  802ef6:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  802efb:	c3                   	ret    

0000000000802efc <lodepng_color_mode_equal>:
  return result;
}

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
  size_t i;
  if(a->colortype != b->colortype) return 0;
  802efc:	b8 00 00 00 00       	mov    $0x0,%eax
  802f01:	8b 0e                	mov    (%rsi),%ecx
  802f03:	39 0f                	cmp    %ecx,(%rdi)
  802f05:	75 72                	jne    802f79 <lodepng_color_mode_equal+0x7d>
  if(a->bitdepth != b->bitdepth) return 0;
  802f07:	8b 56 04             	mov    0x4(%rsi),%edx
  802f0a:	39 57 04             	cmp    %edx,0x4(%rdi)
  802f0d:	75 6a                	jne    802f79 <lodepng_color_mode_equal+0x7d>
  if(a->key_defined != b->key_defined) return 0;
  802f0f:	8b 57 18             	mov    0x18(%rdi),%edx
  802f12:	3b 56 18             	cmp    0x18(%rsi),%edx
  802f15:	75 62                	jne    802f79 <lodepng_color_mode_equal+0x7d>
  if(a->key_defined) {
  802f17:	85 d2                	test   %edx,%edx
  802f19:	74 18                	je     802f33 <lodepng_color_mode_equal+0x37>
    if(a->key_r != b->key_r) return 0;
  802f1b:	8b 56 1c             	mov    0x1c(%rsi),%edx
  802f1e:	39 57 1c             	cmp    %edx,0x1c(%rdi)
  802f21:	75 56                	jne    802f79 <lodepng_color_mode_equal+0x7d>
    if(a->key_g != b->key_g) return 0;
  802f23:	8b 56 20             	mov    0x20(%rsi),%edx
  802f26:	39 57 20             	cmp    %edx,0x20(%rdi)
  802f29:	75 4e                	jne    802f79 <lodepng_color_mode_equal+0x7d>
    if(a->key_b != b->key_b) return 0;
  802f2b:	8b 56 24             	mov    0x24(%rsi),%edx
  802f2e:	39 57 24             	cmp    %edx,0x24(%rdi)
  802f31:	75 46                	jne    802f79 <lodepng_color_mode_equal+0x7d>
  }
  if(a->palettesize != b->palettesize) return 0;
  802f33:	48 8b 57 10          	mov    0x10(%rdi),%rdx
  802f37:	b8 00 00 00 00       	mov    $0x0,%eax
  802f3c:	48 3b 56 10          	cmp    0x10(%rsi),%rdx
  802f40:	75 37                	jne    802f79 <lodepng_color_mode_equal+0x7d>
  for(i = 0; i != a->palettesize * 4; ++i) {
  802f42:	48 c1 e2 02          	shl    $0x2,%rdx
  802f46:	74 26                	je     802f6e <lodepng_color_mode_equal+0x72>
    if(a->palette[i] != b->palette[i]) return 0;
  802f48:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  802f4c:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
  for(i = 0; i != a->palettesize * 4; ++i) {
  802f50:	b8 00 00 00 00       	mov    $0x0,%eax
    if(a->palette[i] != b->palette[i]) return 0;
  802f55:	0f b6 34 01          	movzbl (%rcx,%rax,1),%esi
  802f59:	40 38 34 07          	cmp    %sil,(%rdi,%rax,1)
  802f5d:	75 15                	jne    802f74 <lodepng_color_mode_equal+0x78>
  for(i = 0; i != a->palettesize * 4; ++i) {
  802f5f:	48 83 c0 01          	add    $0x1,%rax
  802f63:	48 39 d0             	cmp    %rdx,%rax
  802f66:	75 ed                	jne    802f55 <lodepng_color_mode_equal+0x59>
  }
  return 1;
  802f68:	b8 01 00 00 00       	mov    $0x1,%eax
  802f6d:	c3                   	ret    
  802f6e:	b8 01 00 00 00       	mov    $0x1,%eax
  802f73:	c3                   	ret    
    if(a->palette[i] != b->palette[i]) return 0;
  802f74:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802f79:	c3                   	ret    

0000000000802f7a <lodepng_get_raw_size_idat>:
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
  802f7a:	89 f8                	mov    %edi,%eax
  802f7c:	83 e0 07             	and    $0x7,%eax
  802f7f:	0f af c2             	imul   %edx,%eax
  802f82:	83 c0 07             	add    $0x7,%eax
  802f85:	c1 e8 03             	shr    $0x3,%eax
  802f88:	89 c0                	mov    %eax,%eax
  802f8a:	c1 ef 03             	shr    $0x3,%edi
  802f8d:	89 ff                	mov    %edi,%edi
  802f8f:	89 d2                	mov    %edx,%edx
  802f91:	48 0f af fa          	imul   %rdx,%rdi
  802f95:	48 8d 44 38 01       	lea    0x1(%rax,%rdi,1),%rax
  return (size_t)h * line;
  802f9a:	89 f6                	mov    %esi,%esi
  802f9c:	48 0f af c6          	imul   %rsi,%rax
}
  802fa0:	c3                   	ret    

0000000000802fa1 <LodePNGUnknownChunks_init>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
  802fa1:	48 c7 87 08 01 00 00 	movq   $0x0,0x108(%rdi)
  802fa8:	00 00 00 00 
  802fac:	48 c7 87 10 01 00 00 	movq   $0x0,0x110(%rdi)
  802fb3:	00 00 00 00 
  802fb7:	48 c7 87 18 01 00 00 	movq   $0x0,0x118(%rdi)
  802fbe:	00 00 00 00 
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
  802fc2:	48 c7 87 20 01 00 00 	movq   $0x0,0x120(%rdi)
  802fc9:	00 00 00 00 
  802fcd:	48 c7 87 28 01 00 00 	movq   $0x0,0x128(%rdi)
  802fd4:	00 00 00 00 
  802fd8:	48 c7 87 30 01 00 00 	movq   $0x0,0x130(%rdi)
  802fdf:	00 00 00 00 
}
  802fe3:	c3                   	ret    

0000000000802fe4 <addColorBits>:
}

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
  802fe4:	49 89 f8             	mov    %rdi,%r8
  802fe7:	49 89 f1             	mov    %rsi,%r9
  802fea:	41 89 ca             	mov    %ecx,%r10d
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
  802fed:	bf 07 00 00 00       	mov    $0x7,%edi
  802ff2:	83 fa 01             	cmp    $0x1,%edx
  802ff5:	74 0f                	je     803006 <addColorBits+0x22>
  802ff7:	83 fa 02             	cmp    $0x2,%edx
  802ffa:	40 0f 94 c7          	sete   %dil
  802ffe:	40 0f b6 ff          	movzbl %dil,%edi
  803002:	8d 7c 3f 01          	lea    0x1(%rdi,%rdi,1),%edi
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  803006:	41 89 fb             	mov    %edi,%r11d
  803009:	45 21 cb             	and    %r9d,%r11d
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  80300c:	be ff ff ff ff       	mov    $0xffffffff,%esi
  803011:	89 f0                	mov    %esi,%eax
  803013:	89 d1                	mov    %edx,%ecx
  803015:	d3 e0                	shl    %cl,%eax
  803017:	f7 d0                	not    %eax
  803019:	44 21 d0             	and    %r10d,%eax
  in = in << (bits * (m - p));
  80301c:	44 29 df             	sub    %r11d,%edi
  80301f:	89 f9                	mov    %edi,%ecx
  803021:	0f af ca             	imul   %edx,%ecx
  803024:	d3 e0                	shl    %cl,%eax
  if(p == 0) out[index * bits / 8u] = in;
  803026:	45 85 db             	test   %r11d,%r11d
  803029:	75 0f                	jne    80303a <addColorBits+0x56>
  80302b:	89 d2                	mov    %edx,%edx
  80302d:	49 0f af d1          	imul   %r9,%rdx
  803031:	48 c1 ea 03          	shr    $0x3,%rdx
  803035:	41 88 04 10          	mov    %al,(%r8,%rdx,1)
  803039:	c3                   	ret    
  else out[index * bits / 8u] |= in;
  80303a:	89 d2                	mov    %edx,%edx
  80303c:	49 0f af d1          	imul   %r9,%rdx
  803040:	48 c1 ea 03          	shr    $0x3,%rdx
  803044:	41 08 04 10          	or     %al,(%r8,%rdx,1)
}
  803048:	c3                   	ret    

0000000000803049 <color_tree_get>:
    }
  }
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  803049:	41 89 f1             	mov    %esi,%r9d
  80304c:	89 d6                	mov    %edx,%esi
  80304e:	89 ca                	mov    %ecx,%edx
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
  803050:	b9 00 00 00 00       	mov    $0x0,%ecx
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
  803055:	45 0f b6 c9          	movzbl %r9b,%r9d
  803059:	40 0f b6 f6          	movzbl %sil,%esi
  80305d:	0f b6 d2             	movzbl %dl,%edx
  803060:	45 0f b6 c0          	movzbl %r8b,%r8d
  803064:	45 89 ca             	mov    %r9d,%r10d
  803067:	41 d3 fa             	sar    %cl,%r10d
  80306a:	41 83 e2 01          	and    $0x1,%r10d
  80306e:	89 f0                	mov    %esi,%eax
  803070:	d3 f8                	sar    %cl,%eax
  803072:	83 e0 01             	and    $0x1,%eax
  803075:	46 8d 14 50          	lea    (%rax,%r10,2),%r10d
  803079:	89 d0                	mov    %edx,%eax
  80307b:	d3 f8                	sar    %cl,%eax
  80307d:	83 e0 01             	and    $0x1,%eax
  803080:	46 8d 14 50          	lea    (%rax,%r10,2),%r10d
  803084:	44 89 c0             	mov    %r8d,%eax
  803087:	d3 f8                	sar    %cl,%eax
  803089:	83 e0 01             	and    $0x1,%eax
  80308c:	42 8d 04 50          	lea    (%rax,%r10,2),%eax
    if(!tree->children[i]) return -1;
  803090:	48 98                	cltq   
  803092:	48 8b 3c c7          	mov    (%rdi,%rax,8),%rdi
  803096:	48 85 ff             	test   %rdi,%rdi
  803099:	74 0f                	je     8030aa <color_tree_get+0x61>
  for(bit = 0; bit < 8; ++bit) {
  80309b:	83 c1 01             	add    $0x1,%ecx
  80309e:	83 f9 08             	cmp    $0x8,%ecx
  8030a1:	75 c1                	jne    803064 <color_tree_get+0x1b>
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
  8030a3:	8b 87 80 00 00 00    	mov    0x80(%rdi),%eax
  8030a9:	c3                   	ret    
    if(!tree->children[i]) return -1;
  8030aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8030af:	c3                   	ret    

00000000008030b0 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
  8030b0:	55                   	push   %rbp
  8030b1:	48 89 e5             	mov    %rsp,%rbp
  8030b4:	41 57                	push   %r15
  8030b6:	41 56                	push   %r14
  8030b8:	41 55                	push   %r13
  8030ba:	41 54                	push   %r12
  8030bc:	53                   	push   %rbx
  8030bd:	48 83 ec 28          	sub    $0x28,%rsp
  8030c1:	49 89 fc             	mov    %rdi,%r12
  8030c4:	49 89 f5             	mov    %rsi,%r13
  8030c7:	49 89 d6             	mov    %rdx,%r14
  8030ca:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  8030ce:	48 8b 5d 10          	mov    0x10(%rbp),%rbx
  if(mode->colortype == LCT_GREY) {
  8030d2:	8b 03                	mov    (%rbx),%eax
  8030d4:	85 c0                	test   %eax,%eax
  8030d6:	0f 85 e2 00 00 00    	jne    8031be <getPixelColorRGBA8+0x10e>
    if(mode->bitdepth == 8) {
  8030dc:	44 8b 7b 04          	mov    0x4(%rbx),%r15d
  8030e0:	41 83 ff 08          	cmp    $0x8,%r15d
  8030e4:	74 3c                	je     803122 <getPixelColorRGBA8+0x72>
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
  8030e6:	41 83 ff 10          	cmp    $0x10,%r15d
  8030ea:	75 66                	jne    803152 <getPixelColorRGBA8+0xa2>
      *r = *g = *b = in[i * 2 + 0];
  8030ec:	4d 01 c9             	add    %r9,%r9
  8030ef:	4b 8d 14 08          	lea    (%r8,%r9,1),%rdx
  8030f3:	0f b6 02             	movzbl (%rdx),%eax
  8030f6:	41 88 06             	mov    %al,(%r14)
  8030f9:	88 06                	mov    %al,(%rsi)
  8030fb:	88 07                	mov    %al,(%rdi)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
  8030fd:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
  803101:	74 13                	je     803116 <getPixelColorRGBA8+0x66>
  803103:	43 0f b6 4c 08 01    	movzbl 0x1(%r8,%r9,1),%ecx
  803109:	0f b6 02             	movzbl (%rdx),%eax
  80310c:	c1 e0 08             	shl    $0x8,%eax
  80310f:	01 c8                	add    %ecx,%eax
  803111:	3b 43 1c             	cmp    0x1c(%rbx),%eax
  803114:	74 33                	je     803149 <getPixelColorRGBA8+0x99>
      else *a = 255;
  803116:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80311a:	c6 00 ff             	movb   $0xff,(%rax)
  80311d:	e9 8d 00 00 00       	jmp    8031af <getPixelColorRGBA8+0xff>
      *r = *g = *b = in[i];
  803122:	43 0f b6 04 08       	movzbl (%r8,%r9,1),%eax
  803127:	88 02                	mov    %al,(%rdx)
  803129:	88 06                	mov    %al,(%rsi)
  80312b:	88 07                	mov    %al,(%rdi)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
  80312d:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
  803131:	74 08                	je     80313b <getPixelColorRGBA8+0x8b>
  803133:	0f b6 c0             	movzbl %al,%eax
  803136:	3b 43 1c             	cmp    0x1c(%rbx),%eax
  803139:	74 09                	je     803144 <getPixelColorRGBA8+0x94>
      else *a = 255;
  80313b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80313f:	c6 00 ff             	movb   $0xff,(%rax)
  803142:	eb 6b                	jmp    8031af <getPixelColorRGBA8+0xff>
      if(mode->key_defined && *r == mode->key_r) *a = 0;
  803144:	c6 01 00             	movb   $0x0,(%rcx)
  803147:	eb 66                	jmp    8031af <getPixelColorRGBA8+0xff>
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
  803149:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80314d:	c6 00 00             	movb   $0x0,(%rax)
  803150:	eb 5d                	jmp    8031af <getPixelColorRGBA8+0xff>
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = i * mode->bitdepth;
  803152:	44 89 fa             	mov    %r15d,%edx
  803155:	4c 0f af ca          	imul   %rdx,%r9
  803159:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80315d:	4c 89 c6             	mov    %r8,%rsi
  803160:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  803164:	48 b8 9a 2d 80 00 00 	movabs $0x802d9a,%rax
  80316b:	00 00 00 
  80316e:	ff d0                	call   *%rax
  803170:	89 c6                	mov    %eax,%esi
      *r = *g = *b = (value * 255) / highest;
  803172:	c1 e0 08             	shl    $0x8,%eax
  803175:	29 f0                	sub    %esi,%eax
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
  803177:	ba 01 00 00 00       	mov    $0x1,%edx
  80317c:	44 89 f9             	mov    %r15d,%ecx
  80317f:	d3 e2                	shl    %cl,%edx
  803181:	8d 4a ff             	lea    -0x1(%rdx),%ecx
      *r = *g = *b = (value * 255) / highest;
  803184:	ba 00 00 00 00       	mov    $0x0,%edx
  803189:	f7 f1                	div    %ecx
  80318b:	41 88 06             	mov    %al,(%r14)
  80318e:	41 88 45 00          	mov    %al,0x0(%r13)
  803192:	41 88 04 24          	mov    %al,(%r12)
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
  803196:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      if(mode->key_defined && value == mode->key_r) *a = 0;
  80319b:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
  80319f:	74 08                	je     8031a9 <getPixelColorRGBA8+0xf9>
  8031a1:	39 73 1c             	cmp    %esi,0x1c(%rbx)
  8031a4:	0f 95 c0             	setne  %al
  8031a7:	f7 d8                	neg    %eax
  8031a9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8031ad:	88 07                	mov    %al,(%rdi)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
  8031af:	48 83 c4 28          	add    $0x28,%rsp
  8031b3:	5b                   	pop    %rbx
  8031b4:	41 5c                	pop    %r12
  8031b6:	41 5d                	pop    %r13
  8031b8:	41 5e                	pop    %r14
  8031ba:	41 5f                	pop    %r15
  8031bc:	5d                   	pop    %rbp
  8031bd:	c3                   	ret    
  } else if(mode->colortype == LCT_RGB) {
  8031be:	83 f8 02             	cmp    $0x2,%eax
  8031c1:	74 4f                	je     803212 <getPixelColorRGBA8+0x162>
  } else if(mode->colortype == LCT_PALETTE) {
  8031c3:	83 f8 03             	cmp    $0x3,%eax
  8031c6:	0f 84 22 01 00 00    	je     8032ee <getPixelColorRGBA8+0x23e>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
  8031cc:	83 f8 04             	cmp    $0x4,%eax
  8031cf:	0f 84 8f 01 00 00    	je     803364 <getPixelColorRGBA8+0x2b4>
  } else if(mode->colortype == LCT_RGBA) {
  8031d5:	83 f8 06             	cmp    $0x6,%eax
  8031d8:	75 d5                	jne    8031af <getPixelColorRGBA8+0xff>
    if(mode->bitdepth == 8) {
  8031da:	83 7b 04 08          	cmpl   $0x8,0x4(%rbx)
  8031de:	0f 84 be 01 00 00    	je     8033a2 <getPixelColorRGBA8+0x2f2>
      *r = in[i * 8 + 0];
  8031e4:	4a 8d 04 cd 00 00 00 	lea    0x0(,%r9,8),%rax
  8031eb:	00 
  8031ec:	43 0f b6 14 c8       	movzbl (%r8,%r9,8),%edx
  8031f1:	88 17                	mov    %dl,(%rdi)
      *g = in[i * 8 + 2];
  8031f3:	41 0f b6 54 00 02    	movzbl 0x2(%r8,%rax,1),%edx
  8031f9:	88 16                	mov    %dl,(%rsi)
      *b = in[i * 8 + 4];
  8031fb:	41 0f b6 54 00 04    	movzbl 0x4(%r8,%rax,1),%edx
  803201:	41 88 16             	mov    %dl,(%r14)
      *a = in[i * 8 + 6];
  803204:	41 0f b6 44 00 06    	movzbl 0x6(%r8,%rax,1),%eax
  80320a:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
  80320e:	88 03                	mov    %al,(%rbx)
}
  803210:	eb 9d                	jmp    8031af <getPixelColorRGBA8+0xff>
    if(mode->bitdepth == 8) {
  803212:	83 7b 04 08          	cmpl   $0x8,0x4(%rbx)
  803216:	74 4c                	je     803264 <getPixelColorRGBA8+0x1b4>
      *r = in[i * 6 + 0];
  803218:	4b 8d 04 49          	lea    (%r9,%r9,2),%rax
  80321c:	48 8d 34 00          	lea    (%rax,%rax,1),%rsi
  803220:	49 8d 04 30          	lea    (%r8,%rsi,1),%rax
  803224:	0f b6 10             	movzbl (%rax),%edx
  803227:	88 17                	mov    %dl,(%rdi)
      *g = in[i * 6 + 2];
  803229:	4d 8d 4c 30 02       	lea    0x2(%r8,%rsi,1),%r9
  80322e:	41 0f b6 11          	movzbl (%r9),%edx
  803232:	41 88 55 00          	mov    %dl,0x0(%r13)
      *b = in[i * 6 + 4];
  803236:	41 0f b6 7c 30 04    	movzbl 0x4(%r8,%rsi,1),%edi
  80323c:	41 88 3e             	mov    %dil,(%r14)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
  80323f:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
  803243:	74 13                	je     803258 <getPixelColorRGBA8+0x1a8>
  803245:	41 0f b6 4c 30 01    	movzbl 0x1(%r8,%rsi,1),%ecx
  80324b:	0f b6 10             	movzbl (%rax),%edx
  80324e:	c1 e2 08             	shl    $0x8,%edx
  803251:	01 ca                	add    %ecx,%edx
  803253:	3b 53 1c             	cmp    0x1c(%rbx),%edx
  803256:	74 5e                	je     8032b6 <getPixelColorRGBA8+0x206>
      else *a = 255;
  803258:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80325c:	c6 00 ff             	movb   $0xff,(%rax)
  80325f:	e9 4b ff ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
  803264:	4b 8d 04 49          	lea    (%r9,%r9,2),%rax
  803268:	41 0f b6 14 00       	movzbl (%r8,%rax,1),%edx
  80326d:	88 17                	mov    %dl,(%rdi)
  80326f:	41 0f b6 54 00 01    	movzbl 0x1(%r8,%rax,1),%edx
  803275:	88 16                	mov    %dl,(%rsi)
  803277:	41 0f b6 44 00 02    	movzbl 0x2(%r8,%rax,1),%eax
  80327d:	41 88 06             	mov    %al,(%r14)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
  803280:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
  803284:	74 08                	je     80328e <getPixelColorRGBA8+0x1de>
  803286:	0f b6 17             	movzbl (%rdi),%edx
  803289:	3b 53 1c             	cmp    0x1c(%rbx),%edx
  80328c:	74 0c                	je     80329a <getPixelColorRGBA8+0x1ea>
      else *a = 255;
  80328e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  803292:	c6 00 ff             	movb   $0xff,(%rax)
  803295:	e9 15 ff ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
  80329a:	0f b6 16             	movzbl (%rsi),%edx
  80329d:	3b 53 20             	cmp    0x20(%rbx),%edx
  8032a0:	75 ec                	jne    80328e <getPixelColorRGBA8+0x1de>
  8032a2:	0f b6 c0             	movzbl %al,%eax
  8032a5:	3b 43 24             	cmp    0x24(%rbx),%eax
  8032a8:	75 e4                	jne    80328e <getPixelColorRGBA8+0x1de>
  8032aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8032ae:	c6 00 00             	movb   $0x0,(%rax)
  8032b1:	e9 f9 fe ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
  8032b6:	41 0f b6 54 30 03    	movzbl 0x3(%r8,%rsi,1),%edx
  8032bc:	41 0f b6 01          	movzbl (%r9),%eax
  8032c0:	c1 e0 08             	shl    $0x8,%eax
  8032c3:	01 d0                	add    %edx,%eax
  8032c5:	3b 43 20             	cmp    0x20(%rbx),%eax
  8032c8:	75 8e                	jne    803258 <getPixelColorRGBA8+0x1a8>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
  8032ca:	41 0f b6 54 30 05    	movzbl 0x5(%r8,%rsi,1),%edx
  8032d0:	40 0f b6 c7          	movzbl %dil,%eax
  8032d4:	c1 e0 08             	shl    $0x8,%eax
  8032d7:	01 d0                	add    %edx,%eax
  8032d9:	3b 43 24             	cmp    0x24(%rbx),%eax
  8032dc:	0f 85 76 ff ff ff    	jne    803258 <getPixelColorRGBA8+0x1a8>
  8032e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8032e6:	c6 00 00             	movb   $0x0,(%rax)
  8032e9:	e9 c1 fe ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>
    if(mode->bitdepth == 8) index = in[i];
  8032ee:	8b 53 04             	mov    0x4(%rbx),%edx
  8032f1:	83 fa 08             	cmp    $0x8,%edx
  8032f4:	75 4f                	jne    803345 <getPixelColorRGBA8+0x295>
  8032f6:	43 0f b6 04 08       	movzbl (%r8,%r9,1),%eax
    *r = mode->palette[index * 4 + 0];
  8032fb:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  803302:	89 d0                	mov    %edx,%eax
  803304:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  803308:	0f b6 04 01          	movzbl (%rcx,%rax,1),%eax
  80330c:	41 88 04 24          	mov    %al,(%r12)
    *g = mode->palette[index * 4 + 1];
  803310:	8d 42 01             	lea    0x1(%rdx),%eax
  803313:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  803317:	0f b6 04 01          	movzbl (%rcx,%rax,1),%eax
  80331b:	41 88 45 00          	mov    %al,0x0(%r13)
    *b = mode->palette[index * 4 + 2];
  80331f:	8d 42 02             	lea    0x2(%rdx),%eax
  803322:	89 c0                	mov    %eax,%eax
  803324:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  803328:	0f b6 04 01          	movzbl (%rcx,%rax,1),%eax
  80332c:	41 88 06             	mov    %al,(%r14)
    *a = mode->palette[index * 4 + 3];
  80332f:	8d 42 03             	lea    0x3(%rdx),%eax
  803332:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  803336:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80333a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80333e:	88 07                	mov    %al,(%rdi)
  803340:	e9 6a fe ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>
      size_t j = i * mode->bitdepth;
  803345:	89 d2                	mov    %edx,%edx
  803347:	4c 0f af ca          	imul   %rdx,%r9
  80334b:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80334f:	4c 89 c6             	mov    %r8,%rsi
  803352:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  803356:	48 b8 9a 2d 80 00 00 	movabs $0x802d9a,%rax
  80335d:	00 00 00 
  803360:	ff d0                	call   *%rax
  803362:	eb 97                	jmp    8032fb <getPixelColorRGBA8+0x24b>
    if(mode->bitdepth == 8) {
  803364:	83 7b 04 08          	cmpl   $0x8,0x4(%rbx)
  803368:	74 1c                	je     803386 <getPixelColorRGBA8+0x2d6>
      *r = *g = *b = in[i * 4 + 0];
  80336a:	43 0f b6 04 88       	movzbl (%r8,%r9,4),%eax
  80336f:	88 02                	mov    %al,(%rdx)
  803371:	88 06                	mov    %al,(%rsi)
  803373:	88 07                	mov    %al,(%rdi)
      *a = in[i * 4 + 2];
  803375:	43 0f b6 44 88 02    	movzbl 0x2(%r8,%r9,4),%eax
  80337b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80337f:	88 06                	mov    %al,(%rsi)
  803381:	e9 29 fe ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>
      *r = *g = *b = in[i * 2 + 0];
  803386:	43 0f b6 04 48       	movzbl (%r8,%r9,2),%eax
  80338b:	88 02                	mov    %al,(%rdx)
  80338d:	88 06                	mov    %al,(%rsi)
  80338f:	88 07                	mov    %al,(%rdi)
      *a = in[i * 2 + 1];
  803391:	43 0f b6 44 48 01    	movzbl 0x1(%r8,%r9,2),%eax
  803397:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80339b:	88 06                	mov    %al,(%rsi)
  80339d:	e9 0d fe ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>
      *r = in[i * 4 + 0];
  8033a2:	4a 8d 04 8d 00 00 00 	lea    0x0(,%r9,4),%rax
  8033a9:	00 
  8033aa:	43 0f b6 14 88       	movzbl (%r8,%r9,4),%edx
  8033af:	88 17                	mov    %dl,(%rdi)
      *g = in[i * 4 + 1];
  8033b1:	41 0f b6 54 00 01    	movzbl 0x1(%r8,%rax,1),%edx
  8033b7:	88 16                	mov    %dl,(%rsi)
      *b = in[i * 4 + 2];
  8033b9:	41 0f b6 54 00 02    	movzbl 0x2(%r8,%rax,1),%edx
  8033bf:	41 88 16             	mov    %dl,(%r14)
      *a = in[i * 4 + 3];
  8033c2:	41 0f b6 44 00 03    	movzbl 0x3(%r8,%rax,1),%eax
  8033c8:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8033cc:	88 07                	mov    %al,(%rdi)
  8033ce:	e9 dc fd ff ff       	jmp    8031af <getPixelColorRGBA8+0xff>

00000000008033d3 <getPixelColorRGBA16>:
}

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  8033d3:	55                   	push   %rbp
  8033d4:	48 89 e5             	mov    %rsp,%rbp
  8033d7:	41 55                	push   %r13
  8033d9:	41 54                	push   %r12
  8033db:	53                   	push   %rbx
  8033dc:	4c 8b 55 10          	mov    0x10(%rbp),%r10
  if(mode->colortype == LCT_GREY) {
  8033e0:	41 8b 02             	mov    (%r10),%eax
  8033e3:	85 c0                	test   %eax,%eax
  8033e5:	75 50                	jne    803437 <getPixelColorRGBA16+0x64>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
  8033e7:	4d 01 c9             	add    %r9,%r9
  8033ea:	4f 8d 1c 08          	lea    (%r8,%r9,1),%r11
  8033ee:	4f 8d 44 08 01       	lea    0x1(%r8,%r9,1),%r8
  8033f3:	41 0f b6 03          	movzbl (%r11),%eax
  8033f7:	c1 e0 08             	shl    $0x8,%eax
  8033fa:	45 0f b6 08          	movzbl (%r8),%r9d
  8033fe:	44 01 c8             	add    %r9d,%eax
  803401:	66 89 02             	mov    %ax,(%rdx)
  803404:	66 89 06             	mov    %ax,(%rsi)
  803407:	66 89 07             	mov    %ax,(%rdi)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
  80340a:	41 83 7a 18 00       	cmpl   $0x0,0x18(%r10)
  80340f:	74 13                	je     803424 <getPixelColorRGBA16+0x51>
  803411:	41 0f b6 03          	movzbl (%r11),%eax
  803415:	c1 e0 08             	shl    $0x8,%eax
  803418:	41 0f b6 10          	movzbl (%r8),%edx
  80341c:	01 d0                	add    %edx,%eax
  80341e:	41 3b 42 1c          	cmp    0x1c(%r10),%eax
  803422:	74 0c                	je     803430 <getPixelColorRGBA16+0x5d>
    else *a = 65535;
  803424:	66 c7 01 ff ff       	movw   $0xffff,(%rcx)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
  803429:	5b                   	pop    %rbx
  80342a:	41 5c                	pop    %r12
  80342c:	41 5d                	pop    %r13
  80342e:	5d                   	pop    %rbp
  80342f:	c3                   	ret    
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
  803430:	66 c7 01 00 00       	movw   $0x0,(%rcx)
  803435:	eb f2                	jmp    803429 <getPixelColorRGBA16+0x56>
  } else if(mode->colortype == LCT_RGB) {
  803437:	83 f8 02             	cmp    $0x2,%eax
  80343a:	74 60                	je     80349c <getPixelColorRGBA16+0xc9>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
  80343c:	83 f8 04             	cmp    $0x4,%eax
  80343f:	0f 84 00 01 00 00    	je     803545 <getPixelColorRGBA16+0x172>
  } else if(mode->colortype == LCT_RGBA) {
  803445:	83 f8 06             	cmp    $0x6,%eax
  803448:	75 df                	jne    803429 <getPixelColorRGBA16+0x56>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
  80344a:	43 0f b6 04 c8       	movzbl (%r8,%r9,8),%eax
  80344f:	c1 e0 08             	shl    $0x8,%eax
  803452:	47 0f b6 54 c8 01    	movzbl 0x1(%r8,%r9,8),%r10d
  803458:	44 01 d0             	add    %r10d,%eax
  80345b:	66 89 07             	mov    %ax,(%rdi)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
  80345e:	43 0f b6 44 c8 02    	movzbl 0x2(%r8,%r9,8),%eax
  803464:	c1 e0 08             	shl    $0x8,%eax
  803467:	43 0f b6 7c c8 03    	movzbl 0x3(%r8,%r9,8),%edi
  80346d:	01 f8                	add    %edi,%eax
  80346f:	66 89 06             	mov    %ax,(%rsi)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
  803472:	43 0f b6 44 c8 04    	movzbl 0x4(%r8,%r9,8),%eax
  803478:	c1 e0 08             	shl    $0x8,%eax
  80347b:	43 0f b6 74 c8 05    	movzbl 0x5(%r8,%r9,8),%esi
  803481:	01 f0                	add    %esi,%eax
  803483:	66 89 02             	mov    %ax,(%rdx)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  803486:	43 0f b6 44 c8 06    	movzbl 0x6(%r8,%r9,8),%eax
  80348c:	c1 e0 08             	shl    $0x8,%eax
  80348f:	43 0f b6 54 c8 07    	movzbl 0x7(%r8,%r9,8),%edx
  803495:	01 d0                	add    %edx,%eax
  803497:	66 89 01             	mov    %ax,(%rcx)
}
  80349a:	eb 8d                	jmp    803429 <getPixelColorRGBA16+0x56>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
  80349c:	4b 8d 04 49          	lea    (%r9,%r9,2),%rax
  8034a0:	48 01 c0             	add    %rax,%rax
  8034a3:	4d 8d 1c 00          	lea    (%r8,%rax,1),%r11
  8034a7:	4d 8d 4c 00 01       	lea    0x1(%r8,%rax,1),%r9
  8034ac:	41 0f b6 1b          	movzbl (%r11),%ebx
  8034b0:	c1 e3 08             	shl    $0x8,%ebx
  8034b3:	45 0f b6 21          	movzbl (%r9),%r12d
  8034b7:	44 01 e3             	add    %r12d,%ebx
  8034ba:	66 89 1f             	mov    %bx,(%rdi)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
  8034bd:	4d 8d 64 00 02       	lea    0x2(%r8,%rax,1),%r12
  8034c2:	49 8d 5c 00 03       	lea    0x3(%r8,%rax,1),%rbx
  8034c7:	41 0f b6 3c 24       	movzbl (%r12),%edi
  8034cc:	c1 e7 08             	shl    $0x8,%edi
  8034cf:	44 0f b6 2b          	movzbl (%rbx),%r13d
  8034d3:	44 01 ef             	add    %r13d,%edi
  8034d6:	66 89 3e             	mov    %di,(%rsi)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
  8034d9:	49 8d 74 00 04       	lea    0x4(%r8,%rax,1),%rsi
  8034de:	49 8d 7c 00 05       	lea    0x5(%r8,%rax,1),%rdi
  8034e3:	0f b6 06             	movzbl (%rsi),%eax
  8034e6:	c1 e0 08             	shl    $0x8,%eax
  8034e9:	44 0f b6 07          	movzbl (%rdi),%r8d
  8034ed:	44 01 c0             	add    %r8d,%eax
  8034f0:	66 89 02             	mov    %ax,(%rdx)
    if(mode->key_defined
  8034f3:	41 83 7a 18 00       	cmpl   $0x0,0x18(%r10)
  8034f8:	74 13                	je     80350d <getPixelColorRGBA16+0x13a>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
  8034fa:	41 0f b6 03          	movzbl (%r11),%eax
  8034fe:	c1 e0 08             	shl    $0x8,%eax
  803501:	41 0f b6 11          	movzbl (%r9),%edx
  803505:	01 d0                	add    %edx,%eax
  803507:	41 3b 42 1c          	cmp    0x1c(%r10),%eax
  80350b:	74 0a                	je     803517 <getPixelColorRGBA16+0x144>
    else *a = 65535;
  80350d:	66 c7 01 ff ff       	movw   $0xffff,(%rcx)
  803512:	e9 12 ff ff ff       	jmp    803429 <getPixelColorRGBA16+0x56>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
  803517:	41 0f b6 04 24       	movzbl (%r12),%eax
  80351c:	c1 e0 08             	shl    $0x8,%eax
  80351f:	0f b6 13             	movzbl (%rbx),%edx
  803522:	01 d0                	add    %edx,%eax
  803524:	41 3b 42 20          	cmp    0x20(%r10),%eax
  803528:	75 e3                	jne    80350d <getPixelColorRGBA16+0x13a>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
  80352a:	0f b6 06             	movzbl (%rsi),%eax
  80352d:	c1 e0 08             	shl    $0x8,%eax
  803530:	0f b6 17             	movzbl (%rdi),%edx
  803533:	01 d0                	add    %edx,%eax
  803535:	41 3b 42 24          	cmp    0x24(%r10),%eax
  803539:	75 d2                	jne    80350d <getPixelColorRGBA16+0x13a>
  80353b:	66 c7 01 00 00       	movw   $0x0,(%rcx)
  803540:	e9 e4 fe ff ff       	jmp    803429 <getPixelColorRGBA16+0x56>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
  803545:	43 0f b6 04 88       	movzbl (%r8,%r9,4),%eax
  80354a:	c1 e0 08             	shl    $0x8,%eax
  80354d:	47 0f b6 54 88 01    	movzbl 0x1(%r8,%r9,4),%r10d
  803553:	44 01 d0             	add    %r10d,%eax
  803556:	66 89 02             	mov    %ax,(%rdx)
  803559:	66 89 06             	mov    %ax,(%rsi)
  80355c:	66 89 07             	mov    %ax,(%rdi)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  80355f:	43 0f b6 44 88 02    	movzbl 0x2(%r8,%r9,4),%eax
  803565:	c1 e0 08             	shl    $0x8,%eax
  803568:	43 0f b6 54 88 03    	movzbl 0x3(%r8,%r9,4),%edx
  80356e:	01 d0                	add    %edx,%eax
  803570:	66 89 01             	mov    %ax,(%rcx)
  803573:	e9 b1 fe ff ff       	jmp    803429 <getPixelColorRGBA16+0x56>

0000000000803578 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
  803578:	41 89 d0             	mov    %edx,%r8d
  short pa = LODEPNG_ABS(b - c);
  80357b:	0f bf c6             	movswl %si,%eax
  80357e:	44 0f bf ca          	movswl %dx,%r9d
  803582:	89 c1                	mov    %eax,%ecx
  803584:	44 29 c9             	sub    %r9d,%ecx
  803587:	89 ca                	mov    %ecx,%edx
  803589:	c1 fa 1f             	sar    $0x1f,%edx
  80358c:	31 d1                	xor    %edx,%ecx
  80358e:	29 d1                	sub    %edx,%ecx
  short pb = LODEPNG_ABS(a - c);
  803590:	44 0f bf d7          	movswl %di,%r10d
  803594:	44 89 d2             	mov    %r10d,%edx
  803597:	44 29 ca             	sub    %r9d,%edx
  80359a:	41 89 d3             	mov    %edx,%r11d
  80359d:	41 c1 fb 1f          	sar    $0x1f,%r11d
  8035a1:	44 31 da             	xor    %r11d,%edx
  8035a4:	44 29 da             	sub    %r11d,%edx
  short pc = LODEPNG_ABS(a + b - c - c);
  8035a7:	44 01 d0             	add    %r10d,%eax
  8035aa:	44 29 c8             	sub    %r9d,%eax
  8035ad:	44 29 c8             	sub    %r9d,%eax
  8035b0:	41 89 c1             	mov    %eax,%r9d
  8035b3:	41 c1 f9 1f          	sar    $0x1f,%r9d
  8035b7:	44 31 c8             	xor    %r9d,%eax
  8035ba:	44 29 c8             	sub    %r9d,%eax
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
  8035bd:	66 39 d1             	cmp    %dx,%cx
  8035c0:	41 89 c9             	mov    %ecx,%r9d
  8035c3:	44 0f 4f ca          	cmovg  %edx,%r9d
  8035c7:	0f 4e f7             	cmovle %edi,%esi
  return (pc < pa) ? c : a;
  8035ca:	66 41 39 c1          	cmp    %ax,%r9w
  8035ce:	44 89 c0             	mov    %r8d,%eax
  8035d1:	0f 4e c6             	cmovle %esi,%eax
}
  8035d4:	c3                   	ret    

00000000008035d5 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  8035d5:	55                   	push   %rbp
  8035d6:	48 89 e5             	mov    %rsp,%rbp
  8035d9:	41 57                	push   %r15
  8035db:	41 56                	push   %r14
  8035dd:	41 55                	push   %r13
  8035df:	41 54                	push   %r12
  8035e1:	53                   	push   %rbx
  8035e2:	48 83 ec 08          	sub    $0x8,%rsp
  8035e6:	49 89 f2             	mov    %rsi,%r10
  8035e9:	49 89 d3             	mov    %rdx,%r11
  8035ec:	48 89 cb             	mov    %rcx,%rbx
  8035ef:	44 8b 65 18          	mov    0x18(%rbp),%r12d
  8035f3:	b9 00 00 00 00       	mov    $0x0,%ecx
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
  8035f8:	49 bf 70 1f 81 00 00 	movabs $0x811f70,%r15
  8035ff:	00 00 00 
  803602:	41 8d 41 ff          	lea    -0x1(%r9),%eax
  803606:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  803609:	49 be b0 1f 81 00 00 	movabs $0x811fb0,%r14
  803610:	00 00 00 
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
  803613:	49 bd 50 1f 81 00 00 	movabs $0x811f50,%r13
  80361a:	00 00 00 
  80361d:	8b 45 10             	mov    0x10(%rbp),%eax
  803620:	83 e8 01             	sub    $0x1,%eax
  803623:	89 45 d0             	mov    %eax,-0x30(%rbp)
  803626:	e9 bd 00 00 00       	jmp    8036e8 <Adam7_getpassvalues+0x113>
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  80362b:	ba 00 00 00 00       	mov    $0x0,%edx
  803630:	e9 a2 00 00 00       	jmp    8036d7 <Adam7_getpassvalues+0x102>
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  803635:	49 c7 00 00 00 00 00 	movq   $0x0,(%r8)
  80363c:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  803643:	49 c7 03 00 00 00 00 	movq   $0x0,(%r11)
  80364a:	b8 00 00 00 00       	mov    $0x0,%eax
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
  80364f:	b9 00 00 00 00       	mov    $0x0,%ecx
  803654:	eb 4e                	jmp    8036a4 <Adam7_getpassvalues+0xcf>
  803656:	4c 01 ea             	add    %r13,%rdx
  803659:	49 89 54 43 08       	mov    %rdx,0x8(%r11,%rax,2)
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
  80365e:	44 89 e2             	mov    %r12d,%edx
  803661:	0f af 14 07          	imul   (%rdi,%rax,1),%edx
  803665:	83 c2 07             	add    $0x7,%edx
  803668:	c1 ea 03             	shr    $0x3,%edx
  80366b:	41 0f af 14 02       	imul   (%r10,%rax,1),%edx
  803670:	48 03 14 43          	add    (%rbx,%rax,2),%rdx
  803674:	48 89 54 43 08       	mov    %rdx,0x8(%rbx,%rax,2)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  803679:	41 8b 14 02          	mov    (%r10,%rax,1),%edx
  80367d:	0f af 14 07          	imul   (%rdi,%rax,1),%edx
  803681:	41 0f af d4          	imul   %r12d,%edx
  803685:	83 c2 07             	add    $0x7,%edx
  803688:	c1 ea 03             	shr    $0x3,%edx
  80368b:	89 d2                	mov    %edx,%edx
  80368d:	49 03 14 40          	add    (%r8,%rax,2),%rdx
  803691:	49 89 54 40 08       	mov    %rdx,0x8(%r8,%rax,2)
  for(i = 0; i != 7; ++i) {
  803696:	48 83 c0 04          	add    $0x4,%rax
  80369a:	48 83 f8 1c          	cmp    $0x1c,%rax
  80369e:	0f 84 97 00 00 00    	je     80373b <Adam7_getpassvalues+0x166>
    filter_passstart[i + 1] = filter_passstart[i]
  8036a4:	49 8b 14 43          	mov    (%r11,%rax,2),%rdx
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
  8036a8:	8b 34 07             	mov    (%rdi,%rax,1),%esi
  8036ab:	49 89 cd             	mov    %rcx,%r13
  8036ae:	85 f6                	test   %esi,%esi
  8036b0:	74 a4                	je     803656 <Adam7_getpassvalues+0x81>
  8036b2:	45 8b 0c 02          	mov    (%r10,%rax,1),%r9d
  8036b6:	45 85 c9             	test   %r9d,%r9d
  8036b9:	74 9b                	je     803656 <Adam7_getpassvalues+0x81>
  8036bb:	41 0f af f4          	imul   %r12d,%esi
  8036bf:	83 c6 07             	add    $0x7,%esi
  8036c2:	c1 ee 03             	shr    $0x3,%esi
  8036c5:	44 8d 6e 01          	lea    0x1(%rsi),%r13d
  8036c9:	45 0f af e9          	imul   %r9d,%r13d
  8036cd:	eb 87                	jmp    803656 <Adam7_getpassvalues+0x81>
  8036cf:	41 c7 04 0a 00 00 00 	movl   $0x0,(%r10,%rcx,1)
  8036d6:	00 
    if(passh[i] == 0) passw[i] = 0;
  8036d7:	89 14 0f             	mov    %edx,(%rdi,%rcx,1)
  for(i = 0; i != 7; ++i) {
  8036da:	48 83 c1 04          	add    $0x4,%rcx
  8036de:	48 83 f9 1c          	cmp    $0x1c,%rcx
  8036e2:	0f 84 4d ff ff ff    	je     803635 <Adam7_getpassvalues+0x60>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
  8036e8:	41 8b 34 0f          	mov    (%r15,%rcx,1),%esi
  8036ec:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8036ef:	01 f0                	add    %esi,%eax
  8036f1:	41 2b 04 0e          	sub    (%r14,%rcx,1),%eax
  8036f5:	ba 00 00 00 00       	mov    $0x0,%edx
  8036fa:	f7 f6                	div    %esi
  8036fc:	89 04 0f             	mov    %eax,(%rdi,%rcx,1)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
  8036ff:	45 8b 4c 0d 00       	mov    0x0(%r13,%rcx,1),%r9d
  803704:	8b 45 d0             	mov    -0x30(%rbp),%eax
  803707:	42 8d 34 08          	lea    (%rax,%r9,1),%esi
  80370b:	48 b8 90 1f 81 00 00 	movabs $0x811f90,%rax
  803712:	00 00 00 
  803715:	2b 34 08             	sub    (%rax,%rcx,1),%esi
  803718:	89 f0                	mov    %esi,%eax
  80371a:	ba 00 00 00 00       	mov    $0x0,%edx
  80371f:	41 f7 f1             	div    %r9d
  803722:	41 89 04 0a          	mov    %eax,(%r10,%rcx,1)
    if(passw[i] == 0) passh[i] = 0;
  803726:	8b 14 0f             	mov    (%rdi,%rcx,1),%edx
  803729:	85 d2                	test   %edx,%edx
  80372b:	74 a2                	je     8036cf <Adam7_getpassvalues+0xfa>
    if(passh[i] == 0) passw[i] = 0;
  80372d:	41 39 f1             	cmp    %esi,%r9d
  803730:	0f 87 f5 fe ff ff    	ja     80362b <Adam7_getpassvalues+0x56>
  803736:	8b 14 0f             	mov    (%rdi,%rcx,1),%edx
  803739:	eb 9c                	jmp    8036d7 <Adam7_getpassvalues+0x102>
  }
}
  80373b:	48 83 c4 08          	add    $0x8,%rsp
  80373f:	5b                   	pop    %rbx
  803740:	41 5c                	pop    %r12
  803742:	41 5d                	pop    %r13
  803744:	41 5e                	pop    %r14
  803746:	41 5f                	pop    %r15
  803748:	5d                   	pop    %rbp
  803749:	c3                   	ret    

000000000080374a <unfilter>:
    default: return 36; /*error: nonexistent filter type given*/
  }
  return 0;
}

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
  80374a:	55                   	push   %rbp
  80374b:	48 89 e5             	mov    %rsp,%rbp
  80374e:	41 57                	push   %r15
  803750:	41 56                	push   %r14
  803752:	41 55                	push   %r13
  803754:	41 54                	push   %r12
  803756:	53                   	push   %rbx
  803757:	48 83 ec 78          	sub    $0x78,%rsp
  80375b:	48 89 fb             	mov    %rdi,%rbx
  80375e:	49 89 f4             	mov    %rsi,%r12
  803761:	89 d7                	mov    %edx,%edi
  803763:	41 89 cd             	mov    %ecx,%r13d
  803766:	89 4d c8             	mov    %ecx,-0x38(%rbp)
  803769:	44 89 c2             	mov    %r8d,%edx

  unsigned y;
  unsigned char* prevline = 0;

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  80376c:	41 8d 40 07          	lea    0x7(%r8),%eax
  803770:	c1 e8 03             	shr    $0x3,%eax
  803773:	41 89 c7             	mov    %eax,%r15d
  803776:	4c 89 7d b8          	mov    %r15,-0x48(%rbp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
  80377a:	be 01 00 00 00       	mov    $0x1,%esi
  80377f:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  803786:	00 00 00 
  803789:	ff d0                	call   *%rax
  80378b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

  for(y = 0; y < h; ++y) {
  80378f:	45 85 ed             	test   %r13d,%r13d
  803792:	0f 84 e6 05 00 00    	je     803d7e <unfilter+0x634>
  803798:	4c 8d 70 ff          	lea    -0x1(%rax),%r14
  80379c:	49 8d 44 24 01       	lea    0x1(%r12),%rax
  8037a1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8037a5:	4c 29 fb             	sub    %r15,%rbx
  8037a8:	48 89 5d c0          	mov    %rbx,-0x40(%rbp)
  8037ac:	4b 8d 04 3f          	lea    (%r15,%r15,1),%rax
  8037b0:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  unsigned char* prevline = 0;
  8037b7:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  for(y = 0; y < h; ++y) {
  8037bd:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
  8037c4:	4d 89 fc             	mov    %r15,%r12
  8037c7:	e9 81 00 00 00       	jmp    80384d <unfilter+0x103>
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
  8037cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8037d1:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8037d5:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8037da:	74 13                	je     8037ef <unfilter+0xa5>
  8037dc:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  8037e2:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  8037e6:	48 83 c0 01          	add    $0x1,%rax
  8037ea:	48 39 c1             	cmp    %rax,%rcx
  8037ed:	75 ed                	jne    8037dc <unfilter+0x92>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
  8037ef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8037f3:	4c 39 f0             	cmp    %r14,%rax
  8037f6:	73 39                	jae    803831 <unfilter+0xe7>
  8037f8:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8037fc:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  803800:	41 02 54 05 00       	add    0x0(%r13,%rax,1),%dl
  803805:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  803809:	48 83 c0 01          	add    $0x1,%rax
  80380d:	49 39 c6             	cmp    %rax,%r14
  803810:	75 ea                	jne    8037fc <unfilter+0xb2>
  803812:	eb 1d                	jmp    803831 <unfilter+0xe7>
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
  803814:	4d 85 f6             	test   %r14,%r14
  803817:	74 18                	je     803831 <unfilter+0xe7>
  803819:	b8 00 00 00 00       	mov    $0x0,%eax
  80381e:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  803824:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  803828:	48 83 c0 01          	add    $0x1,%rax
  80382c:	49 39 c6             	cmp    %rax,%r14
  80382f:	75 ed                	jne    80381e <unfilter+0xd4>
  for(y = 0; y < h; ++y) {
  803831:	83 45 cc 01          	addl   $0x1,-0x34(%rbp)
  803835:	8b 45 cc             	mov    -0x34(%rbp),%eax
  803838:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80383c:	48 01 75 b0          	add    %rsi,-0x50(%rbp)
  803840:	4c 01 75 c0          	add    %r14,-0x40(%rbp)
  803844:	39 45 c8             	cmp    %eax,-0x38(%rbp)
  803847:	0f 84 3d 05 00 00    	je     803d8a <unfilter+0x640>
    size_t outindex = linebytes * y;
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    unsigned char filterType = in[inindex];
  80384d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  803851:	49 89 c5             	mov    %rax,%r13

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
  803854:	4d 89 e7             	mov    %r12,%r15
  803857:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  80385b:	4c 03 65 c0          	add    -0x40(%rbp),%r12
  switch(filterType) {
  80385f:	80 78 ff 04          	cmpb   $0x4,-0x1(%rax)
  803863:	0f 87 1a 05 00 00    	ja     803d83 <unfilter+0x639>
  803869:	0f b6 40 ff          	movzbl -0x1(%rax),%eax
  80386d:	48 bf 90 1b 81 00 00 	movabs $0x811b90,%rdi
  803874:	00 00 00 
  803877:	ff 24 c7             	jmp    *(%rdi,%rax,8)
      if(precon) {
  80387a:	4d 85 ff             	test   %r15,%r15
  80387d:	74 23                	je     8038a2 <unfilter+0x158>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
  80387f:	4d 85 f6             	test   %r14,%r14
  803882:	74 ad                	je     803831 <unfilter+0xe7>
  803884:	b8 00 00 00 00       	mov    $0x0,%eax
  803889:	41 0f b6 14 07       	movzbl (%r15,%rax,1),%edx
  80388e:	41 02 54 05 00       	add    0x0(%r13,%rax,1),%dl
  803893:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  803897:	48 83 c0 01          	add    $0x1,%rax
  80389b:	49 39 c6             	cmp    %rax,%r14
  80389e:	75 e9                	jne    803889 <unfilter+0x13f>
  8038a0:	eb 8f                	jmp    803831 <unfilter+0xe7>
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
  8038a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8038a7:	4d 85 f6             	test   %r14,%r14
  8038aa:	74 85                	je     803831 <unfilter+0xe7>
  8038ac:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  8038b2:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  8038b6:	48 83 c0 01          	add    $0x1,%rax
  8038ba:	49 39 c6             	cmp    %rax,%r14
  8038bd:	75 ed                	jne    8038ac <unfilter+0x162>
  8038bf:	e9 6d ff ff ff       	jmp    803831 <unfilter+0xe7>
      if(precon) {
  8038c4:	4d 85 ff             	test   %r15,%r15
  8038c7:	74 5f                	je     803928 <unfilter+0x1de>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
  8038c9:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8038cd:	48 85 c9             	test   %rcx,%rcx
  8038d0:	74 1e                	je     8038f0 <unfilter+0x1a6>
  8038d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8038d7:	41 0f b6 14 07       	movzbl (%r15,%rax,1),%edx
  8038dc:	d0 ea                	shr    %dl
  8038de:	41 02 54 05 00       	add    0x0(%r13,%rax,1),%dl
  8038e3:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  8038e7:	48 83 c0 01          	add    $0x1,%rax
  8038eb:	48 39 c1             	cmp    %rax,%rcx
  8038ee:	75 e7                	jne    8038d7 <unfilter+0x18d>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
  8038f0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8038f4:	4c 39 f0             	cmp    %r14,%rax
  8038f7:	0f 83 34 ff ff ff    	jae    803831 <unfilter+0xe7>
  8038fd:	48 89 c2             	mov    %rax,%rdx
  803900:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  803904:	0f b6 04 16          	movzbl (%rsi,%rdx,1),%eax
  803908:	41 0f b6 0c 17       	movzbl (%r15,%rdx,1),%ecx
  80390d:	01 c8                	add    %ecx,%eax
  80390f:	d1 f8                	sar    %eax
  803911:	41 02 44 15 00       	add    0x0(%r13,%rdx,1),%al
  803916:	41 88 04 14          	mov    %al,(%r12,%rdx,1)
  80391a:	48 83 c2 01          	add    $0x1,%rdx
  80391e:	49 39 d6             	cmp    %rdx,%r14
  803921:	75 e1                	jne    803904 <unfilter+0x1ba>
  803923:	e9 09 ff ff ff       	jmp    803831 <unfilter+0xe7>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
  803928:	b8 00 00 00 00       	mov    $0x0,%eax
  80392d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  803931:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  803936:	74 13                	je     80394b <unfilter+0x201>
  803938:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  80393e:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  803942:	48 83 c0 01          	add    $0x1,%rax
  803946:	48 39 c1             	cmp    %rax,%rcx
  803949:	75 ed                	jne    803938 <unfilter+0x1ee>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
  80394b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80394f:	4c 39 f0             	cmp    %r14,%rax
  803952:	0f 83 d9 fe ff ff    	jae    803831 <unfilter+0xe7>
  803958:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80395c:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  803960:	d0 ea                	shr    %dl
  803962:	41 02 54 05 00       	add    0x0(%r13,%rax,1),%dl
  803967:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  80396b:	48 83 c0 01          	add    $0x1,%rax
  80396f:	49 39 c6             	cmp    %rax,%r14
  803972:	75 e8                	jne    80395c <unfilter+0x212>
  803974:	e9 b8 fe ff ff       	jmp    803831 <unfilter+0xe7>
      if(precon) {
  803979:	4d 85 ff             	test   %r15,%r15
  80397c:	0f 84 e1 01 00 00    	je     803b63 <unfilter+0x419>
        for(i = 0; i != bytewidth; ++i) {
  803982:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  803986:	48 85 d2             	test   %rdx,%rdx
  803989:	0f 84 3d 03 00 00    	je     803ccc <unfilter+0x582>
  80398f:	bb 00 00 00 00       	mov    $0x0,%ebx
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
  803994:	41 0f b6 04 1f       	movzbl (%r15,%rbx,1),%eax
  803999:	41 02 44 1d 00       	add    0x0(%r13,%rbx,1),%al
  80399e:	41 88 04 1c          	mov    %al,(%r12,%rbx,1)
        for(i = 0; i != bytewidth; ++i) {
  8039a2:	48 89 d8             	mov    %rbx,%rax
  8039a5:	48 83 c3 01          	add    $0x1,%rbx
  8039a9:	48 39 da             	cmp    %rbx,%rdx
  8039ac:	75 e6                	jne    803994 <unfilter+0x24a>
        if(bytewidth >= 4) {
  8039ae:	48 83 fb 03          	cmp    $0x3,%rbx
  8039b2:	0f 86 fa 01 00 00    	jbe    803bb2 <unfilter+0x468>
          for(; i + 3 < length; i += 4) {
  8039b8:	48 83 c0 04          	add    $0x4,%rax
  8039bc:	49 39 c6             	cmp    %rax,%r14
  8039bf:	0f 86 41 01 00 00    	jbe    803b06 <unfilter+0x3bc>
  8039c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8039ca:	4c 89 b5 68 ff ff ff 	mov    %r14,-0x98(%rbp)
  8039d1:	4d 89 ee             	mov    %r13,%r14
  8039d4:	49 89 c5             	mov    %rax,%r13
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
  8039d7:	41 0f b6 04 1e       	movzbl (%r14,%rbx,1),%eax
  8039dc:	88 45 a8             	mov    %al,-0x58(%rbp)
  8039df:	41 0f b6 7c 1e 01    	movzbl 0x1(%r14,%rbx,1),%edi
  8039e5:	40 88 7d 98          	mov    %dil,-0x68(%rbp)
  8039e9:	41 0f b6 74 1e 02    	movzbl 0x2(%r14,%rbx,1),%esi
  8039ef:	40 88 75 97          	mov    %sil,-0x69(%rbp)
  8039f3:	41 0f b6 4c 1e 03    	movzbl 0x3(%r14,%rbx,1),%ecx
  8039f9:	88 4d 96             	mov    %cl,-0x6a(%rbp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
  8039fc:	43 0f b6 54 2c 01    	movzbl 0x1(%r12,%r13,1),%edx
  803a02:	88 55 88             	mov    %dl,-0x78(%rbp)
  803a05:	47 0f b6 54 2c 02    	movzbl 0x2(%r12,%r13,1),%r10d
  803a0b:	44 88 55 95          	mov    %r10b,-0x6b(%rbp)
  803a0f:	47 0f b6 5c 2c 03    	movzbl 0x3(%r12,%r13,1),%r11d
  803a15:	44 88 5d 94          	mov    %r11b,-0x6c(%rbp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
  803a19:	45 0f b6 44 1f 01    	movzbl 0x1(%r15,%rbx,1),%r8d
  803a1f:	44 88 45 93          	mov    %r8b,-0x6d(%rbp)
  803a23:	41 0f b6 44 1f 02    	movzbl 0x2(%r15,%rbx,1),%eax
  803a29:	88 45 80             	mov    %al,-0x80(%rbp)
  803a2c:	41 0f b6 74 1f 03    	movzbl 0x3(%r15,%rbx,1),%esi
  803a32:	40 88 b5 78 ff ff ff 	mov    %sil,-0x88(%rbp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
  803a39:	43 0f b6 4c 2f 01    	movzbl 0x1(%r15,%r13,1),%ecx
  803a3f:	88 8d 70 ff ff ff    	mov    %cl,-0x90(%rbp)
  803a45:	43 0f b6 54 2f 02    	movzbl 0x2(%r15,%r13,1),%edx
  803a4b:	88 55 92             	mov    %dl,-0x6e(%rbp)
  803a4e:	47 0f b6 4c 2f 03    	movzbl 0x3(%r15,%r13,1),%r9d
  803a54:	44 88 4d 91          	mov    %r9b,-0x6f(%rbp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
  803a58:	43 0f b6 14 2f       	movzbl (%r15,%r13,1),%edx
  803a5d:	41 0f b6 34 1f       	movzbl (%r15,%rbx,1),%esi
  803a62:	43 0f b6 3c 2c       	movzbl (%r12,%r13,1),%edi
  803a67:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803a6e:	00 00 00 
  803a71:	ff d0                	call   *%rax
  803a73:	02 45 a8             	add    -0x58(%rbp),%al
  803a76:	41 88 04 1c          	mov    %al,(%r12,%rbx,1)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
  803a7a:	0f b6 95 70 ff ff ff 	movzbl -0x90(%rbp),%edx
  803a81:	0f b6 75 93          	movzbl -0x6d(%rbp),%esi
  803a85:	0f b6 7d 88          	movzbl -0x78(%rbp),%edi
  803a89:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803a90:	00 00 00 
  803a93:	ff d0                	call   *%rax
  803a95:	02 45 98             	add    -0x68(%rbp),%al
  803a98:	41 88 44 1c 01       	mov    %al,0x1(%r12,%rbx,1)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
  803a9d:	0f b6 55 92          	movzbl -0x6e(%rbp),%edx
  803aa1:	0f b6 75 80          	movzbl -0x80(%rbp),%esi
  803aa5:	0f b6 7d 95          	movzbl -0x6b(%rbp),%edi
  803aa9:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803ab0:	00 00 00 
  803ab3:	ff d0                	call   *%rax
  803ab5:	02 45 97             	add    -0x69(%rbp),%al
  803ab8:	41 88 44 1c 02       	mov    %al,0x2(%r12,%rbx,1)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
  803abd:	0f b6 55 91          	movzbl -0x6f(%rbp),%edx
  803ac1:	0f b6 b5 78 ff ff ff 	movzbl -0x88(%rbp),%esi
  803ac8:	0f b6 7d 94          	movzbl -0x6c(%rbp),%edi
  803acc:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803ad3:	00 00 00 
  803ad6:	ff d0                	call   *%rax
  803ad8:	02 45 96             	add    -0x6a(%rbp),%al
  803adb:	41 88 44 1c 03       	mov    %al,0x3(%r12,%rbx,1)
          for(; i + 3 < length; i += 4) {
  803ae0:	48 89 d8             	mov    %rbx,%rax
  803ae3:	48 83 c3 04          	add    $0x4,%rbx
  803ae7:	49 83 c5 04          	add    $0x4,%r13
  803aeb:	48 83 c0 07          	add    $0x7,%rax
  803aef:	48 39 85 68 ff ff ff 	cmp    %rax,-0x98(%rbp)
  803af6:	0f 87 db fe ff ff    	ja     8039d7 <unfilter+0x28d>
  803afc:	4d 89 f5             	mov    %r14,%r13
  803aff:	4c 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%r14
        for(; i != length; ++i) {
  803b06:	48 89 d8             	mov    %rbx,%rax
  803b09:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
  803b0d:	49 39 de             	cmp    %rbx,%r14
  803b10:	0f 84 1b fd ff ff    	je     803831 <unfilter+0xe7>
  803b16:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
  803b1a:	4c 89 6d 98          	mov    %r13,-0x68(%rbp)
  803b1e:	49 89 c5             	mov    %rax,%r13
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
  803b21:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  803b25:	44 0f b6 34 18       	movzbl (%rax,%rbx,1),%r14d
  803b2a:	43 0f b6 14 2f       	movzbl (%r15,%r13,1),%edx
  803b2f:	41 0f b6 34 1f       	movzbl (%r15,%rbx,1),%esi
  803b34:	43 0f b6 3c 2c       	movzbl (%r12,%r13,1),%edi
  803b39:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803b40:	00 00 00 
  803b43:	ff d0                	call   *%rax
  803b45:	41 01 c6             	add    %eax,%r14d
  803b48:	45 88 34 1c          	mov    %r14b,(%r12,%rbx,1)
        for(; i != length; ++i) {
  803b4c:	48 83 c3 01          	add    $0x1,%rbx
  803b50:	49 83 c5 01          	add    $0x1,%r13
  803b54:	48 39 5d a8          	cmp    %rbx,-0x58(%rbp)
  803b58:	75 c7                	jne    803b21 <unfilter+0x3d7>
  803b5a:	4c 8b 75 a8          	mov    -0x58(%rbp),%r14
  803b5e:	e9 ce fc ff ff       	jmp    803831 <unfilter+0xe7>
        for(i = 0; i != bytewidth; ++i) {
  803b63:	b8 00 00 00 00       	mov    $0x0,%eax
  803b68:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  803b6c:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  803b71:	74 13                	je     803b86 <unfilter+0x43c>
          recon[i] = scanline[i];
  803b73:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  803b79:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
        for(i = 0; i != bytewidth; ++i) {
  803b7d:	48 83 c0 01          	add    $0x1,%rax
  803b81:	48 39 c1             	cmp    %rax,%rcx
  803b84:	75 ed                	jne    803b73 <unfilter+0x429>
        for(i = bytewidth; i < length; ++i) {
  803b86:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  803b8a:	4c 39 f0             	cmp    %r14,%rax
  803b8d:	0f 83 9e fc ff ff    	jae    803831 <unfilter+0xe7>
  803b93:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
          recon[i] = (scanline[i] + recon[i - bytewidth]);
  803b97:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  803b9b:	41 02 54 05 00       	add    0x0(%r13,%rax,1),%dl
  803ba0:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
        for(i = bytewidth; i < length; ++i) {
  803ba4:	48 83 c0 01          	add    $0x1,%rax
  803ba8:	49 39 c6             	cmp    %rax,%r14
  803bab:	75 ea                	jne    803b97 <unfilter+0x44d>
  803bad:	e9 7f fc ff ff       	jmp    803831 <unfilter+0xe7>
        } else if(bytewidth >= 3) {
  803bb2:	0f 85 1d 01 00 00    	jne    803cd5 <unfilter+0x58b>
          for(; i + 2 < length; i += 3) {
  803bb8:	49 83 fe 05          	cmp    $0x5,%r14
  803bbc:	0f 86 44 ff ff ff    	jbe    803b06 <unfilter+0x3bc>
  803bc2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  803bc6:	48 03 85 60 ff ff ff 	add    -0xa0(%rbp),%rax
  803bcd:	49 8d 77 03          	lea    0x3(%r15),%rsi
  803bd1:	4c 89 75 80          	mov    %r14,-0x80(%rbp)
  803bd5:	4c 89 bd 78 ff ff ff 	mov    %r15,-0x88(%rbp)
  803bdc:	4c 89 a5 70 ff ff ff 	mov    %r12,-0x90(%rbp)
  803be3:	49 89 f4             	mov    %rsi,%r12
  803be6:	4d 89 ee             	mov    %r13,%r14
  803be9:	49 89 c5             	mov    %rax,%r13
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
  803bec:	41 0f b6 04 1e       	movzbl (%r14,%rbx,1),%eax
  803bf1:	88 45 a8             	mov    %al,-0x58(%rbp)
  803bf4:	41 0f b6 7c 1e 01    	movzbl 0x1(%r14,%rbx,1),%edi
  803bfa:	40 88 7d 98          	mov    %dil,-0x68(%rbp)
  803bfe:	41 0f b6 74 1e 02    	movzbl 0x2(%r14,%rbx,1),%esi
  803c04:	40 88 75 97          	mov    %sil,-0x69(%rbp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
  803c08:	41 0f b6 4d fe       	movzbl -0x2(%r13),%ecx
  803c0d:	88 4d 96             	mov    %cl,-0x6a(%rbp)
  803c10:	41 0f b6 55 ff       	movzbl -0x1(%r13),%edx
  803c15:	88 55 88             	mov    %dl,-0x78(%rbp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
  803c18:	45 0f b6 54 24 01    	movzbl 0x1(%r12),%r10d
  803c1e:	44 88 55 95          	mov    %r10b,-0x6b(%rbp)
  803c22:	45 0f b6 5c 24 02    	movzbl 0x2(%r12),%r11d
  803c28:	44 88 5d 94          	mov    %r11b,-0x6c(%rbp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
  803c2c:	45 0f b6 7c 24 fe    	movzbl -0x2(%r12),%r15d
  803c32:	45 0f b6 44 24 ff    	movzbl -0x1(%r12),%r8d
  803c38:	44 88 45 93          	mov    %r8b,-0x6d(%rbp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
  803c3c:	41 0f b6 54 24 fd    	movzbl -0x3(%r12),%edx
  803c42:	41 0f b6 34 24       	movzbl (%r12),%esi
  803c47:	41 0f b6 7d fd       	movzbl -0x3(%r13),%edi
  803c4c:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803c53:	00 00 00 
  803c56:	ff d0                	call   *%rax
  803c58:	02 45 a8             	add    -0x58(%rbp),%al
  803c5b:	41 88 45 00          	mov    %al,0x0(%r13)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
  803c5f:	41 0f b6 d7          	movzbl %r15b,%edx
  803c63:	0f b6 75 95          	movzbl -0x6b(%rbp),%esi
  803c67:	0f b6 7d 96          	movzbl -0x6a(%rbp),%edi
  803c6b:	49 bf 78 35 80 00 00 	movabs $0x803578,%r15
  803c72:	00 00 00 
  803c75:	41 ff d7             	call   *%r15
  803c78:	02 45 98             	add    -0x68(%rbp),%al
  803c7b:	41 88 45 01          	mov    %al,0x1(%r13)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
  803c7f:	0f b6 55 93          	movzbl -0x6d(%rbp),%edx
  803c83:	0f b6 75 94          	movzbl -0x6c(%rbp),%esi
  803c87:	0f b6 7d 88          	movzbl -0x78(%rbp),%edi
  803c8b:	41 ff d7             	call   *%r15
  803c8e:	02 45 97             	add    -0x69(%rbp),%al
  803c91:	41 88 45 02          	mov    %al,0x2(%r13)
          for(; i + 2 < length; i += 3) {
  803c95:	48 89 d8             	mov    %rbx,%rax
  803c98:	48 83 c3 03          	add    $0x3,%rbx
  803c9c:	49 83 c5 03          	add    $0x3,%r13
  803ca0:	49 83 c4 03          	add    $0x3,%r12
  803ca4:	48 83 c0 05          	add    $0x5,%rax
  803ca8:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  803cac:	0f 87 3a ff ff ff    	ja     803bec <unfilter+0x4a2>
  803cb2:	4c 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%r15
  803cb9:	4c 8b a5 70 ff ff ff 	mov    -0x90(%rbp),%r12
  803cc0:	4d 89 f5             	mov    %r14,%r13
  803cc3:	4c 8b 75 80          	mov    -0x80(%rbp),%r14
  803cc7:	e9 3a fe ff ff       	jmp    803b06 <unfilter+0x3bc>
        for(i = 0; i != bytewidth; ++i) {
  803ccc:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
  803cd0:	e9 31 fe ff ff       	jmp    803b06 <unfilter+0x3bc>
        } else if(bytewidth >= 2) {
  803cd5:	48 83 fb 01          	cmp    $0x1,%rbx
  803cd9:	0f 86 27 fe ff ff    	jbe    803b06 <unfilter+0x3bc>
          for(; i + 1 < length; i += 2) {
  803cdf:	48 83 c0 02          	add    $0x2,%rax
  803ce3:	49 39 c6             	cmp    %rax,%r14
  803ce6:	0f 86 1a fe ff ff    	jbe    803b06 <unfilter+0x3bc>
  803cec:	4c 89 75 88          	mov    %r14,-0x78(%rbp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
  803cf0:	41 0f b6 44 1d 00    	movzbl 0x0(%r13,%rbx,1),%eax
  803cf6:	88 45 a8             	mov    %al,-0x58(%rbp)
  803cf9:	41 0f b6 74 1d 01    	movzbl 0x1(%r13,%rbx,1),%esi
  803cff:	40 88 75 98          	mov    %sil,-0x68(%rbp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
  803d03:	41 0f b6 7c 1c ff    	movzbl -0x1(%r12,%rbx,1),%edi
  803d09:	40 88 7d 97          	mov    %dil,-0x69(%rbp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
  803d0d:	41 0f b6 4c 1f 01    	movzbl 0x1(%r15,%rbx,1),%ecx
  803d13:	88 4d 96             	mov    %cl,-0x6a(%rbp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
  803d16:	45 0f b6 74 1f ff    	movzbl -0x1(%r15,%rbx,1),%r14d
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
  803d1c:	41 0f b6 54 1f fe    	movzbl -0x2(%r15,%rbx,1),%edx
  803d22:	41 0f b6 34 1f       	movzbl (%r15,%rbx,1),%esi
  803d27:	41 0f b6 7c 1c fe    	movzbl -0x2(%r12,%rbx,1),%edi
  803d2d:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803d34:	00 00 00 
  803d37:	ff d0                	call   *%rax
  803d39:	02 45 a8             	add    -0x58(%rbp),%al
  803d3c:	41 88 04 1c          	mov    %al,(%r12,%rbx,1)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
  803d40:	41 0f b6 d6          	movzbl %r14b,%edx
  803d44:	0f b6 75 96          	movzbl -0x6a(%rbp),%esi
  803d48:	0f b6 7d 97          	movzbl -0x69(%rbp),%edi
  803d4c:	48 b8 78 35 80 00 00 	movabs $0x803578,%rax
  803d53:	00 00 00 
  803d56:	ff d0                	call   *%rax
  803d58:	02 45 98             	add    -0x68(%rbp),%al
  803d5b:	41 88 44 1c 01       	mov    %al,0x1(%r12,%rbx,1)
          for(; i + 1 < length; i += 2) {
  803d60:	48 89 d8             	mov    %rbx,%rax
  803d63:	48 83 c3 02          	add    $0x2,%rbx
  803d67:	48 83 c0 03          	add    $0x3,%rax
  803d6b:	48 39 45 88          	cmp    %rax,-0x78(%rbp)
  803d6f:	0f 87 7b ff ff ff    	ja     803cf0 <unfilter+0x5a6>
  803d75:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
  803d79:	e9 88 fd ff ff       	jmp    803b06 <unfilter+0x3bc>

    prevline = &out[outindex];
  }

  return 0;
  803d7e:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803d81:	eb 0c                	jmp    803d8f <unfilter+0x645>
  switch(filterType) {
  803d83:	b8 24 00 00 00       	mov    $0x24,%eax
  803d88:	eb 05                	jmp    803d8f <unfilter+0x645>
  return 0;
  803d8a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803d8f:	48 83 c4 78          	add    $0x78,%rsp
  803d93:	5b                   	pop    %rbx
  803d94:	41 5c                	pop    %r12
  803d96:	41 5d                	pop    %r13
  803d98:	41 5e                	pop    %r14
  803d9a:	41 5f                	pop    %r15
  803d9c:	5d                   	pop    %rbp
  803d9d:	c3                   	ret    

0000000000803d9e <removePaddingBits>:
    }
  }
}

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
  803d9e:	55                   	push   %rbp
  803d9f:	48 89 e5             	mov    %rsp,%rbp
  803da2:	41 57                	push   %r15
  803da4:	41 56                	push   %r14
  803da6:	41 55                	push   %r13
  803da8:	41 54                	push   %r12
  803daa:	53                   	push   %rbx
  803dab:	48 83 ec 38          	sub    $0x38,%rsp
  803daf:	49 89 fd             	mov    %rdi,%r13
  803db2:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  803db6:	49 89 d4             	mov    %rdx,%r12
  803db9:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  803dbd:	48 29 d1             	sub    %rdx,%rcx
  803dc0:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  803dc4:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  803dcb:	00 
  803dcc:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  803dd3:	00 
  for(y = 0; y < h; ++y) {
  803dd4:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
    size_t x;
    for(x = 0; x < olinebits; ++x) {
      unsigned char bit = readBitFromReversedStream(&ibp, in);
  803ddb:	49 bf 78 2d 80 00 00 	movabs $0x802d78,%r15
  803de2:	00 00 00 
      setBitOfReversedStream(&obp, out, bit);
  803de5:	49 be 00 2e 80 00 00 	movabs $0x802e00,%r14
  803dec:	00 00 00 
  for(y = 0; y < h; ++y) {
  803def:	45 85 c0             	test   %r8d,%r8d
  803df2:	75 44                	jne    803e38 <removePaddingBits+0x9a>
    }
    ibp += diff;
  }
}
  803df4:	48 83 c4 38          	add    $0x38,%rsp
  803df8:	5b                   	pop    %rbx
  803df9:	41 5c                	pop    %r12
  803dfb:	41 5d                	pop    %r13
  803dfd:	41 5e                	pop    %r14
  803dff:	41 5f                	pop    %r15
  803e01:	5d                   	pop    %rbp
  803e02:	c3                   	ret    
      unsigned char bit = readBitFromReversedStream(&ibp, in);
  803e03:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  803e07:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  803e0b:	41 ff d7             	call   *%r15
      setBitOfReversedStream(&obp, out, bit);
  803e0e:	0f b6 d0             	movzbl %al,%edx
  803e11:	4c 89 ee             	mov    %r13,%rsi
  803e14:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
  803e18:	41 ff d6             	call   *%r14
    for(x = 0; x < olinebits; ++x) {
  803e1b:	48 83 c3 01          	add    $0x1,%rbx
  803e1f:	49 39 dc             	cmp    %rbx,%r12
  803e22:	75 df                	jne    803e03 <removePaddingBits+0x65>
    ibp += diff;
  803e24:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  803e28:	48 01 45 c8          	add    %rax,-0x38(%rbp)
  for(y = 0; y < h; ++y) {
  803e2c:	83 45 b4 01          	addl   $0x1,-0x4c(%rbp)
  803e30:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  803e33:	39 45 b0             	cmp    %eax,-0x50(%rbp)
  803e36:	74 bc                	je     803df4 <removePaddingBits+0x56>
    for(x = 0; x < olinebits; ++x) {
  803e38:	bb 00 00 00 00       	mov    $0x0,%ebx
  803e3d:	4d 85 e4             	test   %r12,%r12
  803e40:	75 c1                	jne    803e03 <removePaddingBits+0x65>
  803e42:	eb e0                	jmp    803e24 <removePaddingBits+0x86>

0000000000803e44 <readChunk_tRNS>:
  }

  return 0; /* OK */
}

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
  803e44:	49 89 d0             	mov    %rdx,%r8
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
  803e47:	8b 07                	mov    (%rdi),%eax
  803e49:	83 f8 03             	cmp    $0x3,%eax
  803e4c:	74 2b                	je     803e79 <readChunk_tRNS+0x35>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
  } else if(color->colortype == LCT_GREY) {
  803e4e:	85 c0                	test   %eax,%eax
  803e50:	75 5e                	jne    803eb0 <readChunk_tRNS+0x6c>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
  803e52:	48 83 fa 02          	cmp    $0x2,%rdx
  803e56:	0f 85 ac 00 00 00    	jne    803f08 <readChunk_tRNS+0xc4>

    color->key_defined = 1;
  803e5c:	c7 47 18 01 00 00 00 	movl   $0x1,0x18(%rdi)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
  803e63:	0f b6 16             	movzbl (%rsi),%edx
  803e66:	c1 e2 08             	shl    $0x8,%edx
  803e69:	0f b6 4e 01          	movzbl 0x1(%rsi),%ecx
  803e6d:	01 ca                	add    %ecx,%edx
  803e6f:	89 57 24             	mov    %edx,0x24(%rdi)
  803e72:	89 57 20             	mov    %edx,0x20(%rdi)
  803e75:	89 57 1c             	mov    %edx,0x1c(%rdi)
  803e78:	c3                   	ret    
    if(chunkLength > color->palettesize) return 39;
  803e79:	48 39 57 10          	cmp    %rdx,0x10(%rdi)
  803e7d:	72 7d                	jb     803efc <readChunk_tRNS+0xb8>
    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
  803e7f:	48 85 d2             	test   %rdx,%rdx
  803e82:	74 7e                	je     803f02 <readChunk_tRNS+0xbe>
  803e84:	b9 00 00 00 00       	mov    $0x0,%ecx
  803e89:	ba 00 00 00 00       	mov    $0x0,%edx
  803e8e:	44 0f b6 14 16       	movzbl (%rsi,%rdx,1),%r10d
  803e93:	89 c2                	mov    %eax,%edx
  803e95:	4c 8b 4f 08          	mov    0x8(%rdi),%r9
  803e99:	45 88 14 11          	mov    %r10b,(%r9,%rdx,1)
  803e9d:	83 c1 01             	add    $0x1,%ecx
  803ea0:	89 ca                	mov    %ecx,%edx
  803ea2:	83 c0 04             	add    $0x4,%eax
  803ea5:	4c 39 c2             	cmp    %r8,%rdx
  803ea8:	75 e4                	jne    803e8e <readChunk_tRNS+0x4a>
    color->key_g = 256u * data[2] + data[3];
    color->key_b = 256u * data[4] + data[5];
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/

  return 0; /* OK */
  803eaa:	b8 00 00 00 00       	mov    $0x0,%eax
  803eaf:	c3                   	ret    
  } else if(color->colortype == LCT_RGB) {
  803eb0:	83 f8 02             	cmp    $0x2,%eax
  803eb3:	75 59                	jne    803f0e <readChunk_tRNS+0xca>
    if(chunkLength != 6) return 41;
  803eb5:	b8 29 00 00 00       	mov    $0x29,%eax
  803eba:	48 83 fa 06          	cmp    $0x6,%rdx
  803ebe:	75 53                	jne    803f13 <readChunk_tRNS+0xcf>
    color->key_defined = 1;
  803ec0:	c7 47 18 01 00 00 00 	movl   $0x1,0x18(%rdi)
    color->key_r = 256u * data[0] + data[1];
  803ec7:	0f b6 06             	movzbl (%rsi),%eax
  803eca:	c1 e0 08             	shl    $0x8,%eax
  803ecd:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
  803ed1:	01 d0                	add    %edx,%eax
  803ed3:	89 47 1c             	mov    %eax,0x1c(%rdi)
    color->key_g = 256u * data[2] + data[3];
  803ed6:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
  803eda:	c1 e0 08             	shl    $0x8,%eax
  803edd:	0f b6 56 03          	movzbl 0x3(%rsi),%edx
  803ee1:	01 d0                	add    %edx,%eax
  803ee3:	89 47 20             	mov    %eax,0x20(%rdi)
    color->key_b = 256u * data[4] + data[5];
  803ee6:	0f b6 46 04          	movzbl 0x4(%rsi),%eax
  803eea:	c1 e0 08             	shl    $0x8,%eax
  803eed:	0f b6 56 05          	movzbl 0x5(%rsi),%edx
  803ef1:	01 d0                	add    %edx,%eax
  803ef3:	89 47 24             	mov    %eax,0x24(%rdi)
  return 0; /* OK */
  803ef6:	b8 00 00 00 00       	mov    $0x0,%eax
  803efb:	c3                   	ret    
    if(chunkLength > color->palettesize) return 39;
  803efc:	b8 27 00 00 00       	mov    $0x27,%eax
  803f01:	c3                   	ret    
  return 0; /* OK */
  803f02:	b8 00 00 00 00       	mov    $0x0,%eax
  803f07:	c3                   	ret    
    if(chunkLength != 2) return 30;
  803f08:	b8 1e 00 00 00       	mov    $0x1e,%eax
  803f0d:	c3                   	ret    
  else return 42; /*error: tRNS chunk not allowed for other color models*/
  803f0e:	b8 2a 00 00 00       	mov    $0x2a,%eax
}
  803f13:	c3                   	ret    

0000000000803f14 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
  if(info->color.colortype == LCT_PALETTE) {
  803f14:	8b 47 10             	mov    0x10(%rdi),%eax
  803f17:	83 f8 03             	cmp    $0x3,%eax
  803f1a:	74 2c                	je     803f48 <readChunk_bKGD+0x34>
    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;

    info->background_defined = 1;
    info->background_r = info->background_g = info->background_b = data[0];
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
  803f1c:	83 e0 fb             	and    $0xfffffffb,%eax
  803f1f:	75 59                	jne    803f7a <readChunk_bKGD+0x66>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
  803f21:	48 83 fa 02          	cmp    $0x2,%rdx
  803f25:	0f 85 9b 00 00 00    	jne    803fc6 <readChunk_bKGD+0xb2>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
  803f2b:	c7 47 38 01 00 00 00 	movl   $0x1,0x38(%rdi)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
  803f32:	0f b6 16             	movzbl (%rsi),%edx
  803f35:	c1 e2 08             	shl    $0x8,%edx
  803f38:	0f b6 4e 01          	movzbl 0x1(%rsi),%ecx
  803f3c:	01 ca                	add    %ecx,%edx
  803f3e:	89 57 44             	mov    %edx,0x44(%rdi)
  803f41:	89 57 40             	mov    %edx,0x40(%rdi)
  803f44:	89 57 3c             	mov    %edx,0x3c(%rdi)
  803f47:	c3                   	ret    
    if(chunkLength != 1) return 43;
  803f48:	b8 2b 00 00 00       	mov    $0x2b,%eax
  803f4d:	48 83 fa 01          	cmp    $0x1,%rdx
  803f51:	75 7e                	jne    803fd1 <readChunk_bKGD+0xbd>
    if(data[0] >= info->color.palettesize) return 103;
  803f53:	0f b6 16             	movzbl (%rsi),%edx
  803f56:	b8 67 00 00 00       	mov    $0x67,%eax
  803f5b:	48 3b 57 20          	cmp    0x20(%rdi),%rdx
  803f5f:	73 70                	jae    803fd1 <readChunk_bKGD+0xbd>
    info->background_defined = 1;
  803f61:	c7 47 38 01 00 00 00 	movl   $0x1,0x38(%rdi)
    info->background_r = info->background_g = info->background_b = data[0];
  803f68:	0f b6 06             	movzbl (%rsi),%eax
  803f6b:	89 47 44             	mov    %eax,0x44(%rdi)
  803f6e:	89 47 40             	mov    %eax,0x40(%rdi)
  803f71:	89 47 3c             	mov    %eax,0x3c(%rdi)
    info->background_r = 256u * data[0] + data[1];
    info->background_g = 256u * data[2] + data[3];
    info->background_b = 256u * data[4] + data[5];
  }

  return 0; /* OK */
  803f74:	b8 00 00 00 00       	mov    $0x0,%eax
  803f79:	c3                   	ret    
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
  803f7a:	83 f8 02             	cmp    $0x2,%eax
  803f7d:	75 4d                	jne    803fcc <readChunk_bKGD+0xb8>
    if(chunkLength != 6) return 45;
  803f7f:	b8 2d 00 00 00       	mov    $0x2d,%eax
  803f84:	48 83 fa 06          	cmp    $0x6,%rdx
  803f88:	75 47                	jne    803fd1 <readChunk_bKGD+0xbd>
    info->background_defined = 1;
  803f8a:	c7 47 38 01 00 00 00 	movl   $0x1,0x38(%rdi)
    info->background_r = 256u * data[0] + data[1];
  803f91:	0f b6 06             	movzbl (%rsi),%eax
  803f94:	c1 e0 08             	shl    $0x8,%eax
  803f97:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
  803f9b:	01 d0                	add    %edx,%eax
  803f9d:	89 47 3c             	mov    %eax,0x3c(%rdi)
    info->background_g = 256u * data[2] + data[3];
  803fa0:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
  803fa4:	c1 e0 08             	shl    $0x8,%eax
  803fa7:	0f b6 56 03          	movzbl 0x3(%rsi),%edx
  803fab:	01 d0                	add    %edx,%eax
  803fad:	89 47 40             	mov    %eax,0x40(%rdi)
    info->background_b = 256u * data[4] + data[5];
  803fb0:	0f b6 46 04          	movzbl 0x4(%rsi),%eax
  803fb4:	c1 e0 08             	shl    $0x8,%eax
  803fb7:	0f b6 56 05          	movzbl 0x5(%rsi),%edx
  803fbb:	01 d0                	add    %edx,%eax
  803fbd:	89 47 44             	mov    %eax,0x44(%rdi)
  return 0; /* OK */
  803fc0:	b8 00 00 00 00       	mov    $0x0,%eax
  803fc5:	c3                   	ret    
    if(chunkLength != 2) return 44;
  803fc6:	b8 2c 00 00 00       	mov    $0x2c,%eax
  803fcb:	c3                   	ret    
  return 0; /* OK */
  803fcc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803fd1:	c3                   	ret    

0000000000803fd2 <readChunk_pHYs>:

  return 0; /* OK */
}

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
  803fd2:	b8 4a 00 00 00       	mov    $0x4a,%eax
  803fd7:	48 83 fa 09          	cmp    $0x9,%rdx
  803fdb:	75 62                	jne    80403f <readChunk_pHYs+0x6d>

  info->phys_defined = 1;
  803fdd:	c7 87 a4 00 00 00 01 	movl   $0x1,0xa4(%rdi)
  803fe4:	00 00 00 
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
  803fe7:	0f b6 06             	movzbl (%rsi),%eax
  803fea:	c1 e0 08             	shl    $0x8,%eax
  803fed:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
  803ff1:	01 d0                	add    %edx,%eax
  803ff3:	c1 e0 08             	shl    $0x8,%eax
  803ff6:	0f b6 56 02          	movzbl 0x2(%rsi),%edx
  803ffa:	01 d0                	add    %edx,%eax
  803ffc:	c1 e0 08             	shl    $0x8,%eax
  803fff:	0f b6 56 03          	movzbl 0x3(%rsi),%edx
  804003:	01 d0                	add    %edx,%eax
  804005:	89 87 a8 00 00 00    	mov    %eax,0xa8(%rdi)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
  80400b:	0f b6 46 04          	movzbl 0x4(%rsi),%eax
  80400f:	c1 e0 08             	shl    $0x8,%eax
  804012:	0f b6 56 05          	movzbl 0x5(%rsi),%edx
  804016:	01 d0                	add    %edx,%eax
  804018:	c1 e0 08             	shl    $0x8,%eax
  80401b:	0f b6 56 06          	movzbl 0x6(%rsi),%edx
  80401f:	01 d0                	add    %edx,%eax
  804021:	c1 e0 08             	shl    $0x8,%eax
  804024:	0f b6 56 07          	movzbl 0x7(%rsi),%edx
  804028:	01 d0                	add    %edx,%eax
  80402a:	89 87 ac 00 00 00    	mov    %eax,0xac(%rdi)
  info->phys_unit = data[8];
  804030:	0f b6 46 08          	movzbl 0x8(%rsi),%eax
  804034:	89 87 b0 00 00 00    	mov    %eax,0xb0(%rdi)

  return 0; /* OK */
  80403a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80403f:	c3                   	ret    

0000000000804040 <readChunk_cHRM>:

  return 0; /* OK */
}

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
  804040:	b8 61 00 00 00       	mov    $0x61,%eax
  804045:	48 83 fa 20          	cmp    $0x20,%rdx
  804049:	0f 85 36 01 00 00    	jne    804185 <readChunk_cHRM+0x145>

  info->chrm_defined = 1;
  80404f:	c7 87 bc 00 00 00 01 	movl   $0x1,0xbc(%rdi)
  804056:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
  804059:	0f b6 06             	movzbl (%rsi),%eax
  80405c:	c1 e0 08             	shl    $0x8,%eax
  80405f:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
  804063:	01 d0                	add    %edx,%eax
  804065:	c1 e0 08             	shl    $0x8,%eax
  804068:	0f b6 56 02          	movzbl 0x2(%rsi),%edx
  80406c:	01 d0                	add    %edx,%eax
  80406e:	c1 e0 08             	shl    $0x8,%eax
  804071:	0f b6 56 03          	movzbl 0x3(%rsi),%edx
  804075:	01 d0                	add    %edx,%eax
  804077:	89 87 c0 00 00 00    	mov    %eax,0xc0(%rdi)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
  80407d:	0f b6 46 04          	movzbl 0x4(%rsi),%eax
  804081:	c1 e0 08             	shl    $0x8,%eax
  804084:	0f b6 56 05          	movzbl 0x5(%rsi),%edx
  804088:	01 d0                	add    %edx,%eax
  80408a:	c1 e0 08             	shl    $0x8,%eax
  80408d:	0f b6 56 06          	movzbl 0x6(%rsi),%edx
  804091:	01 d0                	add    %edx,%eax
  804093:	c1 e0 08             	shl    $0x8,%eax
  804096:	0f b6 56 07          	movzbl 0x7(%rsi),%edx
  80409a:	01 d0                	add    %edx,%eax
  80409c:	89 87 c4 00 00 00    	mov    %eax,0xc4(%rdi)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
  8040a2:	0f b6 46 08          	movzbl 0x8(%rsi),%eax
  8040a6:	c1 e0 08             	shl    $0x8,%eax
  8040a9:	0f b6 56 09          	movzbl 0x9(%rsi),%edx
  8040ad:	01 d0                	add    %edx,%eax
  8040af:	c1 e0 08             	shl    $0x8,%eax
  8040b2:	0f b6 56 0a          	movzbl 0xa(%rsi),%edx
  8040b6:	01 d0                	add    %edx,%eax
  8040b8:	c1 e0 08             	shl    $0x8,%eax
  8040bb:	0f b6 56 0b          	movzbl 0xb(%rsi),%edx
  8040bf:	01 d0                	add    %edx,%eax
  8040c1:	89 87 c8 00 00 00    	mov    %eax,0xc8(%rdi)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
  8040c7:	0f b6 46 0c          	movzbl 0xc(%rsi),%eax
  8040cb:	c1 e0 08             	shl    $0x8,%eax
  8040ce:	0f b6 56 0d          	movzbl 0xd(%rsi),%edx
  8040d2:	01 d0                	add    %edx,%eax
  8040d4:	c1 e0 08             	shl    $0x8,%eax
  8040d7:	0f b6 56 0e          	movzbl 0xe(%rsi),%edx
  8040db:	01 d0                	add    %edx,%eax
  8040dd:	c1 e0 08             	shl    $0x8,%eax
  8040e0:	0f b6 56 0f          	movzbl 0xf(%rsi),%edx
  8040e4:	01 d0                	add    %edx,%eax
  8040e6:	89 87 cc 00 00 00    	mov    %eax,0xcc(%rdi)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
  8040ec:	0f b6 46 10          	movzbl 0x10(%rsi),%eax
  8040f0:	c1 e0 08             	shl    $0x8,%eax
  8040f3:	0f b6 56 11          	movzbl 0x11(%rsi),%edx
  8040f7:	01 d0                	add    %edx,%eax
  8040f9:	c1 e0 08             	shl    $0x8,%eax
  8040fc:	0f b6 56 12          	movzbl 0x12(%rsi),%edx
  804100:	01 d0                	add    %edx,%eax
  804102:	c1 e0 08             	shl    $0x8,%eax
  804105:	0f b6 56 13          	movzbl 0x13(%rsi),%edx
  804109:	01 d0                	add    %edx,%eax
  80410b:	89 87 d0 00 00 00    	mov    %eax,0xd0(%rdi)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
  804111:	0f b6 46 14          	movzbl 0x14(%rsi),%eax
  804115:	c1 e0 08             	shl    $0x8,%eax
  804118:	0f b6 56 15          	movzbl 0x15(%rsi),%edx
  80411c:	01 d0                	add    %edx,%eax
  80411e:	c1 e0 08             	shl    $0x8,%eax
  804121:	0f b6 56 16          	movzbl 0x16(%rsi),%edx
  804125:	01 d0                	add    %edx,%eax
  804127:	c1 e0 08             	shl    $0x8,%eax
  80412a:	0f b6 56 17          	movzbl 0x17(%rsi),%edx
  80412e:	01 d0                	add    %edx,%eax
  804130:	89 87 d4 00 00 00    	mov    %eax,0xd4(%rdi)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
  804136:	0f b6 46 18          	movzbl 0x18(%rsi),%eax
  80413a:	c1 e0 08             	shl    $0x8,%eax
  80413d:	0f b6 56 19          	movzbl 0x19(%rsi),%edx
  804141:	01 d0                	add    %edx,%eax
  804143:	c1 e0 08             	shl    $0x8,%eax
  804146:	0f b6 56 1a          	movzbl 0x1a(%rsi),%edx
  80414a:	01 d0                	add    %edx,%eax
  80414c:	c1 e0 08             	shl    $0x8,%eax
  80414f:	0f b6 56 1b          	movzbl 0x1b(%rsi),%edx
  804153:	01 d0                	add    %edx,%eax
  804155:	89 87 d8 00 00 00    	mov    %eax,0xd8(%rdi)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
  80415b:	0f b6 46 1c          	movzbl 0x1c(%rsi),%eax
  80415f:	c1 e0 08             	shl    $0x8,%eax
  804162:	0f b6 56 1d          	movzbl 0x1d(%rsi),%edx
  804166:	01 d0                	add    %edx,%eax
  804168:	c1 e0 08             	shl    $0x8,%eax
  80416b:	0f b6 56 1e          	movzbl 0x1e(%rsi),%edx
  80416f:	01 d0                	add    %edx,%eax
  804171:	c1 e0 08             	shl    $0x8,%eax
  804174:	0f b6 56 1f          	movzbl 0x1f(%rsi),%edx
  804178:	01 d0                	add    %edx,%eax
  80417a:	89 87 dc 00 00 00    	mov    %eax,0xdc(%rdi)

  return 0; /* OK */
  804180:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804185:	c3                   	ret    

0000000000804186 <filterScanline>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
  size_t i;
  switch(filterType) {
  804186:	41 80 f9 04          	cmp    $0x4,%r9b
  80418a:	0f 87 56 02 00 00    	ja     8043e6 <filterScanline+0x260>
                           size_t length, size_t bytewidth, unsigned char filterType) {
  804190:	55                   	push   %rbp
  804191:	48 89 e5             	mov    %rsp,%rbp
  804194:	41 57                	push   %r15
  804196:	41 56                	push   %r14
  804198:	41 55                	push   %r13
  80419a:	41 54                	push   %r12
  80419c:	53                   	push   %rbx
  80419d:	48 83 ec 18          	sub    $0x18,%rsp
  8041a1:	49 89 fd             	mov    %rdi,%r13
  8041a4:	48 89 f3             	mov    %rsi,%rbx
  8041a7:	49 89 d7             	mov    %rdx,%r15
  8041aa:	49 89 ce             	mov    %rcx,%r14
  8041ad:	4d 89 c4             	mov    %r8,%r12
  switch(filterType) {
  8041b0:	45 0f b6 c9          	movzbl %r9b,%r9d
  8041b4:	48 b8 b8 1b 81 00 00 	movabs $0x811bb8,%rax
  8041bb:	00 00 00 
  8041be:	42 ff 24 c8          	jmp    *(%rax,%r9,8)
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
      break;
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
  8041c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8041c7:	4d 85 c0             	test   %r8,%r8
  8041ca:	74 12                	je     8041de <filterScanline+0x58>
  8041cc:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  8041d0:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  8041d5:	48 83 c0 01          	add    $0x1,%rax
  8041d9:	49 39 c4             	cmp    %rax,%r12
  8041dc:	75 ee                	jne    8041cc <filterScanline+0x46>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
  8041de:	4d 39 f4             	cmp    %r14,%r12
  8041e1:	73 3c                	jae    80421f <filterScanline+0x99>
  8041e3:	4c 89 e0             	mov    %r12,%rax
  8041e6:	48 89 d9             	mov    %rbx,%rcx
  8041e9:	4c 29 e1             	sub    %r12,%rcx
  8041ec:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  8041f0:	2a 14 01             	sub    (%rcx,%rax,1),%dl
  8041f3:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  8041f8:	48 83 c0 01          	add    $0x1,%rax
  8041fc:	49 39 c6             	cmp    %rax,%r14
  8041ff:	75 eb                	jne    8041ec <filterScanline+0x66>
  804201:	eb 1c                	jmp    80421f <filterScanline+0x99>
      for(i = 0; i != length; ++i) out[i] = scanline[i];
  804203:	48 85 c9             	test   %rcx,%rcx
  804206:	74 17                	je     80421f <filterScanline+0x99>
  804208:	b8 00 00 00 00       	mov    $0x0,%eax
  80420d:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  804211:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  804216:	48 83 c0 01          	add    $0x1,%rax
  80421a:	49 39 c6             	cmp    %rax,%r14
  80421d:	75 ee                	jne    80420d <filterScanline+0x87>
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
    default: return; /*nonexistent filter type given*/
  }
}
  80421f:	48 83 c4 18          	add    $0x18,%rsp
  804223:	5b                   	pop    %rbx
  804224:	41 5c                	pop    %r12
  804226:	41 5d                	pop    %r13
  804228:	41 5e                	pop    %r14
  80422a:	41 5f                	pop    %r15
  80422c:	5d                   	pop    %rbp
  80422d:	c3                   	ret    
      if(prevline) {
  80422e:	48 85 d2             	test   %rdx,%rdx
  804231:	74 22                	je     804255 <filterScanline+0xcf>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
  804233:	48 85 c9             	test   %rcx,%rcx
  804236:	74 e7                	je     80421f <filterScanline+0x99>
  804238:	b8 00 00 00 00       	mov    $0x0,%eax
  80423d:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  804241:	41 2a 14 07          	sub    (%r15,%rax,1),%dl
  804245:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  80424a:	48 83 c0 01          	add    $0x1,%rax
  80424e:	49 39 c6             	cmp    %rax,%r14
  804251:	75 ea                	jne    80423d <filterScanline+0xb7>
  804253:	eb ca                	jmp    80421f <filterScanline+0x99>
        for(i = 0; i != length; ++i) out[i] = scanline[i];
  804255:	b8 00 00 00 00       	mov    $0x0,%eax
  80425a:	48 85 c9             	test   %rcx,%rcx
  80425d:	74 c0                	je     80421f <filterScanline+0x99>
  80425f:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  804263:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  804268:	48 83 c0 01          	add    $0x1,%rax
  80426c:	49 39 c6             	cmp    %rax,%r14
  80426f:	75 ee                	jne    80425f <filterScanline+0xd9>
  804271:	eb ac                	jmp    80421f <filterScanline+0x99>
      if(prevline) {
  804273:	48 85 d2             	test   %rdx,%rdx
  804276:	74 5d                	je     8042d5 <filterScanline+0x14f>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
  804278:	4d 85 c0             	test   %r8,%r8
  80427b:	74 20                	je     80429d <filterScanline+0x117>
  80427d:	b8 00 00 00 00       	mov    $0x0,%eax
  804282:	41 0f b6 0c 07       	movzbl (%r15,%rax,1),%ecx
  804287:	d0 e9                	shr    %cl
  804289:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  80428d:	29 ca                	sub    %ecx,%edx
  80428f:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  804294:	48 83 c0 01          	add    $0x1,%rax
  804298:	49 39 c4             	cmp    %rax,%r12
  80429b:	75 e5                	jne    804282 <filterScanline+0xfc>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
  80429d:	4d 39 f4             	cmp    %r14,%r12
  8042a0:	0f 83 79 ff ff ff    	jae    80421f <filterScanline+0x99>
  8042a6:	4c 89 e0             	mov    %r12,%rax
  8042a9:	48 89 de             	mov    %rbx,%rsi
  8042ac:	4c 29 e6             	sub    %r12,%rsi
  8042af:	0f b6 14 06          	movzbl (%rsi,%rax,1),%edx
  8042b3:	41 0f b6 0c 07       	movzbl (%r15,%rax,1),%ecx
  8042b8:	01 ca                	add    %ecx,%edx
  8042ba:	d1 fa                	sar    %edx
  8042bc:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx
  8042c0:	29 d1                	sub    %edx,%ecx
  8042c2:	41 88 4c 05 00       	mov    %cl,0x0(%r13,%rax,1)
  8042c7:	48 83 c0 01          	add    $0x1,%rax
  8042cb:	49 39 c6             	cmp    %rax,%r14
  8042ce:	75 df                	jne    8042af <filterScanline+0x129>
  8042d0:	e9 4a ff ff ff       	jmp    80421f <filterScanline+0x99>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
  8042d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8042da:	4d 85 c0             	test   %r8,%r8
  8042dd:	74 12                	je     8042f1 <filterScanline+0x16b>
  8042df:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  8042e3:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  8042e8:	48 83 c0 01          	add    $0x1,%rax
  8042ec:	49 39 c4             	cmp    %rax,%r12
  8042ef:	75 ee                	jne    8042df <filterScanline+0x159>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
  8042f1:	4d 39 f4             	cmp    %r14,%r12
  8042f4:	0f 83 25 ff ff ff    	jae    80421f <filterScanline+0x99>
  8042fa:	4c 89 e0             	mov    %r12,%rax
  8042fd:	48 89 de             	mov    %rbx,%rsi
  804300:	4c 29 e6             	sub    %r12,%rsi
  804303:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
  804307:	d0 e9                	shr    %cl
  804309:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  80430d:	29 ca                	sub    %ecx,%edx
  80430f:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  804314:	48 83 c0 01          	add    $0x1,%rax
  804318:	49 39 c6             	cmp    %rax,%r14
  80431b:	75 e6                	jne    804303 <filterScanline+0x17d>
  80431d:	e9 fd fe ff ff       	jmp    80421f <filterScanline+0x99>
      if(prevline) {
  804322:	48 85 d2             	test   %rdx,%rdx
  804325:	74 77                	je     80439e <filterScanline+0x218>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
  804327:	4d 85 c0             	test   %r8,%r8
  80432a:	74 1b                	je     804347 <filterScanline+0x1c1>
  80432c:	b8 00 00 00 00       	mov    $0x0,%eax
  804331:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  804335:	41 2a 14 07          	sub    (%r15,%rax,1),%dl
  804339:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  80433e:	48 83 c0 01          	add    $0x1,%rax
  804342:	49 39 c4             	cmp    %rax,%r12
  804345:	75 ea                	jne    804331 <filterScanline+0x1ab>
        for(i = bytewidth; i < length; ++i) {
  804347:	4d 39 f4             	cmp    %r14,%r12
  80434a:	0f 83 cf fe ff ff    	jae    80421f <filterScanline+0x99>
  804350:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  804357:	00 
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
  804358:	42 0f b6 04 23       	movzbl (%rbx,%r12,1),%eax
  80435d:	88 45 c7             	mov    %al,-0x39(%rbp)
  804360:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804364:	41 0f b6 14 07       	movzbl (%r15,%rax,1),%edx
  804369:	43 0f b6 34 27       	movzbl (%r15,%r12,1),%esi
  80436e:	0f b6 3c 03          	movzbl (%rbx,%rax,1),%edi
  804372:	48 b9 78 35 80 00 00 	movabs $0x803578,%rcx
  804379:	00 00 00 
  80437c:	ff d1                	call   *%rcx
  80437e:	89 c2                	mov    %eax,%edx
  804380:	0f b6 7d c7          	movzbl -0x39(%rbp),%edi
  804384:	29 d7                	sub    %edx,%edi
  804386:	43 88 7c 25 00       	mov    %dil,0x0(%r13,%r12,1)
        for(i = bytewidth; i < length; ++i) {
  80438b:	49 83 c4 01          	add    $0x1,%r12
  80438f:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  804394:	4d 39 e6             	cmp    %r12,%r14
  804397:	75 bf                	jne    804358 <filterScanline+0x1d2>
  804399:	e9 81 fe ff ff       	jmp    80421f <filterScanline+0x99>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
  80439e:	b8 00 00 00 00       	mov    $0x0,%eax
  8043a3:	4d 85 c0             	test   %r8,%r8
  8043a6:	74 12                	je     8043ba <filterScanline+0x234>
  8043a8:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  8043ac:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  8043b1:	48 83 c0 01          	add    $0x1,%rax
  8043b5:	49 39 c4             	cmp    %rax,%r12
  8043b8:	75 ee                	jne    8043a8 <filterScanline+0x222>
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
  8043ba:	4d 39 f4             	cmp    %r14,%r12
  8043bd:	0f 83 5c fe ff ff    	jae    80421f <filterScanline+0x99>
  8043c3:	4c 89 e0             	mov    %r12,%rax
  8043c6:	48 89 d9             	mov    %rbx,%rcx
  8043c9:	4c 29 e1             	sub    %r12,%rcx
  8043cc:	0f b6 14 03          	movzbl (%rbx,%rax,1),%edx
  8043d0:	2a 14 01             	sub    (%rcx,%rax,1),%dl
  8043d3:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  8043d8:	48 83 c0 01          	add    $0x1,%rax
  8043dc:	49 39 c6             	cmp    %rax,%r14
  8043df:	75 eb                	jne    8043cc <filterScanline+0x246>
  8043e1:	e9 39 fe ff ff       	jmp    80421f <filterScanline+0x99>
  8043e6:	c3                   	ret    

00000000008043e7 <addPaddingBits>:

  return error;
}

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
  8043e7:	55                   	push   %rbp
  8043e8:	48 89 e5             	mov    %rsp,%rbp
  8043eb:	41 57                	push   %r15
  8043ed:	41 56                	push   %r14
  8043ef:	41 55                	push   %r13
  8043f1:	41 54                	push   %r12
  8043f3:	53                   	push   %rbx
  8043f4:	48 83 ec 38          	sub    $0x38,%rsp
  8043f8:	49 89 fc             	mov    %rdi,%r12
  8043fb:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8043ff:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  804403:	44 89 45 a8          	mov    %r8d,-0x58(%rbp)
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  804407:	48 29 ca             	sub    %rcx,%rdx
  80440a:	49 89 d6             	mov    %rdx,%r14
  size_t obp = 0, ibp = 0; /*bit pointers*/
  80440d:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  804414:	00 
  804415:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80441c:	00 
  for(y = 0; y != h; ++y) {
  80441d:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%rbp)
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
      unsigned char bit = readBitFromReversedStream(&ibp, in);
  804424:	49 bf 78 2d 80 00 00 	movabs $0x802d78,%r15
  80442b:	00 00 00 
      setBitOfReversedStream(&obp, out, bit);
  80442e:	49 bd 00 2e 80 00 00 	movabs $0x802e00,%r13
  804435:	00 00 00 
  for(y = 0; y != h; ++y) {
  804438:	45 85 c0             	test   %r8d,%r8d
  80443b:	75 5f                	jne    80449c <addPaddingBits+0xb5>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
  80443d:	48 83 c4 38          	add    $0x38,%rsp
  804441:	5b                   	pop    %rbx
  804442:	41 5c                	pop    %r12
  804444:	41 5d                	pop    %r13
  804446:	41 5e                	pop    %r14
  804448:	41 5f                	pop    %r15
  80444a:	5d                   	pop    %rbp
  80444b:	c3                   	ret    
      unsigned char bit = readBitFromReversedStream(&ibp, in);
  80444c:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804450:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
  804454:	41 ff d7             	call   *%r15
      setBitOfReversedStream(&obp, out, bit);
  804457:	0f b6 d0             	movzbl %al,%edx
  80445a:	4c 89 e6             	mov    %r12,%rsi
  80445d:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804461:	41 ff d5             	call   *%r13
    for(x = 0; x < ilinebits; ++x) {
  804464:	48 83 c3 01          	add    $0x1,%rbx
  804468:	48 39 5d b8          	cmp    %rbx,-0x48(%rbp)
  80446c:	75 de                	jne    80444c <addPaddingBits+0x65>
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  80446e:	4d 85 f6             	test   %r14,%r14
  804471:	74 1d                	je     804490 <addPaddingBits+0xa9>
  804473:	bb 00 00 00 00       	mov    $0x0,%ebx
  804478:	ba 00 00 00 00       	mov    $0x0,%edx
  80447d:	4c 89 e6             	mov    %r12,%rsi
  804480:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804484:	41 ff d5             	call   *%r13
  804487:	48 83 c3 01          	add    $0x1,%rbx
  80448b:	49 39 de             	cmp    %rbx,%r14
  80448e:	75 e8                	jne    804478 <addPaddingBits+0x91>
  for(y = 0; y != h; ++y) {
  804490:	83 45 ac 01          	addl   $0x1,-0x54(%rbp)
  804494:	8b 45 ac             	mov    -0x54(%rbp),%eax
  804497:	39 45 a8             	cmp    %eax,-0x58(%rbp)
  80449a:	74 a1                	je     80443d <addPaddingBits+0x56>
    for(x = 0; x < ilinebits; ++x) {
  80449c:	bb 00 00 00 00       	mov    $0x0,%ebx
  8044a1:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8044a6:	75 a4                	jne    80444c <addPaddingBits+0x65>
  8044a8:	eb c4                	jmp    80446e <addPaddingBits+0x87>

00000000008044aa <color_tree_init>:
static void color_tree_init(ColorTree* tree) {
  8044aa:	55                   	push   %rbp
  8044ab:	48 89 e5             	mov    %rsp,%rbp
  8044ae:	53                   	push   %rbx
  8044af:	48 83 ec 08          	sub    $0x8,%rsp
  8044b3:	48 89 fb             	mov    %rdi,%rbx
  memset(dst, value, num);
  8044b6:	ba 80 00 00 00       	mov    $0x80,%edx
  8044bb:	be 00 00 00 00       	mov    $0x0,%esi
  8044c0:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  8044c7:	00 00 00 
  8044ca:	ff d0                	call   *%rax
  tree->index = -1;
  8044cc:	c7 83 80 00 00 00 ff 	movl   $0xffffffff,0x80(%rbx)
  8044d3:	ff ff ff 
}
  8044d6:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8044da:	c9                   	leave  
  8044db:	c3                   	ret    

00000000008044dc <huffmanDecodeSymbol>:
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
  8044dc:	49 89 f0             	mov    %rsi,%r8
  return reader->buffer & ((1u << nbits) - 1u);
  8044df:	8b 47 20             	mov    0x20(%rdi),%eax
  unsigned short l = codetree->table_len[code];
  8044e2:	89 c2                	mov    %eax,%edx
  8044e4:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8044ea:	48 8b 4e 18          	mov    0x18(%rsi),%rcx
  8044ee:	0f b6 0c 11          	movzbl (%rcx,%rdx,1),%ecx
  unsigned short value = codetree->table_value[code];
  8044f2:	48 8b 76 20          	mov    0x20(%rsi),%rsi
  8044f6:	44 0f b7 0c 56       	movzwl (%rsi,%rdx,2),%r9d
  if(l <= FIRSTBITS) {
  8044fb:	80 f9 09             	cmp    $0x9,%cl
  8044fe:	77 11                	ja     804511 <huffmanDecodeSymbol+0x35>
  reader->buffer >>= nbits;
  804500:	d3 e8                	shr    %cl,%eax
  804502:	89 47 20             	mov    %eax,0x20(%rdi)
    advanceBits(reader, l);
  804505:	0f b6 c9             	movzbl %cl,%ecx
  reader->bp += nbits;
  804508:	48 01 4f 18          	add    %rcx,0x18(%rdi)
    return value;
  80450c:	41 0f b7 c1          	movzwl %r9w,%eax
  804510:	c3                   	ret    
  reader->buffer >>= nbits;
  804511:	c1 e8 09             	shr    $0x9,%eax
  804514:	89 47 20             	mov    %eax,0x20(%rdi)
  reader->bp += nbits;
  804517:	48 8b 77 18          	mov    0x18(%rdi),%rsi
  80451b:	4c 8d 56 09          	lea    0x9(%rsi),%r10
  80451f:	4c 89 57 18          	mov    %r10,0x18(%rdi)
    index2 = value + peekBits(reader, l - FIRSTBITS);
  804523:	83 e9 09             	sub    $0x9,%ecx
  return reader->buffer & ((1u << nbits) - 1u);
  804526:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80452b:	d3 e6                	shl    %cl,%esi
  80452d:	89 f2                	mov    %esi,%edx
  80452f:	f7 d2                	not    %edx
  804531:	21 c2                	and    %eax,%edx
    index2 = value + peekBits(reader, l - FIRSTBITS);
  804533:	45 0f b7 c9          	movzwl %r9w,%r9d
  804537:	44 01 ca             	add    %r9d,%edx
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
  80453a:	89 d2                	mov    %edx,%edx
  80453c:	49 8b 48 18          	mov    0x18(%r8),%rcx
  804540:	0f b6 0c 11          	movzbl (%rcx,%rdx,1),%ecx
  804544:	83 e9 09             	sub    $0x9,%ecx
  reader->buffer >>= nbits;
  804547:	d3 e8                	shr    %cl,%eax
  804549:	89 47 20             	mov    %eax,0x20(%rdi)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
  80454c:	89 c9                	mov    %ecx,%ecx
  reader->bp += nbits;
  80454e:	49 01 ca             	add    %rcx,%r10
  804551:	4c 89 57 18          	mov    %r10,0x18(%rdi)
    return codetree->table_value[index2];
  804555:	49 8b 40 20          	mov    0x20(%r8),%rax
  804559:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
}
  80455d:	c3                   	ret    

000000000080455e <LodePNGBitReader_init>:
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
  80455e:	48 89 d1             	mov    %rdx,%rcx
  reader->data = data;
  804561:	48 89 37             	mov    %rsi,(%rdi)
  reader->size = size;
  804564:	48 89 57 08          	mov    %rdx,0x8(%rdi)
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
  804568:	48 8d 34 d5 00 00 00 	lea    0x0(,%rdx,8),%rsi
  80456f:	00 
  804570:	48 89 77 10          	mov    %rsi,0x10(%rdi)
  return (a != 0 && *result / a != b);
  804574:	48 85 d2             	test   %rdx,%rdx
  804577:	74 27                	je     8045a0 <LodePNGBitReader_init+0x42>
  804579:	48 89 f0             	mov    %rsi,%rax
  80457c:	ba 00 00 00 00       	mov    $0x0,%edx
  804581:	48 f7 f1             	div    %rcx
  804584:	48 89 c1             	mov    %rax,%rcx
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
  804587:	b8 69 00 00 00       	mov    $0x69,%eax
  return (a != 0 && *result / a != b);
  80458c:	48 83 f9 08          	cmp    $0x8,%rcx
  804590:	74 01                	je     804593 <LodePNGBitReader_init+0x35>
}
  804592:	c3                   	ret    
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
  804593:	48 83 fe bf          	cmp    $0xffffffffffffffbf,%rsi
  804597:	76 07                	jbe    8045a0 <LodePNGBitReader_init+0x42>
  804599:	b8 69 00 00 00       	mov    $0x69,%eax
  80459e:	eb f2                	jmp    804592 <LodePNGBitReader_init+0x34>
  reader->bp = 0;
  8045a0:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  8045a7:	00 
  reader->buffer = 0;
  8045a8:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%rdi)
  return 0; /*ok*/
  8045af:	b8 00 00 00 00       	mov    $0x0,%eax
  8045b4:	c3                   	ret    

00000000008045b5 <lodepng_reallocate>:
static void* lodepng_reallocate(void* ptr, size_t old_size, size_t new_size) {
  8045b5:	55                   	push   %rbp
  8045b6:	48 89 e5             	mov    %rsp,%rbp
  8045b9:	41 55                	push   %r13
  8045bb:	41 54                	push   %r12
  8045bd:	53                   	push   %rbx
  8045be:	48 83 ec 08          	sub    $0x8,%rsp
  8045c2:	49 89 fc             	mov    %rdi,%r12
  8045c5:	49 89 f5             	mov    %rsi,%r13
  8045c8:	48 89 d7             	mov    %rdx,%rdi
  return jos_malloc(new_size);
  8045cb:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  8045d2:	00 00 00 
  8045d5:	ff d0                	call   *%rax
  8045d7:	48 89 c3             	mov    %rax,%rbx
  memcpy(new_ptr, ptr, old_size);
  8045da:	4c 89 ea             	mov    %r13,%rdx
  8045dd:	4c 89 e6             	mov    %r12,%rsi
  8045e0:	48 89 c7             	mov    %rax,%rdi
  8045e3:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  8045ea:	00 00 00 
  8045ed:	ff d0                	call   *%rax
  jos_free(ptr);
  8045ef:	4c 89 e7             	mov    %r12,%rdi
  8045f2:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8045f9:	00 00 00 
  8045fc:	ff d0                	call   *%rax
}
  8045fe:	48 89 d8             	mov    %rbx,%rax
  804601:	48 83 c4 08          	add    $0x8,%rsp
  804605:	5b                   	pop    %rbx
  804606:	41 5c                	pop    %r12
  804608:	41 5d                	pop    %r13
  80460a:	5d                   	pop    %rbp
  80460b:	c3                   	ret    

000000000080460c <ucvector_resize>:
static unsigned ucvector_resize(ucvector* p, size_t size) {
  80460c:	55                   	push   %rbp
  80460d:	48 89 e5             	mov    %rsp,%rbp
  804610:	41 55                	push   %r13
  804612:	41 54                	push   %r12
  804614:	53                   	push   %rbx
  804615:	48 83 ec 08          	sub    $0x8,%rsp
  804619:	49 89 fc             	mov    %rdi,%r12
  80461c:	48 89 f3             	mov    %rsi,%rbx
  if(size > p->allocsize) {
  80461f:	48 8b 77 10          	mov    0x10(%rdi),%rsi
  804623:	48 39 de             	cmp    %rbx,%rsi
  804626:	73 34                	jae    80465c <ucvector_resize+0x50>
    size_t newsize = (size > p->allocsize * 2u) ? size : ((size * 3u) >> 1u);
  804628:	48 8d 04 36          	lea    (%rsi,%rsi,1),%rax
  80462c:	49 89 dd             	mov    %rbx,%r13
  80462f:	48 39 d8             	cmp    %rbx,%rax
  804632:	72 07                	jb     80463b <ucvector_resize+0x2f>
  804634:	4c 8d 2c 5b          	lea    (%rbx,%rbx,2),%r13
  804638:	49 d1 ed             	shr    %r13
    void* data = lodepng_reallocate(p->data, p->allocsize, newsize);
  80463b:	4c 89 ea             	mov    %r13,%rdx
  80463e:	49 8b 3c 24          	mov    (%r12),%rdi
  804642:	48 b8 b5 45 80 00 00 	movabs $0x8045b5,%rax
  804649:	00 00 00 
  80464c:	ff d0                	call   *%rax
    if(data) {
  80464e:	48 85 c0             	test   %rax,%rax
  804651:	74 1e                	je     804671 <ucvector_resize+0x65>
      p->allocsize = newsize;
  804653:	4d 89 6c 24 10       	mov    %r13,0x10(%r12)
      p->data = (unsigned char*)data;
  804658:	49 89 04 24          	mov    %rax,(%r12)
  p->size = size;
  80465c:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
  return 1; /*success*/
  804661:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804666:	48 83 c4 08          	add    $0x8,%rsp
  80466a:	5b                   	pop    %rbx
  80466b:	41 5c                	pop    %r12
  80466d:	41 5d                	pop    %r13
  80466f:	5d                   	pop    %rbp
  804670:	c3                   	ret    
    else return 0; /*error: not enough memory*/
  804671:	b8 00 00 00 00       	mov    $0x0,%eax
  804676:	eb ee                	jmp    804666 <ucvector_resize+0x5a>

0000000000804678 <ucvector_push_back>:
static unsigned ucvector_push_back(ucvector* p, unsigned char c) {
  804678:	55                   	push   %rbp
  804679:	48 89 e5             	mov    %rsp,%rbp
  80467c:	41 54                	push   %r12
  80467e:	53                   	push   %rbx
  80467f:	48 89 fb             	mov    %rdi,%rbx
  804682:	41 89 f4             	mov    %esi,%r12d
  if(!ucvector_resize(p, p->size + 1)) return 0;
  804685:	48 8b 47 08          	mov    0x8(%rdi),%rax
  804689:	48 8d 70 01          	lea    0x1(%rax),%rsi
  80468d:	48 b8 0c 46 80 00 00 	movabs $0x80460c,%rax
  804694:	00 00 00 
  804697:	ff d0                	call   *%rax
  804699:	85 c0                	test   %eax,%eax
  80469b:	74 11                	je     8046ae <ucvector_push_back+0x36>
  p->data[p->size - 1] = c;
  80469d:	48 8b 13             	mov    (%rbx),%rdx
  8046a0:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8046a4:	44 88 64 02 ff       	mov    %r12b,-0x1(%rdx,%rax,1)
  return 1;
  8046a9:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8046ae:	5b                   	pop    %rbx
  8046af:	41 5c                	pop    %r12
  8046b1:	5d                   	pop    %rbp
  8046b2:	c3                   	ret    

00000000008046b3 <writeBits>:
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  8046b3:	55                   	push   %rbp
  8046b4:	48 89 e5             	mov    %rsp,%rbp
  8046b7:	41 57                	push   %r15
  8046b9:	41 56                	push   %r14
  8046bb:	41 55                	push   %r13
  8046bd:	41 54                	push   %r12
  8046bf:	53                   	push   %rbx
  8046c0:	48 83 ec 08          	sub    $0x8,%rsp
  8046c4:	48 89 fb             	mov    %rdi,%rbx
  8046c7:	41 89 f6             	mov    %esi,%r14d
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
  8046ca:	48 83 fa 01          	cmp    $0x1,%rdx
  8046ce:	74 1a                	je     8046ea <writeBits+0x37>
  8046d0:	49 89 d5             	mov    %rdx,%r13
    for(i = 0; i != nbits; ++i) {
  8046d3:	41 bc 00 00 00 00    	mov    $0x0,%r12d
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
  8046d9:	49 bf 78 46 80 00 00 	movabs $0x804678,%r15
  8046e0:	00 00 00 
    for(i = 0; i != nbits; ++i) {
  8046e3:	48 85 d2             	test   %rdx,%rdx
  8046e6:	75 79                	jne    804761 <writeBits+0xae>
  8046e8:	eb 23                	jmp    80470d <writeBits+0x5a>
    WRITEBIT(writer, value);
  8046ea:	f6 47 08 07          	testb  $0x7,0x8(%rdi)
  8046ee:	74 2c                	je     80471c <writeBits+0x69>
  8046f0:	48 8b 13             	mov    (%rbx),%rdx
  8046f3:	48 8b 42 08          	mov    0x8(%rdx),%rax
  8046f7:	48 8b 12             	mov    (%rdx),%rdx
  8046fa:	8b 4b 08             	mov    0x8(%rbx),%ecx
  8046fd:	83 e1 07             	and    $0x7,%ecx
  804700:	41 d3 e6             	shl    %cl,%r14d
  804703:	44 08 74 02 ff       	or     %r14b,-0x1(%rdx,%rax,1)
  804708:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
}
  80470d:	48 83 c4 08          	add    $0x8,%rsp
  804711:	5b                   	pop    %rbx
  804712:	41 5c                	pop    %r12
  804714:	41 5d                	pop    %r13
  804716:	41 5e                	pop    %r14
  804718:	41 5f                	pop    %r15
  80471a:	5d                   	pop    %rbp
  80471b:	c3                   	ret    
    WRITEBIT(writer, value);
  80471c:	be 00 00 00 00       	mov    $0x0,%esi
  804721:	48 8b 3f             	mov    (%rdi),%rdi
  804724:	48 b8 78 46 80 00 00 	movabs $0x804678,%rax
  80472b:	00 00 00 
  80472e:	ff d0                	call   *%rax
  804730:	eb be                	jmp    8046f0 <writeBits+0x3d>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
  804732:	48 8b 03             	mov    (%rbx),%rax
  804735:	48 8b 50 08          	mov    0x8(%rax),%rdx
  804739:	48 8b 30             	mov    (%rax),%rsi
  80473c:	44 89 f0             	mov    %r14d,%eax
  80473f:	44 89 e1             	mov    %r12d,%ecx
  804742:	d3 e8                	shr    %cl,%eax
  804744:	83 e0 01             	and    $0x1,%eax
  804747:	8b 4b 08             	mov    0x8(%rbx),%ecx
  80474a:	83 e1 07             	and    $0x7,%ecx
  80474d:	d3 e0                	shl    %cl,%eax
  80474f:	08 44 16 ff          	or     %al,-0x1(%rsi,%rdx,1)
  804753:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
    for(i = 0; i != nbits; ++i) {
  804758:	49 83 c4 01          	add    $0x1,%r12
  80475c:	4d 39 e5             	cmp    %r12,%r13
  80475f:	74 ac                	je     80470d <writeBits+0x5a>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
  804761:	f6 43 08 07          	testb  $0x7,0x8(%rbx)
  804765:	75 cb                	jne    804732 <writeBits+0x7f>
  804767:	be 00 00 00 00       	mov    $0x0,%esi
  80476c:	48 8b 3b             	mov    (%rbx),%rdi
  80476f:	41 ff d7             	call   *%r15
  804772:	eb be                	jmp    804732 <writeBits+0x7f>

0000000000804774 <writeBitsReversed>:
  for(i = 0; i != nbits; ++i) {
  804774:	48 85 d2             	test   %rdx,%rdx
  804777:	0f 84 84 00 00 00    	je     804801 <writeBitsReversed+0x8d>
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  80477d:	55                   	push   %rbp
  80477e:	48 89 e5             	mov    %rsp,%rbp
  804781:	41 57                	push   %r15
  804783:	41 56                	push   %r14
  804785:	41 55                	push   %r13
  804787:	41 54                	push   %r12
  804789:	53                   	push   %rbx
  80478a:	48 83 ec 08          	sub    $0x8,%rsp
  80478e:	48 89 fb             	mov    %rdi,%rbx
  804791:	41 89 f6             	mov    %esi,%r14d
  804794:	49 89 d5             	mov    %rdx,%r13
  for(i = 0; i != nbits; ++i) {
  804797:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
  80479d:	49 bf 78 46 80 00 00 	movabs $0x804678,%r15
  8047a4:	00 00 00 
  8047a7:	eb 36                	jmp    8047df <writeBitsReversed+0x6b>
  8047a9:	48 8b 03             	mov    (%rbx),%rax
  8047ac:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8047b0:	48 8b 30             	mov    (%rax),%rsi
  8047b3:	44 89 e9             	mov    %r13d,%ecx
  8047b6:	44 29 e1             	sub    %r12d,%ecx
  8047b9:	44 89 f0             	mov    %r14d,%eax
  8047bc:	d3 e8                	shr    %cl,%eax
  8047be:	83 e0 01             	and    $0x1,%eax
  8047c1:	8b 4b 08             	mov    0x8(%rbx),%ecx
  8047c4:	83 e1 07             	and    $0x7,%ecx
  8047c7:	d3 e0                	shl    %cl,%eax
  8047c9:	08 44 16 ff          	or     %al,-0x1(%rsi,%rdx,1)
  8047cd:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
  for(i = 0; i != nbits; ++i) {
  8047d2:	49 8d 44 24 01       	lea    0x1(%r12),%rax
  8047d7:	4d 39 ec             	cmp    %r13,%r12
  8047da:	74 16                	je     8047f2 <writeBitsReversed+0x7e>
  8047dc:	49 89 c4             	mov    %rax,%r12
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
  8047df:	f6 43 08 07          	testb  $0x7,0x8(%rbx)
  8047e3:	75 c4                	jne    8047a9 <writeBitsReversed+0x35>
  8047e5:	be 00 00 00 00       	mov    $0x0,%esi
  8047ea:	48 8b 3b             	mov    (%rbx),%rdi
  8047ed:	41 ff d7             	call   *%r15
  8047f0:	eb b7                	jmp    8047a9 <writeBitsReversed+0x35>
}
  8047f2:	48 83 c4 08          	add    $0x8,%rsp
  8047f6:	5b                   	pop    %rbx
  8047f7:	41 5c                	pop    %r12
  8047f9:	41 5d                	pop    %r13
  8047fb:	41 5e                	pop    %r14
  8047fd:	41 5f                	pop    %r15
  8047ff:	5d                   	pop    %rbp
  804800:	c3                   	ret    
  804801:	c3                   	ret    

0000000000804802 <writeLZ77data>:
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  804802:	55                   	push   %rbp
  804803:	48 89 e5             	mov    %rsp,%rbp
  804806:	41 57                	push   %r15
  804808:	41 56                	push   %r14
  80480a:	41 55                	push   %r13
  80480c:	41 54                	push   %r12
  80480e:	53                   	push   %rbx
  80480f:	48 83 ec 28          	sub    $0x28,%rsp
  804813:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  804817:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  for(i = 0; i != lz77_encoded->size; ++i) {
  80481b:	48 83 7e 08 00       	cmpq   $0x0,0x8(%rsi)
  804820:	0f 84 df 00 00 00    	je     804905 <writeLZ77data+0x103>
  804826:	49 89 f6             	mov    %rsi,%r14
  804829:	49 89 d7             	mov    %rdx,%r15
  80482c:	bb 00 00 00 00       	mov    $0x0,%ebx
  804831:	eb 0e                	jmp    804841 <writeLZ77data+0x3f>
  804833:	48 83 c3 01          	add    $0x1,%rbx
  804837:	49 39 5e 08          	cmp    %rbx,0x8(%r14)
  80483b:	0f 84 c4 00 00 00    	je     804905 <writeLZ77data+0x103>
    unsigned val = lz77_encoded->data[i];
  804841:	4c 8d 2c 9d 00 00 00 	lea    0x0(,%rbx,4),%r13
  804848:	00 
  804849:	49 8b 06             	mov    (%r14),%rax
  80484c:	44 8b 24 98          	mov    (%rax,%rbx,4),%r12d
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
  804850:	44 89 e0             	mov    %r12d,%eax
  804853:	49 8b 57 08          	mov    0x8(%r15),%rdx
  804857:	8b 14 82             	mov    (%rdx,%rax,4),%edx
  80485a:	49 8b 0f             	mov    (%r15),%rcx
  80485d:	8b 34 81             	mov    (%rcx,%rax,4),%esi
  804860:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804864:	48 b8 74 47 80 00 00 	movabs $0x804774,%rax
  80486b:	00 00 00 
  80486e:	ff d0                	call   *%rax
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
  804870:	41 81 fc 00 01 00 00 	cmp    $0x100,%r12d
  804877:	76 ba                	jbe    804833 <writeLZ77data+0x31>
      unsigned length_extra_bits = lz77_encoded->data[++i];
  804879:	49 8b 06             	mov    (%r14),%rax
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
  80487c:	42 8b 4c 28 08       	mov    0x8(%rax,%r13,1),%ecx
  804881:	48 bf a0 24 81 00 00 	movabs $0x8124a0,%rdi
  804888:	00 00 00 
  80488b:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  80488f:	8b 3c 8f             	mov    (%rdi,%rcx,4),%edi
  804892:	89 7d c4             	mov    %edi,-0x3c(%rbp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
  804895:	48 83 c3 03          	add    $0x3,%rbx
  804899:	42 8b 74 28 0c       	mov    0xc(%rax,%r13,1),%esi
  80489e:	89 75 c0             	mov    %esi,-0x40(%rbp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
  8048a1:	41 8d 94 24 ff fe ff 	lea    -0x101(%r12),%edx
  8048a8:	ff 
      writeBits(writer, length_extra_bits, n_length_extra_bits);
  8048a9:	49 b8 a0 25 81 00 00 	movabs $0x8125a0,%r8
  8048b0:	00 00 00 
  8048b3:	41 8b 14 90          	mov    (%r8,%rdx,4),%edx
  8048b7:	42 8b 74 28 04       	mov    0x4(%rax,%r13,1),%esi
  8048bc:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
  8048c0:	4c 89 ef             	mov    %r13,%rdi
  8048c3:	49 bc b3 46 80 00 00 	movabs $0x8046b3,%r12
  8048ca:	00 00 00 
  8048cd:	41 ff d4             	call   *%r12
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
  8048d0:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8048d4:	48 8b 47 08          	mov    0x8(%rdi),%rax
  8048d8:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8048dc:	8b 14 88             	mov    (%rax,%rcx,4),%edx
  8048df:	48 8b 07             	mov    (%rdi),%rax
  8048e2:	8b 34 88             	mov    (%rax,%rcx,4),%esi
  8048e5:	4c 89 ef             	mov    %r13,%rdi
  8048e8:	48 b8 74 47 80 00 00 	movabs $0x804774,%rax
  8048ef:	00 00 00 
  8048f2:	ff d0                	call   *%rax
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
  8048f4:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8048f7:	8b 75 c0             	mov    -0x40(%rbp),%esi
  8048fa:	4c 89 ef             	mov    %r13,%rdi
  8048fd:	41 ff d4             	call   *%r12
  804900:	e9 2e ff ff ff       	jmp    804833 <writeLZ77data+0x31>
}
  804905:	48 83 c4 28          	add    $0x28,%rsp
  804909:	5b                   	pop    %rbx
  80490a:	41 5c                	pop    %r12
  80490c:	41 5d                	pop    %r13
  80490e:	41 5e                	pop    %r14
  804910:	41 5f                	pop    %r15
  804912:	5d                   	pop    %rbp
  804913:	c3                   	ret    

0000000000804914 <uivector_resize>:
static unsigned uivector_resize(uivector* p, size_t size) {
  804914:	55                   	push   %rbp
  804915:	48 89 e5             	mov    %rsp,%rbp
  804918:	41 55                	push   %r13
  80491a:	41 54                	push   %r12
  80491c:	53                   	push   %rbx
  80491d:	48 83 ec 08          	sub    $0x8,%rsp
  804921:	48 89 fb             	mov    %rdi,%rbx
  804924:	49 89 f4             	mov    %rsi,%r12
  size_t allocsize = size * sizeof(unsigned);
  804927:	4c 8d 2c b5 00 00 00 	lea    0x0(,%rsi,4),%r13
  80492e:	00 
  if(allocsize > p->allocsize) {
  80492f:	48 8b 77 10          	mov    0x10(%rdi),%rsi
  804933:	4c 39 ee             	cmp    %r13,%rsi
  804936:	73 32                	jae    80496a <uivector_resize+0x56>
    size_t newsize = (allocsize > p->allocsize * 2u) ? allocsize : ((allocsize * 3u) >> 1u);
  804938:	48 8d 04 36          	lea    (%rsi,%rsi,1),%rax
  80493c:	4c 39 e8             	cmp    %r13,%rax
  80493f:	72 0b                	jb     80494c <uivector_resize+0x38>
  804941:	4f 8d 2c 64          	lea    (%r12,%r12,2),%r13
  804945:	49 c1 e5 02          	shl    $0x2,%r13
  804949:	49 d1 ed             	shr    %r13
    void* data = lodepng_reallocate(p->data, p->allocsize, newsize);
  80494c:	4c 89 ea             	mov    %r13,%rdx
  80494f:	48 8b 3b             	mov    (%rbx),%rdi
  804952:	48 b8 b5 45 80 00 00 	movabs $0x8045b5,%rax
  804959:	00 00 00 
  80495c:	ff d0                	call   *%rax
    if(data) {
  80495e:	48 85 c0             	test   %rax,%rax
  804961:	74 1b                	je     80497e <uivector_resize+0x6a>
      p->allocsize = newsize;
  804963:	4c 89 6b 10          	mov    %r13,0x10(%rbx)
      p->data = (unsigned*)data;
  804967:	48 89 03             	mov    %rax,(%rbx)
  p->size = size;
  80496a:	4c 89 63 08          	mov    %r12,0x8(%rbx)
  return 1; /*success*/
  80496e:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804973:	48 83 c4 08          	add    $0x8,%rsp
  804977:	5b                   	pop    %rbx
  804978:	41 5c                	pop    %r12
  80497a:	41 5d                	pop    %r13
  80497c:	5d                   	pop    %rbp
  80497d:	c3                   	ret    
    else return 0; /*error: not enough memory*/
  80497e:	b8 00 00 00 00       	mov    $0x0,%eax
  804983:	eb ee                	jmp    804973 <uivector_resize+0x5f>

0000000000804985 <uivector_push_back>:
static unsigned uivector_push_back(uivector* p, unsigned c) {
  804985:	55                   	push   %rbp
  804986:	48 89 e5             	mov    %rsp,%rbp
  804989:	41 54                	push   %r12
  80498b:	53                   	push   %rbx
  80498c:	48 89 fb             	mov    %rdi,%rbx
  80498f:	41 89 f4             	mov    %esi,%r12d
  if(!uivector_resize(p, p->size + 1)) return 0;
  804992:	48 8b 47 08          	mov    0x8(%rdi),%rax
  804996:	48 8d 70 01          	lea    0x1(%rax),%rsi
  80499a:	48 b8 14 49 80 00 00 	movabs $0x804914,%rax
  8049a1:	00 00 00 
  8049a4:	ff d0                	call   *%rax
  8049a6:	85 c0                	test   %eax,%eax
  8049a8:	74 11                	je     8049bb <uivector_push_back+0x36>
  p->data[p->size - 1] = c;
  8049aa:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  8049ae:	48 8b 03             	mov    (%rbx),%rax
  8049b1:	44 89 64 90 fc       	mov    %r12d,-0x4(%rax,%rdx,4)
  return 1;
  8049b6:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8049bb:	5b                   	pop    %rbx
  8049bc:	41 5c                	pop    %r12
  8049be:	5d                   	pop    %rbp
  8049bf:	c3                   	ret    

00000000008049c0 <encodeLZ77>:
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
  8049c0:	55                   	push   %rbp
  8049c1:	48 89 e5             	mov    %rsp,%rbp
  8049c4:	41 57                	push   %r15
  8049c6:	41 56                	push   %r14
  8049c8:	41 55                	push   %r13
  8049ca:	41 54                	push   %r12
  8049cc:	53                   	push   %rbx
  8049cd:	48 83 ec 78          	sub    $0x78,%rsp
  8049d1:	48 89 7d 80          	mov    %rdi,-0x80(%rbp)
  8049d5:	49 89 f5             	mov    %rsi,%r13
  8049d8:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  8049dc:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8049e0:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  8049e4:	44 89 4d 94          	mov    %r9d,-0x6c(%rbp)
  8049e8:	8b 45 18             	mov    0x18(%rbp),%eax
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
  8049eb:	41 81 f9 ff 1f 00 00 	cmp    $0x1fff,%r9d
  8049f2:	0f 87 80 00 00 00    	ja     804a78 <encodeLZ77+0xb8>
  8049f8:	44 89 cb             	mov    %r9d,%ebx
  8049fb:	c1 eb 03             	shr    $0x3,%ebx
  8049fe:	41 89 df             	mov    %ebx,%r15d
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
  804a01:	c7 85 6c ff ff ff 40 	movl   $0x40,-0x94(%rbp)
  804a08:	00 00 00 
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  804a0b:	8b 7d 94             	mov    -0x6c(%rbp),%edi
  804a0e:	8d 5f ff             	lea    -0x1(%rdi),%ebx
  804a11:	89 9d 7c ff ff ff    	mov    %ebx,-0x84(%rbp)
  804a17:	c7 45 9c 3c 00 00 00 	movl   $0x3c,-0x64(%rbp)
  804a1e:	81 fb ff 7f 00 00    	cmp    $0x7fff,%ebx
  804a24:	0f 87 a4 04 00 00    	ja     804ece <encodeLZ77+0x50e>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
  804a2a:	21 fb                	and    %edi,%ebx
  804a2c:	41 89 de             	mov    %ebx,%r14d
  804a2f:	89 5d 9c             	mov    %ebx,-0x64(%rbp)
  804a32:	0f 85 8f 04 00 00    	jne    804ec7 <encodeLZ77+0x507>
  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
  804a38:	3d 02 01 00 00       	cmp    $0x102,%eax
  804a3d:	ba 02 01 00 00       	mov    $0x102,%edx
  804a42:	0f 46 d0             	cmovbe %eax,%edx
  804a45:	89 55 98             	mov    %edx,-0x68(%rbp)
  for(pos = inpos; pos < insize; ++pos) {
  804a48:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804a4c:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  804a50:	0f 83 78 04 00 00    	jae    804ece <encodeLZ77+0x50e>
  unsigned lazylength = 0, lazyoffset = 0;
  804a56:	89 9d 68 ff ff ff    	mov    %ebx,-0x98(%rbp)
  804a5c:	89 9d 78 ff ff ff    	mov    %ebx,-0x88(%rbp)
  unsigned lazy = 0;
  804a62:	89 5d 90             	mov    %ebx,-0x70(%rbp)
  if(end > data + size) end = data + size;
  804a65:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
  804a69:	48 01 c3             	add    %rax,%rbx
  804a6c:	48 89 9d 70 ff ff ff 	mov    %rbx,-0x90(%rbp)
  804a73:	e9 ed 01 00 00       	jmp    804c65 <encodeLZ77+0x2a5>
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
  804a78:	44 8b 7d 94          	mov    -0x6c(%rbp),%r15d
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
  804a7c:	c7 85 6c ff ff ff 02 	movl   $0x102,-0x94(%rbp)
  804a83:	01 00 00 
  804a86:	eb 83                	jmp    804a0b <encodeLZ77+0x4b>
  data = start;
  804a88:	49 89 c6             	mov    %rax,%r14
  804a8b:	e9 4b 02 00 00       	jmp    804cdb <encodeLZ77+0x31b>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
  804a90:	44 89 f0             	mov    %r14d,%eax
  804a93:	48 03 45 c8          	add    -0x38(%rbp),%rax
  804a97:	48 3b 45 a0          	cmp    -0x60(%rbp),%rax
  804a9b:	77 0b                	ja     804aa8 <encodeLZ77+0xe8>
  804a9d:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804aa1:	80 7c 07 ff 00       	cmpb   $0x0,-0x1(%rdi,%rax,1)
  804aa6:	74 0a                	je     804ab2 <encodeLZ77+0xf2>
  804aa8:	41 83 ee 01          	sub    $0x1,%r14d
  804aac:	eb 04                	jmp    804ab2 <encodeLZ77+0xf2>
      numzeros = 0;
  804aae:	44 8b 75 9c          	mov    -0x64(%rbp),%r14d
    updateHashChain(hash, wpos, hashval, numzeros);
  804ab2:	41 0f b7 ce          	movzwl %r14w,%ecx
  804ab6:	8b 55 b8             	mov    -0x48(%rbp),%edx
  804ab9:	48 89 de             	mov    %rbx,%rsi
  804abc:	4c 89 ef             	mov    %r13,%rdi
  804abf:	48 b8 2e 2d 80 00 00 	movabs $0x802d2e,%rax
  804ac6:	00 00 00 
  804ac9:	ff d0                	call   *%rax
    hashpos = hash->chain[wpos];
  804acb:	4d 8b 4d 08          	mov    0x8(%r13),%r9
  804acf:	41 0f b7 0c 59       	movzwl (%r9,%rbx,2),%ecx
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
  804ad4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804ad8:	48 8d ba 02 01 00 00 	lea    0x102(%rdx),%rdi
  804adf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804ae3:	48 39 c7             	cmp    %rax,%rdi
  804ae6:	48 0f 47 f8          	cmova  %rax,%rdi
  804aea:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804aee:	48 01 c7             	add    %rax,%rdi
      if(chainlength++ >= maxchainlength) break;
  804af1:	45 85 ff             	test   %r15d,%r15d
  804af4:	0f 84 13 04 00 00    	je     804f0d <encodeLZ77+0x54d>
    prev_offset = 0;
  804afa:	8b 75 9c             	mov    -0x64(%rbp),%esi
  804afd:	41 89 f3             	mov    %esi,%r11d
    length = 0;
  804b00:	41 89 f4             	mov    %esi,%r12d
    offset = 0;
  804b03:	89 75 a8             	mov    %esi,-0x58(%rbp)
      if(chainlength++ >= maxchainlength) break;
  804b06:	41 b8 01 00 00 00    	mov    $0x1,%r8d
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
  804b0c:	8b 75 94             	mov    -0x6c(%rbp),%esi
  804b0f:	44 8d 14 1e          	lea    (%rsi,%rbx,1),%r10d
        foreptr = &in[pos];
  804b13:	48 01 d0             	add    %rdx,%rax
  804b16:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804b1a:	e9 74 04 00 00       	jmp    804f93 <encodeLZ77+0x5d3>
        backptr = &in[pos - current_offset];
  804b1f:	89 d0                	mov    %edx,%eax
  804b21:	4c 8b 5d c8          	mov    -0x38(%rbp),%r11
  804b25:	49 29 c3             	sub    %rax,%r11
  804b28:	4c 03 5d b0          	add    -0x50(%rbp),%r11
        if(numzeros >= 3) {
  804b2c:	41 83 fe 02          	cmp    $0x2,%r14d
  804b30:	0f 86 0a 04 00 00    	jbe    804f40 <encodeLZ77+0x580>
          unsigned skip = hash->zeros[hashpos];
  804b36:	49 8b 45 28          	mov    0x28(%r13),%rax
  804b3a:	0f b7 04 70          	movzwl (%rax,%rsi,2),%eax
          backptr += skip;
  804b3e:	41 39 c6             	cmp    %eax,%r14d
  804b41:	41 0f 46 c6          	cmovbe %r14d,%eax
  804b45:	89 c0                	mov    %eax,%eax
  804b47:	49 01 c3             	add    %rax,%r11
          foreptr += skip;
  804b4a:	48 03 45 c0          	add    -0x40(%rbp),%rax
        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
  804b4e:	48 39 c7             	cmp    %rax,%rdi
  804b51:	74 20                	je     804b73 <encodeLZ77+0x1b3>
  804b53:	89 55 ac             	mov    %edx,-0x54(%rbp)
  804b56:	0f b6 10             	movzbl (%rax),%edx
  804b59:	41 38 13             	cmp    %dl,(%r11)
  804b5c:	75 12                	jne    804b70 <encodeLZ77+0x1b0>
          ++backptr;
  804b5e:	49 83 c3 01          	add    $0x1,%r11
          ++foreptr;
  804b62:	48 83 c0 01          	add    $0x1,%rax
        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
  804b66:	48 39 c7             	cmp    %rax,%rdi
  804b69:	75 eb                	jne    804b56 <encodeLZ77+0x196>
  804b6b:	8b 55 ac             	mov    -0x54(%rbp),%edx
  804b6e:	eb 03                	jmp    804b73 <encodeLZ77+0x1b3>
  804b70:	8b 55 ac             	mov    -0x54(%rbp),%edx
        current_length = (unsigned)(foreptr - &in[pos]);
  804b73:	48 2b 45 c0          	sub    -0x40(%rbp),%rax
        if(current_length > length) {
  804b77:	44 39 e0             	cmp    %r12d,%eax
  804b7a:	0f 86 31 04 00 00    	jbe    804fb1 <encodeLZ77+0x5f1>
          if(current_length >= nicematch) break;
  804b80:	39 45 98             	cmp    %eax,-0x68(%rbp)
  804b83:	76 0b                	jbe    804b90 <encodeLZ77+0x1d0>
        current_length = (unsigned)(foreptr - &in[pos]);
  804b85:	41 89 c4             	mov    %eax,%r12d
  804b88:	89 55 a8             	mov    %edx,-0x58(%rbp)
  804b8b:	e9 21 04 00 00       	jmp    804fb1 <encodeLZ77+0x5f1>
  804b90:	41 89 c4             	mov    %eax,%r12d
  804b93:	89 55 a8             	mov    %edx,-0x58(%rbp)
  804b96:	e9 4a 04 00 00       	jmp    804fe5 <encodeLZ77+0x625>
      if(lazy) {
  804b9b:	83 7d 90 00          	cmpl   $0x0,-0x70(%rbp)
  804b9f:	74 54                	je     804bf5 <encodeLZ77+0x235>
        if(pos == 0) ERROR_BREAK(81);
  804ba1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  804ba6:	0f 84 34 03 00 00    	je     804ee0 <encodeLZ77+0x520>
        if(length > lazylength + 1) {
  804bac:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  804bb2:	83 c0 01             	add    $0x1,%eax
  804bb5:	44 39 e0             	cmp    %r12d,%eax
  804bb8:	0f 82 25 01 00 00    	jb     804ce3 <encodeLZ77+0x323>
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
  804bbe:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804bc1:	49 8b 55 00          	mov    0x0(%r13),%rdx
  804bc5:	c7 04 82 ff ff ff ff 	movl   $0xffffffff,(%rdx,%rax,4)
          hash->headz[numzeros] = -1; /*idem*/
  804bcc:	44 89 f0             	mov    %r14d,%eax
  804bcf:	49 8b 55 18          	mov    0x18(%r13),%rdx
  804bd3:	c7 04 82 ff ff ff ff 	movl   $0xffffffff,(%rdx,%rax,4)
          --pos;
  804bda:	48 83 6d c8 01       	subq   $0x1,-0x38(%rbp)
        lazy = 0;
  804bdf:	8b 45 9c             	mov    -0x64(%rbp),%eax
  804be2:	89 45 90             	mov    %eax,-0x70(%rbp)
          --pos;
  804be5:	44 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12d
  804bec:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  804bf2:	89 45 a8             	mov    %eax,-0x58(%rbp)
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
  804bf5:	41 83 fc 02          	cmp    $0x2,%r12d
  804bf9:	76 0c                	jbe    804c07 <encodeLZ77+0x247>
  804bfb:	8b 5d 94             	mov    -0x6c(%rbp),%ebx
  804bfe:	39 5d a8             	cmp    %ebx,-0x58(%rbp)
  804c01:	0f 87 eb 02 00 00    	ja     804ef2 <encodeLZ77+0x532>
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
  804c07:	41 83 fc 02          	cmp    $0x2,%r12d
  804c0b:	0f 86 02 03 00 00    	jbe    804f13 <encodeLZ77+0x553>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
  804c11:	44 39 65 10          	cmp    %r12d,0x10(%rbp)
  804c15:	77 17                	ja     804c2e <encodeLZ77+0x26e>
  804c17:	41 83 fc 03          	cmp    $0x3,%r12d
  804c1b:	0f 85 f2 00 00 00    	jne    804d13 <encodeLZ77+0x353>
  804c21:	81 7d a8 00 10 00 00 	cmpl   $0x1000,-0x58(%rbp)
  804c28:	0f 86 e5 00 00 00    	jbe    804d13 <encodeLZ77+0x353>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
  804c2e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804c32:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804c36:	0f b6 34 18          	movzbl (%rax,%rbx,1),%esi
  804c3a:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804c3e:	48 b8 85 49 80 00 00 	movabs $0x804985,%rax
  804c45:	00 00 00 
  804c48:	ff d0                	call   *%rax
  804c4a:	85 c0                	test   %eax,%eax
  804c4c:	0f 84 a9 02 00 00    	je     804efb <encodeLZ77+0x53b>
  for(pos = inpos; pos < insize; ++pos) {
  804c52:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  804c57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804c5b:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  804c5f:	0f 86 69 02 00 00    	jbe    804ece <encodeLZ77+0x50e>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
  804c65:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  804c6b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  804c6f:	48 89 c3             	mov    %rax,%rbx
  804c72:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  804c76:	4c 21 e3             	and    %r12,%rbx
    hashval = getHash(in, insize, pos);
  804c79:	4c 89 e2             	mov    %r12,%rdx
  804c7c:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804c80:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804c84:	48 b8 c8 2c 80 00 00 	movabs $0x802cc8,%rax
  804c8b:	00 00 00 
  804c8e:	ff d0                	call   *%rax
  804c90:	89 45 b8             	mov    %eax,-0x48(%rbp)
    if(usezeros && hashval == 0) {
  804c93:	85 c0                	test   %eax,%eax
  804c95:	0f 85 13 fe ff ff    	jne    804aae <encodeLZ77+0xee>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
  804c9b:	45 85 f6             	test   %r14d,%r14d
  804c9e:	0f 85 ec fd ff ff    	jne    804a90 <encodeLZ77+0xd0>
  const unsigned char* start = data + pos;
  804ca4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  804ca8:	4c 01 e2             	add    %r12,%rdx
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
  804cab:	48 8d 82 02 01 00 00 	lea    0x102(%rdx),%rax
  if(end > data + size) end = data + size;
  804cb2:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  804cb9:	48 39 f8             	cmp    %rdi,%rax
  804cbc:	48 0f 43 c7          	cmovae %rdi,%rax
  data = start;
  804cc0:	49 89 d6             	mov    %rdx,%r14
  while(data != end && *data == 0) ++data;
  804cc3:	48 39 c2             	cmp    %rax,%rdx
  804cc6:	0f 84 bc fd ff ff    	je     804a88 <encodeLZ77+0xc8>
  804ccc:	41 80 3e 00          	cmpb   $0x0,(%r14)
  804cd0:	75 09                	jne    804cdb <encodeLZ77+0x31b>
  804cd2:	49 83 c6 01          	add    $0x1,%r14
  804cd6:	4c 39 f0             	cmp    %r14,%rax
  804cd9:	75 f1                	jne    804ccc <encodeLZ77+0x30c>
  return (unsigned)(data - start);
  804cdb:	41 29 d6             	sub    %edx,%r14d
  804cde:	e9 cf fd ff ff       	jmp    804ab2 <encodeLZ77+0xf2>
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
  804ce3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804ce7:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804ceb:	0f b6 74 18 ff       	movzbl -0x1(%rax,%rbx,1),%esi
  804cf0:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804cf4:	48 b8 85 49 80 00 00 	movabs $0x804985,%rax
  804cfb:	00 00 00 
  804cfe:	ff d0                	call   *%rax
  804d00:	85 c0                	test   %eax,%eax
  804d02:	0f 84 e1 01 00 00    	je     804ee9 <encodeLZ77+0x529>
        lazy = 0;
  804d08:	8b 45 9c             	mov    -0x64(%rbp),%eax
  804d0b:	89 45 90             	mov    %eax,-0x70(%rbp)
  804d0e:	e9 e2 fe ff ff       	jmp    804bf5 <encodeLZ77+0x235>
      addLengthDistance(out, length, offset);
  804d13:	44 89 e2             	mov    %r12d,%edx
  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
  804d16:	be 1d 00 00 00       	mov    $0x1d,%esi
  804d1b:	48 bf 20 26 81 00 00 	movabs $0x812620,%rdi
  804d22:	00 00 00 
  804d25:	48 bb 73 2c 80 00 00 	movabs $0x802c73,%rbx
  804d2c:	00 00 00 
  804d2f:	ff d3                	call   *%rbx
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
  804d31:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804d35:	8b 55 c0             	mov    -0x40(%rbp),%edx
  804d38:	48 b8 20 26 81 00 00 	movabs $0x812620,%rax
  804d3f:	00 00 00 
  804d42:	44 89 e7             	mov    %r12d,%edi
  804d45:	2b 3c 90             	sub    (%rax,%rdx,4),%edi
  804d48:	89 7d ac             	mov    %edi,-0x54(%rbp)
      addLengthDistance(out, length, offset);
  804d4b:	8b 55 a8             	mov    -0x58(%rbp),%edx
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
  804d4e:	be 1e 00 00 00       	mov    $0x1e,%esi
  804d53:	48 bf 20 25 81 00 00 	movabs $0x812520,%rdi
  804d5a:	00 00 00 
  804d5d:	ff d3                	call   *%rbx
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
  804d5f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  804d63:	8b 55 b8             	mov    -0x48(%rbp),%edx
  804d66:	48 b8 20 25 81 00 00 	movabs $0x812520,%rax
  804d6d:	00 00 00 
  804d70:	8b 5d a8             	mov    -0x58(%rbp),%ebx
  804d73:	2b 1c 90             	sub    (%rax,%rdx,4),%ebx
  804d76:	89 5d a8             	mov    %ebx,-0x58(%rbp)
  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);
  804d79:	8b 45 c0             	mov    -0x40(%rbp),%eax
  804d7c:	05 01 01 00 00       	add    $0x101,%eax
  804d81:	89 c6                	mov    %eax,%esi
  804d83:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804d87:	48 bb 85 49 80 00 00 	movabs $0x804985,%rbx
  804d8e:	00 00 00 
  804d91:	ff d3                	call   *%rbx
  uivector_push_back(values, extra_length);
  804d93:	8b 75 ac             	mov    -0x54(%rbp),%esi
  804d96:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804d9a:	ff d3                	call   *%rbx
  uivector_push_back(values, dist_code);
  804d9c:	8b 75 b8             	mov    -0x48(%rbp),%esi
  804d9f:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804da3:	ff d3                	call   *%rbx
  uivector_push_back(values, extra_distance);
  804da5:	8b 75 a8             	mov    -0x58(%rbp),%esi
  804da8:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804dac:	ff d3                	call   *%rbx
      for(i = 1; i < length; ++i) {
  804dae:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804db2:	48 8d 41 01          	lea    0x1(%rcx),%rax
  804db6:	48 89 c7             	mov    %rax,%rdi
  804db9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804dbd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804dc1:	48 89 c3             	mov    %rax,%rbx
  804dc4:	48 01 fb             	add    %rdi,%rbx
  804dc7:	41 8d 7c 24 fe       	lea    -0x2(%r12),%edi
  804dcc:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  804dd0:	48 8d 44 08 02       	lea    0x2(%rax,%rcx,1),%rax
  804dd5:	48 01 f8             	add    %rdi,%rax
  804dd8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  804ddc:	44 89 7d ac          	mov    %r15d,-0x54(%rbp)
  804de0:	eb 4a                	jmp    804e2c <encodeLZ77+0x46c>
  data = start;
  804de2:	49 89 c6             	mov    %rax,%r14
  804de5:	e9 a4 00 00 00       	jmp    804e8e <encodeLZ77+0x4ce>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
  804dea:	44 89 f0             	mov    %r14d,%eax
  804ded:	49 01 c4             	add    %rax,%r12
  804df0:	4c 3b 65 a0          	cmp    -0x60(%rbp),%r12
  804df4:	77 0c                	ja     804e02 <encodeLZ77+0x442>
  804df6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804dfa:	42 80 7c 20 ff 00    	cmpb   $0x0,-0x1(%rax,%r12,1)
  804e00:	74 0a                	je     804e0c <encodeLZ77+0x44c>
  804e02:	41 83 ee 01          	sub    $0x1,%r14d
  804e06:	eb 04                	jmp    804e0c <encodeLZ77+0x44c>
          numzeros = 0;
  804e08:	44 8b 75 9c          	mov    -0x64(%rbp),%r14d
        updateHashChain(hash, wpos, hashval, numzeros);
  804e0c:	41 0f b7 ce          	movzwl %r14w,%ecx
  804e10:	4c 89 fe             	mov    %r15,%rsi
  804e13:	4c 89 ef             	mov    %r13,%rdi
  804e16:	48 b8 2e 2d 80 00 00 	movabs $0x802d2e,%rax
  804e1d:	00 00 00 
  804e20:	ff d0                	call   *%rax
      for(i = 1; i < length; ++i) {
  804e22:	48 83 c3 01          	add    $0x1,%rbx
  804e26:	48 3b 5d c8          	cmp    -0x38(%rbp),%rbx
  804e2a:	74 6a                	je     804e96 <encodeLZ77+0x4d6>
        ++pos;
  804e2c:	49 89 dc             	mov    %rbx,%r12
  804e2f:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804e33:	49 29 fc             	sub    %rdi,%r12
        wpos = pos & (windowsize - 1);
  804e36:	4c 8b 7d 88          	mov    -0x78(%rbp),%r15
  804e3a:	4d 21 e7             	and    %r12,%r15
        hashval = getHash(in, insize, pos);
  804e3d:	4c 89 e2             	mov    %r12,%rdx
  804e40:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804e44:	48 b8 c8 2c 80 00 00 	movabs $0x802cc8,%rax
  804e4b:	00 00 00 
  804e4e:	ff d0                	call   *%rax
  804e50:	89 c2                	mov    %eax,%edx
        if(usezeros && hashval == 0) {
  804e52:	85 c0                	test   %eax,%eax
  804e54:	75 b2                	jne    804e08 <encodeLZ77+0x448>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
  804e56:	45 85 f6             	test   %r14d,%r14d
  804e59:	75 8f                	jne    804dea <encodeLZ77+0x42a>
  const unsigned char* start = data + pos;
  804e5b:	48 89 d9             	mov    %rbx,%rcx
  if(end > data + size) end = data + size;
  804e5e:	48 8d 83 02 01 00 00 	lea    0x102(%rbx),%rax
  804e65:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  804e6c:	48 39 f8             	cmp    %rdi,%rax
  804e6f:	48 0f 47 c7          	cmova  %rdi,%rax
  data = start;
  804e73:	49 89 de             	mov    %rbx,%r14
  while(data != end && *data == 0) ++data;
  804e76:	48 39 c3             	cmp    %rax,%rbx
  804e79:	0f 84 63 ff ff ff    	je     804de2 <encodeLZ77+0x422>
  804e7f:	41 80 3e 00          	cmpb   $0x0,(%r14)
  804e83:	75 09                	jne    804e8e <encodeLZ77+0x4ce>
  804e85:	49 83 c6 01          	add    $0x1,%r14
  804e89:	4c 39 f0             	cmp    %r14,%rax
  804e8c:	75 f1                	jne    804e7f <encodeLZ77+0x4bf>
  return (unsigned)(data - start);
  804e8e:	41 29 ce             	sub    %ecx,%r14d
  804e91:	e9 76 ff ff ff       	jmp    804e0c <encodeLZ77+0x44c>
        ++pos;
  804e96:	44 8b 7d ac          	mov    -0x54(%rbp),%r15d
  804e9a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804e9e:	48 03 45 b8          	add    -0x48(%rbp),%rax
  804ea2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  804ea6:	e9 a7 fd ff ff       	jmp    804c52 <encodeLZ77+0x292>
  804eab:	8b 45 a8             	mov    -0x58(%rbp),%eax
  804eae:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
  804eb4:	44 89 a5 78 ff ff ff 	mov    %r12d,-0x88(%rbp)
        lazy = 1;
  804ebb:	c7 45 90 01 00 00 00 	movl   $0x1,-0x70(%rbp)
  804ec2:	e9 8b fd ff ff       	jmp    804c52 <encodeLZ77+0x292>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
  804ec7:	c7 45 9c 5a 00 00 00 	movl   $0x5a,-0x64(%rbp)
}
  804ece:	8b 45 9c             	mov    -0x64(%rbp),%eax
  804ed1:	48 83 c4 78          	add    $0x78,%rsp
  804ed5:	5b                   	pop    %rbx
  804ed6:	41 5c                	pop    %r12
  804ed8:	41 5d                	pop    %r13
  804eda:	41 5e                	pop    %r14
  804edc:	41 5f                	pop    %r15
  804ede:	5d                   	pop    %rbp
  804edf:	c3                   	ret    
        if(pos == 0) ERROR_BREAK(81);
  804ee0:	c7 45 9c 51 00 00 00 	movl   $0x51,-0x64(%rbp)
  804ee7:	eb e5                	jmp    804ece <encodeLZ77+0x50e>
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
  804ee9:	c7 45 9c 53 00 00 00 	movl   $0x53,-0x64(%rbp)
  804ef0:	eb dc                	jmp    804ece <encodeLZ77+0x50e>
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
  804ef2:	c7 45 9c 56 00 00 00 	movl   $0x56,-0x64(%rbp)
  804ef9:	eb d3                	jmp    804ece <encodeLZ77+0x50e>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
  804efb:	c7 45 9c 53 00 00 00 	movl   $0x53,-0x64(%rbp)
  804f02:	eb ca                	jmp    804ece <encodeLZ77+0x50e>
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
  804f04:	c7 45 9c 56 00 00 00 	movl   $0x56,-0x64(%rbp)
  804f0b:	eb c1                	jmp    804ece <encodeLZ77+0x50e>
    if(lazymatching) {
  804f0d:	83 7d 20 00          	cmpl   $0x0,0x20(%rbp)
  804f11:	75 3e                	jne    804f51 <encodeLZ77+0x591>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
  804f13:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804f17:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804f1b:	0f b6 34 18          	movzbl (%rax,%rbx,1),%esi
  804f1f:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804f23:	48 b8 85 49 80 00 00 	movabs $0x804985,%rax
  804f2a:	00 00 00 
  804f2d:	ff d0                	call   *%rax
  804f2f:	85 c0                	test   %eax,%eax
  804f31:	0f 85 1b fd ff ff    	jne    804c52 <encodeLZ77+0x292>
  804f37:	c7 45 9c 53 00 00 00 	movl   $0x53,-0x64(%rbp)
  804f3e:	eb 8e                	jmp    804ece <encodeLZ77+0x50e>
        foreptr = &in[pos];
  804f40:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
  804f44:	48 39 c7             	cmp    %rax,%rdi
  804f47:	74 1b                	je     804f64 <encodeLZ77+0x5a4>
  804f49:	89 55 ac             	mov    %edx,-0x54(%rbp)
  804f4c:	e9 05 fc ff ff       	jmp    804b56 <encodeLZ77+0x196>
    offset = 0;
  804f51:	44 89 7d a8          	mov    %r15d,-0x58(%rbp)
    length = 0;
  804f55:	45 89 fc             	mov    %r15d,%r12d
      if(lazy) {
  804f58:	83 7d 90 00          	cmpl   $0x0,-0x70(%rbp)
  804f5c:	0f 85 3f fc ff ff    	jne    804ba1 <encodeLZ77+0x1e1>
  804f62:	eb af                	jmp    804f13 <encodeLZ77+0x553>
      if(hashpos == hash->chain[hashpos]) break;
  804f64:	41 0f b7 04 71       	movzwl (%r9,%rsi,2),%eax
  804f69:	44 0f b7 d8          	movzwl %ax,%r11d
  804f6d:	44 39 d9             	cmp    %r11d,%ecx
  804f70:	74 73                	je     804fe5 <encodeLZ77+0x625>
        if(hash->val[hashpos] != (int)hashval) break;
  804f72:	0f b7 c0             	movzwl %ax,%eax
  804f75:	49 8b 4d 10          	mov    0x10(%r13),%rcx
  804f79:	8b 75 b8             	mov    -0x48(%rbp),%esi
  804f7c:	39 34 81             	cmp    %esi,(%rcx,%rax,4)
  804f7f:	75 64                	jne    804fe5 <encodeLZ77+0x625>
  804f81:	44 89 d9             	mov    %r11d,%ecx
      if(chainlength++ >= maxchainlength) break;
  804f84:	41 8d 40 01          	lea    0x1(%r8),%eax
  804f88:	45 39 c7             	cmp    %r8d,%r15d
  804f8b:	74 58                	je     804fe5 <encodeLZ77+0x625>
  804f8d:	41 89 c0             	mov    %eax,%r8d
  804f90:	41 89 d3             	mov    %edx,%r11d
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
  804f93:	89 ce                	mov    %ecx,%esi
  804f95:	89 d8                	mov    %ebx,%eax
  804f97:	29 c8                	sub    %ecx,%eax
  804f99:	44 89 d2             	mov    %r10d,%edx
  804f9c:	29 ca                	sub    %ecx,%edx
  804f9e:	48 39 de             	cmp    %rbx,%rsi
  804fa1:	0f 46 d0             	cmovbe %eax,%edx
      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
  804fa4:	44 39 da             	cmp    %r11d,%edx
  804fa7:	72 3c                	jb     804fe5 <encodeLZ77+0x625>
      if(current_offset > 0) {
  804fa9:	85 d2                	test   %edx,%edx
  804fab:	0f 85 6e fb ff ff    	jne    804b1f <encodeLZ77+0x15f>
      if(hashpos == hash->chain[hashpos]) break;
  804fb1:	41 0f b7 04 71       	movzwl (%r9,%rsi,2),%eax
  804fb6:	44 0f b7 d8          	movzwl %ax,%r11d
  804fba:	41 39 cb             	cmp    %ecx,%r11d
  804fbd:	74 26                	je     804fe5 <encodeLZ77+0x625>
      if(numzeros >= 3 && length > numzeros) {
  804fbf:	41 83 fe 02          	cmp    $0x2,%r14d
  804fc3:	76 ad                	jbe    804f72 <encodeLZ77+0x5b2>
  804fc5:	45 39 e6             	cmp    %r12d,%r14d
  804fc8:	73 a8                	jae    804f72 <encodeLZ77+0x5b2>
        hashpos = hash->chainz[hashpos];
  804fca:	49 8b 45 20          	mov    0x20(%r13),%rax
  804fce:	0f b7 04 70          	movzwl (%rax,%rsi,2),%eax
  804fd2:	0f b7 c8             	movzwl %ax,%ecx
        if(hash->zeros[hashpos] != numzeros) break;
  804fd5:	0f b7 c0             	movzwl %ax,%eax
  804fd8:	49 8b 75 28          	mov    0x28(%r13),%rsi
  804fdc:	0f b7 04 46          	movzwl (%rsi,%rax,2),%eax
  804fe0:	44 39 f0             	cmp    %r14d,%eax
  804fe3:	74 9f                	je     804f84 <encodeLZ77+0x5c4>
    if(lazymatching) {
  804fe5:	83 7d 20 00          	cmpl   $0x0,0x20(%rbp)
  804fe9:	0f 84 06 fc ff ff    	je     804bf5 <encodeLZ77+0x235>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
  804fef:	83 7d 90 00          	cmpl   $0x0,-0x70(%rbp)
  804ff3:	0f 85 a2 fb ff ff    	jne    804b9b <encodeLZ77+0x1db>
  804ff9:	41 83 fc 02          	cmp    $0x2,%r12d
  804ffd:	0f 86 98 fb ff ff    	jbe    804b9b <encodeLZ77+0x1db>
  805003:	8b 9d 6c ff ff ff    	mov    -0x94(%rbp),%ebx
  805009:	81 fb 01 01 00 00    	cmp    $0x101,%ebx
  80500f:	b8 01 01 00 00       	mov    $0x101,%eax
  805014:	0f 46 c3             	cmovbe %ebx,%eax
  805017:	41 39 c4             	cmp    %eax,%r12d
  80501a:	0f 86 8b fe ff ff    	jbe    804eab <encodeLZ77+0x4eb>
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
  805020:	41 83 fc 02          	cmp    $0x2,%r12d
  805024:	76 0c                	jbe    805032 <encodeLZ77+0x672>
  805026:	8b 5d 94             	mov    -0x6c(%rbp),%ebx
  805029:	39 5d a8             	cmp    %ebx,-0x58(%rbp)
  80502c:	0f 87 d2 fe ff ff    	ja     804f04 <encodeLZ77+0x544>
  805032:	8b 45 9c             	mov    -0x64(%rbp),%eax
  805035:	89 45 90             	mov    %eax,-0x70(%rbp)
  805038:	e9 d4 fb ff ff       	jmp    804c11 <encodeLZ77+0x251>

000000000080503d <ucvector_cleanup>:
static void ucvector_cleanup(void* p) {
  80503d:	55                   	push   %rbp
  80503e:	48 89 e5             	mov    %rsp,%rbp
  805041:	53                   	push   %rbx
  805042:	48 83 ec 08          	sub    $0x8,%rsp
  805046:	48 89 fb             	mov    %rdi,%rbx
  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
  805049:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  805050:	00 
  805051:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  805058:	00 
    jos_free(ptr);
  805059:	48 8b 3f             	mov    (%rdi),%rdi
  80505c:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  805063:	00 00 00 
  805066:	ff d0                	call   *%rax
  ((ucvector*)p)->data = NULL;
  805068:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
  80506f:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  805073:	c9                   	leave  
  805074:	c3                   	ret    

0000000000805075 <color_tree_cleanup>:
static void color_tree_cleanup(ColorTree* tree) {
  805075:	55                   	push   %rbp
  805076:	48 89 e5             	mov    %rsp,%rbp
  805079:	41 56                	push   %r14
  80507b:	41 55                	push   %r13
  80507d:	41 54                	push   %r12
  80507f:	53                   	push   %rbx
  805080:	48 89 fb             	mov    %rdi,%rbx
  for(i = 0; i != 16; ++i) {
  805083:	4c 8d a7 80 00 00 00 	lea    0x80(%rdi),%r12
      color_tree_cleanup(tree->children[i]);
  80508a:	49 be 75 50 80 00 00 	movabs $0x805075,%r14
  805091:	00 00 00 
    jos_free(ptr);
  805094:	49 bd be 0e 81 00 00 	movabs $0x810ebe,%r13
  80509b:	00 00 00 
  80509e:	eb 09                	jmp    8050a9 <color_tree_cleanup+0x34>
  for(i = 0; i != 16; ++i) {
  8050a0:	48 83 c3 08          	add    $0x8,%rbx
  8050a4:	4c 39 e3             	cmp    %r12,%rbx
  8050a7:	74 13                	je     8050bc <color_tree_cleanup+0x47>
    if(tree->children[i]) {
  8050a9:	48 8b 3b             	mov    (%rbx),%rdi
  8050ac:	48 85 ff             	test   %rdi,%rdi
  8050af:	74 ef                	je     8050a0 <color_tree_cleanup+0x2b>
      color_tree_cleanup(tree->children[i]);
  8050b1:	41 ff d6             	call   *%r14
    jos_free(ptr);
  8050b4:	48 8b 3b             	mov    (%rbx),%rdi
  8050b7:	41 ff d5             	call   *%r13
}
  8050ba:	eb e4                	jmp    8050a0 <color_tree_cleanup+0x2b>
}
  8050bc:	5b                   	pop    %rbx
  8050bd:	41 5c                	pop    %r12
  8050bf:	41 5d                	pop    %r13
  8050c1:	41 5e                	pop    %r14
  8050c3:	5d                   	pop    %rbp
  8050c4:	c3                   	ret    

00000000008050c5 <LodePNGIText_cleanup>:
static void LodePNGIText_cleanup(LodePNGInfo* info) {
  8050c5:	55                   	push   %rbp
  8050c6:	48 89 e5             	mov    %rsp,%rbp
  8050c9:	41 57                	push   %r15
  8050cb:	41 56                	push   %r14
  8050cd:	41 55                	push   %r13
  8050cf:	41 54                	push   %r12
  8050d1:	53                   	push   %rbx
  8050d2:	48 83 ec 08          	sub    $0x8,%rsp
  8050d6:	49 89 fc             	mov    %rdi,%r12
  for(i = 0; i != info->itext_num; ++i) {
  8050d9:	48 83 7f 60 00       	cmpq   $0x0,0x60(%rdi)
  8050de:	74 77                	je     805157 <LodePNGIText_cleanup+0x92>
  8050e0:	41 be 00 00 00 00    	mov    $0x0,%r14d
    jos_free(ptr);
  8050e6:	49 bd be 0e 81 00 00 	movabs $0x810ebe,%r13
  8050ed:	00 00 00 
    string_cleanup(&info->itext_keys[i]);
  8050f0:	4a 8d 1c f5 00 00 00 	lea    0x0(,%r14,8),%rbx
  8050f7:	00 
  8050f8:	49 89 df             	mov    %rbx,%r15
  8050fb:	4d 03 7c 24 68       	add    0x68(%r12),%r15
    jos_free(ptr);
  805100:	49 8b 3f             	mov    (%r15),%rdi
  805103:	41 ff d5             	call   *%r13
  *out = NULL;
  805106:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
    string_cleanup(&info->itext_langtags[i]);
  80510d:	49 89 df             	mov    %rbx,%r15
  805110:	4d 03 7c 24 70       	add    0x70(%r12),%r15
    jos_free(ptr);
  805115:	49 8b 3f             	mov    (%r15),%rdi
  805118:	41 ff d5             	call   *%r13
  *out = NULL;
  80511b:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
    string_cleanup(&info->itext_transkeys[i]);
  805122:	49 89 df             	mov    %rbx,%r15
  805125:	4d 03 7c 24 78       	add    0x78(%r12),%r15
    jos_free(ptr);
  80512a:	49 8b 3f             	mov    (%r15),%rdi
  80512d:	41 ff d5             	call   *%r13
  *out = NULL;
  805130:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
    string_cleanup(&info->itext_strings[i]);
  805137:	49 03 9c 24 80 00 00 	add    0x80(%r12),%rbx
  80513e:	00 
    jos_free(ptr);
  80513f:	48 8b 3b             	mov    (%rbx),%rdi
  805142:	41 ff d5             	call   *%r13
  *out = NULL;
  805145:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  for(i = 0; i != info->itext_num; ++i) {
  80514c:	49 83 c6 01          	add    $0x1,%r14
  805150:	4d 39 74 24 60       	cmp    %r14,0x60(%r12)
  805155:	75 99                	jne    8050f0 <LodePNGIText_cleanup+0x2b>
    jos_free(ptr);
  805157:	49 8b 7c 24 68       	mov    0x68(%r12),%rdi
  80515c:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  805163:	00 00 00 
  805166:	ff d3                	call   *%rbx
  805168:	49 8b 7c 24 70       	mov    0x70(%r12),%rdi
  80516d:	ff d3                	call   *%rbx
  80516f:	49 8b 7c 24 78       	mov    0x78(%r12),%rdi
  805174:	ff d3                	call   *%rbx
  805176:	49 8b bc 24 80 00 00 	mov    0x80(%r12),%rdi
  80517d:	00 
  80517e:	ff d3                	call   *%rbx
}
  805180:	48 83 c4 08          	add    $0x8,%rsp
  805184:	5b                   	pop    %rbx
  805185:	41 5c                	pop    %r12
  805187:	41 5d                	pop    %r13
  805189:	41 5e                	pop    %r14
  80518b:	41 5f                	pop    %r15
  80518d:	5d                   	pop    %rbp
  80518e:	c3                   	ret    

000000000080518f <LodePNGText_cleanup>:
static void LodePNGText_cleanup(LodePNGInfo* info) {
  80518f:	55                   	push   %rbp
  805190:	48 89 e5             	mov    %rsp,%rbp
  805193:	41 57                	push   %r15
  805195:	41 56                	push   %r14
  805197:	41 55                	push   %r13
  805199:	41 54                	push   %r12
  80519b:	53                   	push   %rbx
  80519c:	48 83 ec 08          	sub    $0x8,%rsp
  8051a0:	49 89 fd             	mov    %rdi,%r13
  for(i = 0; i != info->text_num; ++i) {
  8051a3:	48 83 7f 48 00       	cmpq   $0x0,0x48(%rdi)
  8051a8:	74 47                	je     8051f1 <LodePNGText_cleanup+0x62>
  8051aa:	41 bc 00 00 00 00    	mov    $0x0,%r12d
    jos_free(ptr);
  8051b0:	49 be be 0e 81 00 00 	movabs $0x810ebe,%r14
  8051b7:	00 00 00 
    string_cleanup(&info->text_keys[i]);
  8051ba:	4a 8d 1c e5 00 00 00 	lea    0x0(,%r12,8),%rbx
  8051c1:	00 
  8051c2:	49 89 df             	mov    %rbx,%r15
  8051c5:	4d 03 7d 50          	add    0x50(%r13),%r15
    jos_free(ptr);
  8051c9:	49 8b 3f             	mov    (%r15),%rdi
  8051cc:	41 ff d6             	call   *%r14
  *out = NULL;
  8051cf:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
    string_cleanup(&info->text_strings[i]);
  8051d6:	49 03 5d 58          	add    0x58(%r13),%rbx
    jos_free(ptr);
  8051da:	48 8b 3b             	mov    (%rbx),%rdi
  8051dd:	41 ff d6             	call   *%r14
  *out = NULL;
  8051e0:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  for(i = 0; i != info->text_num; ++i) {
  8051e7:	49 83 c4 01          	add    $0x1,%r12
  8051eb:	4d 39 65 48          	cmp    %r12,0x48(%r13)
  8051ef:	75 c9                	jne    8051ba <LodePNGText_cleanup+0x2b>
    jos_free(ptr);
  8051f1:	49 8b 7d 50          	mov    0x50(%r13),%rdi
  8051f5:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  8051fc:	00 00 00 
  8051ff:	ff d3                	call   *%rbx
  805201:	49 8b 7d 58          	mov    0x58(%r13),%rdi
  805205:	ff d3                	call   *%rbx
}
  805207:	48 83 c4 08          	add    $0x8,%rsp
  80520b:	5b                   	pop    %rbx
  80520c:	41 5c                	pop    %r12
  80520e:	41 5d                	pop    %r13
  805210:	41 5e                	pop    %r14
  805212:	41 5f                	pop    %r15
  805214:	5d                   	pop    %rbp
  805215:	c3                   	ret    

0000000000805216 <HuffmanTree_cleanup>:
static void HuffmanTree_cleanup(HuffmanTree* tree) {
  805216:	55                   	push   %rbp
  805217:	48 89 e5             	mov    %rsp,%rbp
  80521a:	41 54                	push   %r12
  80521c:	53                   	push   %rbx
  80521d:	48 89 fb             	mov    %rdi,%rbx
    jos_free(ptr);
  805220:	48 8b 3f             	mov    (%rdi),%rdi
  805223:	49 bc be 0e 81 00 00 	movabs $0x810ebe,%r12
  80522a:	00 00 00 
  80522d:	41 ff d4             	call   *%r12
  805230:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  805234:	41 ff d4             	call   *%r12
  805237:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  80523b:	41 ff d4             	call   *%r12
  80523e:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  805242:	41 ff d4             	call   *%r12
}
  805245:	5b                   	pop    %rbx
  805246:	41 5c                	pop    %r12
  805248:	5d                   	pop    %rbp
  805249:	c3                   	ret    

000000000080524a <HuffmanTree_makeFromLengths2>:
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
  80524a:	55                   	push   %rbp
  80524b:	48 89 e5             	mov    %rsp,%rbp
  80524e:	41 57                	push   %r15
  805250:	41 56                	push   %r14
  805252:	41 55                	push   %r13
  805254:	41 54                	push   %r12
  805256:	53                   	push   %rbx
  805257:	48 83 ec 08          	sub    $0x8,%rsp
  80525b:	48 89 fb             	mov    %rdi,%rbx
  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
  80525e:	8b 7f 14             	mov    0x14(%rdi),%edi
  805261:	48 c1 e7 02          	shl    $0x2,%rdi
  return jos_malloc(size);
  805265:	49 bd f8 0d 81 00 00 	movabs $0x810df8,%r13
  80526c:	00 00 00 
  80526f:	41 ff d5             	call   *%r13
  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
  805272:	48 89 03             	mov    %rax,(%rbx)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
  805275:	8b 43 10             	mov    0x10(%rbx),%eax
  805278:	8d 78 01             	lea    0x1(%rax),%edi
  80527b:	48 c1 e7 02          	shl    $0x2,%rdi
  return jos_malloc(size);
  80527f:	41 ff d5             	call   *%r13
  805282:	49 89 c4             	mov    %rax,%r12
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
  805285:	8b 43 10             	mov    0x10(%rbx),%eax
  805288:	8d 78 01             	lea    0x1(%rax),%edi
  80528b:	48 c1 e7 02          	shl    $0x2,%rdi
  return jos_malloc(size);
  80528f:	41 ff d5             	call   *%r13
  805292:	49 89 c5             	mov    %rax,%r13
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
  805295:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  805299:	0f 84 51 04 00 00    	je     8056f0 <HuffmanTree_makeFromLengths2+0x4a6>
  80529f:	4d 85 e4             	test   %r12,%r12
  8052a2:	0f 84 48 04 00 00    	je     8056f0 <HuffmanTree_makeFromLengths2+0x4a6>
  8052a8:	48 85 c0             	test   %rax,%rax
  8052ab:	0f 84 3f 04 00 00    	je     8056f0 <HuffmanTree_makeFromLengths2+0x4a6>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
  8052b1:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%rbx)
  8052b5:	74 22                	je     8052d9 <HuffmanTree_makeFromLengths2+0x8f>
  8052b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8052bc:	89 c2                	mov    %eax,%edx
  8052be:	41 c7 44 95 00 00 00 	movl   $0x0,0x0(%r13,%rdx,4)
  8052c5:	00 00 
  8052c7:	41 c7 04 94 00 00 00 	movl   $0x0,(%r12,%rdx,4)
  8052ce:	00 
  8052cf:	89 c2                	mov    %eax,%edx
  8052d1:	83 c0 01             	add    $0x1,%eax
  8052d4:	39 53 10             	cmp    %edx,0x10(%rbx)
  8052d7:	75 e3                	jne    8052bc <HuffmanTree_makeFromLengths2+0x72>
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
  8052d9:	83 7b 14 00          	cmpl   $0x0,0x14(%rbx)
  8052dd:	74 1b                	je     8052fa <HuffmanTree_makeFromLengths2+0xb0>
  8052df:	b8 00 00 00 00       	mov    $0x0,%eax
  8052e4:	89 c1                	mov    %eax,%ecx
  8052e6:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  8052ea:	8b 14 8a             	mov    (%rdx,%rcx,4),%edx
  8052ed:	41 83 04 94 01       	addl   $0x1,(%r12,%rdx,4)
  8052f2:	83 c0 01             	add    $0x1,%eax
  8052f5:	39 43 14             	cmp    %eax,0x14(%rbx)
  8052f8:	75 ea                	jne    8052e4 <HuffmanTree_makeFromLengths2+0x9a>
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
  8052fa:	83 7b 10 00          	cmpl   $0x0,0x10(%rbx)
  8052fe:	74 22                	je     805322 <HuffmanTree_makeFromLengths2+0xd8>
  805300:	ba 01 00 00 00       	mov    $0x1,%edx
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
  805305:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  805308:	89 d6                	mov    %edx,%esi
  80530a:	41 8b 04 8c          	mov    (%r12,%rcx,4),%eax
  80530e:	41 03 44 8d 00       	add    0x0(%r13,%rcx,4),%eax
  805313:	01 c0                	add    %eax,%eax
  805315:	41 89 44 b5 00       	mov    %eax,0x0(%r13,%rsi,4)
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
  80531a:	83 c2 01             	add    $0x1,%edx
  80531d:	39 53 10             	cmp    %edx,0x10(%rbx)
  805320:	73 e3                	jae    805305 <HuffmanTree_makeFromLengths2+0xbb>
    for(n = 0; n != tree->numcodes; ++n) {
  805322:	83 7b 14 00          	cmpl   $0x0,0x14(%rbx)
  805326:	0f 84 61 03 00 00    	je     80568d <HuffmanTree_makeFromLengths2+0x443>
  80532c:	b8 00 00 00 00       	mov    $0x0,%eax
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
  805331:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  805336:	eb 0c                	jmp    805344 <HuffmanTree_makeFromLengths2+0xfa>
    for(n = 0; n != tree->numcodes; ++n) {
  805338:	83 c0 01             	add    $0x1,%eax
  80533b:	39 43 14             	cmp    %eax,0x14(%rbx)
  80533e:	0f 84 49 03 00 00    	je     80568d <HuffmanTree_makeFromLengths2+0x443>
      if(tree->lengths[n] != 0) {
  805344:	89 c2                	mov    %eax,%edx
  805346:	48 8d 34 95 00 00 00 	lea    0x0(,%rdx,4),%rsi
  80534d:	00 
  80534e:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  805352:	8b 0c 91             	mov    (%rcx,%rdx,4),%ecx
  805355:	85 c9                	test   %ecx,%ecx
  805357:	74 df                	je     805338 <HuffmanTree_makeFromLengths2+0xee>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
  805359:	89 c9                	mov    %ecx,%ecx
  80535b:	4d 8d 44 8d 00       	lea    0x0(%r13,%rcx,4),%r8
  805360:	41 8b 08             	mov    (%r8),%ecx
  805363:	44 8d 49 01          	lea    0x1(%rcx),%r9d
  805367:	45 89 08             	mov    %r9d,(%r8)
  80536a:	4c 8b 03             	mov    (%rbx),%r8
  80536d:	41 89 0c 90          	mov    %ecx,(%r8,%rdx,4)
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
  805371:	48 03 33             	add    (%rbx),%rsi
  805374:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  805378:	8b 0c 91             	mov    (%rcx,%rdx,4),%ecx
  80537b:	89 fa                	mov    %edi,%edx
  80537d:	d3 e2                	shl    %cl,%edx
  80537f:	f7 d2                	not    %edx
  805381:	21 16                	and    %edx,(%rsi)
  805383:	eb b3                	jmp    805338 <HuffmanTree_makeFromLengths2+0xee>
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  805385:	45 89 c0             	mov    %r8d,%r8d
  805388:	4b 8d 14 84          	lea    (%r12,%r8,4),%rdx
  80538c:	44 39 12             	cmp    %r10d,(%rdx)
  80538f:	44 0f 43 12          	cmovae (%rdx),%r10d
  805393:	44 89 12             	mov    %r10d,(%rdx)
  for(i = 0; i < tree->numcodes; i++) {
  805396:	49 83 c3 01          	add    $0x1,%r11
  80539a:	8b 53 14             	mov    0x14(%rbx),%edx
  80539d:	49 39 d3             	cmp    %rdx,%r11
  8053a0:	73 45                	jae    8053e7 <HuffmanTree_makeFromLengths2+0x19d>
    unsigned l = tree->lengths[i];
  8053a2:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  8053a6:	46 8b 14 9a          	mov    (%rdx,%r11,4),%r10d
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
  8053aa:	41 83 fa 09          	cmp    $0x9,%r10d
  8053ae:	76 e6                	jbe    805396 <HuffmanTree_makeFromLengths2+0x14c>
    unsigned symbol = tree->codes[i];
  8053b0:	48 8b 13             	mov    (%rbx),%rdx
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
  8053b3:	41 8d 4a f7          	lea    -0x9(%r10),%ecx
  8053b7:	46 8b 2c 9a          	mov    (%rdx,%r11,4),%r13d
  8053bb:	41 d3 ed             	shr    %cl,%r13d
  unsigned i, result = 0;
  8053be:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
  8053c4:	be 00 00 00 00       	mov    $0x0,%esi
  8053c9:	44 89 c9             	mov    %r9d,%ecx
  8053cc:	29 f1                	sub    %esi,%ecx
  8053ce:	44 89 ea             	mov    %r13d,%edx
  8053d1:	d3 ea                	shr    %cl,%edx
  8053d3:	83 e2 01             	and    $0x1,%edx
  8053d6:	89 f1                	mov    %esi,%ecx
  8053d8:	d3 e2                	shl    %cl,%edx
  8053da:	41 09 d0             	or     %edx,%r8d
  8053dd:	83 c6 01             	add    $0x1,%esi
  8053e0:	83 fe 09             	cmp    $0x9,%esi
  8053e3:	75 e4                	jne    8053c9 <HuffmanTree_makeFromLengths2+0x17f>
  8053e5:	eb 9e                	jmp    805385 <HuffmanTree_makeFromLengths2+0x13b>
  size = headsize;
  8053e7:	41 bd 00 02 00 00    	mov    $0x200,%r13d
    if(l > FIRSTBITS) size += ((size_t) 1u << (l - FIRSTBITS));
  8053ed:	be 01 00 00 00       	mov    $0x1,%esi
  8053f2:	eb 09                	jmp    8053fd <HuffmanTree_makeFromLengths2+0x1b3>
  for(i = 0; i < headsize; ++i) {
  8053f4:	48 83 c0 04          	add    $0x4,%rax
  8053f8:	48 39 c7             	cmp    %rax,%rdi
  8053fb:	74 15                	je     805412 <HuffmanTree_makeFromLengths2+0x1c8>
    unsigned l = maxlens[i];
  8053fd:	8b 08                	mov    (%rax),%ecx
    if(l > FIRSTBITS) size += ((size_t) 1u << (l - FIRSTBITS));
  8053ff:	83 f9 09             	cmp    $0x9,%ecx
  805402:	76 f0                	jbe    8053f4 <HuffmanTree_makeFromLengths2+0x1aa>
  805404:	83 e9 09             	sub    $0x9,%ecx
  805407:	48 89 f2             	mov    %rsi,%rdx
  80540a:	48 d3 e2             	shl    %cl,%rdx
  80540d:	49 01 d5             	add    %rdx,%r13
  805410:	eb e2                	jmp    8053f4 <HuffmanTree_makeFromLengths2+0x1aa>
  return jos_malloc(size);
  805412:	44 89 ef             	mov    %r13d,%edi
  805415:	49 be f8 0d 81 00 00 	movabs $0x810df8,%r14
  80541c:	00 00 00 
  80541f:	41 ff d6             	call   *%r14
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
  805422:	48 89 43 18          	mov    %rax,0x18(%rbx)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
  805426:	4b 8d 7c 2d 00       	lea    0x0(%r13,%r13,1),%rdi
  return jos_malloc(size);
  80542b:	41 ff d6             	call   *%r14
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
  80542e:	48 89 43 20          	mov    %rax,0x20(%rbx)
  if(!tree->table_len || !tree->table_value) {
  805432:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  805437:	74 31                	je     80546a <HuffmanTree_makeFromLengths2+0x220>
  805439:	48 85 c0             	test   %rax,%rax
  80543c:	74 2c                	je     80546a <HuffmanTree_makeFromLengths2+0x220>
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
  80543e:	b8 00 00 00 00       	mov    $0x0,%eax
  805443:	4d 85 ed             	test   %r13,%r13
  805446:	74 11                	je     805459 <HuffmanTree_makeFromLengths2+0x20f>
  805448:	48 8b 53 18          	mov    0x18(%rbx),%rdx
  80544c:	c6 04 02 10          	movb   $0x10,(%rdx,%rax,1)
  805450:	48 83 c0 01          	add    $0x1,%rax
  805454:	4c 39 e8             	cmp    %r13,%rax
  805457:	75 ef                	jne    805448 <HuffmanTree_makeFromLengths2+0x1fe>
  pointer = headsize;
  805459:	ba 00 02 00 00       	mov    $0x200,%edx
  for(i = 0; i < headsize; ++i) {
  80545e:	b8 00 00 00 00       	mov    $0x0,%eax
    pointer += ((size_t) 1u << (l - FIRSTBITS));
  805463:	bf 01 00 00 00       	mov    $0x1,%edi
  805468:	eb 25                	jmp    80548f <HuffmanTree_makeFromLengths2+0x245>
    jos_free(ptr);
  80546a:	4c 89 e7             	mov    %r12,%rdi
  80546d:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  805474:	00 00 00 
  805477:	ff d0                	call   *%rax
    return 83; /*alloc fail*/
  805479:	b8 53 00 00 00       	mov    $0x53,%eax
}
  80547e:	e9 86 02 00 00       	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
  for(i = 0; i < headsize; ++i) {
  805483:	48 83 c0 01          	add    $0x1,%rax
  805487:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  80548d:	74 26                	je     8054b5 <HuffmanTree_makeFromLengths2+0x26b>
    unsigned l = maxlens[i];
  80548f:	41 8b 0c 84          	mov    (%r12,%rax,4),%ecx
    if(l <= FIRSTBITS) continue;
  805493:	83 f9 09             	cmp    $0x9,%ecx
  805496:	76 eb                	jbe    805483 <HuffmanTree_makeFromLengths2+0x239>
    tree->table_len[i] = l;
  805498:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  80549c:	88 0c 06             	mov    %cl,(%rsi,%rax,1)
    tree->table_value[i] = pointer;
  80549f:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  8054a3:	66 89 14 46          	mov    %dx,(%rsi,%rax,2)
    pointer += ((size_t) 1u << (l - FIRSTBITS));
  8054a7:	83 e9 09             	sub    $0x9,%ecx
  8054aa:	48 89 fe             	mov    %rdi,%rsi
  8054ad:	48 d3 e6             	shl    %cl,%rsi
  8054b0:	48 01 f2             	add    %rsi,%rdx
  8054b3:	eb ce                	jmp    805483 <HuffmanTree_makeFromLengths2+0x239>
    jos_free(ptr);
  8054b5:	4c 89 e7             	mov    %r12,%rdi
  8054b8:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8054bf:	00 00 00 
  8054c2:	ff d0                	call   *%rax
  for(i = 0; i < tree->numcodes; ++i) {
  8054c4:	83 7b 14 00          	cmpl   $0x0,0x14(%rbx)
  8054c8:	0f 84 49 01 00 00    	je     805617 <HuffmanTree_makeFromLengths2+0x3cd>
  numpresent = 0;
  8054ce:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  for(i = 0; i < tree->numcodes; ++i) {
  8054d4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
  8054da:	41 bc 01 00 00 00    	mov    $0x1,%r12d
      unsigned num = 1u << (FIRSTBITS - l);
  8054e0:	41 be 09 00 00 00    	mov    $0x9,%r14d
  8054e6:	eb 4c                	jmp    805534 <HuffmanTree_makeFromLengths2+0x2ea>
  8054e8:	44 89 f1             	mov    %r14d,%ecx
  8054eb:	29 f9                	sub    %edi,%ecx
  8054ed:	45 89 e1             	mov    %r12d,%r9d
  8054f0:	41 d3 e1             	shl    %cl,%r9d
      for(j = 0; j < num; ++j) {
  8054f3:	ba 00 00 00 00       	mov    $0x0,%edx
        unsigned index = reverse | (j << l);
  8054f8:	89 d0                	mov    %edx,%eax
  8054fa:	89 f9                	mov    %edi,%ecx
  8054fc:	d3 e0                	shl    %cl,%eax
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
  8054fe:	09 f0                	or     %esi,%eax
  805500:	48 89 c1             	mov    %rax,%rcx
  805503:	48 03 4b 18          	add    0x18(%rbx),%rcx
  805507:	80 39 10             	cmpb   $0x10,(%rcx)
  80550a:	0f 85 4e 01 00 00    	jne    80565e <HuffmanTree_makeFromLengths2+0x414>
        tree->table_len[index] = l;
  805510:	40 88 39             	mov    %dil,(%rcx)
        tree->table_value[index] = i;
  805513:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
  805517:	66 44 89 04 41       	mov    %r8w,(%rcx,%rax,2)
      for(j = 0; j < num; ++j) {
  80551c:	83 c2 01             	add    $0x1,%edx
  80551f:	41 39 d1             	cmp    %edx,%r9d
  805522:	75 d4                	jne    8054f8 <HuffmanTree_makeFromLengths2+0x2ae>
  for(i = 0; i < tree->numcodes; ++i) {
  805524:	49 83 c0 01          	add    $0x1,%r8
  805528:	8b 43 14             	mov    0x14(%rbx),%eax
  80552b:	49 39 c0             	cmp    %rax,%r8
  80552e:	0f 83 b0 00 00 00    	jae    8055e4 <HuffmanTree_makeFromLengths2+0x39a>
    unsigned l = tree->lengths[i];
  805534:	48 8b 43 08          	mov    0x8(%rbx),%rax
  805538:	42 8b 3c 80          	mov    (%rax,%r8,4),%edi
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
  80553c:	48 8b 03             	mov    (%rbx),%rax
  80553f:	46 8b 0c 80          	mov    (%rax,%r8,4),%r9d
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
  805543:	85 ff                	test   %edi,%edi
  805545:	74 dd                	je     805524 <HuffmanTree_makeFromLengths2+0x2da>
  unsigned i, result = 0;
  805547:	be 00 00 00 00       	mov    $0x0,%esi
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
  80554c:	ba 00 00 00 00       	mov    $0x0,%edx
  805551:	44 8d 57 ff          	lea    -0x1(%rdi),%r10d
  805555:	44 89 d1             	mov    %r10d,%ecx
  805558:	29 d1                	sub    %edx,%ecx
  80555a:	44 89 c8             	mov    %r9d,%eax
  80555d:	d3 e8                	shr    %cl,%eax
  80555f:	83 e0 01             	and    $0x1,%eax
  805562:	89 d1                	mov    %edx,%ecx
  805564:	d3 e0                	shl    %cl,%eax
  805566:	09 c6                	or     %eax,%esi
  805568:	83 c2 01             	add    $0x1,%edx
  80556b:	39 d7                	cmp    %edx,%edi
  80556d:	75 e6                	jne    805555 <HuffmanTree_makeFromLengths2+0x30b>
    numpresent++;
  80556f:	49 83 c3 01          	add    $0x1,%r11
    if(l <= FIRSTBITS) {
  805573:	83 ff 09             	cmp    $0x9,%edi
  805576:	0f 86 6c ff ff ff    	jbe    8054e8 <HuffmanTree_makeFromLengths2+0x29e>
      unsigned maxlen = tree->table_len[index];
  80557c:	89 f2                	mov    %esi,%edx
  80557e:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  805584:	48 8b 43 18          	mov    0x18(%rbx),%rax
  805588:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
  80558c:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
  805590:	44 0f b7 14 51       	movzwl (%rcx,%rdx,2),%r10d
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
  805595:	89 c1                	mov    %eax,%ecx
  805597:	29 f9                	sub    %edi,%ecx
  805599:	45 89 e1             	mov    %r12d,%r9d
  80559c:	41 d3 e1             	shl    %cl,%r9d
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
  80559f:	39 c7                	cmp    %eax,%edi
  8055a1:	0f 87 c1 00 00 00    	ja     805668 <HuffmanTree_makeFromLengths2+0x41e>
      for(j = 0; j < num; ++j) {
  8055a7:	45 85 c9             	test   %r9d,%r9d
  8055aa:	0f 84 74 ff ff ff    	je     805524 <HuffmanTree_makeFromLengths2+0x2da>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
  8055b0:	c1 ee 09             	shr    $0x9,%esi
      for(j = 0; j < num; ++j) {
  8055b3:	b8 00 00 00 00       	mov    $0x0,%eax
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
  8055b8:	8d 4f f7             	lea    -0x9(%rdi),%ecx
  8055bb:	89 c2                	mov    %eax,%edx
  8055bd:	d3 e2                	shl    %cl,%edx
  8055bf:	09 f2                	or     %esi,%edx
        tree->table_len[index2] = l;
  8055c1:	44 01 d2             	add    %r10d,%edx
  8055c4:	89 d2                	mov    %edx,%edx
  8055c6:	4c 8b 7b 18          	mov    0x18(%rbx),%r15
  8055ca:	41 88 3c 17          	mov    %dil,(%r15,%rdx,1)
        tree->table_value[index2] = i;
  8055ce:	4c 8b 7b 20          	mov    0x20(%rbx),%r15
  8055d2:	66 45 89 04 57       	mov    %r8w,(%r15,%rdx,2)
      for(j = 0; j < num; ++j) {
  8055d7:	83 c0 01             	add    $0x1,%eax
  8055da:	41 39 c1             	cmp    %eax,%r9d
  8055dd:	75 dc                	jne    8055bb <HuffmanTree_makeFromLengths2+0x371>
  8055df:	e9 40 ff ff ff       	jmp    805524 <HuffmanTree_makeFromLengths2+0x2da>
  if(numpresent < 2) {
  8055e4:	49 83 fb 01          	cmp    $0x1,%r11
  8055e8:	76 2d                	jbe    805617 <HuffmanTree_makeFromLengths2+0x3cd>
  return 0;
  8055ea:	b8 00 00 00 00       	mov    $0x0,%eax
    for(i = 0; i < size; ++i) {
  8055ef:	4d 85 ed             	test   %r13,%r13
  8055f2:	0f 84 11 01 00 00    	je     805709 <HuffmanTree_makeFromLengths2+0x4bf>
  8055f8:	48 8b 43 18          	mov    0x18(%rbx),%rax
  8055fc:	49 01 c5             	add    %rax,%r13
      if(tree->table_len[i] == 16) return 55;
  8055ff:	80 38 10             	cmpb   $0x10,(%rax)
  805602:	74 78                	je     80567c <HuffmanTree_makeFromLengths2+0x432>
    for(i = 0; i < size; ++i) {
  805604:	48 83 c0 01          	add    $0x1,%rax
  805608:	4c 39 e8             	cmp    %r13,%rax
  80560b:	75 f2                	jne    8055ff <HuffmanTree_makeFromLengths2+0x3b5>
  return 0;
  80560d:	b8 00 00 00 00       	mov    $0x0,%eax
  805612:	e9 f2 00 00 00       	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
    for(i = 0; i < size; ++i) {
  805617:	4d 85 ed             	test   %r13,%r13
  80561a:	74 56                	je     805672 <HuffmanTree_makeFromLengths2+0x428>
  80561c:	b8 00 00 00 00       	mov    $0x0,%eax
  805621:	eb 23                	jmp    805646 <HuffmanTree_makeFromLengths2+0x3fc>
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
  805623:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  805629:	19 c9                	sbb    %ecx,%ecx
  80562b:	83 e1 f7             	and    $0xfffffff7,%ecx
  80562e:	83 c1 0a             	add    $0xa,%ecx
  805631:	88 0a                	mov    %cl,(%rdx)
        tree->table_value[i] = INVALIDSYMBOL;
  805633:	48 8b 53 20          	mov    0x20(%rbx),%rdx
  805637:	66 c7 04 42 ff ff    	movw   $0xffff,(%rdx,%rax,2)
    for(i = 0; i < size; ++i) {
  80563d:	48 83 c0 01          	add    $0x1,%rax
  805641:	4c 39 e8             	cmp    %r13,%rax
  805644:	74 0e                	je     805654 <HuffmanTree_makeFromLengths2+0x40a>
      if(tree->table_len[i] == 16) {
  805646:	48 89 c2             	mov    %rax,%rdx
  805649:	48 03 53 18          	add    0x18(%rbx),%rdx
  80564d:	80 3a 10             	cmpb   $0x10,(%rdx)
  805650:	75 eb                	jne    80563d <HuffmanTree_makeFromLengths2+0x3f3>
  805652:	eb cf                	jmp    805623 <HuffmanTree_makeFromLengths2+0x3d9>
  return 0;
  805654:	b8 00 00 00 00       	mov    $0x0,%eax
  805659:	e9 ab 00 00 00       	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
  80565e:	b8 37 00 00 00       	mov    $0x37,%eax
  805663:	e9 a1 00 00 00       	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
  805668:	b8 37 00 00 00       	mov    $0x37,%eax
  80566d:	e9 97 00 00 00       	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
  return 0;
  805672:	b8 00 00 00 00       	mov    $0x0,%eax
  805677:	e9 8d 00 00 00       	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
      if(tree->table_len[i] == 16) return 55;
  80567c:	b8 37 00 00 00       	mov    $0x37,%eax
  805681:	e9 83 00 00 00       	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
  if(!maxlens) return 83; /*alloc fail*/
  805686:	b8 53 00 00 00       	mov    $0x53,%eax
  return error;
  80568b:	eb 7c                	jmp    805709 <HuffmanTree_makeFromLengths2+0x4bf>
    jos_free(ptr);
  80568d:	4c 89 e7             	mov    %r12,%rdi
  805690:	49 bc be 0e 81 00 00 	movabs $0x810ebe,%r12
  805697:	00 00 00 
  80569a:	41 ff d4             	call   *%r12
  80569d:	4c 89 ef             	mov    %r13,%rdi
  8056a0:	41 ff d4             	call   *%r12
  return jos_malloc(size);
  8056a3:	bf 00 08 00 00       	mov    $0x800,%edi
  8056a8:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  8056af:	00 00 00 
  8056b2:	ff d0                	call   *%rax
  8056b4:	49 89 c4             	mov    %rax,%r12
  if(!maxlens) return 83; /*alloc fail*/
  8056b7:	48 8d b8 00 08 00 00 	lea    0x800(%rax),%rdi
  8056be:	48 89 c2             	mov    %rax,%rdx
  8056c1:	48 85 c0             	test   %rax,%rax
  8056c4:	74 c0                	je     805686 <HuffmanTree_makeFromLengths2+0x43c>
  for(i = 0; i < headsize; ++i) maxlens[i] = 0;
  8056c6:	c7 02 00 00 00 00    	movl   $0x0,(%rdx)
  8056cc:	48 83 c2 04          	add    $0x4,%rdx
  8056d0:	48 39 d7             	cmp    %rdx,%rdi
  8056d3:	75 f1                	jne    8056c6 <HuffmanTree_makeFromLengths2+0x47c>
  for(i = 0; i < tree->numcodes; i++) {
  8056d5:	83 7b 14 00          	cmpl   $0x0,0x14(%rbx)
  8056d9:	0f 84 08 fd ff ff    	je     8053e7 <HuffmanTree_makeFromLengths2+0x19d>
  8056df:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
  8056e5:	41 b9 08 00 00 00    	mov    $0x8,%r9d
  8056eb:	e9 b2 fc ff ff       	jmp    8053a2 <HuffmanTree_makeFromLengths2+0x158>
    jos_free(ptr);
  8056f0:	4c 89 e7             	mov    %r12,%rdi
  8056f3:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  8056fa:	00 00 00 
  8056fd:	ff d3                	call   *%rbx
  8056ff:	4c 89 ef             	mov    %r13,%rdi
  805702:	ff d3                	call   *%rbx
  805704:	b8 53 00 00 00       	mov    $0x53,%eax
}
  805709:	48 83 c4 08          	add    $0x8,%rsp
  80570d:	5b                   	pop    %rbx
  80570e:	41 5c                	pop    %r12
  805710:	41 5d                	pop    %r13
  805712:	41 5e                	pop    %r14
  805714:	41 5f                	pop    %r15
  805716:	5d                   	pop    %rbp
  805717:	c3                   	ret    

0000000000805718 <HuffmanTree_makeFromLengths>:
                                            size_t numcodes, unsigned maxbitlen) {
  805718:	55                   	push   %rbp
  805719:	48 89 e5             	mov    %rsp,%rbp
  80571c:	41 56                	push   %r14
  80571e:	41 55                	push   %r13
  805720:	41 54                	push   %r12
  805722:	53                   	push   %rbx
  805723:	48 89 fb             	mov    %rdi,%rbx
  805726:	49 89 f5             	mov    %rsi,%r13
  805729:	49 89 d4             	mov    %rdx,%r12
  80572c:	41 89 ce             	mov    %ecx,%r14d
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
  80572f:	48 8d 3c 95 00 00 00 	lea    0x0(,%rdx,4),%rdi
  805736:	00 
  return jos_malloc(size);
  805737:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80573e:	00 00 00 
  805741:	ff d0                	call   *%rax
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
  805743:	48 89 43 08          	mov    %rax,0x8(%rbx)
  if(!tree->lengths) return 83; /*alloc fail*/
  805747:	48 85 c0             	test   %rax,%rax
  80574a:	74 45                	je     805791 <HuffmanTree_makeFromLengths+0x79>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
  80574c:	4d 85 e4             	test   %r12,%r12
  80574f:	74 20                	je     805771 <HuffmanTree_makeFromLengths+0x59>
  805751:	ba 00 00 00 00       	mov    $0x0,%edx
  805756:	b8 00 00 00 00       	mov    $0x0,%eax
  80575b:	41 8b 74 85 00       	mov    0x0(%r13,%rax,4),%esi
  805760:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  805764:	89 34 81             	mov    %esi,(%rcx,%rax,4)
  805767:	83 c2 01             	add    $0x1,%edx
  80576a:	89 d0                	mov    %edx,%eax
  80576c:	4c 39 e0             	cmp    %r12,%rax
  80576f:	75 ea                	jne    80575b <HuffmanTree_makeFromLengths+0x43>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  805771:	44 89 63 14          	mov    %r12d,0x14(%rbx)
  tree->maxbitlen = maxbitlen;
  805775:	44 89 73 10          	mov    %r14d,0x10(%rbx)
  return HuffmanTree_makeFromLengths2(tree);
  805779:	48 89 df             	mov    %rbx,%rdi
  80577c:	48 b8 4a 52 80 00 00 	movabs $0x80524a,%rax
  805783:	00 00 00 
  805786:	ff d0                	call   *%rax
}
  805788:	5b                   	pop    %rbx
  805789:	41 5c                	pop    %r12
  80578b:	41 5d                	pop    %r13
  80578d:	41 5e                	pop    %r14
  80578f:	5d                   	pop    %rbp
  805790:	c3                   	ret    
  if(!tree->lengths) return 83; /*alloc fail*/
  805791:	b8 53 00 00 00       	mov    $0x53,%eax
  805796:	eb f0                	jmp    805788 <HuffmanTree_makeFromLengths+0x70>

0000000000805798 <generateFixedLitLenTree>:
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
  805798:	55                   	push   %rbp
  805799:	48 89 e5             	mov    %rsp,%rbp
  80579c:	41 54                	push   %r12
  80579e:	53                   	push   %rbx
  80579f:	49 89 fc             	mov    %rdi,%r12
  return jos_malloc(size);
  8057a2:	bf 80 04 00 00       	mov    $0x480,%edi
  8057a7:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  8057ae:	00 00 00 
  8057b1:	ff d0                	call   *%rax
  if(!bitlen) return 83; /*alloc fail*/
  8057b3:	48 85 c0             	test   %rax,%rax
  8057b6:	0f 84 a6 00 00 00    	je     805862 <generateFixedLitLenTree+0xca>
  8057bc:	48 89 c3             	mov    %rax,%rbx
  8057bf:	48 8d 90 40 02 00 00 	lea    0x240(%rax),%rdx
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
  8057c6:	c7 00 08 00 00 00    	movl   $0x8,(%rax)
  8057cc:	48 83 c0 04          	add    $0x4,%rax
  8057d0:	48 39 d0             	cmp    %rdx,%rax
  8057d3:	75 f1                	jne    8057c6 <generateFixedLitLenTree+0x2e>
  8057d5:	48 8d 83 40 02 00 00 	lea    0x240(%rbx),%rax
  8057dc:	48 8d 93 00 04 00 00 	lea    0x400(%rbx),%rdx
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
  8057e3:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
  8057e9:	48 83 c0 04          	add    $0x4,%rax
  8057ed:	48 39 d0             	cmp    %rdx,%rax
  8057f0:	75 f1                	jne    8057e3 <generateFixedLitLenTree+0x4b>
  8057f2:	48 8d 83 00 04 00 00 	lea    0x400(%rbx),%rax
  8057f9:	48 8d 93 60 04 00 00 	lea    0x460(%rbx),%rdx
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
  805800:	c7 00 07 00 00 00    	movl   $0x7,(%rax)
  805806:	48 83 c0 04          	add    $0x4,%rax
  80580a:	48 39 d0             	cmp    %rdx,%rax
  80580d:	75 f1                	jne    805800 <generateFixedLitLenTree+0x68>
  80580f:	48 8d 83 60 04 00 00 	lea    0x460(%rbx),%rax
  805816:	48 8d 93 80 04 00 00 	lea    0x480(%rbx),%rdx
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
  80581d:	c7 00 08 00 00 00    	movl   $0x8,(%rax)
  805823:	48 83 c0 04          	add    $0x4,%rax
  805827:	48 39 d0             	cmp    %rdx,%rax
  80582a:	75 f1                	jne    80581d <generateFixedLitLenTree+0x85>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
  80582c:	b9 0f 00 00 00       	mov    $0xf,%ecx
  805831:	ba 20 01 00 00       	mov    $0x120,%edx
  805836:	48 89 de             	mov    %rbx,%rsi
  805839:	4c 89 e7             	mov    %r12,%rdi
  80583c:	48 b8 18 57 80 00 00 	movabs $0x805718,%rax
  805843:	00 00 00 
  805846:	ff d0                	call   *%rax
  805848:	41 89 c4             	mov    %eax,%r12d
    jos_free(ptr);
  80584b:	48 89 df             	mov    %rbx,%rdi
  80584e:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  805855:	00 00 00 
  805858:	ff d0                	call   *%rax
}
  80585a:	44 89 e0             	mov    %r12d,%eax
  80585d:	5b                   	pop    %rbx
  80585e:	41 5c                	pop    %r12
  805860:	5d                   	pop    %rbp
  805861:	c3                   	ret    
  if(!bitlen) return 83; /*alloc fail*/
  805862:	41 bc 53 00 00 00    	mov    $0x53,%r12d
  805868:	eb f0                	jmp    80585a <generateFixedLitLenTree+0xc2>

000000000080586a <generateFixedDistanceTree>:
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
  80586a:	55                   	push   %rbp
  80586b:	48 89 e5             	mov    %rsp,%rbp
  80586e:	41 54                	push   %r12
  805870:	53                   	push   %rbx
  805871:	49 89 fc             	mov    %rdi,%r12
  return jos_malloc(size);
  805874:	bf 80 00 00 00       	mov    $0x80,%edi
  805879:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  805880:	00 00 00 
  805883:	ff d0                	call   *%rax
  if(!bitlen) return 83; /*alloc fail*/
  805885:	48 85 c0             	test   %rax,%rax
  805888:	74 4f                	je     8058d9 <generateFixedDistanceTree+0x6f>
  80588a:	48 89 c3             	mov    %rax,%rbx
  80588d:	48 8d 90 80 00 00 00 	lea    0x80(%rax),%rdx
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
  805894:	c7 00 05 00 00 00    	movl   $0x5,(%rax)
  80589a:	48 83 c0 04          	add    $0x4,%rax
  80589e:	48 39 d0             	cmp    %rdx,%rax
  8058a1:	75 f1                	jne    805894 <generateFixedDistanceTree+0x2a>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
  8058a3:	b9 0f 00 00 00       	mov    $0xf,%ecx
  8058a8:	ba 20 00 00 00       	mov    $0x20,%edx
  8058ad:	48 89 de             	mov    %rbx,%rsi
  8058b0:	4c 89 e7             	mov    %r12,%rdi
  8058b3:	48 b8 18 57 80 00 00 	movabs $0x805718,%rax
  8058ba:	00 00 00 
  8058bd:	ff d0                	call   *%rax
  8058bf:	41 89 c4             	mov    %eax,%r12d
    jos_free(ptr);
  8058c2:	48 89 df             	mov    %rbx,%rdi
  8058c5:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8058cc:	00 00 00 
  8058cf:	ff d0                	call   *%rax
}
  8058d1:	44 89 e0             	mov    %r12d,%eax
  8058d4:	5b                   	pop    %rbx
  8058d5:	41 5c                	pop    %r12
  8058d7:	5d                   	pop    %rbp
  8058d8:	c3                   	ret    
  if(!bitlen) return 83; /*alloc fail*/
  8058d9:	41 bc 53 00 00 00    	mov    $0x53,%r12d
  8058df:	eb f0                	jmp    8058d1 <generateFixedDistanceTree+0x67>

00000000008058e1 <color_tree_add>:
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  8058e1:	55                   	push   %rbp
  8058e2:	48 89 e5             	mov    %rsp,%rbp
  8058e5:	41 57                	push   %r15
  8058e7:	41 56                	push   %r14
  8058e9:	41 55                	push   %r13
  8058eb:	41 54                	push   %r12
  8058ed:	53                   	push   %rbx
  8058ee:	48 83 ec 18          	sub    $0x18,%rsp
  8058f2:	49 89 fd             	mov    %rdi,%r13
  8058f5:	44 89 4d c8          	mov    %r9d,-0x38(%rbp)
  8058f9:	88 4d cf             	mov    %cl,-0x31(%rbp)
  8058fc:	44 88 45 ce          	mov    %r8b,-0x32(%rbp)
  for(bit = 0; bit < 8; ++bit) {
  805900:	bb 00 00 00 00       	mov    $0x0,%ebx
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
  805905:	44 0f b6 fe          	movzbl %sil,%r15d
  805909:	44 0f b6 f2          	movzbl %dl,%r14d
  80590d:	eb 10                	jmp    80591f <color_tree_add+0x3e>
    tree = tree->children[i];
  80590f:	4d 63 e4             	movslq %r12d,%r12
  805912:	4f 8b 6c e5 00       	mov    0x0(%r13,%r12,8),%r13
  for(bit = 0; bit < 8; ++bit) {
  805917:	83 c3 01             	add    $0x1,%ebx
  80591a:	83 fb 08             	cmp    $0x8,%ebx
  80591d:	74 68                	je     805987 <color_tree_add+0xa6>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
  80591f:	44 89 fa             	mov    %r15d,%edx
  805922:	89 d9                	mov    %ebx,%ecx
  805924:	d3 fa                	sar    %cl,%edx
  805926:	83 e2 01             	and    $0x1,%edx
  805929:	44 89 f0             	mov    %r14d,%eax
  80592c:	d3 f8                	sar    %cl,%eax
  80592e:	83 e0 01             	and    $0x1,%eax
  805931:	8d 14 50             	lea    (%rax,%rdx,2),%edx
  805934:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
  805938:	d3 f8                	sar    %cl,%eax
  80593a:	83 e0 01             	and    $0x1,%eax
  80593d:	8d 14 50             	lea    (%rax,%rdx,2),%edx
  805940:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax
  805944:	d3 f8                	sar    %cl,%eax
  805946:	83 e0 01             	and    $0x1,%eax
  805949:	44 8d 24 50          	lea    (%rax,%rdx,2),%r12d
    if(!tree->children[i]) {
  80594d:	49 63 c4             	movslq %r12d,%rax
  805950:	49 83 7c c5 00 00    	cmpq   $0x0,0x0(%r13,%rax,8)
  805956:	75 b7                	jne    80590f <color_tree_add+0x2e>
  return jos_malloc(size);
  805958:	bf 88 00 00 00       	mov    $0x88,%edi
  80595d:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  805964:	00 00 00 
  805967:	ff d0                	call   *%rax
  805969:	48 89 c7             	mov    %rax,%rdi
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
  80596c:	49 63 c4             	movslq %r12d,%rax
  80596f:	49 89 7c c5 00       	mov    %rdi,0x0(%r13,%rax,8)
      if(!tree->children[i]) return 83; /*alloc fail*/
  805974:	48 85 ff             	test   %rdi,%rdi
  805977:	74 2c                	je     8059a5 <color_tree_add+0xc4>
      color_tree_init(tree->children[i]);
  805979:	48 b8 aa 44 80 00 00 	movabs $0x8044aa,%rax
  805980:	00 00 00 
  805983:	ff d0                	call   *%rax
  805985:	eb 88                	jmp    80590f <color_tree_add+0x2e>
  tree->index = (int)index;
  805987:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80598a:	41 89 85 80 00 00 00 	mov    %eax,0x80(%r13)
  return 0;
  805991:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805996:	48 83 c4 18          	add    $0x18,%rsp
  80599a:	5b                   	pop    %rbx
  80599b:	41 5c                	pop    %r12
  80599d:	41 5d                	pop    %r13
  80599f:	41 5e                	pop    %r14
  8059a1:	41 5f                	pop    %r15
  8059a3:	5d                   	pop    %rbp
  8059a4:	c3                   	ret    
      if(!tree->children[i]) return 83; /*alloc fail*/
  8059a5:	b8 53 00 00 00       	mov    $0x53,%eax
  8059aa:	eb ea                	jmp    805996 <color_tree_add+0xb5>

00000000008059ac <alloc_string>:
static char* alloc_string(const char* in) {
  8059ac:	55                   	push   %rbp
  8059ad:	48 89 e5             	mov    %rsp,%rbp
  8059b0:	41 54                	push   %r12
  8059b2:	53                   	push   %rbx
  8059b3:	49 89 fc             	mov    %rdi,%r12
  size_t insize = lodepng_strlen(in);
  8059b6:	48 b8 d3 28 80 00 00 	movabs $0x8028d3,%rax
  8059bd:	00 00 00 
  8059c0:	ff d0                	call   *%rax
  8059c2:	48 89 c3             	mov    %rax,%rbx
  char* out = (char*)lodepng_malloc(insize + 1);
  8059c5:	48 8d 78 01          	lea    0x1(%rax),%rdi
  return jos_malloc(size);
  8059c9:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  8059d0:	00 00 00 
  8059d3:	ff d0                	call   *%rax
  8059d5:	48 89 c2             	mov    %rax,%rdx
  if(out) {
  8059d8:	48 85 c0             	test   %rax,%rax
  8059db:	74 1f                	je     8059fc <alloc_string+0x50>
    for(i = 0; i != insize; ++i) {
  8059dd:	48 85 db             	test   %rbx,%rbx
  8059e0:	74 16                	je     8059f8 <alloc_string+0x4c>
  8059e2:	b8 00 00 00 00       	mov    $0x0,%eax
      out[i] = in[i];
  8059e7:	41 0f b6 0c 04       	movzbl (%r12,%rax,1),%ecx
  8059ec:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    for(i = 0; i != insize; ++i) {
  8059ef:	48 83 c0 01          	add    $0x1,%rax
  8059f3:	48 39 c3             	cmp    %rax,%rbx
  8059f6:	75 ef                	jne    8059e7 <alloc_string+0x3b>
    out[i] = 0;
  8059f8:	c6 04 1a 00          	movb   $0x0,(%rdx,%rbx,1)
}
  8059fc:	48 89 d0             	mov    %rdx,%rax
  8059ff:	5b                   	pop    %rbx
  805a00:	41 5c                	pop    %r12
  805a02:	5d                   	pop    %rbp
  805a03:	c3                   	ret    

0000000000805a04 <lodepng_color_mode_alloc_palette>:
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  805a04:	55                   	push   %rbp
  805a05:	48 89 e5             	mov    %rsp,%rbp
  805a08:	53                   	push   %rbx
  805a09:	48 83 ec 08          	sub    $0x8,%rsp
  805a0d:	48 89 fb             	mov    %rdi,%rbx
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  805a10:	48 83 7f 08 00       	cmpq   $0x0,0x8(%rdi)
  805a15:	74 3a                	je     805a51 <lodepng_color_mode_alloc_palette+0x4d>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  805a17:	b8 00 00 00 00       	mov    $0x0,%eax
    info->palette[i * 4 + 0] = 0;
  805a1c:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  805a20:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
    info->palette[i * 4 + 1] = 0;
  805a24:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  805a28:	c6 44 02 01 00       	movb   $0x0,0x1(%rdx,%rax,1)
    info->palette[i * 4 + 2] = 0;
  805a2d:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  805a31:	c6 44 02 02 00       	movb   $0x0,0x2(%rdx,%rax,1)
    info->palette[i * 4 + 3] = 255;
  805a36:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  805a3a:	c6 44 02 03 ff       	movb   $0xff,0x3(%rdx,%rax,1)
  for(i = 0; i != 256; ++i) {
  805a3f:	48 83 c0 04          	add    $0x4,%rax
  805a43:	48 3d 00 04 00 00    	cmp    $0x400,%rax
  805a49:	75 d1                	jne    805a1c <lodepng_color_mode_alloc_palette+0x18>
}
  805a4b:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  805a4f:	c9                   	leave  
  805a50:	c3                   	ret    
  return jos_malloc(size);
  805a51:	bf 00 04 00 00       	mov    $0x400,%edi
  805a56:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  805a5d:	00 00 00 
  805a60:	ff d0                	call   *%rax
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  805a62:	48 89 43 08          	mov    %rax,0x8(%rbx)
  if(!info->palette) return; /*alloc fail*/
  805a66:	48 85 c0             	test   %rax,%rax
  805a69:	74 e0                	je     805a4b <lodepng_color_mode_alloc_palette+0x47>
  805a6b:	eb aa                	jmp    805a17 <lodepng_color_mode_alloc_palette+0x13>

0000000000805a6d <readChunk_PLTE>:
  color->palettesize = chunkLength / 3u;
  805a6d:	48 b9 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rcx
  805a74:	aa aa aa 
  805a77:	48 89 d0             	mov    %rdx,%rax
  805a7a:	48 f7 e1             	mul    %rcx
  805a7d:	48 d1 ea             	shr    %rdx
  805a80:	48 89 57 10          	mov    %rdx,0x10(%rdi)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
  805a84:	48 83 ea 01          	sub    $0x1,%rdx
  805a88:	b8 26 00 00 00       	mov    $0x26,%eax
  805a8d:	48 81 fa ff 00 00 00 	cmp    $0xff,%rdx
  805a94:	0f 87 b7 00 00 00    	ja     805b51 <readChunk_PLTE+0xe4>
static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
  805a9a:	55                   	push   %rbp
  805a9b:	48 89 e5             	mov    %rsp,%rbp
  805a9e:	41 54                	push   %r12
  805aa0:	53                   	push   %rbx
  805aa1:	48 89 fb             	mov    %rdi,%rbx
  805aa4:	49 89 f4             	mov    %rsi,%r12
  lodepng_color_mode_alloc_palette(color);
  805aa7:	48 b8 04 5a 80 00 00 	movabs $0x805a04,%rax
  805aae:	00 00 00 
  805ab1:	ff d0                	call   *%rax
  if(!color->palette && color->palettesize) {
  805ab3:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  805ab8:	74 7c                	je     805b36 <readChunk_PLTE+0xc9>
  for(i = 0; i != color->palettesize; ++i) {
  805aba:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  805abf:	74 6e                	je     805b2f <readChunk_PLTE+0xc2>
  805ac1:	b8 00 00 00 00       	mov    $0x0,%eax
  805ac6:	be 00 00 00 00       	mov    $0x0,%esi
  805acb:	ba 00 00 00 00       	mov    $0x0,%edx
    color->palette[4 * i + 0] = data[pos++]; /*R*/
  805ad0:	89 d1                	mov    %edx,%ecx
  805ad2:	45 0f b6 04 0c       	movzbl (%r12,%rcx,1),%r8d
  805ad7:	89 c1                	mov    %eax,%ecx
  805ad9:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  805add:	44 88 04 0f          	mov    %r8b,(%rdi,%rcx,1)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
  805ae1:	8d 4a 02             	lea    0x2(%rdx),%ecx
  805ae4:	8d 7a 01             	lea    0x1(%rdx),%edi
  805ae7:	45 0f b6 0c 3c       	movzbl (%r12,%rdi,1),%r9d
  805aec:	8d 78 01             	lea    0x1(%rax),%edi
  805aef:	4c 8b 43 08          	mov    0x8(%rbx),%r8
  805af3:	45 88 0c 38          	mov    %r9b,(%r8,%rdi,1)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
  805af7:	83 c2 03             	add    $0x3,%edx
  805afa:	89 c9                	mov    %ecx,%ecx
  805afc:	45 0f b6 04 0c       	movzbl (%r12,%rcx,1),%r8d
  805b01:	8d 48 02             	lea    0x2(%rax),%ecx
  805b04:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  805b08:	44 88 04 0f          	mov    %r8b,(%rdi,%rcx,1)
    color->palette[4 * i + 3] = 255; /*alpha*/
  805b0c:	8d 48 03             	lea    0x3(%rax),%ecx
  805b0f:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  805b13:	c6 04 0f ff          	movb   $0xff,(%rdi,%rcx,1)
  for(i = 0; i != color->palettesize; ++i) {
  805b17:	83 c6 01             	add    $0x1,%esi
  805b1a:	83 c0 04             	add    $0x4,%eax
  805b1d:	89 f1                	mov    %esi,%ecx
  805b1f:	48 3b 4b 10          	cmp    0x10(%rbx),%rcx
  805b23:	75 ab                	jne    805ad0 <readChunk_PLTE+0x63>
  return 0; /* OK */
  805b25:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b2a:	5b                   	pop    %rbx
  805b2b:	41 5c                	pop    %r12
  805b2d:	5d                   	pop    %rbp
  805b2e:	c3                   	ret    
  return 0; /* OK */
  805b2f:	b8 00 00 00 00       	mov    $0x0,%eax
  805b34:	eb f4                	jmp    805b2a <readChunk_PLTE+0xbd>
  805b36:	b8 00 00 00 00       	mov    $0x0,%eax
  if(!color->palette && color->palettesize) {
  805b3b:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  805b40:	74 e8                	je     805b2a <readChunk_PLTE+0xbd>
    color->palettesize = 0;
  805b42:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  805b49:	00 
    return 83; /*alloc fail*/
  805b4a:	b8 53 00 00 00       	mov    $0x53,%eax
  805b4f:	eb d9                	jmp    805b2a <readChunk_PLTE+0xbd>
}
  805b51:	c3                   	ret    

0000000000805b52 <lodepng_assign_icc>:
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
  805b52:	b8 64 00 00 00       	mov    $0x64,%eax
  805b57:	85 c9                	test   %ecx,%ecx
  805b59:	0f 84 85 00 00 00    	je     805be4 <lodepng_assign_icc+0x92>
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
  805b5f:	55                   	push   %rbp
  805b60:	48 89 e5             	mov    %rsp,%rbp
  805b63:	41 55                	push   %r13
  805b65:	41 54                	push   %r12
  805b67:	53                   	push   %rbx
  805b68:	48 83 ec 08          	sub    $0x8,%rsp
  805b6c:	49 89 fc             	mov    %rdi,%r12
  805b6f:	49 89 d5             	mov    %rdx,%r13
  805b72:	89 cb                	mov    %ecx,%ebx
  info->iccp_name = alloc_string(name);
  805b74:	48 89 f7             	mov    %rsi,%rdi
  805b77:	48 b8 ac 59 80 00 00 	movabs $0x8059ac,%rax
  805b7e:	00 00 00 
  805b81:	ff d0                	call   *%rax
  805b83:	49 89 84 24 f0 00 00 	mov    %rax,0xf0(%r12)
  805b8a:	00 
  return jos_malloc(size);
  805b8b:	89 df                	mov    %ebx,%edi
  805b8d:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  805b94:	00 00 00 
  805b97:	ff d0                	call   *%rax
  805b99:	48 89 c7             	mov    %rax,%rdi
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
  805b9c:	49 89 84 24 f8 00 00 	mov    %rax,0xf8(%r12)
  805ba3:	00 
  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
  805ba4:	49 83 bc 24 f0 00 00 	cmpq   $0x0,0xf0(%r12)
  805bab:	00 00 
  805bad:	74 2e                	je     805bdd <lodepng_assign_icc+0x8b>
  805baf:	48 85 c0             	test   %rax,%rax
  805bb2:	74 29                	je     805bdd <lodepng_assign_icc+0x8b>
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
  805bb4:	89 da                	mov    %ebx,%edx
  memcpy(dst, src, size);
  805bb6:	4c 89 ee             	mov    %r13,%rsi
  805bb9:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  805bc0:	00 00 00 
  805bc3:	ff d0                	call   *%rax
  info->iccp_profile_size = profile_size;
  805bc5:	41 89 9c 24 00 01 00 	mov    %ebx,0x100(%r12)
  805bcc:	00 
  return 0; /*ok*/
  805bcd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805bd2:	48 83 c4 08          	add    $0x8,%rsp
  805bd6:	5b                   	pop    %rbx
  805bd7:	41 5c                	pop    %r12
  805bd9:	41 5d                	pop    %r13
  805bdb:	5d                   	pop    %rbp
  805bdc:	c3                   	ret    
  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
  805bdd:	b8 53 00 00 00       	mov    $0x53,%eax
  805be2:	eb ee                	jmp    805bd2 <lodepng_assign_icc+0x80>
}
  805be4:	c3                   	ret    

0000000000805be5 <lodepng_malloc>:
void* lodepng_malloc(size_t size) {
  805be5:	55                   	push   %rbp
  805be6:	48 89 e5             	mov    %rsp,%rbp
  return jos_malloc(size);
  805be9:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  805bf0:	00 00 00 
  805bf3:	ff d0                	call   *%rax
}
  805bf5:	5d                   	pop    %rbp
  805bf6:	c3                   	ret    

0000000000805bf7 <lodepng_free>:
void lodepng_free(void* ptr) {
  805bf7:	55                   	push   %rbp
  805bf8:	48 89 e5             	mov    %rsp,%rbp
    jos_free(ptr);
  805bfb:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  805c02:	00 00 00 
  805c05:	ff d0                	call   *%rax
}
  805c07:	5d                   	pop    %rbp
  805c08:	c3                   	ret    

0000000000805c09 <lodepng_realloc>:
void* lodepng_realloc(void* ptr, size_t new_size) {
  805c09:	55                   	push   %rbp
  805c0a:	48 89 e5             	mov    %rsp,%rbp
  805c0d:	48 89 f7             	mov    %rsi,%rdi
  return jos_malloc(new_size);
  805c10:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  805c17:	00 00 00 
  805c1a:	ff d0                	call   *%rax
}
  805c1c:	5d                   	pop    %rbp
  805c1d:	c3                   	ret    

0000000000805c1e <lodepng_load_file>:
unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
  805c1e:	55                   	push   %rbp
  805c1f:	48 89 e5             	mov    %rsp,%rbp
  805c22:	41 57                	push   %r15
  805c24:	41 56                	push   %r14
  805c26:	41 55                	push   %r13
  805c28:	41 54                	push   %r12
  805c2a:	53                   	push   %rbx
  805c2b:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
  805c32:	48 89 bd 38 ff ff ff 	mov    %rdi,-0xc8(%rbp)
  805c39:	49 89 f5             	mov    %rsi,%r13
  805c3c:	48 89 d3             	mov    %rdx,%rbx
  fd = open(filename, O_RDONLY);
  805c3f:	be 00 00 00 00       	mov    $0x0,%esi
  805c44:	48 89 d7             	mov    %rdx,%rdi
  805c47:	48 b8 2a 20 80 00 00 	movabs $0x80202a,%rax
  805c4e:	00 00 00 
  805c51:	ff d0                	call   *%rax
  if (fd < 0)
  805c53:	85 c0                	test   %eax,%eax
  805c55:	0f 88 d5 00 00 00    	js     805d30 <lodepng_load_file+0x112>
  805c5b:	41 89 c4             	mov    %eax,%r12d
  stat(filename, &st);
  805c5e:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
  805c65:	48 89 df             	mov    %rbx,%rdi
  805c68:	48 b8 5f 1d 80 00 00 	movabs $0x801d5f,%rax
  805c6f:	00 00 00 
  805c72:	ff d0                	call   *%rax
  size = st.st_size;
  805c74:	44 8b 75 c0          	mov    -0x40(%rbp),%r14d
  805c78:	4d 63 fe             	movslq %r14d,%r15
  close(fd);
  805c7b:	44 89 e7             	mov    %r12d,%edi
  805c7e:	48 b8 bf 18 80 00 00 	movabs $0x8018bf,%rax
  805c85:	00 00 00 
  805c88:	ff d0                	call   *%rax
  if(size < 0) return 78;
  805c8a:	b8 4e 00 00 00       	mov    $0x4e,%eax
  805c8f:	4d 85 ff             	test   %r15,%r15
  805c92:	0f 88 86 00 00 00    	js     805d1e <lodepng_load_file+0x100>
  *outsize = (size_t)size;
  805c98:	4d 89 fc             	mov    %r15,%r12
  805c9b:	4d 89 7d 00          	mov    %r15,0x0(%r13)
  return jos_malloc(size);
  805c9f:	44 89 f7             	mov    %r14d,%edi
  805ca2:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  805ca9:	00 00 00 
  805cac:	ff d0                	call   *%rax
  805cae:	49 89 c5             	mov    %rax,%r13
  *out = (unsigned char*)lodepng_malloc((size_t)size);
  805cb1:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  805cb8:	4c 89 28             	mov    %r13,(%rax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
  805cbb:	4d 85 ed             	test   %r13,%r13
  805cbe:	75 0a                	jne    805cca <lodepng_load_file+0xac>
  805cc0:	b8 53 00 00 00       	mov    $0x53,%eax
  805cc5:	4d 85 ff             	test   %r15,%r15
  805cc8:	7f 54                	jg     805d1e <lodepng_load_file+0x100>
  file = open(filename, O_RDONLY);
  805cca:	be 00 00 00 00       	mov    $0x0,%esi
  805ccf:	48 89 df             	mov    %rbx,%rdi
  805cd2:	48 b8 2a 20 80 00 00 	movabs $0x80202a,%rax
  805cd9:	00 00 00 
  805cdc:	ff d0                	call   *%rax
  805cde:	89 c3                	mov    %eax,%ebx
  if(file < 0) return 78;
  805ce0:	b8 4e 00 00 00       	mov    $0x4e,%eax
  805ce5:	85 db                	test   %ebx,%ebx
  805ce7:	78 35                	js     805d1e <lodepng_load_file+0x100>
  readsize = readn(file, out, size);
  805ce9:	4c 89 e2             	mov    %r12,%rdx
  805cec:	4c 89 ee             	mov    %r13,%rsi
  805cef:	89 df                	mov    %ebx,%edi
  805cf1:	48 b8 f1 1a 80 00 00 	movabs $0x801af1,%rax
  805cf8:	00 00 00 
  805cfb:	ff d0                	call   *%rax
  805cfd:	49 89 c5             	mov    %rax,%r13
  close(file);
  805d00:	89 df                	mov    %ebx,%edi
  805d02:	48 b8 bf 18 80 00 00 	movabs $0x8018bf,%rax
  805d09:	00 00 00 
  805d0c:	ff d0                	call   *%rax
  if(readsize != size) return 78;
  805d0e:	4d 39 ec             	cmp    %r13,%r12
  805d11:	b8 00 00 00 00       	mov    $0x0,%eax
  805d16:	ba 4e 00 00 00       	mov    $0x4e,%edx
  805d1b:	0f 45 c2             	cmovne %edx,%eax
}
  805d1e:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  805d25:	5b                   	pop    %rbx
  805d26:	41 5c                	pop    %r12
  805d28:	41 5d                	pop    %r13
  805d2a:	41 5e                	pop    %r14
  805d2c:	41 5f                	pop    %r15
  805d2e:	5d                   	pop    %rbp
  805d2f:	c3                   	ret    
  if(size < 0) return 78;
  805d30:	b8 4e 00 00 00       	mov    $0x4e,%eax
  805d35:	eb e7                	jmp    805d1e <lodepng_load_file+0x100>

0000000000805d37 <lodepng_save_file>:
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
  805d37:	55                   	push   %rbp
  805d38:	48 89 e5             	mov    %rsp,%rbp
  805d3b:	41 55                	push   %r13
  805d3d:	41 54                	push   %r12
  805d3f:	53                   	push   %rbx
  805d40:	48 83 ec 08          	sub    $0x8,%rsp
  805d44:	49 89 fc             	mov    %rdi,%r12
  805d47:	49 89 f5             	mov    %rsi,%r13
  805d4a:	48 89 d7             	mov    %rdx,%rdi
  file = open(filename, O_WRONLY );
  805d4d:	be 01 00 00 00       	mov    $0x1,%esi
  805d52:	48 b8 2a 20 80 00 00 	movabs $0x80202a,%rax
  805d59:	00 00 00 
  805d5c:	ff d0                	call   *%rax
  805d5e:	89 c3                	mov    %eax,%ebx
  if(!file) return 79;
  805d60:	b8 4f 00 00 00       	mov    $0x4f,%eax
  805d65:	85 db                	test   %ebx,%ebx
  805d67:	74 27                	je     805d90 <lodepng_save_file+0x59>
  write(file, buffer, buffersize);
  805d69:	4c 89 ea             	mov    %r13,%rdx
  805d6c:	4c 89 e6             	mov    %r12,%rsi
  805d6f:	89 df                	mov    %ebx,%edi
  805d71:	48 b8 62 1b 80 00 00 	movabs $0x801b62,%rax
  805d78:	00 00 00 
  805d7b:	ff d0                	call   *%rax
  close(file);
  805d7d:	89 df                	mov    %ebx,%edi
  805d7f:	48 b8 bf 18 80 00 00 	movabs $0x8018bf,%rax
  805d86:	00 00 00 
  805d89:	ff d0                	call   *%rax
  return 0;
  805d8b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805d90:	48 83 c4 08          	add    $0x8,%rsp
  805d94:	5b                   	pop    %rbx
  805d95:	41 5c                	pop    %r12
  805d97:	41 5d                	pop    %r13
  805d99:	5d                   	pop    %rbp
  805d9a:	c3                   	ret    

0000000000805d9b <LodePNGBitWriter_init>:
  writer->data = data;
  805d9b:	48 89 37             	mov    %rsi,(%rdi)
  writer->bp = 0;
  805d9e:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  805da5:	00 
}
  805da6:	c3                   	ret    

0000000000805da7 <lode_png_test_bitreader>:
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  805da7:	55                   	push   %rbp
  805da8:	48 89 e5             	mov    %rsp,%rbp
  805dab:	41 57                	push   %r15
  805dad:	41 56                	push   %r14
  805daf:	41 55                	push   %r13
  805db1:	41 54                	push   %r12
  805db3:	53                   	push   %rbx
  805db4:	48 83 ec 48          	sub    $0x48,%rsp
  805db8:	48 89 d3             	mov    %rdx,%rbx
  805dbb:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  805dbf:	49 89 cd             	mov    %rcx,%r13
  805dc2:	4d 89 c6             	mov    %r8,%r14
  LodePNGBitReader_init(&reader, data, size);
  805dc5:	48 89 f2             	mov    %rsi,%rdx
  805dc8:	48 89 fe             	mov    %rdi,%rsi
  805dcb:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  805dcf:	48 b8 5e 45 80 00 00 	movabs $0x80455e,%rax
  805dd6:	00 00 00 
  805dd9:	ff d0                	call   *%rax
  for(i = 0; i < numsteps; i++) {
  805ddb:	48 85 db             	test   %rbx,%rbx
  805dde:	0f 84 17 02 00 00    	je     805ffb <lode_png_test_bitreader+0x254>
  805de4:	bb 00 00 00 00       	mov    $0x0,%ebx
    result[i] = readBits(&reader, step);
  805de9:	49 bf 1e 2a 80 00 00 	movabs $0x802a1e,%r15
  805df0:	00 00 00 
  805df3:	e9 bb 01 00 00       	jmp    805fb3 <lode_png_test_bitreader+0x20c>
  size_t start = reader->bp >> 3u;
  805df8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  805dfc:	48 89 d0             	mov    %rdx,%rax
  805dff:	48 c1 e8 03          	shr    $0x3,%rax
  size_t size = reader->size;
  805e03:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  if(start + 4u < size) {
  805e07:	48 8d 70 04          	lea    0x4(%rax),%rsi
  805e0b:	48 39 f1             	cmp    %rsi,%rcx
  805e0e:	76 4d                	jbe    805e5d <lode_png_test_bitreader+0xb6>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  805e10:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    reader->buffer >>= (reader->bp & 7u);
  805e14:	89 d7                	mov    %edx,%edi
  805e16:	83 e7 07             	and    $0x7,%edi
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  805e19:	0f b6 54 06 01       	movzbl 0x1(%rsi,%rax,1),%edx
  805e1e:	c1 e2 08             	shl    $0x8,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  805e21:	0f b6 4c 06 02       	movzbl 0x2(%rsi,%rax,1),%ecx
  805e26:	c1 e1 10             	shl    $0x10,%ecx
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  805e29:	09 ca                	or     %ecx,%edx
  805e2b:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
  805e2f:	09 ca                	or     %ecx,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  805e31:	0f b6 4c 06 03       	movzbl 0x3(%rsi,%rax,1),%ecx
  805e36:	c1 e1 18             	shl    $0x18,%ecx
  805e39:	09 ca                	or     %ecx,%edx
    reader->buffer >>= (reader->bp & 7u);
  805e3b:	89 f9                	mov    %edi,%ecx
  805e3d:	d3 ea                	shr    %cl,%edx
  805e3f:	89 55 c8             	mov    %edx,-0x38(%rbp)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
  805e42:	0f b6 44 06 04       	movzbl 0x4(%rsi,%rax,1),%eax
  805e47:	c1 e0 18             	shl    $0x18,%eax
  805e4a:	b9 08 00 00 00       	mov    $0x8,%ecx
  805e4f:	29 f9                	sub    %edi,%ecx
  805e51:	d3 e0                	shl    %cl,%eax
  805e53:	09 c2                	or     %eax,%edx
  805e55:	89 55 c8             	mov    %edx,-0x38(%rbp)
    return 1;
  805e58:	e9 3e 01 00 00       	jmp    805f9b <lode_png_test_bitreader+0x1f4>
    reader->buffer = 0;
  805e5d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
  805e64:	48 39 c8             	cmp    %rcx,%rax
  805e67:	73 0b                	jae    805e74 <lode_png_test_bitreader+0xcd>
  805e69:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  805e6d:	0f b6 34 06          	movzbl (%rsi,%rax,1),%esi
  805e71:	89 75 c8             	mov    %esi,-0x38(%rbp)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
  805e74:	48 8d 70 01          	lea    0x1(%rax),%rsi
  805e78:	48 39 f1             	cmp    %rsi,%rcx
  805e7b:	76 0f                	jbe    805e8c <lode_png_test_bitreader+0xe5>
  805e7d:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  805e81:	0f b6 74 06 01       	movzbl 0x1(%rsi,%rax,1),%esi
  805e86:	c1 e6 08             	shl    $0x8,%esi
  805e89:	09 75 c8             	or     %esi,-0x38(%rbp)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
  805e8c:	48 8d 70 02          	lea    0x2(%rax),%rsi
  805e90:	48 39 f1             	cmp    %rsi,%rcx
  805e93:	76 0f                	jbe    805ea4 <lode_png_test_bitreader+0xfd>
  805e95:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  805e99:	0f b6 74 06 02       	movzbl 0x2(%rsi,%rax,1),%esi
  805e9e:	c1 e6 10             	shl    $0x10,%esi
  805ea1:	09 75 c8             	or     %esi,-0x38(%rbp)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
  805ea4:	48 8d 70 03          	lea    0x3(%rax),%rsi
  805ea8:	48 39 f1             	cmp    %rsi,%rcx
  805eab:	76 0f                	jbe    805ebc <lode_png_test_bitreader+0x115>
  805ead:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  805eb1:	0f b6 44 01 03       	movzbl 0x3(%rcx,%rax,1),%eax
  805eb6:	c1 e0 18             	shl    $0x18,%eax
  805eb9:	09 45 c8             	or     %eax,-0x38(%rbp)
    reader->buffer >>= (reader->bp & 7u);
  805ebc:	89 d1                	mov    %edx,%ecx
  805ebe:	83 e1 07             	and    $0x7,%ecx
  805ec1:	d3 6d c8             	shrl   %cl,-0x38(%rbp)
    return reader->bp + nbits <= reader->bitsize;
  805ec4:	4c 01 e2             	add    %r12,%rdx
    if(!ok) return 0;
  805ec7:	48 3b 55 b8          	cmp    -0x48(%rbp),%rdx
  805ecb:	0f 86 ca 00 00 00    	jbe    805f9b <lode_png_test_bitreader+0x1f4>
  805ed1:	b8 00 00 00 00       	mov    $0x0,%eax
  805ed6:	e9 11 01 00 00       	jmp    805fec <lode_png_test_bitreader+0x245>
  size_t start = reader->bp >> 3u;
  805edb:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  805edf:	48 89 f0             	mov    %rsi,%rax
  805ee2:	48 c1 e8 03          	shr    $0x3,%rax
  size_t size = reader->size;
  805ee6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  if(start + 3u < size) {
  805eea:	48 8d 48 03          	lea    0x3(%rax),%rcx
  805eee:	48 39 ca             	cmp    %rcx,%rdx
  805ef1:	76 32                	jbe    805f25 <lode_png_test_bitreader+0x17e>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  805ef3:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  805ef7:	0f b6 54 01 01       	movzbl 0x1(%rcx,%rax,1),%edx
  805efc:	c1 e2 08             	shl    $0x8,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  805eff:	0f b6 7c 01 02       	movzbl 0x2(%rcx,%rax,1),%edi
  805f04:	c1 e7 10             	shl    $0x10,%edi
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  805f07:	09 fa                	or     %edi,%edx
  805f09:	0f b6 3c 01          	movzbl (%rcx,%rax,1),%edi
  805f0d:	09 fa                	or     %edi,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  805f0f:	0f b6 44 01 03       	movzbl 0x3(%rcx,%rax,1),%eax
  805f14:	c1 e0 18             	shl    $0x18,%eax
  805f17:	09 d0                	or     %edx,%eax
    reader->buffer >>= (reader->bp & 7u);
  805f19:	89 f1                	mov    %esi,%ecx
  805f1b:	83 e1 07             	and    $0x7,%ecx
  805f1e:	d3 e8                	shr    %cl,%eax
  805f20:	89 45 c8             	mov    %eax,-0x38(%rbp)
    return 1;
  805f23:	eb 76                	jmp    805f9b <lode_png_test_bitreader+0x1f4>
    reader->buffer = 0;
  805f25:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
  805f2c:	48 39 d0             	cmp    %rdx,%rax
  805f2f:	73 0b                	jae    805f3c <lode_png_test_bitreader+0x195>
  805f31:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  805f35:	0f b6 0c 01          	movzbl (%rcx,%rax,1),%ecx
  805f39:	89 4d c8             	mov    %ecx,-0x38(%rbp)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
  805f3c:	48 8d 48 01          	lea    0x1(%rax),%rcx
  805f40:	48 39 ca             	cmp    %rcx,%rdx
  805f43:	76 0f                	jbe    805f54 <lode_png_test_bitreader+0x1ad>
  805f45:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  805f49:	0f b6 4c 01 01       	movzbl 0x1(%rcx,%rax,1),%ecx
  805f4e:	c1 e1 08             	shl    $0x8,%ecx
  805f51:	09 4d c8             	or     %ecx,-0x38(%rbp)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
  805f54:	48 8d 48 02          	lea    0x2(%rax),%rcx
  805f58:	48 39 ca             	cmp    %rcx,%rdx
  805f5b:	76 0f                	jbe    805f6c <lode_png_test_bitreader+0x1c5>
  805f5d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  805f61:	0f b6 44 02 02       	movzbl 0x2(%rdx,%rax,1),%eax
  805f66:	c1 e0 10             	shl    $0x10,%eax
  805f69:	09 45 c8             	or     %eax,-0x38(%rbp)
    reader->buffer >>= (reader->bp & 7u);
  805f6c:	89 f1                	mov    %esi,%ecx
  805f6e:	83 e1 07             	and    $0x7,%ecx
  805f71:	d3 6d c8             	shrl   %cl,-0x38(%rbp)
    return reader->bp + nbits <= reader->bitsize;
  805f74:	4c 01 e6             	add    %r12,%rsi
    if(!ok) return 0;
  805f77:	48 3b 75 b8          	cmp    -0x48(%rbp),%rsi
  805f7b:	76 1e                	jbe    805f9b <lode_png_test_bitreader+0x1f4>
  805f7d:	b8 00 00 00 00       	mov    $0x0,%eax
  805f82:	eb 68                	jmp    805fec <lode_png_test_bitreader+0x245>
    else ok = ensureBits9(&reader, step);
  805f84:	4c 89 e6             	mov    %r12,%rsi
  805f87:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  805f8b:	48 b8 28 29 80 00 00 	movabs $0x802928,%rax
  805f92:	00 00 00 
  805f95:	ff d0                	call   *%rax
    if(!ok) return 0;
  805f97:	85 c0                	test   %eax,%eax
  805f99:	74 51                	je     805fec <lode_png_test_bitreader+0x245>
    result[i] = readBits(&reader, step);
  805f9b:	4c 89 e6             	mov    %r12,%rsi
  805f9e:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  805fa2:	41 ff d7             	call   *%r15
  805fa5:	41 89 04 9e          	mov    %eax,(%r14,%rbx,4)
  for(i = 0; i < numsteps; i++) {
  805fa9:	48 83 c3 01          	add    $0x1,%rbx
  805fad:	48 39 5d 98          	cmp    %rbx,-0x68(%rbp)
  805fb1:	74 34                	je     805fe7 <lode_png_test_bitreader+0x240>
    size_t step = steps[i];
  805fb3:	4d 8b 64 dd 00       	mov    0x0(%r13,%rbx,8),%r12
    if(step > 25) ok = ensureBits32(&reader, step);
  805fb8:	49 83 fc 19          	cmp    $0x19,%r12
  805fbc:	0f 87 36 fe ff ff    	ja     805df8 <lode_png_test_bitreader+0x51>
    else if(step > 17) ok = ensureBits25(&reader, step);
  805fc2:	49 83 fc 11          	cmp    $0x11,%r12
  805fc6:	0f 87 0f ff ff ff    	ja     805edb <lode_png_test_bitreader+0x134>
    else if(step > 9) ok = ensureBits17(&reader, step);
  805fcc:	49 83 fc 09          	cmp    $0x9,%r12
  805fd0:	76 b2                	jbe    805f84 <lode_png_test_bitreader+0x1dd>
  805fd2:	4c 89 e6             	mov    %r12,%rsi
  805fd5:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  805fd9:	48 b8 90 29 80 00 00 	movabs $0x802990,%rax
  805fe0:	00 00 00 
  805fe3:	ff d0                	call   *%rax
  805fe5:	eb b0                	jmp    805f97 <lode_png_test_bitreader+0x1f0>
  return 1;
  805fe7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  805fec:	48 83 c4 48          	add    $0x48,%rsp
  805ff0:	5b                   	pop    %rbx
  805ff1:	41 5c                	pop    %r12
  805ff3:	41 5d                	pop    %r13
  805ff5:	41 5e                	pop    %r14
  805ff7:	41 5f                	pop    %r15
  805ff9:	5d                   	pop    %rbp
  805ffa:	c3                   	ret    
  return 1;
  805ffb:	b8 01 00 00 00       	mov    $0x1,%eax
  806000:	eb ea                	jmp    805fec <lode_png_test_bitreader+0x245>

0000000000806002 <lodepng_huffman_code_lengths>:
                                      size_t numcodes, unsigned maxbitlen) {
  806002:	55                   	push   %rbp
  806003:	48 89 e5             	mov    %rsp,%rbp
  806006:	41 57                	push   %r15
  806008:	41 56                	push   %r14
  80600a:	41 55                	push   %r13
  80600c:	41 54                	push   %r12
  80600e:	53                   	push   %rbx
  80600f:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  806016:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
  80601d:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%rbp)
  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
  806023:	41 be 50 00 00 00    	mov    $0x50,%r14d
  806029:	48 85 d2             	test   %rdx,%rdx
  80602c:	0f 84 b8 00 00 00    	je     8060ea <lodepng_huffman_code_lengths+0xe8>
  806032:	49 89 f5             	mov    %rsi,%r13
  806035:	49 89 d4             	mov    %rdx,%r12
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
  806038:	b8 01 00 00 00       	mov    $0x1,%eax
  80603d:	d3 e0                	shl    %cl,%eax
  80603f:	39 d0                	cmp    %edx,%eax
  806041:	0f 82 a3 00 00 00    	jb     8060ea <lodepng_huffman_code_lengths+0xe8>
  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  806047:	48 8d 3c 52          	lea    (%rdx,%rdx,2),%rdi
  80604b:	48 c1 e7 03          	shl    $0x3,%rdi
  return jos_malloc(size);
  80604f:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  806056:	00 00 00 
  806059:	ff d0                	call   *%rax
  80605b:	49 89 c7             	mov    %rax,%r15
  if(!leaves) return 83; /*alloc fail*/
  80605e:	48 85 c0             	test   %rax,%rax
  806061:	0f 84 24 04 00 00    	je     80648b <lodepng_huffman_code_lengths+0x489>
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
  806067:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(i = 0; i != numcodes; ++i) {
  80606c:	b8 00 00 00 00       	mov    $0x0,%eax
  806071:	ba 00 00 00 00       	mov    $0x0,%edx
  806076:	eb 0a                	jmp    806082 <lodepng_huffman_code_lengths+0x80>
  806078:	83 c0 01             	add    $0x1,%eax
  80607b:	89 c2                	mov    %eax,%edx
  80607d:	4c 39 e2             	cmp    %r12,%rdx
  806080:	74 1c                	je     80609e <lodepng_huffman_code_lengths+0x9c>
    if(frequencies[i] > 0) {
  806082:	41 8b 54 95 00       	mov    0x0(%r13,%rdx,4),%edx
  806087:	85 d2                	test   %edx,%edx
  806089:	74 ed                	je     806078 <lodepng_huffman_code_lengths+0x76>
      leaves[numpresent].weight = (int)frequencies[i];
  80608b:	48 8d 0c 5b          	lea    (%rbx,%rbx,2),%rcx
  80608f:	49 8d 0c cf          	lea    (%r15,%rcx,8),%rcx
  806093:	89 11                	mov    %edx,(%rcx)
      leaves[numpresent].index = i;
  806095:	89 41 04             	mov    %eax,0x4(%rcx)
      ++numpresent;
  806098:	48 83 c3 01          	add    $0x1,%rbx
  80609c:	eb da                	jmp    806078 <lodepng_huffman_code_lengths+0x76>
  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
  80609e:	4a 8d 14 a5 00 00 00 	lea    0x0(,%r12,4),%rdx
  8060a5:	00 
  memset(dst, value, num);
  8060a6:	be 00 00 00 00       	mov    $0x0,%esi
  8060ab:	4c 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%r14
  8060b2:	4c 89 f7             	mov    %r14,%rdi
  8060b5:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  8060bc:	00 00 00 
  8060bf:	ff d0                	call   *%rax
  if(numpresent == 0) {
  8060c1:	48 85 db             	test   %rbx,%rbx
  8060c4:	75 39                	jne    8060ff <lodepng_huffman_code_lengths+0xfd>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
  8060c6:	41 c7 46 04 01 00 00 	movl   $0x1,0x4(%r14)
  8060cd:	00 
  8060ce:	41 c7 06 01 00 00 00 	movl   $0x1,(%r14)
  unsigned error = 0;
  8060d5:	41 be 00 00 00 00    	mov    $0x0,%r14d
    jos_free(ptr);
  8060db:	4c 89 ff             	mov    %r15,%rdi
  8060de:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8060e5:	00 00 00 
  8060e8:	ff d0                	call   *%rax
}
  8060ea:	44 89 f0             	mov    %r14d,%eax
  8060ed:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8060f4:	5b                   	pop    %rbx
  8060f5:	41 5c                	pop    %r12
  8060f7:	41 5d                	pop    %r13
  8060f9:	41 5e                	pop    %r14
  8060fb:	41 5f                	pop    %r15
  8060fd:	5d                   	pop    %rbp
  8060fe:	c3                   	ret    
  } else if(numpresent == 1) {
  8060ff:	48 83 fb 01          	cmp    $0x1,%rbx
  806103:	75 2c                	jne    806131 <lodepng_huffman_code_lengths+0x12f>
    lengths[leaves[0].index] = 1;
  806105:	41 8b 47 04          	mov    0x4(%r15),%eax
  806109:	48 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%rbx
  806110:	c7 04 83 01 00 00 00 	movl   $0x1,(%rbx,%rax,4)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
  806117:	41 83 7f 04 00       	cmpl   $0x0,0x4(%r15)
  80611c:	0f 94 c0             	sete   %al
  80611f:	0f b6 c0             	movzbl %al,%eax
  806122:	c7 04 83 01 00 00 00 	movl   $0x1,(%rbx,%rax,4)
  unsigned error = 0;
  806129:	41 be 00 00 00 00    	mov    $0x0,%r14d
  80612f:	eb aa                	jmp    8060db <lodepng_huffman_code_lengths+0xd9>
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  806131:	48 8d 04 5b          	lea    (%rbx,%rbx,2),%rax
  806135:	48 c1 e0 03          	shl    $0x3,%rax
  806139:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  return jos_malloc(size);
  806140:	89 c7                	mov    %eax,%edi
  806142:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  806149:	00 00 00 
  80614c:	ff d0                	call   *%rax
  80614e:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  for(width = 1; width < num; width *= 2) {
  806155:	41 be 01 00 00 00    	mov    $0x1,%r14d
  size_t width, counter = 0;
  80615b:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
  806162:	00 
  806163:	4c 89 bd 60 ff ff ff 	mov    %r15,-0xa0(%rbp)
  80616a:	e9 c7 00 00 00       	jmp    806236 <lodepng_huffman_code_lengths+0x234>
    BPMNode* a = (counter & 1) ? mem : leaves;
  80616f:	4c 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%r8
    BPMNode* b = (counter & 1) ? leaves : mem;
  806176:	4c 8b ad 68 ff ff ff 	mov    -0x98(%rbp),%r13
  80617d:	e9 cc 00 00 00       	jmp    80624e <lodepng_huffman_code_lengths+0x24c>
        else b[k] = a[j++];
  806182:	48 8d 3c 52          	lea    (%rdx,%rdx,2),%rdi
  806186:	49 8d 3c f8          	lea    (%r8,%rdi,8),%rdi
  80618a:	4c 8b 27             	mov    (%rdi),%r12
  80618d:	4c 89 20             	mov    %r12,(%rax)
  806190:	4c 8b 67 08          	mov    0x8(%rdi),%r12
  806194:	4c 89 60 08          	mov    %r12,0x8(%rax)
  806198:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  80619c:	48 89 78 10          	mov    %rdi,0x10(%rax)
  8061a0:	48 8d 52 01          	lea    0x1(%rdx),%rdx
      for(k = p; k < r; k++) {
  8061a4:	48 83 c6 01          	add    $0x1,%rsi
  8061a8:	48 83 c0 18          	add    $0x18,%rax
  8061ac:	49 39 f1             	cmp    %rsi,%r9
  8061af:	74 40                	je     8061f1 <lodepng_huffman_code_lengths+0x1ef>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
  8061b1:	49 39 ca             	cmp    %rcx,%r10
  8061b4:	76 cc                	jbe    806182 <lodepng_huffman_code_lengths+0x180>
  8061b6:	49 39 d1             	cmp    %rdx,%r9
  8061b9:	76 12                	jbe    8061cd <lodepng_huffman_code_lengths+0x1cb>
  8061bb:	48 8d 3c 49          	lea    (%rcx,%rcx,2),%rdi
  8061bf:	4c 8d 24 52          	lea    (%rdx,%rdx,2),%r12
  8061c3:	47 8b 24 e0          	mov    (%r8,%r12,8),%r12d
  8061c7:	45 39 24 f8          	cmp    %r12d,(%r8,%rdi,8)
  8061cb:	7f b5                	jg     806182 <lodepng_huffman_code_lengths+0x180>
  8061cd:	48 8d 3c 49          	lea    (%rcx,%rcx,2),%rdi
  8061d1:	49 8d 3c f8          	lea    (%r8,%rdi,8),%rdi
  8061d5:	4c 8b 27             	mov    (%rdi),%r12
  8061d8:	4c 89 20             	mov    %r12,(%rax)
  8061db:	4c 8b 67 08          	mov    0x8(%rdi),%r12
  8061df:	4c 89 60 08          	mov    %r12,0x8(%rax)
  8061e3:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8061e7:	48 89 78 10          	mov    %rdi,0x10(%rax)
  8061eb:	48 8d 49 01          	lea    0x1(%rcx),%rcx
  8061ef:	eb b3                	jmp    8061a4 <lodepng_huffman_code_lengths+0x1a2>
    for(p = 0; p < num; p += 2 * width) {
  8061f1:	4c 03 6d 88          	add    -0x78(%rbp),%r13
  8061f5:	4c 39 db             	cmp    %r11,%rbx
  8061f8:	76 2f                	jbe    806229 <lodepng_huffman_code_lengths+0x227>
      size_t q = (p + width > num) ? num : (p + width);
  8061fa:	4b 8d 04 1e          	lea    (%r14,%r11,1),%rax
  8061fe:	48 39 c3             	cmp    %rax,%rbx
  806201:	49 89 c2             	mov    %rax,%r10
  806204:	4c 0f 46 d3          	cmovbe %rbx,%r10
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
  806208:	4c 89 d9             	mov    %r11,%rcx
  80620b:	4e 8d 1c 30          	lea    (%rax,%r14,1),%r11
  80620f:	4c 39 db             	cmp    %r11,%rbx
  806212:	4d 89 d9             	mov    %r11,%r9
  806215:	4c 0f 46 cb          	cmovbe %rbx,%r9
      for(k = p; k < r; k++) {
  806219:	49 39 c9             	cmp    %rcx,%r9
  80621c:	76 d3                	jbe    8061f1 <lodepng_huffman_code_lengths+0x1ef>
  80621e:	4c 89 e8             	mov    %r13,%rax
  806221:	48 89 ce             	mov    %rcx,%rsi
      size_t i = p, j = q, k;
  806224:	4c 89 d2             	mov    %r10,%rdx
  806227:	eb 88                	jmp    8061b1 <lodepng_huffman_code_lengths+0x1af>
    counter++;
  806229:	48 83 45 80 01       	addq   $0x1,-0x80(%rbp)
  for(width = 1; width < num; width *= 2) {
  80622e:	4c 39 fb             	cmp    %r15,%rbx
  806231:	76 33                	jbe    806266 <lodepng_huffman_code_lengths+0x264>
  806233:	4d 89 fe             	mov    %r15,%r14
    BPMNode* a = (counter & 1) ? mem : leaves;
  806236:	f6 45 80 01          	testb  $0x1,-0x80(%rbp)
  80623a:	0f 84 2f ff ff ff    	je     80616f <lodepng_huffman_code_lengths+0x16d>
  806240:	4c 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%r8
    BPMNode* b = (counter & 1) ? leaves : mem;
  806247:	4c 8b ad 60 ff ff ff 	mov    -0xa0(%rbp),%r13
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
  80624e:	4f 8d 3c 36          	lea    (%r14,%r14,1),%r15
  806252:	4b 8d 04 37          	lea    (%r15,%r14,1),%rax
  806256:	48 c1 e0 04          	shl    $0x4,%rax
  80625a:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80625e:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  806264:	eb 94                	jmp    8061fa <lodepng_huffman_code_lengths+0x1f8>
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
  806266:	4c 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%r15
  80626d:	f6 45 80 01          	testb  $0x1,-0x80(%rbp)
  806271:	0f 85 c5 01 00 00    	jne    80643c <lodepng_huffman_code_lengths+0x43a>
    jos_free(ptr);
  806277:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
  80627e:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  806285:	00 00 00 
  806288:	ff d0                	call   *%rax
    lists.listsize = maxbitlen;
  80628a:	8b b5 74 ff ff ff    	mov    -0x8c(%rbp),%esi
  806290:	89 75 b8             	mov    %esi,-0x48(%rbp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
  806293:	8d 46 01             	lea    0x1(%rsi),%eax
  806296:	0f af c6             	imul   %esi,%eax
  806299:	01 c0                	add    %eax,%eax
  80629b:	89 45 98             	mov    %eax,-0x68(%rbp)
    lists.nextfree = 0;
  80629e:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%rbp)
    lists.numfree = lists.memsize;
  8062a5:	89 45 a8             	mov    %eax,-0x58(%rbp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
  8062a8:	89 c0                	mov    %eax,%eax
  8062aa:	48 8d 3c 40          	lea    (%rax,%rax,2),%rdi
  8062ae:	48 c1 e7 03          	shl    $0x3,%rdi
  return jos_malloc(size);
  8062b2:	49 bc f8 0d 81 00 00 	movabs $0x810df8,%r12
  8062b9:	00 00 00 
  8062bc:	41 ff d4             	call   *%r12
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
  8062bf:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
  8062c3:	8b 7d 98             	mov    -0x68(%rbp),%edi
  8062c6:	48 c1 e7 03          	shl    $0x3,%rdi
  return jos_malloc(size);
  8062ca:	41 ff d4             	call   *%r12
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
  8062cd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
  8062d1:	8b 7d b8             	mov    -0x48(%rbp),%edi
  8062d4:	48 c1 e7 03          	shl    $0x3,%rdi
  return jos_malloc(size);
  8062d8:	41 ff d4             	call   *%r12
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
  8062db:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
  8062df:	8b 7d b8             	mov    -0x48(%rbp),%edi
  8062e2:	48 c1 e7 03          	shl    $0x3,%rdi
  return jos_malloc(size);
  8062e6:	41 ff d4             	call   *%r12
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
  8062e9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
  8062ed:	41 be 53 00 00 00    	mov    $0x53,%r14d
  8062f3:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8062f8:	0f 84 66 01 00 00    	je     806464 <lodepng_huffman_code_lengths+0x462>
  8062fe:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  806303:	0f 84 5b 01 00 00    	je     806464 <lodepng_huffman_code_lengths+0x462>
  806309:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80630e:	0f 84 4a 01 00 00    	je     80645e <lodepng_huffman_code_lengths+0x45c>
  806314:	48 85 c0             	test   %rax,%rax
  806317:	0f 84 41 01 00 00    	je     80645e <lodepng_huffman_code_lengths+0x45c>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
  80631d:	83 7d 98 00          	cmpl   $0x0,-0x68(%rbp)
  806321:	74 23                	je     806346 <lodepng_huffman_code_lengths+0x344>
  806323:	b8 00 00 00 00       	mov    $0x0,%eax
  806328:	89 c2                	mov    %eax,%edx
  80632a:	48 8d 34 52          	lea    (%rdx,%rdx,2),%rsi
  80632e:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  806332:	48 8d 34 f1          	lea    (%rcx,%rsi,8),%rsi
  806336:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80633a:	48 89 34 d1          	mov    %rsi,(%rcx,%rdx,8)
  80633e:	83 c0 01             	add    $0x1,%eax
  806341:	39 45 98             	cmp    %eax,-0x68(%rbp)
  806344:	75 e2                	jne    806328 <lodepng_huffman_code_lengths+0x326>
      bpmnode_create(&lists, leaves[0].weight, 1, 0);
  806346:	b9 00 00 00 00       	mov    $0x0,%ecx
  80634b:	ba 01 00 00 00       	mov    $0x1,%edx
  806350:	41 8b 37             	mov    (%r15),%esi
  806353:	48 8d 7d 98          	lea    -0x68(%rbp),%rdi
  806357:	49 bc 3b 2a 80 00 00 	movabs $0x802a3b,%r12
  80635e:	00 00 00 
  806361:	41 ff d4             	call   *%r12
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
  806364:	41 8b 77 18          	mov    0x18(%r15),%esi
  806368:	b9 00 00 00 00       	mov    $0x0,%ecx
  80636d:	ba 02 00 00 00       	mov    $0x2,%edx
  806372:	48 8d 7d 98          	lea    -0x68(%rbp),%rdi
  806376:	41 ff d4             	call   *%r12
      for(i = 0; i != lists.listsize; ++i) {
  806379:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  80637d:	74 27                	je     8063a6 <lodepng_huffman_code_lengths+0x3a4>
  80637f:	ba 00 00 00 00       	mov    $0x0,%edx
        lists.chains0[i] = &lists.memory[0];
  806384:	89 d1                	mov    %edx,%ecx
  806386:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80638a:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80638e:	48 89 04 ce          	mov    %rax,(%rsi,%rcx,8)
        lists.chains1[i] = &lists.memory[1];
  806392:	48 83 c0 18          	add    $0x18,%rax
  806396:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80639a:	48 89 04 ce          	mov    %rax,(%rsi,%rcx,8)
      for(i = 0; i != lists.listsize; ++i) {
  80639e:	83 c2 01             	add    $0x1,%edx
  8063a1:	39 55 b8             	cmp    %edx,-0x48(%rbp)
  8063a4:	75 de                	jne    806384 <lodepng_huffman_code_lengths+0x382>
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
  8063a6:	4c 8d 6c 1b fe       	lea    -0x2(%rbx,%rbx,1),%r13
  8063ab:	49 83 fd 02          	cmp    $0x2,%r13
  8063af:	74 35                	je     8063e6 <lodepng_huffman_code_lengths+0x3e4>
  8063b1:	41 bc 02 00 00 00    	mov    $0x2,%r12d
  8063b7:	49 be 2c 2b 80 00 00 	movabs $0x802b2c,%r14
  8063be:	00 00 00 
  8063c1:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  8063c7:	8d 48 ff             	lea    -0x1(%rax),%ecx
  8063ca:	45 89 e0             	mov    %r12d,%r8d
  8063cd:	48 89 da             	mov    %rbx,%rdx
  8063d0:	4c 89 fe             	mov    %r15,%rsi
  8063d3:	48 8d 7d 98          	lea    -0x68(%rbp),%rdi
  8063d7:	41 ff d6             	call   *%r14
  8063da:	41 83 c4 01          	add    $0x1,%r12d
  8063de:	44 89 e0             	mov    %r12d,%eax
  8063e1:	4c 39 e8             	cmp    %r13,%rax
  8063e4:	75 db                	jne    8063c1 <lodepng_huffman_code_lengths+0x3bf>
      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
  8063e6:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  8063ec:	8d 50 ff             	lea    -0x1(%rax),%edx
  8063ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8063f3:	48 8b 0c d0          	mov    (%rax,%rdx,8),%rcx
  unsigned error = 0;
  8063f7:	41 be 00 00 00 00    	mov    $0x0,%r14d
      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
  8063fd:	48 85 c9             	test   %rcx,%rcx
  806400:	74 62                	je     806464 <lodepng_huffman_code_lengths+0x462>
  806402:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
  806409:	b8 00 00 00 00       	mov    $0x0,%eax
  80640e:	83 79 04 00          	cmpl   $0x0,0x4(%rcx)
  806412:	74 17                	je     80642b <lodepng_huffman_code_lengths+0x429>
  806414:	89 c2                	mov    %eax,%edx
  806416:	48 8d 14 52          	lea    (%rdx,%rdx,2),%rdx
  80641a:	41 8b 54 d7 04       	mov    0x4(%r15,%rdx,8),%edx
  80641f:	83 04 96 01          	addl   $0x1,(%rsi,%rdx,4)
  806423:	83 c0 01             	add    $0x1,%eax
  806426:	39 41 04             	cmp    %eax,0x4(%rcx)
  806429:	75 e9                	jne    806414 <lodepng_huffman_code_lengths+0x412>
      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
  80642b:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  80642f:	48 85 c9             	test   %rcx,%rcx
  806432:	75 d5                	jne    806409 <lodepng_huffman_code_lengths+0x407>
  unsigned error = 0;
  806434:	41 be 00 00 00 00    	mov    $0x0,%r14d
  80643a:	eb 28                	jmp    806464 <lodepng_huffman_code_lengths+0x462>
  memcpy(dst, src, size);
  80643c:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  806443:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  80644a:	4c 89 ff             	mov    %r15,%rdi
  80644d:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  806454:	00 00 00 
  806457:	ff d0                	call   *%rax
}
  806459:	e9 19 fe ff ff       	jmp    806277 <lodepng_huffman_code_lengths+0x275>
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
  80645e:	41 be 53 00 00 00    	mov    $0x53,%r14d
    jos_free(ptr);
  806464:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  806468:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  80646f:	00 00 00 
  806472:	ff d3                	call   *%rbx
  806474:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  806478:	ff d3                	call   *%rbx
  80647a:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  80647e:	ff d3                	call   *%rbx
  806480:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  806484:	ff d3                	call   *%rbx
  806486:	e9 50 fc ff ff       	jmp    8060db <lodepng_huffman_code_lengths+0xd9>
  if(!leaves) return 83; /*alloc fail*/
  80648b:	41 be 53 00 00 00    	mov    $0x53,%r14d
  806491:	e9 54 fc ff ff       	jmp    8060ea <lodepng_huffman_code_lengths+0xe8>

0000000000806496 <HuffmanTree_makeFromFrequencies>:
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
  806496:	55                   	push   %rbp
  806497:	48 89 e5             	mov    %rsp,%rbp
  80649a:	41 56                	push   %r14
  80649c:	41 55                	push   %r13
  80649e:	41 54                	push   %r12
  8064a0:	53                   	push   %rbx
  8064a1:	49 89 fd             	mov    %rdi,%r13
  8064a4:	49 89 f4             	mov    %rsi,%r12
  8064a7:	48 89 cb             	mov    %rcx,%rbx
  8064aa:	45 89 c6             	mov    %r8d,%r14d
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
  8064ad:	48 8d 3c 8d 00 00 00 	lea    0x0(,%rcx,4),%rdi
  8064b4:	00 
  8064b5:	83 7c 8e fc 00       	cmpl   $0x0,-0x4(%rsi,%rcx,4)
  8064ba:	75 1e                	jne    8064da <HuffmanTree_makeFromFrequencies+0x44>
  8064bc:	48 39 d1             	cmp    %rdx,%rcx
  8064bf:	76 19                	jbe    8064da <HuffmanTree_makeFromFrequencies+0x44>
  8064c1:	48 83 eb 01          	sub    $0x1,%rbx
  8064c5:	48 8d 3c 9d 00 00 00 	lea    0x0(,%rbx,4),%rdi
  8064cc:	00 
  8064cd:	41 83 7c 9c fc 00    	cmpl   $0x0,-0x4(%r12,%rbx,4)
  8064d3:	75 05                	jne    8064da <HuffmanTree_makeFromFrequencies+0x44>
  8064d5:	48 39 da             	cmp    %rbx,%rdx
  8064d8:	72 e7                	jb     8064c1 <HuffmanTree_makeFromFrequencies+0x2b>
  return jos_malloc(size);
  8064da:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  8064e1:	00 00 00 
  8064e4:	ff d0                	call   *%rax
  8064e6:	48 89 c7             	mov    %rax,%rdi
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
  8064e9:	49 89 45 08          	mov    %rax,0x8(%r13)
  if(!tree->lengths) return 83; /*alloc fail*/
  8064ed:	48 85 c0             	test   %rax,%rax
  8064f0:	74 3b                	je     80652d <HuffmanTree_makeFromFrequencies+0x97>
  tree->maxbitlen = maxbitlen;
  8064f2:	45 89 75 10          	mov    %r14d,0x10(%r13)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  8064f6:	41 89 5d 14          	mov    %ebx,0x14(%r13)
  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
  8064fa:	44 89 f1             	mov    %r14d,%ecx
  8064fd:	48 89 da             	mov    %rbx,%rdx
  806500:	4c 89 e6             	mov    %r12,%rsi
  806503:	48 b8 02 60 80 00 00 	movabs $0x806002,%rax
  80650a:	00 00 00 
  80650d:	ff d0                	call   *%rax
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
  80650f:	85 c0                	test   %eax,%eax
  806511:	74 09                	je     80651c <HuffmanTree_makeFromFrequencies+0x86>
}
  806513:	5b                   	pop    %rbx
  806514:	41 5c                	pop    %r12
  806516:	41 5d                	pop    %r13
  806518:	41 5e                	pop    %r14
  80651a:	5d                   	pop    %rbp
  80651b:	c3                   	ret    
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
  80651c:	4c 89 ef             	mov    %r13,%rdi
  80651f:	48 b8 4a 52 80 00 00 	movabs $0x80524a,%rax
  806526:	00 00 00 
  806529:	ff d0                	call   *%rax
  80652b:	eb e6                	jmp    806513 <HuffmanTree_makeFromFrequencies+0x7d>
  if(!tree->lengths) return 83; /*alloc fail*/
  80652d:	b8 53 00 00 00       	mov    $0x53,%eax
  806532:	eb df                	jmp    806513 <HuffmanTree_makeFromFrequencies+0x7d>

0000000000806534 <lodepng_inflate>:
                         const LodePNGDecompressSettings* settings) {
  806534:	55                   	push   %rbp
  806535:	48 89 e5             	mov    %rsp,%rbp
  806538:	41 57                	push   %r15
  80653a:	41 56                	push   %r14
  80653c:	41 55                	push   %r13
  80653e:	41 54                	push   %r12
  806540:	53                   	push   %rbx
  806541:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
  806548:	48 89 bd e0 fe ff ff 	mov    %rdi,-0x120(%rbp)
  80654f:	48 89 f0             	mov    %rsi,%rax
  806552:	48 89 b5 d8 fe ff ff 	mov    %rsi,-0x128(%rbp)
  806559:	48 89 d6             	mov    %rdx,%rsi
  80655c:	48 89 ca             	mov    %rcx,%rdx
  80655f:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
  ucvector_init_buffer(&v, *out, *outsize);
  806566:	48 8b 00             	mov    (%rax),%rax
  p->data = buffer;
  806569:	48 8b 0f             	mov    (%rdi),%rcx
  80656c:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  p->allocsize = p->size = size;
  806570:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  806574:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
  806578:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  80657f:	48 b8 5e 45 80 00 00 	movabs $0x80455e,%rax
  806586:	00 00 00 
  806589:	ff d0                	call   *%rax
  80658b:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  if(error) return error;
  806591:	85 c0                	test   %eax,%eax
  806593:	0f 85 f0 0b 00 00    	jne    807189 <lodepng_inflate+0xc55>
  size_t pos = 0; /*byte position in the out buffer*/
  806599:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  80659f:	eb 38                	jmp    8065d9 <lodepng_inflate+0xa5>
  lodepng_memcpy(out->data + *pos, reader->data + bytepos, LEN);
  8065a1:	4c 89 e6             	mov    %r12,%rsi
  8065a4:	48 03 b5 18 ff ff ff 	add    -0xe8(%rbp),%rsi
  8065ab:	4c 89 ff             	mov    %r15,%rdi
  8065ae:	48 03 7d b8          	add    -0x48(%rbp),%rdi
  memcpy(dst, src, size);
  8065b2:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  8065b9:	00 00 00 
  8065bc:	ff d0                	call   *%rax
  reader->bp = bytepos << 3u;
  8065be:	49 c1 e6 03          	shl    $0x3,%r14
  8065c2:	4c 89 b5 30 ff ff ff 	mov    %r14,-0xd0(%rbp)
  *pos += LEN;
  8065c9:	49 89 df             	mov    %rbx,%r15
  while(!BFINAL) {
  8065cc:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%rbp)
  8065d3:	0f 85 b0 0b 00 00    	jne    807189 <lodepng_inflate+0xc55>
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
  8065d9:	be 03 00 00 00       	mov    $0x3,%esi
  8065de:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  8065e5:	48 b8 28 29 80 00 00 	movabs $0x802928,%rax
  8065ec:	00 00 00 
  8065ef:	ff d0                	call   *%rax
  8065f1:	85 c0                	test   %eax,%eax
  8065f3:	0f 84 6e 0b 00 00    	je     807167 <lodepng_inflate+0xc33>
    BFINAL = readBits(&reader, 1);
  8065f9:	be 01 00 00 00       	mov    $0x1,%esi
  8065fe:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806605:	48 bb 1e 2a 80 00 00 	movabs $0x802a1e,%rbx
  80660c:	00 00 00 
  80660f:	ff d3                	call   *%rbx
  806611:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%rbp)
    BTYPE = readBits(&reader, 2);
  806617:	be 02 00 00 00       	mov    $0x2,%esi
  80661c:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806623:	ff d3                	call   *%rbx
    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
  806625:	83 f8 03             	cmp    $0x3,%eax
  806628:	0f 84 45 0b 00 00    	je     807173 <lodepng_inflate+0xc3f>
    else if(BTYPE == 0) error = inflateNoCompression(out, &pos, &reader, settings); /*no compression*/
  80662e:	85 c0                	test   %eax,%eax
  806630:	0f 85 a1 00 00 00    	jne    8066d7 <lodepng_inflate+0x1a3>
  size_t size = reader->size;
  806636:	4c 8b ad 20 ff ff ff 	mov    -0xe0(%rbp),%r13
  bytepos = (reader->bp + 7u) >> 3u;
  80663d:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  806644:	48 83 c0 07          	add    $0x7,%rax
  806648:	48 c1 e8 03          	shr    $0x3,%rax
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
  80664c:	4c 8d 60 04          	lea    0x4(%rax),%r12
  806650:	4d 39 e5             	cmp    %r12,%r13
  806653:	0f 86 26 0b 00 00    	jbe    80717f <lodepng_inflate+0xc4b>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
  806659:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
  806660:	0f b6 5c 01 01       	movzbl 0x1(%rcx,%rax,1),%ebx
  806665:	c1 e3 08             	shl    $0x8,%ebx
  806668:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  80666c:	01 d3                	add    %edx,%ebx
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
  80666e:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  806675:	83 7f 04 00          	cmpl   $0x0,0x4(%rdi)
  806679:	75 1c                	jne    806697 <lodepng_inflate+0x163>
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
  80667b:	0f b6 54 01 03       	movzbl 0x3(%rcx,%rax,1),%edx
  806680:	c1 e2 08             	shl    $0x8,%edx
  806683:	0f b6 44 01 02       	movzbl 0x2(%rcx,%rax,1),%eax
  806688:	01 d0                	add    %edx,%eax
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
  80668a:	01 d8                	add    %ebx,%eax
  80668c:	3d ff ff 00 00       	cmp    $0xffff,%eax
  806691:	0f 85 26 0b 00 00    	jne    8071bd <lodepng_inflate+0xc89>
  if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/
  806697:	41 89 de             	mov    %ebx,%r14d
  80669a:	4b 8d 1c 3e          	lea    (%r14,%r15,1),%rbx
  80669e:	48 89 de             	mov    %rbx,%rsi
  8066a1:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  8066a5:	48 b8 0c 46 80 00 00 	movabs $0x80460c,%rax
  8066ac:	00 00 00 
  8066af:	ff d0                	call   *%rax
  8066b1:	85 c0                	test   %eax,%eax
  8066b3:	0f 84 10 0b 00 00    	je     8071c9 <lodepng_inflate+0xc95>
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
  8066b9:	4c 89 f2             	mov    %r14,%rdx
  8066bc:	4d 01 e6             	add    %r12,%r14
  8066bf:	4d 39 f5             	cmp    %r14,%r13
  8066c2:	0f 83 d9 fe ff ff    	jae    8065a1 <lodepng_inflate+0x6d>
  8066c8:	c7 85 04 ff ff ff 17 	movl   $0x17,-0xfc(%rbp)
  8066cf:	00 00 00 
    if(error) return error;
  8066d2:	e9 b2 0a 00 00       	jmp    807189 <lodepng_inflate+0xc55>
  tree->codes = 0;
  8066d7:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  8066de:	00 00 00 00 
  tree->lengths = 0;
  8066e2:	48 c7 85 48 ff ff ff 	movq   $0x0,-0xb8(%rbp)
  8066e9:	00 00 00 00 
  tree->table_len = 0;
  8066ed:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
  8066f4:	00 00 00 00 
  tree->table_value = 0;
  8066f8:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  8066ff:	00 00 00 00 
  tree->codes = 0;
  806703:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
  80670a:	00 00 00 00 
  tree->lengths = 0;
  80670e:	48 c7 85 70 ff ff ff 	movq   $0x0,-0x90(%rbp)
  806715:	00 00 00 00 
  tree->table_len = 0;
  806719:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
  806720:	00 
  tree->table_value = 0;
  806721:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
  806728:	00 
  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  806729:	83 f8 01             	cmp    $0x1,%eax
  80672c:	0f 84 e1 01 00 00    	je     806913 <lodepng_inflate+0x3df>
  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
  806732:	be 0e 00 00 00       	mov    $0xe,%esi
  806737:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  80673e:	48 b8 90 29 80 00 00 	movabs $0x802990,%rax
  806745:	00 00 00 
  806748:	ff d0                	call   *%rax
  80674a:	c7 85 0c ff ff ff 31 	movl   $0x31,-0xf4(%rbp)
  806751:	00 00 00 
  806754:	85 c0                	test   %eax,%eax
  806756:	0f 84 40 08 00 00    	je     806f9c <lodepng_inflate+0xa68>
  HLIT =  readBits(reader, 5) + 257;
  80675c:	be 05 00 00 00       	mov    $0x5,%esi
  806761:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806768:	48 bb 1e 2a 80 00 00 	movabs $0x802a1e,%rbx
  80676f:	00 00 00 
  806772:	ff d3                	call   *%rbx
  806774:	89 85 00 ff ff ff    	mov    %eax,-0x100(%rbp)
  HDIST = readBits(reader, 5) + 1;
  80677a:	be 05 00 00 00       	mov    $0x5,%esi
  80677f:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806786:	ff d3                	call   *%rbx
  806788:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%rbp)
  HCLEN = readBits(reader, 4) + 4;
  80678e:	be 04 00 00 00       	mov    $0x4,%esi
  806793:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  80679a:	ff d3                	call   *%rbx
  80679c:	41 89 c5             	mov    %eax,%r13d
  80679f:	8d 58 04             	lea    0x4(%rax),%ebx
  return jos_malloc(size);
  8067a2:	bf 4c 00 00 00       	mov    $0x4c,%edi
  8067a7:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  8067ae:	00 00 00 
  8067b1:	ff d0                	call   *%rax
  8067b3:	49 89 c6             	mov    %rax,%r14
  if(!bitlen_cl) return 83 /*alloc fail*/;
  8067b6:	48 85 c0             	test   %rax,%rax
  8067b9:	0f 84 dc 05 00 00    	je     806d9b <lodepng_inflate+0x867>
  tree->codes = 0;
  8067bf:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8067c6:	00 
  tree->lengths = 0;
  8067c7:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8067ce:	00 
  tree->table_len = 0;
  8067cf:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8067d6:	00 
  tree->table_value = 0;
  8067d7:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  8067de:	00 
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
  8067df:	8d 04 5b             	lea    (%rbx,%rbx,2),%eax
  if(lodepng_addofl(a, b, &d)) return 1;
  8067e2:	48 03 85 30 ff ff ff 	add    -0xd0(%rbp),%rax
  8067e9:	0f 82 34 05 00 00    	jb     806d23 <lodepng_inflate+0x7ef>
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
  8067ef:	48 39 85 28 ff ff ff 	cmp    %rax,-0xd8(%rbp)
  8067f6:	0f 82 7d 05 00 00    	jb     806d79 <lodepng_inflate+0x845>
    for(i = 0; i != HCLEN; ++i) {
  8067fc:	85 db                	test   %ebx,%ebx
  8067fe:	74 6b                	je     80686b <lodepng_inflate+0x337>
  806800:	49 bc 40 24 81 00 00 	movabs $0x812440,%r12
  806807:	00 00 00 
  80680a:	41 8d 55 03          	lea    0x3(%r13),%edx
  80680e:	49 8d 44 24 04       	lea    0x4(%r12),%rax
  806813:	4c 8d 2c 90          	lea    (%rax,%rdx,4),%r13
      ensureBits9(reader, 3); /*out of bounds already checked above */
  806817:	89 9d 0c ff ff ff    	mov    %ebx,-0xf4(%rbp)
  80681d:	be 03 00 00 00       	mov    $0x3,%esi
  806822:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806829:	48 b8 28 29 80 00 00 	movabs $0x802928,%rax
  806830:	00 00 00 
  806833:	ff d0                	call   *%rax
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
  806835:	41 8b 04 24          	mov    (%r12),%eax
  806839:	49 8d 1c 86          	lea    (%r14,%rax,4),%rbx
  80683d:	be 03 00 00 00       	mov    $0x3,%esi
  806842:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806849:	48 b8 1e 2a 80 00 00 	movabs $0x802a1e,%rax
  806850:	00 00 00 
  806853:	ff d0                	call   *%rax
  806855:	89 03                	mov    %eax,(%rbx)
    for(i = 0; i != HCLEN; ++i) {
  806857:	49 83 c4 04          	add    $0x4,%r12
  80685b:	4d 39 ec             	cmp    %r13,%r12
  80685e:	75 bd                	jne    80681d <lodepng_inflate+0x2e9>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
  806860:	8b 9d 0c ff ff ff    	mov    -0xf4(%rbp),%ebx
  806866:	83 fb 13             	cmp    $0x13,%ebx
  806869:	74 1f                	je     80688a <lodepng_inflate+0x356>
      bitlen_cl[CLCL_ORDER[i]] = 0;
  80686b:	48 ba 40 24 81 00 00 	movabs $0x812440,%rdx
  806872:	00 00 00 
  806875:	89 d8                	mov    %ebx,%eax
  806877:	8b 04 82             	mov    (%rdx,%rax,4),%eax
  80687a:	41 c7 04 86 00 00 00 	movl   $0x0,(%r14,%rax,4)
  806881:	00 
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
  806882:	83 c3 01             	add    $0x1,%ebx
  806885:	83 fb 13             	cmp    $0x13,%ebx
  806888:	75 eb                	jne    806875 <lodepng_inflate+0x341>
    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
  80688a:	b9 07 00 00 00       	mov    $0x7,%ecx
  80688f:	ba 13 00 00 00       	mov    $0x13,%edx
  806894:	4c 89 f6             	mov    %r14,%rsi
  806897:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  80689b:	48 b8 18 57 80 00 00 	movabs $0x805718,%rax
  8068a2:	00 00 00 
  8068a5:	ff d0                	call   *%rax
  8068a7:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
  8068ad:	48 c7 85 e8 fe ff ff 	movq   $0x0,-0x118(%rbp)
  8068b4:	00 00 00 00 
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
  8068b8:	48 c7 85 f0 fe ff ff 	movq   $0x0,-0x110(%rbp)
  8068bf:	00 00 00 00 
    if(error) break;
  8068c3:	85 c0                	test   %eax,%eax
  8068c5:	0f 85 78 04 00 00    	jne    806d43 <lodepng_inflate+0x80f>
  return jos_malloc(size);
  8068cb:	bf 80 04 00 00       	mov    $0x480,%edi
  8068d0:	48 bb f8 0d 81 00 00 	movabs $0x810df8,%rbx
  8068d7:	00 00 00 
  8068da:	ff d3                	call   *%rbx
  8068dc:	49 89 c5             	mov    %rax,%r13
  8068df:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
  8068e6:	bf 80 00 00 00       	mov    $0x80,%edi
  8068eb:	ff d3                	call   *%rbx
  8068ed:	49 89 c4             	mov    %rax,%r12
  8068f0:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
  8068f7:	4c 89 ef             	mov    %r13,%rdi
  8068fa:	4d 85 ed             	test   %r13,%r13
  8068fd:	74 05                	je     806904 <lodepng_inflate+0x3d0>
  8068ff:	48 85 c0             	test   %rax,%rax
  806902:	75 4e                	jne    806952 <lodepng_inflate+0x41e>
  806904:	c7 85 0c ff ff ff 53 	movl   $0x53,-0xf4(%rbp)
  80690b:	00 00 00 
  80690e:	e9 30 04 00 00       	jmp    806d43 <lodepng_inflate+0x80f>
  unsigned error = generateFixedLitLenTree(tree_ll);
  806913:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80691a:	48 b8 98 57 80 00 00 	movabs $0x805798,%rax
  806921:	00 00 00 
  806924:	ff d0                	call   *%rax
  806926:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  if(error) return error;
  80692c:	85 c0                	test   %eax,%eax
  80692e:	0f 85 26 09 00 00    	jne    80725a <lodepng_inflate+0xd26>
  return generateFixedDistanceTree(tree_d);
  806934:	48 8d bd 68 ff ff ff 	lea    -0x98(%rbp),%rdi
  80693b:	48 b8 6a 58 80 00 00 	movabs $0x80586a,%rax
  806942:	00 00 00 
  806945:	ff d0                	call   *%rax
  806947:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  80694d:	e9 4a 06 00 00       	jmp    806f9c <lodepng_inflate+0xa68>
  HLIT =  readBits(reader, 5) + 257;
  806952:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
  806958:	44 8d a8 01 01 00 00 	lea    0x101(%rax),%r13d
  HDIST = readBits(reader, 5) + 1;
  80695f:	8b 8d d4 fe ff ff    	mov    -0x12c(%rbp),%ecx
  806965:	83 c1 01             	add    $0x1,%ecx
  806968:	89 8d d4 fe ff ff    	mov    %ecx,-0x12c(%rbp)
  memset(dst, value, num);
  80696e:	ba 80 04 00 00       	mov    $0x480,%edx
  806973:	be 00 00 00 00       	mov    $0x0,%esi
  806978:	48 bb f9 0e 80 00 00 	movabs $0x800ef9,%rbx
  80697f:	00 00 00 
  806982:	ff d3                	call   *%rbx
  806984:	ba 80 00 00 00       	mov    $0x80,%edx
  806989:	be 00 00 00 00       	mov    $0x0,%esi
  80698e:	4c 89 e7             	mov    %r12,%rdi
  806991:	ff d3                	call   *%rbx
    i = 0;
  806993:	8b 9d 0c ff ff ff    	mov    -0xf4(%rbp),%ebx
          else bitlen_d[i - HLIT] = 0;
  806999:	b8 ff fe ff ff       	mov    $0xfffffeff,%eax
  80699e:	2b 85 00 ff ff ff    	sub    -0x100(%rbp),%eax
  8069a4:	4c 89 b5 c8 fe ff ff 	mov    %r14,-0x138(%rbp)
  8069ab:	4d 89 e6             	mov    %r12,%r14
  8069ae:	4c 89 bd c0 fe ff ff 	mov    %r15,-0x140(%rbp)
  8069b5:	41 89 c7             	mov    %eax,%r15d
}
  8069b8:	e9 8a 00 00 00       	jmp    806a47 <lodepng_inflate+0x513>
    reader->buffer = 0;
  8069bd:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%rbp)
  8069c4:	00 00 00 
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
  8069c7:	48 39 d0             	cmp    %rdx,%rax
  8069ca:	73 11                	jae    8069dd <lodepng_inflate+0x4a9>
  8069cc:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  8069d3:	0f b6 34 06          	movzbl (%rsi,%rax,1),%esi
  8069d7:	89 b5 38 ff ff ff    	mov    %esi,-0xc8(%rbp)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
  8069dd:	48 8d 70 01          	lea    0x1(%rax),%rsi
  8069e1:	48 39 f2             	cmp    %rsi,%rdx
  8069e4:	76 15                	jbe    8069fb <lodepng_inflate+0x4c7>
  8069e6:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  8069ed:	0f b6 74 06 01       	movzbl 0x1(%rsi,%rax,1),%esi
  8069f2:	c1 e6 08             	shl    $0x8,%esi
  8069f5:	09 b5 38 ff ff ff    	or     %esi,-0xc8(%rbp)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
  8069fb:	48 8d 70 02          	lea    0x2(%rax),%rsi
  8069ff:	48 39 f2             	cmp    %rsi,%rdx
  806a02:	76 15                	jbe    806a19 <lodepng_inflate+0x4e5>
  806a04:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  806a0b:	0f b6 44 02 02       	movzbl 0x2(%rdx,%rax,1),%eax
  806a10:	c1 e0 10             	shl    $0x10,%eax
  806a13:	09 85 38 ff ff ff    	or     %eax,-0xc8(%rbp)
    reader->buffer >>= (reader->bp & 7u);
  806a19:	83 e1 07             	and    $0x7,%ecx
  806a1c:	d3 ad 38 ff ff ff    	shrl   %cl,-0xc8(%rbp)
    return reader->bp + nbits <= reader->bitsize;
  806a22:	e9 8a 00 00 00       	jmp    806ab1 <lodepng_inflate+0x57d>
        else bitlen_d[i - HLIT] = code;
  806a27:	89 da                	mov    %ebx,%edx
  806a29:	44 29 ea             	sub    %r13d,%edx
  806a2c:	41 89 04 96          	mov    %eax,(%r14,%rdx,4)
        ++i;
  806a30:	83 c3 01             	add    $0x1,%ebx
      if(reader->bp > reader->bitsize) {
  806a33:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  806a3a:	48 39 85 30 ff ff ff 	cmp    %rax,-0xd0(%rbp)
  806a41:	0f 87 c8 07 00 00    	ja     80720f <lodepng_inflate+0xcdb>
    while(i < HLIT + HDIST) {
  806a47:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
  806a4d:	45 8d 64 05 00       	lea    0x0(%r13,%rax,1),%r12d
  806a52:	44 39 e3             	cmp    %r12d,%ebx
  806a55:	0f 83 3d 02 00 00    	jae    806c98 <lodepng_inflate+0x764>
  size_t start = reader->bp >> 3u;
  806a5b:	48 8b 8d 30 ff ff ff 	mov    -0xd0(%rbp),%rcx
  806a62:	48 89 c8             	mov    %rcx,%rax
  806a65:	48 c1 e8 03          	shr    $0x3,%rax
  size_t size = reader->size;
  806a69:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  if(start + 3u < size) {
  806a70:	48 8d 70 03          	lea    0x3(%rax),%rsi
  806a74:	48 39 f2             	cmp    %rsi,%rdx
  806a77:	0f 86 40 ff ff ff    	jbe    8069bd <lodepng_inflate+0x489>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  806a7d:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  806a84:	0f b6 54 06 01       	movzbl 0x1(%rsi,%rax,1),%edx
  806a89:	c1 e2 08             	shl    $0x8,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  806a8c:	0f b6 7c 06 02       	movzbl 0x2(%rsi,%rax,1),%edi
  806a91:	c1 e7 10             	shl    $0x10,%edi
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  806a94:	09 fa                	or     %edi,%edx
  806a96:	0f b6 3c 06          	movzbl (%rsi,%rax,1),%edi
  806a9a:	09 fa                	or     %edi,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  806a9c:	0f b6 44 06 03       	movzbl 0x3(%rsi,%rax,1),%eax
  806aa1:	c1 e0 18             	shl    $0x18,%eax
  806aa4:	09 d0                	or     %edx,%eax
    reader->buffer >>= (reader->bp & 7u);
  806aa6:	83 e1 07             	and    $0x7,%ecx
  806aa9:	d3 e8                	shr    %cl,%eax
  806aab:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
      code = huffmanDecodeSymbol(reader, &tree_cl);
  806ab1:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  806ab5:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806abc:	48 b8 dc 44 80 00 00 	movabs $0x8044dc,%rax
  806ac3:	00 00 00 
  806ac6:	ff d0                	call   *%rax
      if(code <= 15) /*a length code*/ {
  806ac8:	83 f8 0f             	cmp    $0xf,%eax
  806acb:	77 1a                	ja     806ae7 <lodepng_inflate+0x5b3>
        if(i < HLIT) bitlen_ll[i] = code;
  806acd:	41 39 dd             	cmp    %ebx,%r13d
  806ad0:	0f 86 51 ff ff ff    	jbe    806a27 <lodepng_inflate+0x4f3>
  806ad6:	89 da                	mov    %ebx,%edx
  806ad8:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  806adf:	89 04 91             	mov    %eax,(%rcx,%rdx,4)
  806ae2:	e9 49 ff ff ff       	jmp    806a30 <lodepng_inflate+0x4fc>
      } else if(code == 16) /*repeat previous*/ {
  806ae7:	83 f8 10             	cmp    $0x10,%eax
  806aea:	74 4b                	je     806b37 <lodepng_inflate+0x603>
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
  806aec:	83 f8 11             	cmp    $0x11,%eax
  806aef:	0f 84 d7 00 00 00    	je     806bcc <lodepng_inflate+0x698>
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
  806af5:	83 f8 12             	cmp    $0x12,%eax
  806af8:	0f 85 f4 06 00 00    	jne    8071f2 <lodepng_inflate+0xcbe>
        replength += readBits(reader, 7);
  806afe:	be 07 00 00 00       	mov    $0x7,%esi
  806b03:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806b0a:	48 b8 1e 2a 80 00 00 	movabs $0x802a1e,%rax
  806b11:	00 00 00 
  806b14:	ff d0                	call   *%rax
  806b16:	89 c2                	mov    %eax,%edx
        for(n = 0; n < replength; ++n) {
  806b18:	83 f8 f5             	cmp    $0xfffffff5,%eax
  806b1b:	0f 84 12 ff ff ff    	je     806a33 <lodepng_inflate+0x4ff>
  806b21:	89 d8                	mov    %ebx,%eax
  806b23:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  806b2a:	48 8d 04 81          	lea    (%rcx,%rax,4),%rax
  806b2e:	8d 54 13 0b          	lea    0xb(%rbx,%rdx,1),%edx
  806b32:	e9 17 01 00 00       	jmp    806c4e <lodepng_inflate+0x71a>
        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
  806b37:	85 db                	test   %ebx,%ebx
  806b39:	0f 84 96 06 00 00    	je     8071d5 <lodepng_inflate+0xca1>
        replength += readBits(reader, 2);
  806b3f:	be 02 00 00 00       	mov    $0x2,%esi
  806b44:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806b4b:	48 b8 1e 2a 80 00 00 	movabs $0x802a1e,%rax
  806b52:	00 00 00 
  806b55:	ff d0                	call   *%rax
  806b57:	89 c2                	mov    %eax,%edx
        if(i < HLIT + 1) value = bitlen_ll[i - 1];
  806b59:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
  806b5f:	05 02 01 00 00       	add    $0x102,%eax
  806b64:	39 c3                	cmp    %eax,%ebx
  806b66:	73 29                	jae    806b91 <lodepng_inflate+0x65d>
  806b68:	8d 43 ff             	lea    -0x1(%rbx),%eax
  806b6b:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  806b72:	8b 0c 81             	mov    (%rcx,%rax,4),%ecx
        for(n = 0; n < replength; ++n) {
  806b75:	83 fa fd             	cmp    $0xfffffffd,%edx
  806b78:	0f 84 b5 fe ff ff    	je     806a33 <lodepng_inflate+0x4ff>
  806b7e:	89 d8                	mov    %ebx,%eax
  806b80:	48 8b bd f0 fe ff ff 	mov    -0x110(%rbp),%rdi
  806b87:	48 8d 04 87          	lea    (%rdi,%rax,4),%rax
  806b8b:	8d 54 13 03          	lea    0x3(%rbx,%rdx,1),%edx
  806b8f:	eb 2b                	jmp    806bbc <lodepng_inflate+0x688>
        else value = bitlen_d[i - HLIT - 1];
  806b91:	44 89 e8             	mov    %r13d,%eax
  806b94:	f7 d0                	not    %eax
  806b96:	01 d8                	add    %ebx,%eax
  806b98:	89 c0                	mov    %eax,%eax
  806b9a:	41 8b 0c 86          	mov    (%r14,%rax,4),%ecx
  806b9e:	eb d5                	jmp    806b75 <lodepng_inflate+0x641>
          else bitlen_d[i - HLIT] = value;
  806ba0:	41 8d 34 1f          	lea    (%r15,%rbx,1),%esi
  806ba4:	41 89 0c b6          	mov    %ecx,(%r14,%rsi,4)
          ++i;
  806ba8:	83 c3 01             	add    $0x1,%ebx
        for(n = 0; n < replength; ++n) {
  806bab:	39 d3                	cmp    %edx,%ebx
  806bad:	74 16                	je     806bc5 <lodepng_inflate+0x691>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
  806baf:	48 83 c0 04          	add    $0x4,%rax
  806bb3:	41 39 dc             	cmp    %ebx,%r12d
  806bb6:	0f 84 a6 00 00 00    	je     806c62 <lodepng_inflate+0x72e>
          if(i < HLIT) bitlen_ll[i] = value;
  806bbc:	44 39 eb             	cmp    %r13d,%ebx
  806bbf:	73 df                	jae    806ba0 <lodepng_inflate+0x66c>
  806bc1:	89 08                	mov    %ecx,(%rax)
  806bc3:	eb e3                	jmp    806ba8 <lodepng_inflate+0x674>
          ++i;
  806bc5:	89 d3                	mov    %edx,%ebx
  806bc7:	e9 67 fe ff ff       	jmp    806a33 <lodepng_inflate+0x4ff>
        replength += readBits(reader, 3);
  806bcc:	be 03 00 00 00       	mov    $0x3,%esi
  806bd1:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806bd8:	48 b8 1e 2a 80 00 00 	movabs $0x802a1e,%rax
  806bdf:	00 00 00 
  806be2:	ff d0                	call   *%rax
  806be4:	89 c2                	mov    %eax,%edx
        for(n = 0; n < replength; ++n) {
  806be6:	83 f8 fd             	cmp    $0xfffffffd,%eax
  806be9:	0f 84 44 fe ff ff    	je     806a33 <lodepng_inflate+0x4ff>
  806bef:	89 d8                	mov    %ebx,%eax
  806bf1:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  806bf8:	48 8d 04 81          	lea    (%rcx,%rax,4),%rax
  806bfc:	8d 54 13 03          	lea    0x3(%rbx,%rdx,1),%edx
  806c00:	eb 1c                	jmp    806c1e <lodepng_inflate+0x6ea>
          else bitlen_d[i - HLIT] = 0;
  806c02:	41 8d 0c 1f          	lea    (%r15,%rbx,1),%ecx
  806c06:	41 c7 04 8e 00 00 00 	movl   $0x0,(%r14,%rcx,4)
  806c0d:	00 
          ++i;
  806c0e:	83 c3 01             	add    $0x1,%ebx
        for(n = 0; n < replength; ++n) {
  806c11:	39 da                	cmp    %ebx,%edx
  806c13:	74 16                	je     806c2b <lodepng_inflate+0x6f7>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
  806c15:	48 83 c0 04          	add    $0x4,%rax
  806c19:	41 39 dc             	cmp    %ebx,%r12d
  806c1c:	74 56                	je     806c74 <lodepng_inflate+0x740>
          if(i < HLIT) bitlen_ll[i] = 0;
  806c1e:	44 39 eb             	cmp    %r13d,%ebx
  806c21:	73 df                	jae    806c02 <lodepng_inflate+0x6ce>
  806c23:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  806c29:	eb e3                	jmp    806c0e <lodepng_inflate+0x6da>
          ++i;
  806c2b:	89 d3                	mov    %edx,%ebx
  806c2d:	e9 01 fe ff ff       	jmp    806a33 <lodepng_inflate+0x4ff>
          else bitlen_d[i - HLIT] = 0;
  806c32:	41 8d 0c 1f          	lea    (%r15,%rbx,1),%ecx
  806c36:	41 c7 04 8e 00 00 00 	movl   $0x0,(%r14,%rcx,4)
  806c3d:	00 
          ++i;
  806c3e:	83 c3 01             	add    $0x1,%ebx
        for(n = 0; n < replength; ++n) {
  806c41:	39 d3                	cmp    %edx,%ebx
  806c43:	74 16                	je     806c5b <lodepng_inflate+0x727>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
  806c45:	48 83 c0 04          	add    $0x4,%rax
  806c49:	41 39 dc             	cmp    %ebx,%r12d
  806c4c:	74 38                	je     806c86 <lodepng_inflate+0x752>
          if(i < HLIT) bitlen_ll[i] = 0;
  806c4e:	41 39 dd             	cmp    %ebx,%r13d
  806c51:	76 df                	jbe    806c32 <lodepng_inflate+0x6fe>
  806c53:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  806c59:	eb e3                	jmp    806c3e <lodepng_inflate+0x70a>
          ++i;
  806c5b:	89 d3                	mov    %edx,%ebx
  806c5d:	e9 d1 fd ff ff       	jmp    806a33 <lodepng_inflate+0x4ff>
          ++i;
  806c62:	44 89 e3             	mov    %r12d,%ebx
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
  806c65:	c7 85 0c ff ff ff 0d 	movl   $0xd,-0xf4(%rbp)
  806c6c:	00 00 00 
  806c6f:	e9 bf fd ff ff       	jmp    806a33 <lodepng_inflate+0x4ff>
          ++i;
  806c74:	44 89 e3             	mov    %r12d,%ebx
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
  806c77:	c7 85 0c ff ff ff 0e 	movl   $0xe,-0xf4(%rbp)
  806c7e:	00 00 00 
  806c81:	e9 ad fd ff ff       	jmp    806a33 <lodepng_inflate+0x4ff>
          ++i;
  806c86:	44 89 e3             	mov    %r12d,%ebx
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
  806c89:	c7 85 0c ff ff ff 0f 	movl   $0xf,-0xf4(%rbp)
  806c90:	00 00 00 
  806c93:	e9 9b fd ff ff       	jmp    806a33 <lodepng_inflate+0x4ff>
    if(error) break;
  806c98:	4c 8b b5 c8 fe ff ff 	mov    -0x138(%rbp),%r14
  806c9f:	4c 8b bd c0 fe ff ff 	mov    -0x140(%rbp),%r15
  806ca6:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%rbp)
  806cad:	0f 85 90 00 00 00    	jne    806d43 <lodepng_inflate+0x80f>
    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
  806cb3:	c7 85 0c ff ff ff 40 	movl   $0x40,-0xf4(%rbp)
  806cba:	00 00 00 
  806cbd:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  806cc4:	83 b8 00 04 00 00 00 	cmpl   $0x0,0x400(%rax)
  806ccb:	74 76                	je     806d43 <lodepng_inflate+0x80f>
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
  806ccd:	b9 0f 00 00 00       	mov    $0xf,%ecx
  806cd2:	ba 20 01 00 00       	mov    $0x120,%edx
  806cd7:	48 89 c6             	mov    %rax,%rsi
  806cda:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  806ce1:	48 b8 18 57 80 00 00 	movabs $0x805718,%rax
  806ce8:	00 00 00 
  806ceb:	ff d0                	call   *%rax
  806ced:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
    if(error) break;
  806cf3:	85 c0                	test   %eax,%eax
  806cf5:	75 4c                	jne    806d43 <lodepng_inflate+0x80f>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
  806cf7:	b9 0f 00 00 00       	mov    $0xf,%ecx
  806cfc:	ba 20 00 00 00       	mov    $0x20,%edx
  806d01:	48 8b b5 e8 fe ff ff 	mov    -0x118(%rbp),%rsi
  806d08:	48 8d bd 68 ff ff ff 	lea    -0x98(%rbp),%rdi
  806d0f:	48 b8 18 57 80 00 00 	movabs $0x805718,%rax
  806d16:	00 00 00 
  806d19:	ff d0                	call   *%rax
  806d1b:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
    break; /*end of error-while*/
  806d21:	eb 20                	jmp    806d43 <lodepng_inflate+0x80f>
  unsigned* bitlen_d = 0; /*dist code lengths*/
  806d23:	48 c7 85 e8 fe ff ff 	movq   $0x0,-0x118(%rbp)
  806d2a:	00 00 00 00 
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
  806d2e:	48 c7 85 f0 fe ff ff 	movq   $0x0,-0x110(%rbp)
  806d35:	00 00 00 00 
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
  806d39:	c7 85 0c ff ff ff 32 	movl   $0x32,-0xf4(%rbp)
  806d40:	00 00 00 
    jos_free(ptr);
  806d43:	4c 89 f7             	mov    %r14,%rdi
  806d46:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  806d4d:	00 00 00 
  806d50:	ff d3                	call   *%rbx
  806d52:	48 8b bd f0 fe ff ff 	mov    -0x110(%rbp),%rdi
  806d59:	ff d3                	call   *%rbx
  806d5b:	48 8b bd e8 fe ff ff 	mov    -0x118(%rbp),%rdi
  806d62:	ff d3                	call   *%rbx
  HuffmanTree_cleanup(&tree_cl);
  806d64:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  806d68:	48 b8 16 52 80 00 00 	movabs $0x805216,%rax
  806d6f:	00 00 00 
  806d72:	ff d0                	call   *%rax
  return error;
  806d74:	e9 23 02 00 00       	jmp    806f9c <lodepng_inflate+0xa68>
  unsigned* bitlen_d = 0; /*dist code lengths*/
  806d79:	48 c7 85 e8 fe ff ff 	movq   $0x0,-0x118(%rbp)
  806d80:	00 00 00 00 
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
  806d84:	48 c7 85 f0 fe ff ff 	movq   $0x0,-0x110(%rbp)
  806d8b:	00 00 00 00 
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
  806d8f:	c7 85 0c ff ff ff 32 	movl   $0x32,-0xf4(%rbp)
  806d96:	00 00 00 
  806d99:	eb a8                	jmp    806d43 <lodepng_inflate+0x80f>
  if(!bitlen_cl) return 83 /*alloc fail*/;
  806d9b:	c7 85 0c ff ff ff 53 	movl   $0x53,-0xf4(%rbp)
  806da2:	00 00 00 
  806da5:	e9 f2 01 00 00       	jmp    806f9c <lodepng_inflate+0xa68>
    reader->buffer = 0;
  806daa:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%rbp)
  806db1:	00 00 00 
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
  806db4:	48 39 d0             	cmp    %rdx,%rax
  806db7:	73 11                	jae    806dca <lodepng_inflate+0x896>
  806db9:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  806dc0:	0f b6 34 06          	movzbl (%rsi,%rax,1),%esi
  806dc4:	89 b5 38 ff ff ff    	mov    %esi,-0xc8(%rbp)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
  806dca:	48 8d 70 01          	lea    0x1(%rax),%rsi
  806dce:	48 39 f2             	cmp    %rsi,%rdx
  806dd1:	76 15                	jbe    806de8 <lodepng_inflate+0x8b4>
  806dd3:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  806dda:	0f b6 74 06 01       	movzbl 0x1(%rsi,%rax,1),%esi
  806ddf:	c1 e6 08             	shl    $0x8,%esi
  806de2:	09 b5 38 ff ff ff    	or     %esi,-0xc8(%rbp)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
  806de8:	48 8d 70 02          	lea    0x2(%rax),%rsi
  806dec:	48 39 f2             	cmp    %rsi,%rdx
  806def:	76 15                	jbe    806e06 <lodepng_inflate+0x8d2>
  806df1:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  806df8:	0f b6 44 02 02       	movzbl 0x2(%rdx,%rax,1),%eax
  806dfd:	c1 e0 10             	shl    $0x10,%eax
  806e00:	09 85 38 ff ff ff    	or     %eax,-0xc8(%rbp)
    reader->buffer >>= (reader->bp & 7u);
  806e06:	83 e1 07             	and    $0x7,%ecx
  806e09:	d3 ad 38 ff ff ff    	shrl   %cl,-0xc8(%rbp)
    return reader->bp + nbits <= reader->bitsize;
  806e0f:	e9 eb 01 00 00       	jmp    806fff <lodepng_inflate+0xacb>
      if(!ucvector_resize(out, (*pos) + 1)) ERROR_BREAK(83 /*alloc fail*/);
  806e14:	4d 8d 67 01          	lea    0x1(%r15),%r12
  806e18:	4c 89 e6             	mov    %r12,%rsi
  806e1b:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  806e1f:	48 b8 0c 46 80 00 00 	movabs $0x80460c,%rax
  806e26:	00 00 00 
  806e29:	ff d0                	call   *%rax
  806e2b:	85 c0                	test   %eax,%eax
  806e2d:	0f 84 f9 03 00 00    	je     80722c <lodepng_inflate+0xcf8>
      out->data[*pos] = (unsigned char)code_ll;
  806e33:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  806e37:	42 88 1c 38          	mov    %bl,(%rax,%r15,1)
      ++(*pos);
  806e3b:	4d 89 e7             	mov    %r12,%r15
  806e3e:	e9 45 01 00 00       	jmp    806f88 <lodepng_inflate+0xa54>
        length += readBits(reader, numextrabits_l);
  806e43:	89 f6                	mov    %esi,%esi
  806e45:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806e4c:	48 b8 1e 2a 80 00 00 	movabs $0x802a1e,%rax
  806e53:	00 00 00 
  806e56:	ff d0                	call   *%rax
  806e58:	89 c0                	mov    %eax,%eax
  806e5a:	49 01 c5             	add    %rax,%r13
  806e5d:	e9 f8 01 00 00       	jmp    80705a <lodepng_inflate+0xb26>
    reader->buffer = 0;
  806e62:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%rbp)
  806e69:	00 00 00 
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
  806e6c:	48 39 c2             	cmp    %rax,%rdx
  806e6f:	73 11                	jae    806e82 <lodepng_inflate+0x94e>
  806e71:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  806e78:	0f b6 34 16          	movzbl (%rsi,%rdx,1),%esi
  806e7c:	89 b5 38 ff ff ff    	mov    %esi,-0xc8(%rbp)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
  806e82:	48 8d 72 01          	lea    0x1(%rdx),%rsi
  806e86:	48 39 f0             	cmp    %rsi,%rax
  806e89:	76 15                	jbe    806ea0 <lodepng_inflate+0x96c>
  806e8b:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  806e92:	0f b6 74 16 01       	movzbl 0x1(%rsi,%rdx,1),%esi
  806e97:	c1 e6 08             	shl    $0x8,%esi
  806e9a:	09 b5 38 ff ff ff    	or     %esi,-0xc8(%rbp)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
  806ea0:	48 8d 72 02          	lea    0x2(%rdx),%rsi
  806ea4:	48 39 f0             	cmp    %rsi,%rax
  806ea7:	76 15                	jbe    806ebe <lodepng_inflate+0x98a>
  806ea9:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  806eb0:	0f b6 74 16 02       	movzbl 0x2(%rsi,%rdx,1),%esi
  806eb5:	c1 e6 10             	shl    $0x10,%esi
  806eb8:	09 b5 38 ff ff ff    	or     %esi,-0xc8(%rbp)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
  806ebe:	48 8d 72 03          	lea    0x3(%rdx),%rsi
  806ec2:	48 39 f0             	cmp    %rsi,%rax
  806ec5:	76 15                	jbe    806edc <lodepng_inflate+0x9a8>
  806ec7:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  806ece:	0f b6 44 10 03       	movzbl 0x3(%rax,%rdx,1),%eax
  806ed3:	c1 e0 18             	shl    $0x18,%eax
  806ed6:	09 85 38 ff ff ff    	or     %eax,-0xc8(%rbp)
    reader->buffer >>= (reader->bp & 7u);
  806edc:	83 e1 07             	and    $0x7,%ecx
  806edf:	d3 ad 38 ff ff ff    	shrl   %cl,-0xc8(%rbp)
      code_d = huffmanDecodeSymbol(reader, &tree_d);
  806ee5:	48 8d b5 68 ff ff ff 	lea    -0x98(%rbp),%rsi
  806eec:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  806ef3:	48 b8 dc 44 80 00 00 	movabs $0x8044dc,%rax
  806efa:	00 00 00 
  806efd:	ff d0                	call   *%rax
      if(code_d > 29) {
  806eff:	83 f8 1d             	cmp    $0x1d,%eax
  806f02:	0f 87 c8 01 00 00    	ja     8070d0 <lodepng_inflate+0xb9c>
      distance = DISTANCEBASE[code_d];
  806f08:	89 c0                	mov    %eax,%eax
  806f0a:	48 b9 20 25 81 00 00 	movabs $0x812520,%rcx
  806f11:	00 00 00 
  806f14:	44 8b 24 81          	mov    (%rcx,%rax,4),%r12d
      numextrabits_d = DISTANCEEXTRA[code_d];
  806f18:	48 ba a0 24 81 00 00 	movabs $0x8124a0,%rdx
  806f1f:	00 00 00 
  806f22:	8b 34 82             	mov    (%rdx,%rax,4),%esi
      if(numextrabits_d != 0) {
  806f25:	85 f6                	test   %esi,%esi
  806f27:	0f 85 b9 01 00 00    	jne    8070e6 <lodepng_inflate+0xbb2>
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
  806f2d:	45 89 e4             	mov    %r12d,%r12d
  806f30:	4d 39 fc             	cmp    %r15,%r12
  806f33:	0f 87 ff 02 00 00    	ja     807238 <lodepng_inflate+0xd04>
      backward = start - distance;
  806f39:	4c 89 fb             	mov    %r15,%rbx
  806f3c:	4c 29 e3             	sub    %r12,%rbx
      if(!ucvector_resize(out, (*pos) + length)) ERROR_BREAK(83 /*alloc fail*/);
  806f3f:	4f 8d 74 3d 00       	lea    0x0(%r13,%r15,1),%r14
  806f44:	4c 89 f6             	mov    %r14,%rsi
  806f47:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  806f4b:	48 b8 0c 46 80 00 00 	movabs $0x80460c,%rax
  806f52:	00 00 00 
  806f55:	ff d0                	call   *%rax
  806f57:	85 c0                	test   %eax,%eax
  806f59:	0f 84 e5 02 00 00    	je     807244 <lodepng_inflate+0xd10>
      if(distance < length) {
  806f5f:	4d 39 ec             	cmp    %r13,%r12
  806f62:	0f 82 9b 01 00 00    	jb     807103 <lodepng_inflate+0xbcf>
        lodepng_memcpy(out->data + *pos, out->data + backward, length);
  806f68:	48 03 5d b8          	add    -0x48(%rbp),%rbx
  806f6c:	48 89 de             	mov    %rbx,%rsi
  806f6f:	4c 89 ff             	mov    %r15,%rdi
  806f72:	48 03 7d b8          	add    -0x48(%rbp),%rdi
  memcpy(dst, src, size);
  806f76:	4c 89 ea             	mov    %r13,%rdx
  806f79:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  806f80:	00 00 00 
  806f83:	ff d0                	call   *%rax
        *pos += length;
  806f85:	4d 89 f7             	mov    %r14,%r15
    if(reader->bp > reader->bitsize) {
  806f88:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  806f8f:	48 39 85 30 ff ff ff 	cmp    %rax,-0xd0(%rbp)
  806f96:	0f 87 b4 02 00 00    	ja     807250 <lodepng_inflate+0xd1c>
  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
  806f9c:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%rbp)
  806fa3:	0f 85 b1 02 00 00    	jne    80725a <lodepng_inflate+0xd26>
  size_t start = reader->bp >> 3u;
  806fa9:	48 8b 8d 30 ff ff ff 	mov    -0xd0(%rbp),%rcx
  806fb0:	48 89 c8             	mov    %rcx,%rax
  806fb3:	48 c1 e8 03          	shr    $0x3,%rax
  size_t size = reader->size;
  806fb7:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  if(start + 3u < size) {
  806fbe:	48 8d 70 03          	lea    0x3(%rax),%rsi
  806fc2:	48 39 f2             	cmp    %rsi,%rdx
  806fc5:	0f 86 df fd ff ff    	jbe    806daa <lodepng_inflate+0x876>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  806fcb:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  806fd2:	0f b6 54 06 01       	movzbl 0x1(%rsi,%rax,1),%edx
  806fd7:	c1 e2 08             	shl    $0x8,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  806fda:	0f b6 7c 06 02       	movzbl 0x2(%rsi,%rax,1),%edi
  806fdf:	c1 e7 10             	shl    $0x10,%edi
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  806fe2:	09 fa                	or     %edi,%edx
  806fe4:	0f b6 3c 06          	movzbl (%rsi,%rax,1),%edi
  806fe8:	09 fa                	or     %edi,%edx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  806fea:	0f b6 44 06 03       	movzbl 0x3(%rsi,%rax,1),%eax
  806fef:	c1 e0 18             	shl    $0x18,%eax
  806ff2:	09 d0                	or     %edx,%eax
    reader->buffer >>= (reader->bp & 7u);
  806ff4:	83 e1 07             	and    $0x7,%ecx
  806ff7:	d3 e8                	shr    %cl,%eax
  806ff9:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
  806fff:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
  807006:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  80700d:	48 b8 dc 44 80 00 00 	movabs $0x8044dc,%rax
  807014:	00 00 00 
  807017:	ff d0                	call   *%rax
  807019:	89 c3                	mov    %eax,%ebx
    if(code_ll <= 255) /*literal symbol*/ {
  80701b:	3d ff 00 00 00       	cmp    $0xff,%eax
  807020:	0f 86 ee fd ff ff    	jbe    806e14 <lodepng_inflate+0x8e0>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
  807026:	8d 80 ff fe ff ff    	lea    -0x101(%rax),%eax
  80702c:	83 f8 1c             	cmp    $0x1c,%eax
  80702f:	0f 87 17 01 00 00    	ja     80714c <lodepng_inflate+0xc18>
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
  807035:	89 c0                	mov    %eax,%eax
  807037:	48 b9 20 26 81 00 00 	movabs $0x812620,%rcx
  80703e:	00 00 00 
  807041:	44 8b 2c 81          	mov    (%rcx,%rax,4),%r13d
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
  807045:	48 bb a0 25 81 00 00 	movabs $0x8125a0,%rbx
  80704c:	00 00 00 
  80704f:	8b 34 83             	mov    (%rbx,%rax,4),%esi
      if(numextrabits_l != 0) {
  807052:	85 f6                	test   %esi,%esi
  807054:	0f 85 e9 fd ff ff    	jne    806e43 <lodepng_inflate+0x90f>
  size_t start = reader->bp >> 3u;
  80705a:	48 8b 8d 30 ff ff ff 	mov    -0xd0(%rbp),%rcx
  807061:	48 89 ca             	mov    %rcx,%rdx
  807064:	48 c1 ea 03          	shr    $0x3,%rdx
  size_t size = reader->size;
  807068:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  if(start + 4u < size) {
  80706f:	48 8d 72 04          	lea    0x4(%rdx),%rsi
  807073:	48 39 f0             	cmp    %rsi,%rax
  807076:	0f 86 e6 fd ff ff    	jbe    806e62 <lodepng_inflate+0x92e>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  80707c:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
    reader->buffer >>= (reader->bp & 7u);
  807083:	83 e1 07             	and    $0x7,%ecx
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  807086:	0f b6 44 16 01       	movzbl 0x1(%rsi,%rdx,1),%eax
  80708b:	c1 e0 08             	shl    $0x8,%eax
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  80708e:	0f b6 7c 16 02       	movzbl 0x2(%rsi,%rdx,1),%edi
  807093:	c1 e7 10             	shl    $0x10,%edi
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
  807096:	09 f8                	or     %edi,%eax
  807098:	0f b6 3c 16          	movzbl (%rsi,%rdx,1),%edi
  80709c:	09 f8                	or     %edi,%eax
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
  80709e:	0f b6 7c 16 03       	movzbl 0x3(%rsi,%rdx,1),%edi
  8070a3:	c1 e7 18             	shl    $0x18,%edi
  8070a6:	09 f8                	or     %edi,%eax
    reader->buffer >>= (reader->bp & 7u);
  8070a8:	d3 e8                	shr    %cl,%eax
  8070aa:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
  8070b0:	0f b6 54 16 04       	movzbl 0x4(%rsi,%rdx,1),%edx
  8070b5:	c1 e2 18             	shl    $0x18,%edx
  8070b8:	be 08 00 00 00       	mov    $0x8,%esi
  8070bd:	29 ce                	sub    %ecx,%esi
  8070bf:	89 f1                	mov    %esi,%ecx
  8070c1:	d3 e2                	shl    %cl,%edx
  8070c3:	09 d0                	or     %edx,%eax
  8070c5:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
    return 1;
  8070cb:	e9 15 fe ff ff       	jmp    806ee5 <lodepng_inflate+0x9b1>
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
  8070d0:	83 f8 20             	cmp    $0x20,%eax
  8070d3:	19 c0                	sbb    %eax,%eax
  8070d5:	83 e0 02             	and    $0x2,%eax
  8070d8:	83 c0 10             	add    $0x10,%eax
  8070db:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  8070e1:	e9 74 01 00 00       	jmp    80725a <lodepng_inflate+0xd26>
        distance += readBits(reader, numextrabits_d);
  8070e6:	89 f6                	mov    %esi,%esi
  8070e8:	48 8d bd 18 ff ff ff 	lea    -0xe8(%rbp),%rdi
  8070ef:	48 b8 1e 2a 80 00 00 	movabs $0x802a1e,%rax
  8070f6:	00 00 00 
  8070f9:	ff d0                	call   *%rax
  8070fb:	41 01 c4             	add    %eax,%r12d
  8070fe:	e9 2a fe ff ff       	jmp    806f2d <lodepng_inflate+0x9f9>
        lodepng_memcpy(out->data + *pos, out->data + backward, distance);
  807103:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  807107:	48 8d 34 1f          	lea    (%rdi,%rbx,1),%rsi
  80710b:	4c 01 ff             	add    %r15,%rdi
  memcpy(dst, src, size);
  80710e:	4c 89 e2             	mov    %r12,%rdx
  807111:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  807118:	00 00 00 
  80711b:	ff d0                	call   *%rax
        for(forward = distance; forward < length; ++forward) {
  80711d:	48 89 de             	mov    %rbx,%rsi
  807120:	4c 29 e6             	sub    %r12,%rsi
  807123:	4c 01 ee             	add    %r13,%rsi
  807126:	4d 01 e4             	add    %r12,%r12
  807129:	49 8d 14 1c          	lea    (%r12,%rbx,1),%rdx
          out->data[(*pos)++] = out->data[backward++];
  80712d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807131:	48 89 d9             	mov    %rbx,%rcx
  807134:	48 83 c3 01          	add    $0x1,%rbx
  807138:	0f b6 0c 08          	movzbl (%rax,%rcx,1),%ecx
  80713c:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
        for(forward = distance; forward < length; ++forward) {
  80713f:	48 39 f3             	cmp    %rsi,%rbx
  807142:	75 e5                	jne    807129 <lodepng_inflate+0xbf5>
          out->data[(*pos)++] = out->data[backward++];
  807144:	4d 01 ef             	add    %r13,%r15
  807147:	e9 3c fe ff ff       	jmp    806f88 <lodepng_inflate+0xa54>
    } else if(code_ll == 256) {
  80714c:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
  807152:	0f 84 2f 01 00 00    	je     807287 <lodepng_inflate+0xd53>
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
  807158:	c7 85 0c ff ff ff 10 	movl   $0x10,-0xf4(%rbp)
  80715f:	00 00 00 
  807162:	e9 f3 00 00 00       	jmp    80725a <lodepng_inflate+0xd26>
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
  807167:	c7 85 04 ff ff ff 34 	movl   $0x34,-0xfc(%rbp)
  80716e:	00 00 00 
  807171:	eb 16                	jmp    807189 <lodepng_inflate+0xc55>
    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
  807173:	c7 85 04 ff ff ff 14 	movl   $0x14,-0xfc(%rbp)
  80717a:	00 00 00 
  80717d:	eb 0a                	jmp    807189 <lodepng_inflate+0xc55>
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
  80717f:	c7 85 04 ff ff ff 34 	movl   $0x34,-0xfc(%rbp)
  807186:	00 00 00 
  *out = v.data;
  807189:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80718d:	48 8b 8d e0 fe ff ff 	mov    -0x120(%rbp),%rcx
  807194:	48 89 01             	mov    %rax,(%rcx)
  *outsize = v.size;
  807197:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80719b:	48 8b 8d d8 fe ff ff 	mov    -0x128(%rbp),%rcx
  8071a2:	48 89 01             	mov    %rax,(%rcx)
}
  8071a5:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  8071ab:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8071b2:	5b                   	pop    %rbx
  8071b3:	41 5c                	pop    %r12
  8071b5:	41 5d                	pop    %r13
  8071b7:	41 5e                	pop    %r14
  8071b9:	41 5f                	pop    %r15
  8071bb:	5d                   	pop    %rbp
  8071bc:	c3                   	ret    
    return 21; /*error: NLEN is not one's complement of LEN*/
  8071bd:	c7 85 04 ff ff ff 15 	movl   $0x15,-0xfc(%rbp)
  8071c4:	00 00 00 
  8071c7:	eb c0                	jmp    807189 <lodepng_inflate+0xc55>
  if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/
  8071c9:	c7 85 04 ff ff ff 53 	movl   $0x53,-0xfc(%rbp)
  8071d0:	00 00 00 
  8071d3:	eb b4                	jmp    807189 <lodepng_inflate+0xc55>
        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
  8071d5:	4c 8b b5 c8 fe ff ff 	mov    -0x138(%rbp),%r14
  8071dc:	4c 8b bd c0 fe ff ff 	mov    -0x140(%rbp),%r15
  8071e3:	c7 85 0c ff ff ff 36 	movl   $0x36,-0xf4(%rbp)
  8071ea:	00 00 00 
  8071ed:	e9 51 fb ff ff       	jmp    806d43 <lodepng_inflate+0x80f>
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
  8071f2:	4c 8b b5 c8 fe ff ff 	mov    -0x138(%rbp),%r14
  8071f9:	4c 8b bd c0 fe ff ff 	mov    -0x140(%rbp),%r15
  807200:	c7 85 0c ff ff ff 10 	movl   $0x10,-0xf4(%rbp)
  807207:	00 00 00 
  80720a:	e9 34 fb ff ff       	jmp    806d43 <lodepng_inflate+0x80f>
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
  80720f:	4c 8b b5 c8 fe ff ff 	mov    -0x138(%rbp),%r14
  807216:	4c 8b bd c0 fe ff ff 	mov    -0x140(%rbp),%r15
  80721d:	c7 85 0c ff ff ff 32 	movl   $0x32,-0xf4(%rbp)
  807224:	00 00 00 
    if(error) break;
  807227:	e9 17 fb ff ff       	jmp    806d43 <lodepng_inflate+0x80f>
      if(!ucvector_resize(out, (*pos) + 1)) ERROR_BREAK(83 /*alloc fail*/);
  80722c:	c7 85 0c ff ff ff 53 	movl   $0x53,-0xf4(%rbp)
  807233:	00 00 00 
  807236:	eb 22                	jmp    80725a <lodepng_inflate+0xd26>
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
  807238:	c7 85 0c ff ff ff 34 	movl   $0x34,-0xf4(%rbp)
  80723f:	00 00 00 
  807242:	eb 16                	jmp    80725a <lodepng_inflate+0xd26>
      if(!ucvector_resize(out, (*pos) + length)) ERROR_BREAK(83 /*alloc fail*/);
  807244:	c7 85 0c ff ff ff 53 	movl   $0x53,-0xf4(%rbp)
  80724b:	00 00 00 
  80724e:	eb 0a                	jmp    80725a <lodepng_inflate+0xd26>
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
  807250:	c7 85 0c ff ff ff 33 	movl   $0x33,-0xf4(%rbp)
  807257:	00 00 00 
  HuffmanTree_cleanup(&tree_ll);
  80725a:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  807261:	48 bb 16 52 80 00 00 	movabs $0x805216,%rbx
  807268:	00 00 00 
  80726b:	ff d3                	call   *%rbx
  HuffmanTree_cleanup(&tree_d);
  80726d:	48 8d bd 68 ff ff ff 	lea    -0x98(%rbp),%rdi
  807274:	ff d3                	call   *%rbx
    if(error) return error;
  807276:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  80727c:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  807282:	e9 02 ff ff ff       	jmp    807189 <lodepng_inflate+0xc55>
  HuffmanTree_cleanup(&tree_ll);
  807287:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80728e:	48 bb 16 52 80 00 00 	movabs $0x805216,%rbx
  807295:	00 00 00 
  807298:	ff d3                	call   *%rbx
  HuffmanTree_cleanup(&tree_d);
  80729a:	48 8d bd 68 ff ff ff 	lea    -0x98(%rbp),%rdi
  8072a1:	ff d3                	call   *%rbx
    if(error) return error;
  8072a3:	e9 24 f3 ff ff       	jmp    8065cc <lodepng_inflate+0x98>

00000000008072a8 <lodepng_deflate>:
                         const LodePNGCompressSettings* settings) {
  8072a8:	55                   	push   %rbp
  8072a9:	48 89 e5             	mov    %rsp,%rbp
  8072ac:	41 57                	push   %r15
  8072ae:	41 56                	push   %r14
  8072b0:	41 55                	push   %r13
  8072b2:	41 54                	push   %r12
  8072b4:	53                   	push   %rbx
  8072b5:	48 81 ec 88 01 00 00 	sub    $0x188,%rsp
  8072bc:	48 89 bd b0 fe ff ff 	mov    %rdi,-0x150(%rbp)
  8072c3:	48 89 b5 a8 fe ff ff 	mov    %rsi,-0x158(%rbp)
  8072ca:	48 89 95 90 fe ff ff 	mov    %rdx,-0x170(%rbp)
  8072d1:	4c 89 85 d0 fe ff ff 	mov    %r8,-0x130(%rbp)
  ucvector_init_buffer(&v, *out, *outsize);
  8072d8:	48 8b 06             	mov    (%rsi),%rax
  p->data = buffer;
  8072db:	48 8b 17             	mov    (%rdi),%rdx
  8072de:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  p->allocsize = p->size = size;
  8072e2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8072e6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  writer->data = data;
  8072ea:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8072ee:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
  writer->bp = 0;
  8072f5:	48 c7 85 f0 fe ff ff 	movq   $0x0,-0x110(%rbp)
  8072fc:	00 00 00 00 
  if(settings->btype > 2) return 61;
  807300:	41 8b 00             	mov    (%r8),%eax
  807303:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
  807309:	83 f8 02             	cmp    $0x2,%eax
  80730c:	0f 87 fb 10 00 00    	ja     80840d <lodepng_deflate+0x1165>
  807312:	49 89 cf             	mov    %rcx,%r15
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
  807315:	85 c0                	test   %eax,%eax
  807317:	0f 84 d2 01 00 00    	je     8074ef <lodepng_deflate+0x247>
  else if(settings->btype == 1) blocksize = insize;
  80731d:	48 89 8d c8 fe ff ff 	mov    %rcx,-0x138(%rbp)
  807324:	83 bd d8 fe ff ff 01 	cmpl   $0x1,-0x128(%rbp)
  80732b:	74 34                	je     807361 <lodepng_deflate+0xb9>
    blocksize = insize / 8u + 8;
  80732d:	48 89 c8             	mov    %rcx,%rax
  807330:	48 c1 e8 03          	shr    $0x3,%rax
  807334:	48 8d 48 08          	lea    0x8(%rax),%rcx
  807338:	48 81 f9 00 00 04 00 	cmp    $0x40000,%rcx
  80733f:	b8 00 00 04 00       	mov    $0x40000,%eax
  807344:	48 0f 46 c1          	cmovbe %rcx,%rax
  807348:	48 89 c1             	mov    %rax,%rcx
  80734b:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
  807351:	b8 00 00 01 00       	mov    $0x10000,%eax
  807356:	48 0f 43 c1          	cmovae %rcx,%rax
  80735a:	48 89 85 c8 fe ff ff 	mov    %rax,-0x138(%rbp)
  numdeflateblocks = (insize + blocksize - 1) / blocksize;
  807361:	48 8b 8d c8 fe ff ff 	mov    -0x138(%rbp),%rcx
  807368:	4a 8d 44 39 ff       	lea    -0x1(%rcx,%r15,1),%rax
  if(numdeflateblocks == 0) numdeflateblocks = 1;
  80736d:	48 c7 85 d8 fe ff ff 	movq   $0x1,-0x128(%rbp)
  807374:	01 00 00 00 
  807378:	48 39 c1             	cmp    %rax,%rcx
  80737b:	77 0f                	ja     80738c <lodepng_deflate+0xe4>
  numdeflateblocks = (insize + blocksize - 1) / blocksize;
  80737d:	ba 00 00 00 00       	mov    $0x0,%edx
  807382:	48 f7 f1             	div    %rcx
  807385:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
  error = hash_init(&hash, settings->windowsize);
  80738c:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  807393:	8b 58 08             	mov    0x8(%rax),%ebx
  return jos_malloc(size);
  807396:	bf 00 00 04 00       	mov    $0x40000,%edi
  80739b:	49 bc f8 0d 81 00 00 	movabs $0x810df8,%r12
  8073a2:	00 00 00 
  8073a5:	41 ff d4             	call   *%r12
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
  8073a8:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
  8073ac:	41 89 dd             	mov    %ebx,%r13d
  8073af:	4a 8d 3c ad 00 00 00 	lea    0x0(,%r13,4),%rdi
  8073b6:	00 
  return jos_malloc(size);
  8073b7:	41 ff d4             	call   *%r12
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
  8073ba:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  8073be:	4d 01 ed             	add    %r13,%r13
  return jos_malloc(size);
  8073c1:	44 89 ef             	mov    %r13d,%edi
  8073c4:	41 ff d4             	call   *%r12
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  8073c7:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  return jos_malloc(size);
  8073cb:	44 89 ef             	mov    %r13d,%edi
  8073ce:	41 ff d4             	call   *%r12
  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  8073d1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  return jos_malloc(size);
  8073d5:	bf 0c 04 00 00       	mov    $0x40c,%edi
  8073da:	41 ff d4             	call   *%r12
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
  8073dd:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  return jos_malloc(size);
  8073e1:	44 89 ef             	mov    %r13d,%edi
  8073e4:	41 ff d4             	call   *%r12
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  8073e7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
  8073eb:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  8073f0:	0f 84 7e 0f 00 00    	je     808374 <lodepng_deflate+0x10cc>
  8073f6:	48 83 7d 90 00       	cmpq   $0x0,-0x70(%rbp)
  8073fb:	0f 84 7f 0f 00 00    	je     808380 <lodepng_deflate+0x10d8>
  807401:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  807406:	0f 84 80 0f 00 00    	je     80838c <lodepng_deflate+0x10e4>
  80740c:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  807411:	0f 84 81 0f 00 00    	je     808398 <lodepng_deflate+0x10f0>
  807417:	48 85 c0             	test   %rax,%rax
  80741a:	0f 84 78 0f 00 00    	je     808398 <lodepng_deflate+0x10f0>
  807420:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  807425:	0f 84 d6 0f 00 00    	je     808401 <lodepng_deflate+0x1159>
  80742b:	b8 00 00 00 00       	mov    $0x0,%eax
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
  807430:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  807434:	c7 04 02 ff ff ff ff 	movl   $0xffffffff,(%rdx,%rax,1)
  80743b:	48 83 c0 04          	add    $0x4,%rax
  80743f:	48 3d 00 00 04 00    	cmp    $0x40000,%rax
  807445:	75 e9                	jne    807430 <lodepng_deflate+0x188>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
  807447:	85 db                	test   %ebx,%ebx
  807449:	74 39                	je     807484 <lodepng_deflate+0x1dc>
  80744b:	89 d9                	mov    %ebx,%ecx
  80744d:	48 8d 34 8d 00 00 00 	lea    0x0(,%rcx,4),%rsi
  807454:	00 
  807455:	b8 00 00 00 00       	mov    $0x0,%eax
  80745a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80745e:	c7 04 02 ff ff ff ff 	movl   $0xffffffff,(%rdx,%rax,1)
  807465:	48 83 c0 04          	add    $0x4,%rax
  807469:	48 39 f0             	cmp    %rsi,%rax
  80746c:	75 ec                	jne    80745a <lodepng_deflate+0x1b2>
  80746e:	b8 00 00 00 00       	mov    $0x0,%eax
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
  807473:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  807477:	66 89 04 42          	mov    %ax,(%rdx,%rax,2)
  80747b:	48 83 c0 01          	add    $0x1,%rax
  80747f:	48 39 c8             	cmp    %rcx,%rax
  807482:	75 ef                	jne    807473 <lodepng_deflate+0x1cb>
  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
  807484:	b8 00 00 00 00       	mov    $0x0,%eax
  807489:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80748d:	c7 04 02 ff ff ff ff 	movl   $0xffffffff,(%rdx,%rax,1)
  807494:	48 83 c0 04          	add    $0x4,%rax
  807498:	48 3d 0c 04 00 00    	cmp    $0x40c,%rax
  80749e:	75 e9                	jne    807489 <lodepng_deflate+0x1e1>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
  8074a0:	85 db                	test   %ebx,%ebx
  8074a2:	74 18                	je     8074bc <lodepng_deflate+0x214>
  8074a4:	89 db                	mov    %ebx,%ebx
  8074a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8074ab:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8074af:	66 89 04 42          	mov    %ax,(%rdx,%rax,2)
  8074b3:	48 83 c0 01          	add    $0x1,%rax
  8074b7:	48 39 d8             	cmp    %rbx,%rax
  8074ba:	75 ef                	jne    8074ab <lodepng_deflate+0x203>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
  8074bc:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  8074c2:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  8074c8:	4d 89 fe             	mov    %r15,%r14
  8074cb:	4c 8b bd d8 fe ff ff 	mov    -0x128(%rbp),%r15
  8074d2:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  8074d9:	00 
  8074da:	0f 85 17 02 00 00    	jne    8076f7 <lodepng_deflate+0x44f>
  error = hash_init(&hash, settings->windowsize);
  8074e0:	c7 85 d8 fe ff ff 00 	movl   $0x0,-0x128(%rbp)
  8074e7:	00 00 00 
  8074ea:	e9 b3 0e 00 00       	jmp    8083a2 <lodepng_deflate+0x10fa>
  size_t i, j, numdeflateblocks = (datasize + 65534u) / 65535u;
  8074ef:	48 8d 89 fe ff 00 00 	lea    0xfffe(%rcx),%rcx
  8074f6:	48 ba 01 80 00 80 00 	movabs $0x8000800080008001,%rdx
  8074fd:	80 00 80 
  807500:	48 89 c8             	mov    %rcx,%rax
  807503:	48 f7 e2             	mul    %rdx
  807506:	48 89 d0             	mov    %rdx,%rax
  807509:	48 c1 e8 0f          	shr    $0xf,%rax
  80750d:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
  for(i = 0; i != numdeflateblocks; ++i) {
  807514:	48 81 f9 fe ff 00 00 	cmp    $0xfffe,%rcx
  80751b:	0f 86 af 0e 00 00    	jbe    8083d0 <lodepng_deflate+0x1128>
  unsigned datapos = 0;
  807521:	8b 9d d8 fe ff ff    	mov    -0x128(%rbp),%ebx
  for(i = 0; i != numdeflateblocks; ++i) {
  807527:	48 c7 85 d0 fe ff ff 	movq   $0x0,-0x130(%rbp)
  80752e:	00 00 00 00 
    BFINAL = (i == numdeflateblocks - 1);
  807532:	48 83 e8 01          	sub    $0x1,%rax
  807536:	48 89 85 a0 fe ff ff 	mov    %rax,-0x160(%rbp)
    ucvector_push_back(out, firstbyte);
  80753d:	49 bc 78 46 80 00 00 	movabs $0x804678,%r12
  807544:	00 00 00 
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
  807547:	4c 8b b5 90 fe ff ff 	mov    -0x170(%rbp),%r14
  80754e:	eb 1c                	jmp    80756c <lodepng_deflate+0x2c4>
  for(i = 0; i != numdeflateblocks; ++i) {
  807550:	48 83 85 d0 fe ff ff 	addq   $0x1,-0x130(%rbp)
  807557:	01 
  807558:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  80755f:	48 39 85 b8 fe ff ff 	cmp    %rax,-0x148(%rbp)
  807566:	0f 84 64 0e 00 00    	je     8083d0 <lodepng_deflate+0x1128>
    BFINAL = (i == numdeflateblocks - 1);
  80756c:	48 8b 8d d0 fe ff ff 	mov    -0x130(%rbp),%rcx
  807573:	48 39 8d a0 fe ff ff 	cmp    %rcx,-0x160(%rbp)
  80757a:	40 0f 94 c6          	sete   %sil
  80757e:	40 0f b6 f6          	movzbl %sil,%esi
    ucvector_push_back(out, firstbyte);
  807582:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  807586:	41 ff d4             	call   *%r12
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
  807589:	89 d8                	mov    %ebx,%eax
  80758b:	4c 89 f9             	mov    %r15,%rcx
  80758e:	48 89 85 c8 fe ff ff 	mov    %rax,-0x138(%rbp)
  807595:	48 29 c1             	sub    %rax,%rcx
  807598:	45 89 fd             	mov    %r15d,%r13d
  80759b:	41 29 dd             	sub    %ebx,%r13d
  80759e:	48 81 f9 ff ff 00 00 	cmp    $0xffff,%rcx
  8075a5:	b9 ff ff 00 00       	mov    $0xffff,%ecx
  8075aa:	44 0f 43 e9          	cmovae %ecx,%r13d
    NLEN = 65535 - LEN;
  8075ae:	44 29 e9             	sub    %r13d,%ecx
  8075b1:	89 8d c0 fe ff ff    	mov    %ecx,-0x140(%rbp)
    ucvector_push_back(out, (unsigned char)(LEN & 255));
  8075b7:	41 0f b6 f5          	movzbl %r13b,%esi
  8075bb:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  8075bf:	41 ff d4             	call   *%r12
    ucvector_push_back(out, (unsigned char)(LEN >> 8u));
  8075c2:	44 89 e8             	mov    %r13d,%eax
  8075c5:	0f b6 f4             	movzbl %ah,%esi
  8075c8:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  8075cc:	41 ff d4             	call   *%r12
    ucvector_push_back(out, (unsigned char)(NLEN & 255));
  8075cf:	44 8b ad c0 fe ff ff 	mov    -0x140(%rbp),%r13d
  8075d6:	41 0f b6 f5          	movzbl %r13b,%esi
  8075da:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  8075de:	41 ff d4             	call   *%r12
    ucvector_push_back(out, (unsigned char)(NLEN >> 8u));
  8075e1:	44 89 e8             	mov    %r13d,%eax
  8075e4:	0f b6 f4             	movzbl %ah,%esi
  8075e7:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  8075eb:	41 ff d4             	call   *%r12
    for(j = 0; j < 65535 && datapos < datasize; ++j) {
  8075ee:	4c 3b bd c8 fe ff ff 	cmp    -0x138(%rbp),%r15
  8075f5:	0f 86 55 ff ff ff    	jbe    807550 <lodepng_deflate+0x2a8>
      ucvector_push_back(out, data[datapos++]);
  8075fb:	8d 43 01             	lea    0x1(%rbx),%eax
  8075fe:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%rbp)
  807604:	48 8b 8d c8 fe ff ff 	mov    -0x138(%rbp),%rcx
  80760b:	41 0f b6 34 0e       	movzbl (%r14,%rcx,1),%esi
  807610:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  807614:	41 ff d4             	call   *%r12
    for(j = 0; j < 65535 && datapos < datasize; ++j) {
  807617:	44 8d ab ff ff 00 00 	lea    0xffff(%rbx),%r13d
      ucvector_push_back(out, data[datapos++]);
  80761e:	8b 9d c0 fe ff ff    	mov    -0x140(%rbp),%ebx
    for(j = 0; j < 65535 && datapos < datasize; ++j) {
  807624:	89 d8                	mov    %ebx,%eax
  807626:	49 39 c7             	cmp    %rax,%r15
  807629:	0f 86 21 ff ff ff    	jbe    807550 <lodepng_deflate+0x2a8>
      ucvector_push_back(out, data[datapos++]);
  80762f:	83 c3 01             	add    $0x1,%ebx
  807632:	41 0f b6 34 06       	movzbl (%r14,%rax,1),%esi
  807637:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80763b:	41 ff d4             	call   *%r12
    for(j = 0; j < 65535 && datapos < datasize; ++j) {
  80763e:	44 39 eb             	cmp    %r13d,%ebx
  807641:	75 e1                	jne    807624 <lodepng_deflate+0x37c>
      ucvector_push_back(out, data[datapos++]);
  807643:	44 89 eb             	mov    %r13d,%ebx
  807646:	e9 05 ff ff ff       	jmp    807550 <lodepng_deflate+0x2a8>
  tree->codes = 0;
  80764b:	48 c7 85 38 ff ff ff 	movq   $0x0,-0xc8(%rbp)
  807652:	00 00 00 00 
  tree->lengths = 0;
  807656:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  80765d:	00 00 00 00 
  tree->table_len = 0;
  807661:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  807668:	00 00 00 00 
  tree->table_value = 0;
  80766c:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
  807673:	00 00 00 00 
  tree->codes = 0;
  807677:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  80767e:	00 00 00 00 
  tree->lengths = 0;
  807682:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
  807689:	00 00 00 00 
  tree->table_len = 0;
  80768d:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
  807694:	00 00 00 00 
  tree->table_value = 0;
  807698:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
  80769f:	00 
  error = generateFixedLitLenTree(&tree_ll);
  8076a0:	48 8d bd 38 ff ff ff 	lea    -0xc8(%rbp),%rdi
  8076a7:	48 b8 98 57 80 00 00 	movabs $0x805798,%rax
  8076ae:	00 00 00 
  8076b1:	ff d0                	call   *%rax
  8076b3:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
  8076b9:	85 c0                	test   %eax,%eax
  8076bb:	0f 84 90 02 00 00    	je     807951 <lodepng_deflate+0x6a9>
  HuffmanTree_cleanup(&tree_ll);
  8076c1:	48 8d bd 38 ff ff ff 	lea    -0xc8(%rbp),%rdi
  8076c8:	48 bb 16 52 80 00 00 	movabs $0x805216,%rbx
  8076cf:	00 00 00 
  8076d2:	ff d3                	call   *%rbx
  HuffmanTree_cleanup(&tree_d);
  8076d4:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  8076db:	ff d3                	call   *%rbx
    for(i = 0; i != numdeflateblocks && !error; ++i) {
  8076dd:	49 83 c5 01          	add    $0x1,%r13
  8076e1:	4d 39 ef             	cmp    %r13,%r15
  8076e4:	0f 84 b8 0c 00 00    	je     8083a2 <lodepng_deflate+0x10fa>
  8076ea:	83 bd d8 fe ff ff 00 	cmpl   $0x0,-0x128(%rbp)
  8076f1:	0f 85 ab 0c 00 00    	jne    8083a2 <lodepng_deflate+0x10fa>
      unsigned final = (i == numdeflateblocks - 1);
  8076f7:	49 8d 47 ff          	lea    -0x1(%r15),%rax
  8076fb:	4c 39 e8             	cmp    %r13,%rax
  8076fe:	0f 94 c3             	sete   %bl
  807701:	0f b6 db             	movzbl %bl,%ebx
      size_t end = start + blocksize;
  807704:	4c 89 a5 b8 fe ff ff 	mov    %r12,-0x148(%rbp)
  80770b:	4c 03 a5 c8 fe ff ff 	add    -0x138(%rbp),%r12
      if(end > insize) end = insize;
  807712:	4d 39 e6             	cmp    %r12,%r14
  807715:	4c 89 e0             	mov    %r12,%rax
  807718:	49 0f 46 c6          	cmovbe %r14,%rax
  80771c:	48 89 85 c0 fe ff ff 	mov    %rax,-0x140(%rbp)
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
  807723:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  80772a:	8b 00                	mov    (%rax),%eax
  80772c:	83 f8 01             	cmp    $0x1,%eax
  80772f:	0f 84 16 ff ff ff    	je     80764b <lodepng_deflate+0x3a3>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
  807735:	c7 85 d8 fe ff ff 00 	movl   $0x0,-0x128(%rbp)
  80773c:	00 00 00 
  80773f:	83 f8 02             	cmp    $0x2,%eax
  807742:	75 99                	jne    8076dd <lodepng_deflate+0x435>
  p->data = NULL;
  807744:	48 c7 85 f8 fe ff ff 	movq   $0x0,-0x108(%rbp)
  80774b:	00 00 00 00 
  p->size = p->allocsize = 0;
  80774f:	48 c7 85 08 ff ff ff 	movq   $0x0,-0xf8(%rbp)
  807756:	00 00 00 00 
  80775a:	48 c7 85 00 ff ff ff 	movq   $0x0,-0x100(%rbp)
  807761:	00 00 00 00 
  tree->codes = 0;
  807765:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
  80776c:	00 00 00 00 
  tree->lengths = 0;
  807770:	48 c7 85 18 ff ff ff 	movq   $0x0,-0xe8(%rbp)
  807777:	00 00 00 00 
  tree->table_len = 0;
  80777b:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
  807782:	00 00 00 00 
  tree->table_value = 0;
  807786:	48 c7 85 30 ff ff ff 	movq   $0x0,-0xd0(%rbp)
  80778d:	00 00 00 00 
  tree->codes = 0;
  807791:	48 c7 85 38 ff ff ff 	movq   $0x0,-0xc8(%rbp)
  807798:	00 00 00 00 
  tree->lengths = 0;
  80779c:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  8077a3:	00 00 00 00 
  tree->table_len = 0;
  8077a7:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  8077ae:	00 00 00 00 
  tree->table_value = 0;
  8077b2:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
  8077b9:	00 00 00 00 
  tree->codes = 0;
  8077bd:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  8077c4:	00 00 00 00 
  tree->lengths = 0;
  8077c8:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
  8077cf:	00 00 00 00 
  tree->table_len = 0;
  8077d3:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
  8077da:	00 00 00 00 
  tree->table_value = 0;
  8077de:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
  8077e5:	00 
  return jos_malloc(size);
  8077e6:	bf 78 04 00 00       	mov    $0x478,%edi
  8077eb:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  8077f2:	00 00 00 
  8077f5:	ff d0                	call   *%rax
  8077f7:	48 89 85 a0 fe ff ff 	mov    %rax,-0x160(%rbp)
  8077fe:	bf 78 00 00 00       	mov    $0x78,%edi
  807803:	48 b9 f8 0d 81 00 00 	movabs $0x810df8,%rcx
  80780a:	00 00 00 
  80780d:	ff d1                	call   *%rcx
  80780f:	48 89 85 98 fe ff ff 	mov    %rax,-0x168(%rbp)
  807816:	bf 4c 00 00 00       	mov    $0x4c,%edi
  80781b:	48 b9 f8 0d 81 00 00 	movabs $0x810df8,%rcx
  807822:	00 00 00 
  807825:	ff d1                	call   *%rcx
  807827:	48 89 c6             	mov    %rax,%rsi
  80782a:	48 89 85 88 fe ff ff 	mov    %rax,-0x178(%rbp)
  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
  807831:	48 83 bd a0 fe ff ff 	cmpq   $0x0,-0x160(%rbp)
  807838:	00 
  807839:	0f 94 c2             	sete   %dl
  80783c:	48 83 bd 98 fe ff ff 	cmpq   $0x0,-0x168(%rbp)
  807843:	00 
  807844:	0f 94 c0             	sete   %al
  807847:	08 c2                	or     %al,%dl
  807849:	0f 85 39 0a 00 00    	jne    808288 <lodepng_deflate+0xfe0>
  80784f:	48 85 f6             	test   %rsi,%rsi
  807852:	0f 84 30 0a 00 00    	je     808288 <lodepng_deflate+0xfe0>
  memset(dst, value, num);
  807858:	ba 78 04 00 00       	mov    $0x478,%edx
  80785d:	be 00 00 00 00       	mov    $0x0,%esi
  807862:	48 8b bd a0 fe ff ff 	mov    -0x160(%rbp),%rdi
  807869:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  807870:	00 00 00 
  807873:	ff d0                	call   *%rax
  807875:	ba 78 00 00 00       	mov    $0x78,%edx
  80787a:	be 00 00 00 00       	mov    $0x0,%esi
  80787f:	48 8b bd 98 fe ff ff 	mov    -0x168(%rbp),%rdi
  807886:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  80788d:	00 00 00 
  807890:	ff d0                	call   *%rax
  807892:	ba 4c 00 00 00       	mov    $0x4c,%edx
  807897:	be 00 00 00 00       	mov    $0x0,%esi
  80789c:	48 8b bd 88 fe ff ff 	mov    -0x178(%rbp),%rdi
  8078a3:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  8078aa:	00 00 00 
  8078ad:	ff d0                	call   *%rax
    if(settings->use_lz77) {
  8078af:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  8078b6:	83 78 04 00          	cmpl   $0x0,0x4(%rax)
  8078ba:	0f 85 9b 02 00 00    	jne    807b5b <lodepng_deflate+0x8b3>
  size_t datasize = dataend - datapos;
  8078c0:	48 8b b5 c0 fe ff ff 	mov    -0x140(%rbp),%rsi
  8078c7:	48 2b b5 b8 fe ff ff 	sub    -0x148(%rbp),%rsi
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
  8078ce:	48 8d bd f8 fe ff ff 	lea    -0x108(%rbp),%rdi
  8078d5:	48 b8 14 49 80 00 00 	movabs $0x804914,%rax
  8078dc:	00 00 00 
  8078df:	ff d0                	call   *%rax
  8078e1:	85 c0                	test   %eax,%eax
  8078e3:	0f 84 57 0a 00 00    	je     808340 <lodepng_deflate+0x1098>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
  8078e9:	48 8b 8d c0 fe ff ff 	mov    -0x140(%rbp),%rcx
  8078f0:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8078f7:	48 39 c1             	cmp    %rax,%rcx
  8078fa:	76 2f                	jbe    80792b <lodepng_deflate+0x683>
  8078fc:	48 8b b5 90 fe ff ff 	mov    -0x170(%rbp),%rsi
  807903:	48 01 f0             	add    %rsi,%rax
  807906:	48 01 f1             	add    %rsi,%rcx
  807909:	48 89 cf             	mov    %rcx,%rdi
  80790c:	ba 00 00 00 00       	mov    $0x0,%edx
  807911:	0f b6 30             	movzbl (%rax),%esi
  807914:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80791b:	89 34 11             	mov    %esi,(%rcx,%rdx,1)
  80791e:	48 83 c0 01          	add    $0x1,%rax
  807922:	48 83 c2 04          	add    $0x4,%rdx
  807926:	48 39 c7             	cmp    %rax,%rdi
  807929:	75 e6                	jne    807911 <lodepng_deflate+0x669>
    for(i = 0; i != lz77_encoded.size; ++i) {
  80792b:	48 83 bd 00 ff ff ff 	cmpq   $0x0,-0x100(%rbp)
  807932:	00 
  807933:	0f 84 d9 02 00 00    	je     807c12 <lodepng_deflate+0x96a>
  807939:	b8 00 00 00 00       	mov    $0x0,%eax
  80793e:	4c 8b 85 98 fe ff ff 	mov    -0x168(%rbp),%r8
  807945:	48 8b b5 a0 fe ff ff 	mov    -0x160(%rbp),%rsi
  80794c:	e9 8b 02 00 00       	jmp    807bdc <lodepng_deflate+0x934>
  if(!error) error = generateFixedDistanceTree(&tree_d);
  807951:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  807958:	48 b8 6a 58 80 00 00 	movabs $0x80586a,%rax
  80795f:	00 00 00 
  807962:	ff d0                	call   *%rax
  807964:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
  if(!error) {
  80796a:	85 c0                	test   %eax,%eax
  80796c:	0f 85 4f fd ff ff    	jne    8076c1 <lodepng_deflate+0x419>
    writeBits(writer, BFINAL, 1);
  807972:	ba 01 00 00 00       	mov    $0x1,%edx
  807977:	89 de                	mov    %ebx,%esi
  807979:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  807980:	48 bb b3 46 80 00 00 	movabs $0x8046b3,%rbx
  807987:	00 00 00 
  80798a:	ff d3                	call   *%rbx
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
  80798c:	ba 01 00 00 00       	mov    $0x1,%edx
  807991:	be 01 00 00 00       	mov    $0x1,%esi
  807996:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  80799d:	ff d3                	call   *%rbx
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
  80799f:	ba 01 00 00 00       	mov    $0x1,%edx
  8079a4:	be 00 00 00 00       	mov    $0x0,%esi
  8079a9:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  8079b0:	ff d3                	call   *%rbx
    if(settings->use_lz77) /*LZ77 encoded*/ {
  8079b2:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  8079b9:	83 78 04 00          	cmpl   $0x0,0x4(%rax)
  8079bd:	0f 85 9c 00 00 00    	jne    807a5f <lodepng_deflate+0x7b7>
      for(i = datapos; i < dataend; ++i) {
  8079c3:	48 8b 85 90 fe ff ff 	mov    -0x170(%rbp),%rax
  8079ca:	48 89 c3             	mov    %rax,%rbx
  8079cd:	48 8b bd b8 fe ff ff 	mov    -0x148(%rbp),%rdi
  8079d4:	48 01 fb             	add    %rdi,%rbx
  8079d7:	48 8b 8d c0 fe ff ff 	mov    -0x140(%rbp),%rcx
  8079de:	48 89 ce             	mov    %rcx,%rsi
  8079e1:	48 01 c6             	add    %rax,%rsi
  8079e4:	48 39 f9             	cmp    %rdi,%rcx
  8079e7:	76 44                	jbe    807a2d <lodepng_deflate+0x785>
  8079e9:	4c 89 bd c0 fe ff ff 	mov    %r15,-0x140(%rbp)
  8079f0:	49 89 f7             	mov    %rsi,%r15
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
  8079f3:	0f b6 03             	movzbl (%rbx),%eax
  8079f6:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  8079fd:	8b 14 82             	mov    (%rdx,%rax,4),%edx
  807a00:	48 8b 8d 38 ff ff ff 	mov    -0xc8(%rbp),%rcx
  807a07:	8b 34 81             	mov    (%rcx,%rax,4),%esi
  807a0a:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  807a11:	48 b8 74 47 80 00 00 	movabs $0x804774,%rax
  807a18:	00 00 00 
  807a1b:	ff d0                	call   *%rax
      for(i = datapos; i < dataend; ++i) {
  807a1d:	48 83 c3 01          	add    $0x1,%rbx
  807a21:	49 39 df             	cmp    %rbx,%r15
  807a24:	75 cd                	jne    8079f3 <lodepng_deflate+0x74b>
  807a26:	4c 8b bd c0 fe ff ff 	mov    -0x140(%rbp),%r15
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
  807a2d:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  807a34:	8b 90 00 04 00 00    	mov    0x400(%rax),%edx
  807a3a:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  807a41:	8b b0 00 04 00 00    	mov    0x400(%rax),%esi
  807a47:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  807a4e:	48 b8 74 47 80 00 00 	movabs $0x804774,%rax
  807a55:	00 00 00 
  807a58:	ff d0                	call   *%rax
  807a5a:	e9 62 fc ff ff       	jmp    8076c1 <lodepng_deflate+0x419>
  p->data = NULL;
  807a5f:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
  807a66:	00 00 00 00 
  p->size = p->allocsize = 0;
  807a6a:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  807a71:	00 00 00 00 
  807a75:	48 c7 85 18 ff ff ff 	movq   $0x0,-0xe8(%rbp)
  807a7c:	00 00 00 00 
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
  807a80:	48 83 ec 08          	sub    $0x8,%rsp
  807a84:	48 8b 8d d0 fe ff ff 	mov    -0x130(%rbp),%rcx
  807a8b:	8b 41 14             	mov    0x14(%rcx),%eax
  807a8e:	50                   	push   %rax
  807a8f:	8b 41 10             	mov    0x10(%rcx),%eax
  807a92:	50                   	push   %rax
  807a93:	8b 41 0c             	mov    0xc(%rcx),%eax
  807a96:	50                   	push   %rax
  807a97:	44 8b 49 08          	mov    0x8(%rcx),%r9d
  807a9b:	4c 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%r8
  807aa2:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  807aa9:	48 8b 95 90 fe ff ff 	mov    -0x170(%rbp),%rdx
  807ab0:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  807ab4:	48 8d bd 10 ff ff ff 	lea    -0xf0(%rbp),%rdi
  807abb:	48 b8 c0 49 80 00 00 	movabs $0x8049c0,%rax
  807ac2:	00 00 00 
  807ac5:	ff d0                	call   *%rax
  807ac7:	89 c3                	mov    %eax,%ebx
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
  807ac9:	48 83 c4 20          	add    $0x20,%rsp
  807acd:	85 c0                	test   %eax,%eax
  807acf:	74 34                	je     807b05 <lodepng_deflate+0x85d>
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
  807ad1:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  807ad8:	00 00 00 00 
  807adc:	48 c7 85 18 ff ff ff 	movq   $0x0,-0xe8(%rbp)
  807ae3:	00 00 00 00 
    jos_free(ptr);
  807ae7:	48 8b bd 10 ff ff ff 	mov    -0xf0(%rbp),%rdi
  807aee:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  807af5:	00 00 00 
  807af8:	ff d0                	call   *%rax
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
  807afa:	89 9d d8 fe ff ff    	mov    %ebx,-0x128(%rbp)
  807b00:	e9 bc fb ff ff       	jmp    8076c1 <lodepng_deflate+0x419>
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
  807b05:	48 8d 8d 60 ff ff ff 	lea    -0xa0(%rbp),%rcx
  807b0c:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  807b13:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  807b1a:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  807b21:	48 b8 02 48 80 00 00 	movabs $0x804802,%rax
  807b28:	00 00 00 
  807b2b:	ff d0                	call   *%rax
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
  807b2d:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  807b34:	00 00 00 00 
  807b38:	48 c7 85 18 ff ff ff 	movq   $0x0,-0xe8(%rbp)
  807b3f:	00 00 00 00 
    jos_free(ptr);
  807b43:	48 8b bd 10 ff ff ff 	mov    -0xf0(%rbp),%rdi
  807b4a:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  807b51:	00 00 00 
  807b54:	ff d0                	call   *%rax
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
  807b56:	e9 d2 fe ff ff       	jmp    807a2d <lodepng_deflate+0x785>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
  807b5b:	48 83 ec 08          	sub    $0x8,%rsp
  807b5f:	48 8b 8d d0 fe ff ff 	mov    -0x130(%rbp),%rcx
  807b66:	8b 41 14             	mov    0x14(%rcx),%eax
  807b69:	50                   	push   %rax
  807b6a:	8b 41 10             	mov    0x10(%rcx),%eax
  807b6d:	50                   	push   %rax
  807b6e:	8b 41 0c             	mov    0xc(%rcx),%eax
  807b71:	50                   	push   %rax
  807b72:	44 8b 49 08          	mov    0x8(%rcx),%r9d
  807b76:	4c 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%r8
  807b7d:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  807b84:	48 8b 95 90 fe ff ff 	mov    -0x170(%rbp),%rdx
  807b8b:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  807b8f:	48 8d bd f8 fe ff ff 	lea    -0x108(%rbp),%rdi
  807b96:	48 b8 c0 49 80 00 00 	movabs $0x8049c0,%rax
  807b9d:	00 00 00 
  807ba0:	ff d0                	call   *%rax
  807ba2:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
      if(error) break;
  807ba8:	48 83 c4 20          	add    $0x20,%rsp
  807bac:	85 c0                	test   %eax,%eax
  807bae:	0f 84 77 fd ff ff    	je     80792b <lodepng_deflate+0x683>
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
  807bb4:	48 c7 85 c0 fe ff ff 	movq   $0x0,-0x140(%rbp)
  807bbb:	00 00 00 00 
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
  807bbf:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  807bc6:	00 00 00 00 
  807bca:	e9 d9 06 00 00       	jmp    8082a8 <lodepng_deflate+0x1000>
    for(i = 0; i != lz77_encoded.size; ++i) {
  807bcf:	48 83 c0 01          	add    $0x1,%rax
  807bd3:	48 3b 85 00 ff ff ff 	cmp    -0x100(%rbp),%rax
  807bda:	74 36                	je     807c12 <lodepng_deflate+0x96a>
      unsigned symbol = lz77_encoded.data[i];
  807bdc:	48 8d 3c 85 00 00 00 	lea    0x0(,%rax,4),%rdi
  807be3:	00 
  807be4:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  807beb:	8b 14 82             	mov    (%rdx,%rax,4),%edx
      ++frequencies_ll[symbol];
  807bee:	89 d1                	mov    %edx,%ecx
  807bf0:	83 04 8e 01          	addl   $0x1,(%rsi,%rcx,4)
      if(symbol > 256) {
  807bf4:	81 fa 00 01 00 00    	cmp    $0x100,%edx
  807bfa:	76 d3                	jbe    807bcf <lodepng_deflate+0x927>
        unsigned dist = lz77_encoded.data[i + 2];
  807bfc:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
        ++frequencies_d[dist];
  807c03:	8b 54 3a 08          	mov    0x8(%rdx,%rdi,1),%edx
  807c07:	41 83 04 90 01       	addl   $0x1,(%r8,%rdx,4)
        i += 3;
  807c0c:	48 83 c0 03          	add    $0x3,%rax
  807c10:	eb bd                	jmp    807bcf <lodepng_deflate+0x927>
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
  807c12:	48 8b 85 a0 fe ff ff 	mov    -0x160(%rbp),%rax
  807c19:	c7 80 00 04 00 00 01 	movl   $0x1,0x400(%rax)
  807c20:	00 00 00 
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
  807c23:	41 b8 0f 00 00 00    	mov    $0xf,%r8d
  807c29:	b9 1e 01 00 00       	mov    $0x11e,%ecx
  807c2e:	ba 01 01 00 00       	mov    $0x101,%edx
  807c33:	48 89 c6             	mov    %rax,%rsi
  807c36:	48 8d bd 10 ff ff ff 	lea    -0xf0(%rbp),%rdi
  807c3d:	48 b8 96 64 80 00 00 	movabs $0x806496,%rax
  807c44:	00 00 00 
  807c47:	ff d0                	call   *%rax
  807c49:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
  807c4f:	48 c7 85 c0 fe ff ff 	movq   $0x0,-0x140(%rbp)
  807c56:	00 00 00 00 
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
  807c5a:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  807c61:	00 00 00 00 
    if(error) break;
  807c65:	85 c0                	test   %eax,%eax
  807c67:	0f 85 3b 06 00 00    	jne    8082a8 <lodepng_deflate+0x1000>
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
  807c6d:	41 b8 0f 00 00 00    	mov    $0xf,%r8d
  807c73:	b9 1e 00 00 00       	mov    $0x1e,%ecx
  807c78:	ba 02 00 00 00       	mov    $0x2,%edx
  807c7d:	48 8b b5 98 fe ff ff 	mov    -0x168(%rbp),%rsi
  807c84:	48 8d bd 38 ff ff ff 	lea    -0xc8(%rbp),%rdi
  807c8b:	48 b8 96 64 80 00 00 	movabs $0x806496,%rax
  807c92:	00 00 00 
  807c95:	ff d0                	call   *%rax
  807c97:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
  807c9d:	48 c7 85 c0 fe ff ff 	movq   $0x0,-0x140(%rbp)
  807ca4:	00 00 00 00 
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
  807ca8:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  807caf:	00 00 00 00 
    if(error) break;
  807cb3:	85 c0                	test   %eax,%eax
  807cb5:	0f 85 ed 05 00 00    	jne    8082a8 <lodepng_deflate+0x1000>
    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
  807cbb:	81 bd 24 ff ff ff 1e 	cmpl   $0x11e,-0xdc(%rbp)
  807cc2:	01 00 00 
  807cc5:	b8 1e 01 00 00       	mov    $0x11e,%eax
  807cca:	0f 46 85 24 ff ff ff 	cmovbe -0xdc(%rbp),%eax
  807cd1:	89 85 70 fe ff ff    	mov    %eax,-0x190(%rbp)
  807cd7:	89 c1                	mov    %eax,%ecx
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
  807cd9:	83 bd 4c ff ff ff 1e 	cmpl   $0x1e,-0xb4(%rbp)
  807ce0:	b8 1e 00 00 00       	mov    $0x1e,%eax
  807ce5:	0f 46 85 4c ff ff ff 	cmovbe -0xb4(%rbp),%eax
  807cec:	89 85 64 fe ff ff    	mov    %eax,-0x19c(%rbp)
  807cf2:	89 c6                	mov    %eax,%esi
  807cf4:	48 89 b5 80 fe ff ff 	mov    %rsi,-0x180(%rbp)
    numcodes_lld = numcodes_ll + numcodes_d;
  807cfb:	48 89 8d 68 fe ff ff 	mov    %rcx,-0x198(%rbp)
  807d02:	48 89 c8             	mov    %rcx,%rax
  807d05:	48 01 f0             	add    %rsi,%rax
  807d08:	48 89 85 78 fe ff ff 	mov    %rax,-0x188(%rbp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
  807d0f:	48 8d 34 85 00 00 00 	lea    0x0(,%rax,4),%rsi
  807d16:	00 
  return jos_malloc(size);
  807d17:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
  807d1e:	89 f7                	mov    %esi,%edi
  807d20:	48 ba f8 0d 81 00 00 	movabs $0x810df8,%rdx
  807d27:	00 00 00 
  807d2a:	ff d2                	call   *%rdx
  807d2c:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
  807d33:	8b bd c0 fe ff ff    	mov    -0x140(%rbp),%edi
  807d39:	48 ba f8 0d 81 00 00 	movabs $0x810df8,%rdx
  807d40:	00 00 00 
  807d43:	ff d2                	call   *%rdx
  807d45:	48 89 85 c0 fe ff ff 	mov    %rax,-0x140(%rbp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
  807d4c:	48 83 bd b8 fe ff ff 	cmpq   $0x0,-0x148(%rbp)
  807d53:	00 
  807d54:	0f 84 0b 06 00 00    	je     808365 <lodepng_deflate+0x10bd>
  807d5a:	48 85 c0             	test   %rax,%rax
  807d5d:	0f 84 02 06 00 00    	je     808365 <lodepng_deflate+0x10bd>
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
  807d63:	48 8b 85 68 fe ff ff 	mov    -0x198(%rbp),%rax
  807d6a:	48 85 c0             	test   %rax,%rax
  807d6d:	0f 84 3b 07 00 00    	je     8084ae <lodepng_deflate+0x1206>
  807d73:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  807d7a:	00 
  807d7b:	b8 00 00 00 00       	mov    $0x0,%eax
  807d80:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
  807d87:	8b 0c 01             	mov    (%rcx,%rax,1),%ecx
  807d8a:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  807d91:	89 0c 06             	mov    %ecx,(%rsi,%rax,1)
  807d94:	48 83 c0 04          	add    $0x4,%rax
  807d98:	48 39 d0             	cmp    %rdx,%rax
  807d9b:	75 e3                	jne    807d80 <lodepng_deflate+0xad8>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
  807d9d:	48 83 bd 80 fe ff ff 	cmpq   $0x0,-0x180(%rbp)
  807da4:	00 
  807da5:	74 38                	je     807ddf <lodepng_deflate+0xb37>
  807da7:	48 8b 8d 80 fe ff ff 	mov    -0x180(%rbp),%rcx
  807dae:	48 c1 e1 02          	shl    $0x2,%rcx
  807db2:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  807db9:	48 8b b5 68 fe ff ff 	mov    -0x198(%rbp),%rsi
  807dc0:	48 8d 14 b0          	lea    (%rax,%rsi,4),%rdx
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
  807dc4:	b8 00 00 00 00       	mov    $0x0,%eax
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
  807dc9:	48 8b b5 40 ff ff ff 	mov    -0xc0(%rbp),%rsi
  807dd0:	8b 34 06             	mov    (%rsi,%rax,1),%esi
  807dd3:	89 34 02             	mov    %esi,(%rdx,%rax,1)
  807dd6:	48 83 c0 04          	add    $0x4,%rax
  807dda:	48 39 c1             	cmp    %rax,%rcx
  807ddd:	75 ea                	jne    807dc9 <lodepng_deflate+0xb21>
    numcodes_lld_e = 0;
  807ddf:	48 c7 85 80 fe ff ff 	movq   $0x0,-0x180(%rbp)
  807de6:	00 00 00 00 
    for(i = 0; i != numcodes_lld; ++i) {
  807dea:	be 00 00 00 00       	mov    $0x0,%esi
  807def:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  807df6:	4c 8d 48 04          	lea    0x4(%rax),%r9
  807dfa:	48 83 bd 78 fe ff ff 	cmpq   $0x0,-0x188(%rbp)
  807e01:	00 
  807e02:	74 32                	je     807e36 <lodepng_deflate+0xb8e>
  807e04:	89 9d 68 fe ff ff    	mov    %ebx,-0x198(%rbp)
  807e0a:	4c 89 a5 58 fe ff ff 	mov    %r12,-0x1a8(%rbp)
  807e11:	4c 89 ad 50 fe ff ff 	mov    %r13,-0x1b0(%rbp)
  807e18:	4c 8b 85 78 fe ff ff 	mov    -0x188(%rbp),%r8
  807e1f:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  807e26:	48 8b 9d c0 fe ff ff 	mov    -0x140(%rbp),%rbx
  807e2d:	48 8b bd 80 fe ff ff 	mov    -0x180(%rbp),%rdi
  807e34:	eb 58                	jmp    807e8e <lodepng_deflate+0xbe6>
    numcodes_lld_e = 0;
  807e36:	48 8b 85 78 fe ff ff 	mov    -0x188(%rbp),%rax
  807e3d:	48 89 85 80 fe ff ff 	mov    %rax,-0x180(%rbp)
  807e44:	e9 89 01 00 00       	jmp    807fd2 <lodepng_deflate+0xd2a>
          if(j > 138) j = 138;
  807e49:	81 fa 8a 00 00 00    	cmp    $0x8a,%edx
  807e4f:	b8 8a 00 00 00       	mov    $0x8a,%eax
  807e54:	0f 47 d0             	cmova  %eax,%edx
          bitlen_lld_e[numcodes_lld_e++] = 18;
  807e57:	48 8d 04 bd 00 00 00 	lea    0x0(,%rdi,4),%rax
  807e5e:	00 
  807e5f:	c7 04 bb 12 00 00 00 	movl   $0x12,(%rbx,%rdi,4)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
  807e66:	48 83 c7 02          	add    $0x2,%rdi
  807e6a:	44 8d 5a f5          	lea    -0xb(%rdx),%r11d
  807e6e:	44 89 5c 03 04       	mov    %r11d,0x4(%rbx,%rax,1)
  807e73:	eb 76                	jmp    807eeb <lodepng_deflate+0xc43>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
  807e75:	83 f8 02             	cmp    $0x2,%eax
  807e78:	77 79                	ja     807ef3 <lodepng_deflate+0xc4b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
  807e7a:	89 14 bb             	mov    %edx,(%rbx,%rdi,4)
  807e7d:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
    for(i = 0; i != numcodes_lld; ++i) {
  807e81:	48 83 c6 01          	add    $0x1,%rsi
  807e85:	49 39 f0             	cmp    %rsi,%r8
  807e88:	0f 84 f3 00 00 00    	je     807f81 <lodepng_deflate+0xcd9>
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
  807e8e:	4c 8d 66 01          	lea    0x1(%rsi),%r12
  807e92:	4d 39 c4             	cmp    %r8,%r12
  807e95:	0f 83 0b 06 00 00    	jae    8084a6 <lodepng_deflate+0x11fe>
  807e9b:	8b 14 b1             	mov    (%rcx,%rsi,4),%edx
  807e9e:	4d 89 e3             	mov    %r12,%r11
      unsigned j = 0; /*amount of repetitions*/
  807ea1:	8b 85 d8 fe ff ff    	mov    -0x128(%rbp),%eax
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
  807ea7:	42 39 14 99          	cmp    %edx,(%rcx,%r11,4)
  807eab:	75 0e                	jne    807ebb <lodepng_deflate+0xc13>
  807ead:	83 c0 01             	add    $0x1,%eax
  807eb0:	41 89 c3             	mov    %eax,%r11d
  807eb3:	4d 01 e3             	add    %r12,%r11
  807eb6:	4d 39 d8             	cmp    %r11,%r8
  807eb9:	77 ec                	ja     807ea7 <lodepng_deflate+0xbff>
      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
  807ebb:	85 d2                	test   %edx,%edx
  807ebd:	75 b6                	jne    807e75 <lodepng_deflate+0xbcd>
  807ebf:	83 f8 01             	cmp    $0x1,%eax
  807ec2:	76 b1                	jbe    807e75 <lodepng_deflate+0xbcd>
        ++j; /*include the first zero*/
  807ec4:	8d 50 01             	lea    0x1(%rax),%edx
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
  807ec7:	83 fa 0a             	cmp    $0xa,%edx
  807eca:	0f 87 79 ff ff ff    	ja     807e49 <lodepng_deflate+0xba1>
          bitlen_lld_e[numcodes_lld_e++] = 17;
  807ed0:	4c 8d 1c bd 00 00 00 	lea    0x0(,%rdi,4),%r11
  807ed7:	00 
  807ed8:	c7 04 bb 11 00 00 00 	movl   $0x11,(%rbx,%rdi,4)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
  807edf:	48 83 c7 02          	add    $0x2,%rdi
  807ee3:	83 e8 02             	sub    $0x2,%eax
  807ee6:	42 89 44 1b 04       	mov    %eax,0x4(%rbx,%r11,1)
        i += (j - 1);
  807eeb:	8d 42 ff             	lea    -0x1(%rdx),%eax
  807eee:	48 01 c6             	add    %rax,%rsi
  807ef1:	eb 8e                	jmp    807e81 <lodepng_deflate+0xbd9>
        unsigned num = j / 6u, rest = j % 6u;
  807ef3:	41 89 c3             	mov    %eax,%r11d
  807ef6:	41 ba ab aa aa aa    	mov    $0xaaaaaaab,%r10d
  807efc:	4d 0f af da          	imul   %r10,%r11
  807f00:	49 c1 eb 22          	shr    $0x22,%r11
  807f04:	45 89 dd             	mov    %r11d,%r13d
  807f07:	47 8d 24 5b          	lea    (%r11,%r11,2),%r12d
  807f0b:	45 01 e4             	add    %r12d,%r12d
  807f0e:	41 89 c3             	mov    %eax,%r11d
  807f11:	45 29 e3             	sub    %r12d,%r11d
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
  807f14:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  807f18:	4c 8d 14 bd 00 00 00 	lea    0x0(,%rdi,4),%r10
  807f1f:	00 
  807f20:	89 14 bb             	mov    %edx,(%rbx,%rdi,4)
        for(k = 0; k < num; ++k) {
  807f23:	45 89 ed             	mov    %r13d,%r13d
  807f26:	4d 85 ed             	test   %r13,%r13
  807f29:	74 28                	je     807f53 <lodepng_deflate+0xcab>
  807f2b:	4a 8d 54 13 04       	lea    0x4(%rbx,%r10,1),%rdx
  807f30:	4e 8d 24 6f          	lea    (%rdi,%r13,2),%r12
  807f34:	4f 8d 24 a1          	lea    (%r9,%r12,4),%r12
          bitlen_lld_e[numcodes_lld_e++] = 16;
  807f38:	c7 02 10 00 00 00    	movl   $0x10,(%rdx)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
  807f3e:	c7 42 04 03 00 00 00 	movl   $0x3,0x4(%rdx)
        for(k = 0; k < num; ++k) {
  807f45:	48 83 c2 08          	add    $0x8,%rdx
  807f49:	49 39 d4             	cmp    %rdx,%r12
  807f4c:	75 ea                	jne    807f38 <lodepng_deflate+0xc90>
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
  807f4e:	4e 8d 64 6f 01       	lea    0x1(%rdi,%r13,2),%r12
        if(rest >= 3) {
  807f53:	41 83 fb 02          	cmp    $0x2,%r11d
  807f57:	76 20                	jbe    807f79 <lodepng_deflate+0xcd1>
          bitlen_lld_e[numcodes_lld_e++] = 16;
  807f59:	42 c7 04 a3 10 00 00 	movl   $0x10,(%rbx,%r12,4)
  807f60:	00 
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
  807f61:	49 8d 7c 24 02       	lea    0x2(%r12),%rdi
  807f66:	41 83 eb 03          	sub    $0x3,%r11d
  807f6a:	46 89 5c a3 04       	mov    %r11d,0x4(%rbx,%r12,4)
        i += j;
  807f6f:	89 c0                	mov    %eax,%eax
  807f71:	48 01 c6             	add    %rax,%rsi
  807f74:	e9 08 ff ff ff       	jmp    807e81 <lodepng_deflate+0xbd9>
        else j -= rest;
  807f79:	44 29 d8             	sub    %r11d,%eax
  807f7c:	4c 89 e7             	mov    %r12,%rdi
  807f7f:	eb ee                	jmp    807f6f <lodepng_deflate+0xcc7>
    for(i = 0; i != numcodes_lld_e; ++i) {
  807f81:	8b 9d 68 fe ff ff    	mov    -0x198(%rbp),%ebx
  807f87:	4c 8b a5 58 fe ff ff 	mov    -0x1a8(%rbp),%r12
  807f8e:	4c 8b ad 50 fe ff ff 	mov    -0x1b0(%rbp),%r13
  807f95:	48 89 bd 80 fe ff ff 	mov    %rdi,-0x180(%rbp)
  807f9c:	48 85 ff             	test   %rdi,%rdi
  807f9f:	74 31                	je     807fd2 <lodepng_deflate+0xd2a>
  807fa1:	b8 00 00 00 00       	mov    $0x0,%eax
  807fa6:	48 8b b5 88 fe ff ff 	mov    -0x178(%rbp),%rsi
      ++frequencies_cl[bitlen_lld_e[i]];
  807fad:	48 8b 8d c0 fe ff ff 	mov    -0x140(%rbp),%rcx
  807fb4:	48 8d 14 81          	lea    (%rcx,%rax,4),%rdx
  807fb8:	8b 0a                	mov    (%rdx),%ecx
  807fba:	83 04 8e 01          	addl   $0x1,(%rsi,%rcx,4)
      if(bitlen_lld_e[i] >= 16) ++i;
  807fbe:	83 3a 10             	cmpl   $0x10,(%rdx)
  807fc1:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
    for(i = 0; i != numcodes_lld_e; ++i) {
  807fc5:	48 83 c0 01          	add    $0x1,%rax
  807fc9:	48 3b 85 80 fe ff ff 	cmp    -0x180(%rbp),%rax
  807fd0:	75 db                	jne    807fad <lodepng_deflate+0xd05>
    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
  807fd2:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  807fd8:	b9 13 00 00 00       	mov    $0x13,%ecx
  807fdd:	ba 13 00 00 00       	mov    $0x13,%edx
  807fe2:	48 8b b5 88 fe ff ff 	mov    -0x178(%rbp),%rsi
  807fe9:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  807ff0:	48 b8 96 64 80 00 00 	movabs $0x806496,%rax
  807ff7:	00 00 00 
  807ffa:	ff d0                	call   *%rax
  807ffc:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
    if(error) break;
  808002:	85 c0                	test   %eax,%eax
  808004:	0f 85 9e 02 00 00    	jne    8082a8 <lodepng_deflate+0x1000>
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
  80800a:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
    numcodes_cl = NUM_CODE_LENGTH_CODES;
  808011:	b9 13 00 00 00       	mov    $0x13,%ecx
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
  808016:	48 b8 40 24 81 00 00 	movabs $0x812440,%rax
  80801d:	00 00 00 
  808020:	48 89 8d 78 fe ff ff 	mov    %rcx,-0x188(%rbp)
  808027:	48 83 e9 01          	sub    $0x1,%rcx
  80802b:	8b 34 88             	mov    (%rax,%rcx,4),%esi
  80802e:	83 3c b2 00          	cmpl   $0x0,(%rdx,%rsi,4)
  808032:	0f 85 e1 03 00 00    	jne    808419 <lodepng_deflate+0x1171>
  808038:	48 83 f9 04          	cmp    $0x4,%rcx
  80803c:	75 e2                	jne    808020 <lodepng_deflate+0xd78>
    writeBits(writer, BFINAL, 1);
  80803e:	48 89 8d 78 fe ff ff 	mov    %rcx,-0x188(%rbp)
  808045:	ba 01 00 00 00       	mov    $0x1,%edx
  80804a:	89 de                	mov    %ebx,%esi
  80804c:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808053:	48 bb b3 46 80 00 00 	movabs $0x8046b3,%rbx
  80805a:	00 00 00 
  80805d:	ff d3                	call   *%rbx
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
  80805f:	ba 01 00 00 00       	mov    $0x1,%edx
  808064:	be 00 00 00 00       	mov    $0x0,%esi
  808069:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808070:	ff d3                	call   *%rbx
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
  808072:	ba 01 00 00 00       	mov    $0x1,%edx
  808077:	be 01 00 00 00       	mov    $0x1,%esi
  80807c:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808083:	ff d3                	call   *%rbx
    HLIT = (unsigned)(numcodes_ll - 257);
  808085:	8b b5 70 fe ff ff    	mov    -0x190(%rbp),%esi
  80808b:	81 ee 01 01 00 00    	sub    $0x101,%esi
    writeBits(writer, HLIT, 5);
  808091:	ba 05 00 00 00       	mov    $0x5,%edx
  808096:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  80809d:	ff d3                	call   *%rbx
    HDIST = (unsigned)(numcodes_d - 1);
  80809f:	8b b5 64 fe ff ff    	mov    -0x19c(%rbp),%esi
  8080a5:	83 ee 01             	sub    $0x1,%esi
    writeBits(writer, HDIST, 5);
  8080a8:	ba 05 00 00 00       	mov    $0x5,%edx
  8080ad:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  8080b4:	ff d3                	call   *%rbx
    writeBits(writer, HCLEN, 4);
  8080b6:	ba 04 00 00 00       	mov    $0x4,%edx
  8080bb:	be 00 00 00 00       	mov    $0x0,%esi
  8080c0:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  8080c7:	ff d3                	call   *%rbx
  8080c9:	bb 00 00 00 00       	mov    $0x0,%ebx
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
  8080ce:	48 b8 40 24 81 00 00 	movabs $0x812440,%rax
  8080d5:	00 00 00 
  8080d8:	8b 14 98             	mov    (%rax,%rbx,4),%edx
  8080db:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8080e2:	8b 34 90             	mov    (%rax,%rdx,4),%esi
  8080e5:	ba 03 00 00 00       	mov    $0x3,%edx
  8080ea:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  8080f1:	48 b8 b3 46 80 00 00 	movabs $0x8046b3,%rax
  8080f8:	00 00 00 
  8080fb:	ff d0                	call   *%rax
  8080fd:	48 83 c3 01          	add    $0x1,%rbx
  808101:	48 3b 9d 78 fe ff ff 	cmp    -0x188(%rbp),%rbx
  808108:	75 c4                	jne    8080ce <lodepng_deflate+0xe26>
    for(i = 0; i != numcodes_lld_e; ++i) {
  80810a:	48 83 bd 80 fe ff ff 	cmpq   $0x0,-0x180(%rbp)
  808111:	00 
  808112:	0f 84 07 01 00 00    	je     80821f <lodepng_deflate+0xf77>
  808118:	bb 00 00 00 00       	mov    $0x0,%ebx
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
  80811d:	4c 89 bd 78 fe ff ff 	mov    %r15,-0x188(%rbp)
  808124:	4c 89 a5 70 fe ff ff 	mov    %r12,-0x190(%rbp)
  80812b:	eb 39                	jmp    808166 <lodepng_deflate+0xebe>
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
  80812d:	48 83 c3 01          	add    $0x1,%rbx
  808131:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  808138:	42 8b 74 38 04       	mov    0x4(%rax,%r15,1),%esi
  80813d:	ba 02 00 00 00       	mov    $0x2,%edx
  808142:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808149:	48 b8 b3 46 80 00 00 	movabs $0x8046b3,%rax
  808150:	00 00 00 
  808153:	ff d0                	call   *%rax
    for(i = 0; i != numcodes_lld_e; ++i) {
  808155:	48 83 c3 01          	add    $0x1,%rbx
  808159:	48 39 9d 80 fe ff ff 	cmp    %rbx,-0x180(%rbp)
  808160:	0f 84 ab 00 00 00    	je     808211 <lodepng_deflate+0xf69>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
  808166:	4c 8d 3c 9d 00 00 00 	lea    0x0(,%rbx,4),%r15
  80816d:	00 
  80816e:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  808175:	4e 8d 24 38          	lea    (%rax,%r15,1),%r12
  808179:	41 8b 04 24          	mov    (%r12),%eax
  80817d:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  808184:	8b 14 82             	mov    (%rdx,%rax,4),%edx
  808187:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80818e:	8b 34 81             	mov    (%rcx,%rax,4),%esi
  808191:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808198:	48 b8 74 47 80 00 00 	movabs $0x804774,%rax
  80819f:	00 00 00 
  8081a2:	ff d0                	call   *%rax
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
  8081a4:	41 8b 04 24          	mov    (%r12),%eax
  8081a8:	83 f8 10             	cmp    $0x10,%eax
  8081ab:	74 80                	je     80812d <lodepng_deflate+0xe85>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
  8081ad:	83 f8 11             	cmp    $0x11,%eax
  8081b0:	74 32                	je     8081e4 <lodepng_deflate+0xf3c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
  8081b2:	83 f8 12             	cmp    $0x12,%eax
  8081b5:	75 9e                	jne    808155 <lodepng_deflate+0xead>
  8081b7:	48 83 c3 01          	add    $0x1,%rbx
  8081bb:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  8081c2:	42 8b 74 38 04       	mov    0x4(%rax,%r15,1),%esi
  8081c7:	ba 07 00 00 00       	mov    $0x7,%edx
  8081cc:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  8081d3:	48 b8 b3 46 80 00 00 	movabs $0x8046b3,%rax
  8081da:	00 00 00 
  8081dd:	ff d0                	call   *%rax
  8081df:	e9 71 ff ff ff       	jmp    808155 <lodepng_deflate+0xead>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
  8081e4:	48 83 c3 01          	add    $0x1,%rbx
  8081e8:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  8081ef:	42 8b 74 38 04       	mov    0x4(%rax,%r15,1),%esi
  8081f4:	ba 03 00 00 00       	mov    $0x3,%edx
  8081f9:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808200:	48 b8 b3 46 80 00 00 	movabs $0x8046b3,%rax
  808207:	00 00 00 
  80820a:	ff d0                	call   *%rax
  80820c:	e9 44 ff ff ff       	jmp    808155 <lodepng_deflate+0xead>
  808211:	4c 8b bd 78 fe ff ff 	mov    -0x188(%rbp),%r15
  808218:	4c 8b a5 70 fe ff ff 	mov    -0x190(%rbp),%r12
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
  80821f:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  808226:	48 8d 95 10 ff ff ff 	lea    -0xf0(%rbp),%rdx
  80822d:	48 8d b5 f8 fe ff ff 	lea    -0x108(%rbp),%rsi
  808234:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  80823b:	48 b8 02 48 80 00 00 	movabs $0x804802,%rax
  808242:	00 00 00 
  808245:	ff d0                	call   *%rax
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
  808247:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80824e:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
  808254:	85 c0                	test   %eax,%eax
  808256:	75 0c                	jne    808264 <lodepng_deflate+0xfbc>
  808258:	c7 85 d8 fe ff ff 40 	movl   $0x40,-0x128(%rbp)
  80825f:	00 00 00 
  808262:	eb 44                	jmp    8082a8 <lodepng_deflate+0x1000>
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
  808264:	89 c2                	mov    %eax,%edx
  808266:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80826d:	8b b0 00 04 00 00    	mov    0x400(%rax),%esi
  808273:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  80827a:	48 b8 74 47 80 00 00 	movabs $0x804774,%rax
  808281:	00 00 00 
  808284:	ff d0                	call   *%rax
    break; /*end of error-while*/
  808286:	eb 20                	jmp    8082a8 <lodepng_deflate+0x1000>
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
  808288:	48 c7 85 c0 fe ff ff 	movq   $0x0,-0x140(%rbp)
  80828f:	00 00 00 00 
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
  808293:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  80829a:	00 00 00 00 
  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
  80829e:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  8082a5:	00 00 00 
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
  8082a8:	48 c7 85 08 ff ff ff 	movq   $0x0,-0xf8(%rbp)
  8082af:	00 00 00 00 
  8082b3:	48 c7 85 00 ff ff ff 	movq   $0x0,-0x100(%rbp)
  8082ba:	00 00 00 00 
    jos_free(ptr);
  8082be:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  8082c5:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8082cc:	00 00 00 
  8082cf:	ff d0                	call   *%rax
  ((uivector*)p)->data = NULL;
  8082d1:	48 c7 85 f8 fe ff ff 	movq   $0x0,-0x108(%rbp)
  8082d8:	00 00 00 00 
  HuffmanTree_cleanup(&tree_ll);
  8082dc:	48 8d bd 10 ff ff ff 	lea    -0xf0(%rbp),%rdi
  8082e3:	48 bb 16 52 80 00 00 	movabs $0x805216,%rbx
  8082ea:	00 00 00 
  8082ed:	ff d3                	call   *%rbx
  HuffmanTree_cleanup(&tree_d);
  8082ef:	48 8d bd 38 ff ff ff 	lea    -0xc8(%rbp),%rdi
  8082f6:	ff d3                	call   *%rbx
  HuffmanTree_cleanup(&tree_cl);
  8082f8:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  8082ff:	ff d3                	call   *%rbx
    jos_free(ptr);
  808301:	48 8b bd a0 fe ff ff 	mov    -0x160(%rbp),%rdi
  808308:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  80830f:	00 00 00 
  808312:	48 89 c3             	mov    %rax,%rbx
  808315:	ff d0                	call   *%rax
  808317:	48 8b bd 98 fe ff ff 	mov    -0x168(%rbp),%rdi
  80831e:	ff d3                	call   *%rbx
  808320:	48 8b bd 88 fe ff ff 	mov    -0x178(%rbp),%rdi
  808327:	ff d3                	call   *%rbx
  808329:	48 8b bd b8 fe ff ff 	mov    -0x148(%rbp),%rdi
  808330:	ff d3                	call   *%rbx
  808332:	48 8b bd c0 fe ff ff 	mov    -0x140(%rbp),%rdi
  808339:	ff d3                	call   *%rbx
  return error;
  80833b:	e9 9d f3 ff ff       	jmp    8076dd <lodepng_deflate+0x435>
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
  808340:	48 c7 85 c0 fe ff ff 	movq   $0x0,-0x140(%rbp)
  808347:	00 00 00 00 
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
  80834b:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  808352:	00 00 00 00 
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
  808356:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  80835d:	00 00 00 
  808360:	e9 43 ff ff ff       	jmp    8082a8 <lodepng_deflate+0x1000>
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
  808365:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  80836c:	00 00 00 
  80836f:	e9 34 ff ff ff       	jmp    8082a8 <lodepng_deflate+0x1000>
  808374:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  80837b:	00 00 00 
  80837e:	eb 22                	jmp    8083a2 <lodepng_deflate+0x10fa>
  808380:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  808387:	00 00 00 
  80838a:	eb 16                	jmp    8083a2 <lodepng_deflate+0x10fa>
  80838c:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  808393:	00 00 00 
  808396:	eb 0a                	jmp    8083a2 <lodepng_deflate+0x10fa>
  808398:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  80839f:	00 00 00 
    jos_free(ptr);
  8083a2:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8083a6:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  8083ad:	00 00 00 
  8083b0:	ff d3                	call   *%rbx
  8083b2:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8083b6:	ff d3                	call   *%rbx
  8083b8:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  8083bc:	ff d3                	call   *%rbx
  8083be:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8083c2:	ff d3                	call   *%rbx
  8083c4:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8083c8:	ff d3                	call   *%rbx
  8083ca:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8083ce:	ff d3                	call   *%rbx
  *out = v.data;
  8083d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8083d4:	48 8b 8d b0 fe ff ff 	mov    -0x150(%rbp),%rcx
  8083db:	48 89 01             	mov    %rax,(%rcx)
  *outsize = v.size;
  8083de:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8083e2:	48 8b 8d a8 fe ff ff 	mov    -0x158(%rbp),%rcx
  8083e9:	48 89 01             	mov    %rax,(%rcx)
}
  8083ec:	8b 85 d8 fe ff ff    	mov    -0x128(%rbp),%eax
  8083f2:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  8083f6:	5b                   	pop    %rbx
  8083f7:	41 5c                	pop    %r12
  8083f9:	41 5d                	pop    %r13
  8083fb:	41 5e                	pop    %r14
  8083fd:	41 5f                	pop    %r15
  8083ff:	5d                   	pop    %rbp
  808400:	c3                   	ret    
  808401:	c7 85 d8 fe ff ff 53 	movl   $0x53,-0x128(%rbp)
  808408:	00 00 00 
  80840b:	eb 95                	jmp    8083a2 <lodepng_deflate+0x10fa>
  if(settings->btype > 2) return 61;
  80840d:	c7 85 d8 fe ff ff 3d 	movl   $0x3d,-0x128(%rbp)
  808414:	00 00 00 
  808417:	eb b7                	jmp    8083d0 <lodepng_deflate+0x1128>
    writeBits(writer, BFINAL, 1);
  808419:	ba 01 00 00 00       	mov    $0x1,%edx
  80841e:	89 de                	mov    %ebx,%esi
  808420:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808427:	48 bb b3 46 80 00 00 	movabs $0x8046b3,%rbx
  80842e:	00 00 00 
  808431:	ff d3                	call   *%rbx
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
  808433:	ba 01 00 00 00       	mov    $0x1,%edx
  808438:	be 00 00 00 00       	mov    $0x0,%esi
  80843d:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808444:	ff d3                	call   *%rbx
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
  808446:	ba 01 00 00 00       	mov    $0x1,%edx
  80844b:	be 01 00 00 00       	mov    $0x1,%esi
  808450:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808457:	ff d3                	call   *%rbx
    HLIT = (unsigned)(numcodes_ll - 257);
  808459:	8b b5 70 fe ff ff    	mov    -0x190(%rbp),%esi
  80845f:	81 ee 01 01 00 00    	sub    $0x101,%esi
    writeBits(writer, HLIT, 5);
  808465:	ba 05 00 00 00       	mov    $0x5,%edx
  80846a:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808471:	ff d3                	call   *%rbx
    HDIST = (unsigned)(numcodes_d - 1);
  808473:	8b b5 64 fe ff ff    	mov    -0x19c(%rbp),%esi
  808479:	83 ee 01             	sub    $0x1,%esi
    writeBits(writer, HDIST, 5);
  80847c:	ba 05 00 00 00       	mov    $0x5,%edx
  808481:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  808488:	ff d3                	call   *%rbx
    HCLEN = (unsigned)(numcodes_cl - 4);
  80848a:	8b 8d 78 fe ff ff    	mov    -0x188(%rbp),%ecx
  808490:	8d 71 fc             	lea    -0x4(%rcx),%esi
    writeBits(writer, HCLEN, 4);
  808493:	ba 04 00 00 00       	mov    $0x4,%edx
  808498:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
  80849f:	ff d3                	call   *%rbx
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
  8084a1:	e9 23 fc ff ff       	jmp    8080c9 <lodepng_deflate+0xe21>
      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
  8084a6:	8b 14 b1             	mov    (%rcx,%rsi,4),%edx
  8084a9:	e9 cc f9 ff ff       	jmp    807e7a <lodepng_deflate+0xbd2>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
  8084ae:	48 83 bd 80 fe ff ff 	cmpq   $0x0,-0x180(%rbp)
  8084b5:	00 
  8084b6:	0f 85 eb f8 ff ff    	jne    807da7 <lodepng_deflate+0xaff>
  8084bc:	e9 11 fb ff ff       	jmp    807fd2 <lodepng_deflate+0xd2a>

00000000008084c1 <lodepng_zlib_decompress>:
  if(insize < 2) return 53; /*error, size of zlib data too small*/
  8084c1:	48 83 f9 01          	cmp    $0x1,%rcx
  8084c5:	0f 86 9d 00 00 00    	jbe    808568 <lodepng_zlib_decompress+0xa7>
                                 size_t insize, const LodePNGDecompressSettings* settings) {
  8084cb:	55                   	push   %rbp
  8084cc:	48 89 e5             	mov    %rsp,%rbp
  8084cf:	53                   	push   %rbx
  8084d0:	48 83 ec 08          	sub    $0x8,%rsp
  8084d4:	49 89 f9             	mov    %rdi,%r9
  8084d7:	49 89 f2             	mov    %rsi,%r10
  8084da:	48 89 d6             	mov    %rdx,%rsi
  if((in[0] * 256 + in[1]) % 31 != 0) {
  8084dd:	44 0f b6 1a          	movzbl (%rdx),%r11d
  8084e1:	0f b6 7a 01          	movzbl 0x1(%rdx),%edi
  8084e5:	41 0f b6 d3          	movzbl %r11b,%edx
  8084e9:	c1 e2 08             	shl    $0x8,%edx
  8084ec:	40 0f b6 c7          	movzbl %dil,%eax
  8084f0:	01 c2                	add    %eax,%edx
  8084f2:	48 63 c2             	movslq %edx,%rax
  8084f5:	48 69 c0 43 08 21 84 	imul   $0xffffffff84210843,%rax,%rax
  8084fc:	48 c1 e8 20          	shr    $0x20,%rax
  808500:	01 d0                	add    %edx,%eax
  808502:	c1 f8 04             	sar    $0x4,%eax
  808505:	89 c3                	mov    %eax,%ebx
  808507:	c1 e3 05             	shl    $0x5,%ebx
  80850a:	29 c3                	sub    %eax,%ebx
    return 24;
  80850c:	b8 18 00 00 00       	mov    $0x18,%eax
  if((in[0] * 256 + in[1]) % 31 != 0) {
  808511:	39 da                	cmp    %ebx,%edx
  808513:	75 39                	jne    80854e <lodepng_zlib_decompress+0x8d>
  FDICT = (in[1] >> 5) & 1;
  808515:	40 c0 ef 05          	shr    $0x5,%dil
  808519:	83 e7 01             	and    $0x1,%edi
  if(CM != 8 || CINFO > 7) {
  80851c:	44 89 d8             	mov    %r11d,%eax
  80851f:	83 e0 0f             	and    $0xf,%eax
  808522:	3c 08                	cmp    $0x8,%al
  808524:	75 48                	jne    80856e <lodepng_zlib_decompress+0xad>
  808526:	45 84 db             	test   %r11b,%r11b
  808529:	78 43                	js     80856e <lodepng_zlib_decompress+0xad>
    return 26;
  80852b:	b8 1a 00 00 00       	mov    $0x1a,%eax
  if(FDICT != 0) {
  808530:	40 84 ff             	test   %dil,%dil
  808533:	75 19                	jne    80854e <lodepng_zlib_decompress+0x8d>
  error = inflate(out, outsize, in + 2, insize - 2, settings);
  808535:	48 83 e9 02          	sub    $0x2,%rcx
  808539:	48 8d 56 02          	lea    0x2(%rsi),%rdx
  if(settings->custom_inflate) {
  80853d:	49 8b 40 10          	mov    0x10(%r8),%rax
  808541:	48 85 c0             	test   %rax,%rax
  808544:	74 0e                	je     808554 <lodepng_zlib_decompress+0x93>
    return settings->custom_inflate(out, outsize, in, insize, settings);
  808546:	4c 89 d6             	mov    %r10,%rsi
  808549:	4c 89 cf             	mov    %r9,%rdi
  80854c:	ff d0                	call   *%rax
}
  80854e:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  808552:	c9                   	leave  
  808553:	c3                   	ret    
    return lodepng_inflate(out, outsize, in, insize, settings);
  808554:	4c 89 d6             	mov    %r10,%rsi
  808557:	4c 89 cf             	mov    %r9,%rdi
  80855a:	48 b8 34 65 80 00 00 	movabs $0x806534,%rax
  808561:	00 00 00 
  808564:	ff d0                	call   *%rax
  808566:	eb e6                	jmp    80854e <lodepng_zlib_decompress+0x8d>
  if(insize < 2) return 53; /*error, size of zlib data too small*/
  808568:	b8 35 00 00 00       	mov    $0x35,%eax
}
  80856d:	c3                   	ret    
    return 25;
  80856e:	b8 19 00 00 00       	mov    $0x19,%eax
  808573:	eb d9                	jmp    80854e <lodepng_zlib_decompress+0x8d>

0000000000808575 <zlib_decompress>:
                                size_t insize, const LodePNGDecompressSettings* settings) {
  808575:	55                   	push   %rbp
  808576:	48 89 e5             	mov    %rsp,%rbp
  if(settings->custom_zlib) {
  808579:	49 8b 40 08          	mov    0x8(%r8),%rax
  80857d:	48 85 c0             	test   %rax,%rax
  808580:	74 04                	je     808586 <zlib_decompress+0x11>
    return settings->custom_zlib(out, outsize, in, insize, settings);
  808582:	ff d0                	call   *%rax
}
  808584:	5d                   	pop    %rbp
  808585:	c3                   	ret    
    return lodepng_zlib_decompress(out, outsize, in, insize, settings);
  808586:	48 b8 c1 84 80 00 00 	movabs $0x8084c1,%rax
  80858d:	00 00 00 
  808590:	ff d0                	call   *%rax
  808592:	eb f0                	jmp    808584 <zlib_decompress+0xf>

0000000000808594 <lodepng_zlib_compress>:
                               size_t insize, const LodePNGCompressSettings* settings) {
  808594:	55                   	push   %rbp
  808595:	48 89 e5             	mov    %rsp,%rbp
  808598:	41 57                	push   %r15
  80859a:	41 56                	push   %r14
  80859c:	41 55                	push   %r13
  80859e:	41 54                	push   %r12
  8085a0:	53                   	push   %rbx
  8085a1:	48 83 ec 18          	sub    $0x18,%rsp
  8085a5:	49 89 fc             	mov    %rdi,%r12
  8085a8:	49 89 f7             	mov    %rsi,%r15
  8085ab:	48 89 d3             	mov    %rdx,%rbx
  8085ae:	49 89 ce             	mov    %rcx,%r14
  unsigned char* deflatedata = 0;
  8085b1:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8085b8:	00 
  size_t deflatesize = 0;
  8085b9:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8085c0:	00 
  if(settings->custom_deflate) {
  8085c1:	49 8b 40 20          	mov    0x20(%r8),%rax
  8085c5:	48 85 c0             	test   %rax,%rax
  8085c8:	74 43                	je     80860d <lodepng_zlib_compress+0x79>
    return settings->custom_deflate(out, outsize, in, insize, settings);
  8085ca:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  8085ce:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8085d2:	ff d0                	call   *%rax
  8085d4:	41 89 c5             	mov    %eax,%r13d
  *out = NULL;
  8085d7:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
  8085de:	00 
  *outsize = 0;
  8085df:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
  if(!error) {
  8085e6:	45 85 ed             	test   %r13d,%r13d
  8085e9:	74 3b                	je     808626 <lodepng_zlib_compress+0x92>
    jos_free(ptr);
  8085eb:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8085ef:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8085f6:	00 00 00 
  8085f9:	ff d0                	call   *%rax
}
  8085fb:	44 89 e8             	mov    %r13d,%eax
  8085fe:	48 83 c4 18          	add    $0x18,%rsp
  808602:	5b                   	pop    %rbx
  808603:	41 5c                	pop    %r12
  808605:	41 5d                	pop    %r13
  808607:	41 5e                	pop    %r14
  808609:	41 5f                	pop    %r15
  80860b:	5d                   	pop    %rbp
  80860c:	c3                   	ret    
    return lodepng_deflate(out, outsize, in, insize, settings);
  80860d:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  808611:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  808615:	48 b8 a8 72 80 00 00 	movabs $0x8072a8,%rax
  80861c:	00 00 00 
  80861f:	ff d0                	call   *%rax
  808621:	41 89 c5             	mov    %eax,%r13d
  808624:	eb b1                	jmp    8085d7 <lodepng_zlib_compress+0x43>
    *outsize = deflatesize + 6;
  808626:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80862a:	48 8d 78 06          	lea    0x6(%rax),%rdi
  80862e:	49 89 3f             	mov    %rdi,(%r15)
  return jos_malloc(size);
  808631:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  808638:	00 00 00 
  80863b:	ff d0                	call   *%rax
  80863d:	49 89 c2             	mov    %rax,%r10
    *out = (unsigned char*)lodepng_malloc(*outsize);
  808640:	49 89 04 24          	mov    %rax,(%r12)
    if(!*out) error = 83; /*alloc fail*/
  808644:	48 85 c0             	test   %rax,%rax
  808647:	0f 84 cd 00 00 00    	je     80871a <lodepng_zlib_compress+0x186>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
  80864d:	44 89 f7             	mov    %r14d,%edi
  unsigned s2 = (adler >> 16u) & 0xffffu;
  808650:	44 89 e8             	mov    %r13d,%eax
  unsigned s1 = adler & 0xffffu;
  808653:	be 01 00 00 00       	mov    $0x1,%esi
    unsigned amount = len > 5552u ? 5552u : len;
  808658:	41 b9 b0 15 00 00    	mov    $0x15b0,%r9d
    s1 %= 65521u;
  80865e:	41 b8 71 80 07 80    	mov    $0x80078071,%r8d
  while(len != 0u) {
  808664:	45 85 f6             	test   %r14d,%r14d
  808667:	0f 84 b8 00 00 00    	je     808725 <lodepng_zlib_compress+0x191>
    unsigned amount = len > 5552u ? 5552u : len;
  80866d:	81 ff b0 15 00 00    	cmp    $0x15b0,%edi
  808673:	44 89 ca             	mov    %r9d,%edx
  808676:	0f 46 d7             	cmovbe %edi,%edx
    len -= amount;
  808679:	89 f9                	mov    %edi,%ecx
  80867b:	29 d7                	sub    %edx,%edi
    for(i = 0; i != amount; ++i) {
  80867d:	85 c9                	test   %ecx,%ecx
  80867f:	74 1c                	je     80869d <lodepng_zlib_compress+0x109>
  808681:	8d 52 ff             	lea    -0x1(%rdx),%edx
  808684:	48 8d 4c 13 01       	lea    0x1(%rbx,%rdx,1),%rcx
      s1 += (*data++);
  808689:	48 83 c3 01          	add    $0x1,%rbx
  80868d:	0f b6 53 ff          	movzbl -0x1(%rbx),%edx
  808691:	01 d6                	add    %edx,%esi
      s2 += s1;
  808693:	01 f0                	add    %esi,%eax
    for(i = 0; i != amount; ++i) {
  808695:	48 39 d9             	cmp    %rbx,%rcx
  808698:	75 ef                	jne    808689 <lodepng_zlib_compress+0xf5>
      s1 += (*data++);
  80869a:	48 89 cb             	mov    %rcx,%rbx
    s1 %= 65521u;
  80869d:	89 f2                	mov    %esi,%edx
  80869f:	49 0f af d0          	imul   %r8,%rdx
  8086a3:	48 c1 ea 2f          	shr    $0x2f,%rdx
  8086a7:	69 d2 f1 ff 00 00    	imul   $0xfff1,%edx,%edx
  8086ad:	29 d6                	sub    %edx,%esi
    s2 %= 65521u;
  8086af:	89 c2                	mov    %eax,%edx
  8086b1:	49 0f af d0          	imul   %r8,%rdx
  8086b5:	48 c1 ea 2f          	shr    $0x2f,%rdx
  8086b9:	69 d2 f1 ff 00 00    	imul   $0xfff1,%edx,%edx
  8086bf:	29 d0                	sub    %edx,%eax
  while(len != 0u) {
  8086c1:	85 ff                	test   %edi,%edi
  8086c3:	75 a8                	jne    80866d <lodepng_zlib_compress+0xd9>
  return (s2 << 16u) | s1;
  8086c5:	c1 e0 10             	shl    $0x10,%eax
  8086c8:	09 c6                	or     %eax,%esi
    (*out)[0] = (unsigned char)(CMFFLG >> 8);
  8086ca:	41 c6 02 78          	movb   $0x78,(%r10)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
  8086ce:	49 8b 04 24          	mov    (%r12),%rax
  8086d2:	c6 40 01 01          	movb   $0x1,0x1(%rax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
  8086d6:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8086db:	74 20                	je     8086fd <lodepng_zlib_compress+0x169>
  8086dd:	ba 00 00 00 00       	mov    $0x0,%edx
  8086e2:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8086e6:	0f b6 3c 11          	movzbl (%rcx,%rdx,1),%edi
  8086ea:	49 8b 0c 24          	mov    (%r12),%rcx
  8086ee:	40 88 7c 11 02       	mov    %dil,0x2(%rcx,%rdx,1)
  8086f3:	48 83 c2 01          	add    $0x1,%rdx
  8086f7:	48 39 55 c0          	cmp    %rdx,-0x40(%rbp)
  8086fb:	75 e5                	jne    8086e2 <lodepng_zlib_compress+0x14e>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
  8086fd:	49 8b 07             	mov    (%r15),%rax
  808700:	49 8b 14 24          	mov    (%r12),%rdx
  808704:	48 8d 7c 02 fc       	lea    -0x4(%rdx,%rax,1),%rdi
  808709:	48 b8 0c 29 80 00 00 	movabs $0x80290c,%rax
  808710:	00 00 00 
  808713:	ff d0                	call   *%rax
  808715:	e9 d1 fe ff ff       	jmp    8085eb <lodepng_zlib_compress+0x57>
    if(!*out) error = 83; /*alloc fail*/
  80871a:	41 bd 53 00 00 00    	mov    $0x53,%r13d
  808720:	e9 c6 fe ff ff       	jmp    8085eb <lodepng_zlib_compress+0x57>
  unsigned s2 = (adler >> 16u) & 0xffffu;
  808725:	44 89 f0             	mov    %r14d,%eax
  808728:	eb 9b                	jmp    8086c5 <lodepng_zlib_compress+0x131>

000000000080872a <zlib_compress>:
                              size_t insize, const LodePNGCompressSettings* settings) {
  80872a:	55                   	push   %rbp
  80872b:	48 89 e5             	mov    %rsp,%rbp
  if(settings->custom_zlib) {
  80872e:	49 8b 40 18          	mov    0x18(%r8),%rax
  808732:	48 85 c0             	test   %rax,%rax
  808735:	74 04                	je     80873b <zlib_compress+0x11>
    return settings->custom_zlib(out, outsize, in, insize, settings);
  808737:	ff d0                	call   *%rax
}
  808739:	5d                   	pop    %rbp
  80873a:	c3                   	ret    
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
  80873b:	48 b8 94 85 80 00 00 	movabs $0x808594,%rax
  808742:	00 00 00 
  808745:	ff d0                	call   *%rax
  808747:	eb f0                	jmp    808739 <zlib_compress+0xf>

0000000000808749 <lodepng_compress_settings_init>:
  settings->btype = 2;
  808749:	c7 07 02 00 00 00    	movl   $0x2,(%rdi)
  settings->use_lz77 = 1;
  80874f:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%rdi)
  settings->windowsize = DEFAULT_WINDOWSIZE;
  808756:	c7 47 08 00 08 00 00 	movl   $0x800,0x8(%rdi)
  settings->minmatch = 3;
  80875d:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%rdi)
  settings->nicematch = 128;
  808764:	c7 47 10 80 00 00 00 	movl   $0x80,0x10(%rdi)
  settings->lazymatching = 1;
  80876b:	c7 47 14 01 00 00 00 	movl   $0x1,0x14(%rdi)
  settings->custom_zlib = 0;
  808772:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  808779:	00 
  settings->custom_deflate = 0;
  80877a:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
  808781:	00 
  settings->custom_context = 0;
  808782:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
  808789:	00 
}
  80878a:	c3                   	ret    

000000000080878b <lodepng_decompress_settings_init>:
  settings->ignore_adler32 = 0;
  80878b:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
  settings->ignore_nlen = 0;
  808791:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%rdi)
  settings->custom_zlib = 0;
  808798:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  80879f:	00 
  settings->custom_inflate = 0;
  8087a0:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  8087a7:	00 
  settings->custom_context = 0;
  8087a8:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  8087af:	00 
}
  8087b0:	c3                   	ret    

00000000008087b1 <lodepng_crc32>:
  for(i = 0; i < length; ++i) {
  8087b1:	48 85 f6             	test   %rsi,%rsi
  8087b4:	74 2e                	je     8087e4 <lodepng_crc32+0x33>
  8087b6:	48 89 fa             	mov    %rdi,%rdx
  8087b9:	48 01 fe             	add    %rdi,%rsi
  unsigned r = 0xffffffffu;
  8087bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  8087c1:	48 bf e0 1f 81 00 00 	movabs $0x811fe0,%rdi
  8087c8:	00 00 00 
  8087cb:	89 c1                	mov    %eax,%ecx
  8087cd:	32 0a                	xor    (%rdx),%cl
  8087cf:	0f b6 c9             	movzbl %cl,%ecx
  8087d2:	c1 e8 08             	shr    $0x8,%eax
  8087d5:	33 04 8f             	xor    (%rdi,%rcx,4),%eax
  for(i = 0; i < length; ++i) {
  8087d8:	48 83 c2 01          	add    $0x1,%rdx
  8087dc:	48 39 f2             	cmp    %rsi,%rdx
  8087df:	75 ea                	jne    8087cb <lodepng_crc32+0x1a>
  return r ^ 0xffffffffu;
  8087e1:	f7 d0                	not    %eax
}
  8087e3:	c3                   	ret    
  unsigned r = 0xffffffffu;
  8087e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8087e9:	eb f6                	jmp    8087e1 <lodepng_crc32+0x30>

00000000008087eb <lodepng_chunk_length>:
unsigned lodepng_chunk_length(const unsigned char* chunk) {
  8087eb:	55                   	push   %rbp
  8087ec:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_read32bitInt(&chunk[0]);
  8087ef:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  8087f6:	00 00 00 
  8087f9:	ff d0                	call   *%rax
}
  8087fb:	5d                   	pop    %rbp
  8087fc:	c3                   	ret    

00000000008087fd <lodepng_chunk_type>:
void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
  8087fd:	b8 00 00 00 00       	mov    $0x0,%eax
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
  808802:	0f b6 54 06 04       	movzbl 0x4(%rsi,%rax,1),%edx
  808807:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  80880a:	48 83 c0 01          	add    $0x1,%rax
  80880e:	48 83 f8 04          	cmp    $0x4,%rax
  808812:	75 ee                	jne    808802 <lodepng_chunk_type+0x5>
  type[4] = 0; /*null termination char*/
  808814:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
}
  808818:	c3                   	ret    

0000000000808819 <lodepng_chunk_type_equals>:
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
  808819:	55                   	push   %rbp
  80881a:	48 89 e5             	mov    %rsp,%rbp
  80881d:	41 54                	push   %r12
  80881f:	53                   	push   %rbx
  808820:	49 89 fc             	mov    %rdi,%r12
  808823:	48 89 f3             	mov    %rsi,%rbx
  if(lodepng_strlen(type) != 4) return 0;
  808826:	48 89 f7             	mov    %rsi,%rdi
  808829:	48 b8 d3 28 80 00 00 	movabs $0x8028d3,%rax
  808830:	00 00 00 
  808833:	ff d0                	call   *%rax
  808835:	48 89 c2             	mov    %rax,%rdx
  808838:	b8 00 00 00 00       	mov    $0x0,%eax
  80883d:	48 83 fa 04          	cmp    $0x4,%rdx
  808841:	75 12                	jne    808855 <lodepng_chunk_type_equals+0x3c>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
  808843:	41 0f b6 4c 24 04    	movzbl 0x4(%r12),%ecx
  808849:	0f be 13             	movsbl (%rbx),%edx
  80884c:	b8 00 00 00 00       	mov    $0x0,%eax
  808851:	39 d1                	cmp    %edx,%ecx
  808853:	74 05                	je     80885a <lodepng_chunk_type_equals+0x41>
}
  808855:	5b                   	pop    %rbx
  808856:	41 5c                	pop    %r12
  808858:	5d                   	pop    %rbp
  808859:	c3                   	ret    
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
  80885a:	41 0f b6 4c 24 05    	movzbl 0x5(%r12),%ecx
  808860:	0f be 53 01          	movsbl 0x1(%rbx),%edx
  808864:	39 d1                	cmp    %edx,%ecx
  808866:	75 ed                	jne    808855 <lodepng_chunk_type_equals+0x3c>
  808868:	41 0f b6 4c 24 06    	movzbl 0x6(%r12),%ecx
  80886e:	0f be 53 02          	movsbl 0x2(%rbx),%edx
  808872:	39 d1                	cmp    %edx,%ecx
  808874:	75 df                	jne    808855 <lodepng_chunk_type_equals+0x3c>
  808876:	41 0f b6 54 24 07    	movzbl 0x7(%r12),%edx
  80887c:	0f be 43 03          	movsbl 0x3(%rbx),%eax
  808880:	39 c2                	cmp    %eax,%edx
  808882:	0f 94 c0             	sete   %al
  808885:	0f b6 c0             	movzbl %al,%eax
  808888:	eb cb                	jmp    808855 <lodepng_chunk_type_equals+0x3c>

000000000080888a <lodepng_chunk_ancillary>:
  return((chunk[4] & 32) != 0);
  80888a:	0f b6 47 04          	movzbl 0x4(%rdi),%eax
  80888e:	c0 e8 05             	shr    $0x5,%al
  808891:	83 e0 01             	and    $0x1,%eax
}
  808894:	c3                   	ret    

0000000000808895 <lodepng_chunk_private>:
  return((chunk[6] & 32) != 0);
  808895:	0f b6 47 06          	movzbl 0x6(%rdi),%eax
  808899:	c0 e8 05             	shr    $0x5,%al
  80889c:	83 e0 01             	and    $0x1,%eax
}
  80889f:	c3                   	ret    

00000000008088a0 <lodepng_chunk_safetocopy>:
  return((chunk[7] & 32) != 0);
  8088a0:	0f b6 47 07          	movzbl 0x7(%rdi),%eax
  8088a4:	c0 e8 05             	shr    $0x5,%al
  8088a7:	83 e0 01             	and    $0x1,%eax
}
  8088aa:	c3                   	ret    

00000000008088ab <lodepng_chunk_data>:
  return &chunk[8];
  8088ab:	48 8d 47 08          	lea    0x8(%rdi),%rax
}
  8088af:	c3                   	ret    

00000000008088b0 <lodepng_chunk_data_const>:
  return &chunk[8];
  8088b0:	48 8d 47 08          	lea    0x8(%rdi),%rax
}
  8088b4:	c3                   	ret    

00000000008088b5 <lodepng_chunk_check_crc>:
unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
  8088b5:	55                   	push   %rbp
  8088b6:	48 89 e5             	mov    %rsp,%rbp
  8088b9:	41 55                	push   %r13
  8088bb:	41 54                	push   %r12
  8088bd:	53                   	push   %rbx
  8088be:	48 83 ec 08          	sub    $0x8,%rsp
  8088c2:	48 89 fb             	mov    %rdi,%rbx
  return lodepng_read32bitInt(&chunk[0]);
  8088c5:	49 bd ed 28 80 00 00 	movabs $0x8028ed,%r13
  8088cc:	00 00 00 
  8088cf:	41 ff d5             	call   *%r13
  8088d2:	41 89 c4             	mov    %eax,%r12d
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
  8088d5:	8d 78 08             	lea    0x8(%rax),%edi
  8088d8:	48 01 df             	add    %rbx,%rdi
  8088db:	41 ff d5             	call   *%r13
  8088de:	41 89 c5             	mov    %eax,%r13d
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
  8088e1:	41 8d 74 24 04       	lea    0x4(%r12),%esi
  8088e6:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
  8088ea:	48 b8 b1 87 80 00 00 	movabs $0x8087b1,%rax
  8088f1:	00 00 00 
  8088f4:	ff d0                	call   *%rax
  if(CRC != checksum) return 1;
  8088f6:	41 39 c5             	cmp    %eax,%r13d
  8088f9:	0f 95 c0             	setne  %al
  8088fc:	0f b6 c0             	movzbl %al,%eax
}
  8088ff:	48 83 c4 08          	add    $0x8,%rsp
  808903:	5b                   	pop    %rbx
  808904:	41 5c                	pop    %r12
  808906:	41 5d                	pop    %r13
  808908:	5d                   	pop    %rbp
  808909:	c3                   	ret    

000000000080890a <lodepng_chunk_generate_crc>:
void lodepng_chunk_generate_crc(unsigned char* chunk) {
  80890a:	55                   	push   %rbp
  80890b:	48 89 e5             	mov    %rsp,%rbp
  80890e:	41 54                	push   %r12
  808910:	53                   	push   %rbx
  808911:	49 89 fc             	mov    %rdi,%r12
  return lodepng_read32bitInt(&chunk[0]);
  808914:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  80891b:	00 00 00 
  80891e:	ff d0                	call   *%rax
  808920:	89 c3                	mov    %eax,%ebx
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
  808922:	8d 70 04             	lea    0x4(%rax),%esi
  808925:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
  80892a:	48 b8 b1 87 80 00 00 	movabs $0x8087b1,%rax
  808931:	00 00 00 
  808934:	ff d0                	call   *%rax
  808936:	89 c6                	mov    %eax,%esi
  lodepng_set32bitInt(chunk + 8 + length, CRC);
  808938:	89 db                	mov    %ebx,%ebx
  80893a:	49 8d 7c 1c 08       	lea    0x8(%r12,%rbx,1),%rdi
  80893f:	48 b8 0c 29 80 00 00 	movabs $0x80290c,%rax
  808946:	00 00 00 
  808949:	ff d0                	call   *%rax
}
  80894b:	5b                   	pop    %rbx
  80894c:	41 5c                	pop    %r12
  80894e:	5d                   	pop    %rbp
  80894f:	c3                   	ret    

0000000000808950 <lodepng_chunk_next>:
unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
  808950:	55                   	push   %rbp
  808951:	48 89 e5             	mov    %rsp,%rbp
  808954:	41 54                	push   %r12
  808956:	53                   	push   %rbx
  808957:	49 89 f4             	mov    %rsi,%r12
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
  80895a:	48 39 f7             	cmp    %rsi,%rdi
  80895d:	73 37                	jae    808996 <lodepng_chunk_next+0x46>
  80895f:	48 89 fb             	mov    %rdi,%rbx
  808962:	48 89 f0             	mov    %rsi,%rax
  808965:	48 29 f8             	sub    %rdi,%rax
  808968:	48 83 f8 0b          	cmp    $0xb,%rax
  80896c:	7e 28                	jle    808996 <lodepng_chunk_next+0x46>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
  80896e:	80 3f 89             	cmpb   $0x89,(%rdi)
  808971:	75 06                	jne    808979 <lodepng_chunk_next+0x29>
  808973:	80 7f 01 50          	cmpb   $0x50,0x1(%rdi)
  808977:	74 25                	je     80899e <lodepng_chunk_next+0x4e>
  return lodepng_read32bitInt(&chunk[0]);
  808979:	48 89 df             	mov    %rbx,%rdi
  80897c:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  808983:	00 00 00 
  808986:	ff d0                	call   *%rax
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
  808988:	89 c0                	mov    %eax,%eax
    result = chunk + total_chunk_length;
  80898a:	48 8d 44 03 0c       	lea    0xc(%rbx,%rax,1),%rax
    return result;
  80898f:	48 39 c3             	cmp    %rax,%rbx
  808992:	4c 0f 46 e0          	cmovbe %rax,%r12
}
  808996:	4c 89 e0             	mov    %r12,%rax
  808999:	5b                   	pop    %rbx
  80899a:	41 5c                	pop    %r12
  80899c:	5d                   	pop    %rbp
  80899d:	c3                   	ret    
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
  80899e:	80 7f 02 4e          	cmpb   $0x4e,0x2(%rdi)
  8089a2:	75 d5                	jne    808979 <lodepng_chunk_next+0x29>
  8089a4:	80 7f 03 47          	cmpb   $0x47,0x3(%rdi)
  8089a8:	75 cf                	jne    808979 <lodepng_chunk_next+0x29>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
  8089aa:	80 7f 04 0d          	cmpb   $0xd,0x4(%rdi)
  8089ae:	75 c9                	jne    808979 <lodepng_chunk_next+0x29>
  8089b0:	80 7f 05 0a          	cmpb   $0xa,0x5(%rdi)
  8089b4:	75 c3                	jne    808979 <lodepng_chunk_next+0x29>
  8089b6:	80 7f 06 1a          	cmpb   $0x1a,0x6(%rdi)
  8089ba:	75 bd                	jne    808979 <lodepng_chunk_next+0x29>
  8089bc:	80 7f 07 0a          	cmpb   $0xa,0x7(%rdi)
  8089c0:	75 b7                	jne    808979 <lodepng_chunk_next+0x29>
    return chunk + 8;
  8089c2:	4c 8d 67 08          	lea    0x8(%rdi),%r12
  8089c6:	eb ce                	jmp    808996 <lodepng_chunk_next+0x46>

00000000008089c8 <lodepng_chunk_next_const>:
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
  8089c8:	55                   	push   %rbp
  8089c9:	48 89 e5             	mov    %rsp,%rbp
  8089cc:	41 54                	push   %r12
  8089ce:	53                   	push   %rbx
  8089cf:	49 89 f4             	mov    %rsi,%r12
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
  8089d2:	48 39 f7             	cmp    %rsi,%rdi
  8089d5:	73 37                	jae    808a0e <lodepng_chunk_next_const+0x46>
  8089d7:	48 89 fb             	mov    %rdi,%rbx
  8089da:	48 89 f0             	mov    %rsi,%rax
  8089dd:	48 29 f8             	sub    %rdi,%rax
  8089e0:	48 83 f8 0b          	cmp    $0xb,%rax
  8089e4:	7e 28                	jle    808a0e <lodepng_chunk_next_const+0x46>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
  8089e6:	80 3f 89             	cmpb   $0x89,(%rdi)
  8089e9:	75 06                	jne    8089f1 <lodepng_chunk_next_const+0x29>
  8089eb:	80 7f 01 50          	cmpb   $0x50,0x1(%rdi)
  8089ef:	74 25                	je     808a16 <lodepng_chunk_next_const+0x4e>
  return lodepng_read32bitInt(&chunk[0]);
  8089f1:	48 89 df             	mov    %rbx,%rdi
  8089f4:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  8089fb:	00 00 00 
  8089fe:	ff d0                	call   *%rax
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
  808a00:	89 c0                	mov    %eax,%eax
    result = chunk + total_chunk_length;
  808a02:	48 8d 44 03 0c       	lea    0xc(%rbx,%rax,1),%rax
    return result;
  808a07:	48 39 c3             	cmp    %rax,%rbx
  808a0a:	4c 0f 46 e0          	cmovbe %rax,%r12
}
  808a0e:	4c 89 e0             	mov    %r12,%rax
  808a11:	5b                   	pop    %rbx
  808a12:	41 5c                	pop    %r12
  808a14:	5d                   	pop    %rbp
  808a15:	c3                   	ret    
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
  808a16:	80 7f 02 4e          	cmpb   $0x4e,0x2(%rdi)
  808a1a:	75 d5                	jne    8089f1 <lodepng_chunk_next_const+0x29>
  808a1c:	80 7f 03 47          	cmpb   $0x47,0x3(%rdi)
  808a20:	75 cf                	jne    8089f1 <lodepng_chunk_next_const+0x29>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
  808a22:	80 7f 04 0d          	cmpb   $0xd,0x4(%rdi)
  808a26:	75 c9                	jne    8089f1 <lodepng_chunk_next_const+0x29>
  808a28:	80 7f 05 0a          	cmpb   $0xa,0x5(%rdi)
  808a2c:	75 c3                	jne    8089f1 <lodepng_chunk_next_const+0x29>
  808a2e:	80 7f 06 1a          	cmpb   $0x1a,0x6(%rdi)
  808a32:	75 bd                	jne    8089f1 <lodepng_chunk_next_const+0x29>
  808a34:	80 7f 07 0a          	cmpb   $0xa,0x7(%rdi)
  808a38:	75 b7                	jne    8089f1 <lodepng_chunk_next_const+0x29>
    return chunk + 8;
  808a3a:	4c 8d 67 08          	lea    0x8(%rdi),%r12
  808a3e:	eb ce                	jmp    808a0e <lodepng_chunk_next_const+0x46>

0000000000808a40 <lodepng_chunk_find>:
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808a40:	48 39 f7             	cmp    %rsi,%rdi
  808a43:	73 72                	jae    808ab7 <lodepng_chunk_find+0x77>
unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
  808a45:	55                   	push   %rbp
  808a46:	48 89 e5             	mov    %rsp,%rbp
  808a49:	41 57                	push   %r15
  808a4b:	41 56                	push   %r14
  808a4d:	41 55                	push   %r13
  808a4f:	41 54                	push   %r12
  808a51:	53                   	push   %rbx
  808a52:	48 83 ec 08          	sub    $0x8,%rsp
  808a56:	48 89 fb             	mov    %rdi,%rbx
  808a59:	49 89 f4             	mov    %rsi,%r12
  808a5c:	49 89 d5             	mov    %rdx,%r13
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808a5f:	48 89 f0             	mov    %rsi,%rax
  808a62:	48 29 f8             	sub    %rdi,%rax
  808a65:	48 83 f8 0b          	cmp    $0xb,%rax
  808a69:	7e 52                	jle    808abd <lodepng_chunk_find+0x7d>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
  808a6b:	49 be 19 88 80 00 00 	movabs $0x808819,%r14
  808a72:	00 00 00 
    chunk = lodepng_chunk_next(chunk, end);
  808a75:	49 bf 50 89 80 00 00 	movabs $0x808950,%r15
  808a7c:	00 00 00 
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
  808a7f:	4c 89 ee             	mov    %r13,%rsi
  808a82:	48 89 df             	mov    %rbx,%rdi
  808a85:	41 ff d6             	call   *%r14
  808a88:	84 c0                	test   %al,%al
  808a8a:	75 38                	jne    808ac4 <lodepng_chunk_find+0x84>
    chunk = lodepng_chunk_next(chunk, end);
  808a8c:	4c 89 e6             	mov    %r12,%rsi
  808a8f:	48 89 df             	mov    %rbx,%rdi
  808a92:	41 ff d7             	call   *%r15
  808a95:	48 89 c3             	mov    %rax,%rbx
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808a98:	49 39 c4             	cmp    %rax,%r12
  808a9b:	76 13                	jbe    808ab0 <lodepng_chunk_find+0x70>
  808a9d:	4c 89 e0             	mov    %r12,%rax
  808aa0:	48 29 d8             	sub    %rbx,%rax
  808aa3:	48 83 f8 0b          	cmp    $0xb,%rax
  808aa7:	7f d6                	jg     808a7f <lodepng_chunk_find+0x3f>
  808aa9:	b8 00 00 00 00       	mov    $0x0,%eax
  808aae:	eb 17                	jmp    808ac7 <lodepng_chunk_find+0x87>
  808ab0:	b8 00 00 00 00       	mov    $0x0,%eax
  808ab5:	eb 10                	jmp    808ac7 <lodepng_chunk_find+0x87>
  808ab7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808abc:	c3                   	ret    
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808abd:	b8 00 00 00 00       	mov    $0x0,%eax
  808ac2:	eb 03                	jmp    808ac7 <lodepng_chunk_find+0x87>
  808ac4:	48 89 d8             	mov    %rbx,%rax
}
  808ac7:	48 83 c4 08          	add    $0x8,%rsp
  808acb:	5b                   	pop    %rbx
  808acc:	41 5c                	pop    %r12
  808ace:	41 5d                	pop    %r13
  808ad0:	41 5e                	pop    %r14
  808ad2:	41 5f                	pop    %r15
  808ad4:	5d                   	pop    %rbp
  808ad5:	c3                   	ret    

0000000000808ad6 <lodepng_chunk_find_const>:
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808ad6:	48 39 f7             	cmp    %rsi,%rdi
  808ad9:	73 72                	jae    808b4d <lodepng_chunk_find_const+0x77>
const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
  808adb:	55                   	push   %rbp
  808adc:	48 89 e5             	mov    %rsp,%rbp
  808adf:	41 57                	push   %r15
  808ae1:	41 56                	push   %r14
  808ae3:	41 55                	push   %r13
  808ae5:	41 54                	push   %r12
  808ae7:	53                   	push   %rbx
  808ae8:	48 83 ec 08          	sub    $0x8,%rsp
  808aec:	48 89 fb             	mov    %rdi,%rbx
  808aef:	49 89 f4             	mov    %rsi,%r12
  808af2:	49 89 d5             	mov    %rdx,%r13
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808af5:	48 89 f0             	mov    %rsi,%rax
  808af8:	48 29 f8             	sub    %rdi,%rax
  808afb:	48 83 f8 0b          	cmp    $0xb,%rax
  808aff:	7e 52                	jle    808b53 <lodepng_chunk_find_const+0x7d>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
  808b01:	49 be 19 88 80 00 00 	movabs $0x808819,%r14
  808b08:	00 00 00 
    chunk = lodepng_chunk_next_const(chunk, end);
  808b0b:	49 bf c8 89 80 00 00 	movabs $0x8089c8,%r15
  808b12:	00 00 00 
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
  808b15:	4c 89 ee             	mov    %r13,%rsi
  808b18:	48 89 df             	mov    %rbx,%rdi
  808b1b:	41 ff d6             	call   *%r14
  808b1e:	84 c0                	test   %al,%al
  808b20:	75 38                	jne    808b5a <lodepng_chunk_find_const+0x84>
    chunk = lodepng_chunk_next_const(chunk, end);
  808b22:	4c 89 e6             	mov    %r12,%rsi
  808b25:	48 89 df             	mov    %rbx,%rdi
  808b28:	41 ff d7             	call   *%r15
  808b2b:	48 89 c3             	mov    %rax,%rbx
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808b2e:	49 39 c4             	cmp    %rax,%r12
  808b31:	76 13                	jbe    808b46 <lodepng_chunk_find_const+0x70>
  808b33:	4c 89 e0             	mov    %r12,%rax
  808b36:	48 29 d8             	sub    %rbx,%rax
  808b39:	48 83 f8 0b          	cmp    $0xb,%rax
  808b3d:	7f d6                	jg     808b15 <lodepng_chunk_find_const+0x3f>
  808b3f:	b8 00 00 00 00       	mov    $0x0,%eax
  808b44:	eb 17                	jmp    808b5d <lodepng_chunk_find_const+0x87>
  808b46:	b8 00 00 00 00       	mov    $0x0,%eax
  808b4b:	eb 10                	jmp    808b5d <lodepng_chunk_find_const+0x87>
  808b4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808b52:	c3                   	ret    
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
  808b53:	b8 00 00 00 00       	mov    $0x0,%eax
  808b58:	eb 03                	jmp    808b5d <lodepng_chunk_find_const+0x87>
  808b5a:	48 89 d8             	mov    %rbx,%rax
}
  808b5d:	48 83 c4 08          	add    $0x8,%rsp
  808b61:	5b                   	pop    %rbx
  808b62:	41 5c                	pop    %r12
  808b64:	41 5d                	pop    %r13
  808b66:	41 5e                	pop    %r14
  808b68:	41 5f                	pop    %r15
  808b6a:	5d                   	pop    %rbp
  808b6b:	c3                   	ret    

0000000000808b6c <lodepng_chunk_append>:
unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk) {
  808b6c:	55                   	push   %rbp
  808b6d:	48 89 e5             	mov    %rsp,%rbp
  808b70:	41 57                	push   %r15
  808b72:	41 56                	push   %r14
  808b74:	41 55                	push   %r13
  808b76:	41 54                	push   %r12
  808b78:	53                   	push   %rbx
  808b79:	48 83 ec 18          	sub    $0x18,%rsp
  808b7d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  808b81:	49 89 f6             	mov    %rsi,%r14
  808b84:	49 89 d5             	mov    %rdx,%r13
  return lodepng_read32bitInt(&chunk[0]);
  808b87:	48 89 d7             	mov    %rdx,%rdi
  808b8a:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  808b91:	00 00 00 
  808b94:	ff d0                	call   *%rax
  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
  808b96:	89 c3                	mov    %eax,%ebx
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
  808b98:	48 83 c3 0c          	add    $0xc,%rbx
  if(lodepng_addofl(*outlength, total_chunk_length, &new_length)) return 77;
  808b9c:	4d 8b 26             	mov    (%r14),%r12
  808b9f:	b8 4d 00 00 00       	mov    $0x4d,%eax
  808ba4:	4d 89 e7             	mov    %r12,%r15
  808ba7:	49 01 df             	add    %rbx,%r15
  808baa:	72 4e                	jb     808bfa <lodepng_chunk_append+0x8e>
  new_buffer = (unsigned char*)lodepng_reallocate(*out, *outlength, new_length);
  808bac:	4c 89 fa             	mov    %r15,%rdx
  808baf:	4c 89 e6             	mov    %r12,%rsi
  808bb2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808bb6:	48 8b 38             	mov    (%rax),%rdi
  808bb9:	48 b8 b5 45 80 00 00 	movabs $0x8045b5,%rax
  808bc0:	00 00 00 
  808bc3:	ff d0                	call   *%rax
  if(!new_buffer) return 83; /*alloc fail*/
  808bc5:	48 85 c0             	test   %rax,%rax
  808bc8:	74 3f                	je     808c09 <lodepng_chunk_append+0x9d>
  (*out) = new_buffer;
  808bca:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  808bce:	48 89 06             	mov    %rax,(%rsi)
  (*outlength) = new_length;
  808bd1:	4d 89 3e             	mov    %r15,(%r14)
  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
  808bd4:	ba 00 00 00 00       	mov    $0x0,%edx
  808bd9:	b8 00 00 00 00       	mov    $0x0,%eax
  808bde:	4c 03 26             	add    (%rsi),%r12
  808be1:	41 0f b6 4c 05 00    	movzbl 0x0(%r13,%rax,1),%ecx
  808be7:	41 88 0c 04          	mov    %cl,(%r12,%rax,1)
  808beb:	83 c2 01             	add    $0x1,%edx
  808bee:	89 d0                	mov    %edx,%eax
  808bf0:	48 39 d8             	cmp    %rbx,%rax
  808bf3:	75 ec                	jne    808be1 <lodepng_chunk_append+0x75>
  return 0;
  808bf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808bfa:	48 83 c4 18          	add    $0x18,%rsp
  808bfe:	5b                   	pop    %rbx
  808bff:	41 5c                	pop    %r12
  808c01:	41 5d                	pop    %r13
  808c03:	41 5e                	pop    %r14
  808c05:	41 5f                	pop    %r15
  808c07:	5d                   	pop    %rbp
  808c08:	c3                   	ret    
  if(!new_buffer) return 83; /*alloc fail*/
  808c09:	b8 53 00 00 00       	mov    $0x53,%eax
  808c0e:	eb ea                	jmp    808bfa <lodepng_chunk_append+0x8e>

0000000000808c10 <addUnknownChunks>:
  }
  return key;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  808c10:	55                   	push   %rbp
  808c11:	48 89 e5             	mov    %rsp,%rbp
  808c14:	41 57                	push   %r15
  808c16:	41 56                	push   %r14
  808c18:	41 55                	push   %r13
  808c1a:	41 54                	push   %r12
  808c1c:	53                   	push   %rbx
  808c1d:	48 83 ec 28          	sub    $0x28,%rsp
  808c21:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  808c25:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
  808c29:	48 85 d2             	test   %rdx,%rdx
  808c2c:	74 71                	je     808c9f <addUnknownChunks+0x8f>
  808c2e:	49 89 fd             	mov    %rdi,%r13
  808c31:	48 89 d0             	mov    %rdx,%rax
  unsigned char* inchunk = data;
  808c34:	48 89 f3             	mov    %rsi,%rbx
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
  808c37:	48 8d 57 08          	lea    0x8(%rdi),%rdx
  808c3b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  808c3f:	49 be 6c 8b 80 00 00 	movabs $0x808b6c,%r14
  808c46:	00 00 00 
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  808c49:	48 01 c6             	add    %rax,%rsi
  808c4c:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  808c50:	49 bf 50 89 80 00 00 	movabs $0x808950,%r15
  808c57:	00 00 00 
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
  808c5a:	48 89 da             	mov    %rbx,%rdx
  808c5d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  808c61:	4c 89 ef             	mov    %r13,%rdi
  808c64:	41 ff d6             	call   *%r14
  808c67:	41 89 c4             	mov    %eax,%r12d
  808c6a:	85 c0                	test   %eax,%eax
  808c6c:	75 1f                	jne    808c8d <addUnknownChunks+0x7d>
    out->allocsize = out->size; /*fix the allocsize again*/
  808c6e:	49 8b 45 08          	mov    0x8(%r13),%rax
  808c72:	49 89 45 10          	mov    %rax,0x10(%r13)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  808c76:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  808c7a:	48 89 df             	mov    %rbx,%rdi
  808c7d:	41 ff d7             	call   *%r15
  808c80:	48 89 c3             	mov    %rax,%rbx
  while((size_t)(inchunk - data) < datasize) {
  808c83:	48 2b 45 c0          	sub    -0x40(%rbp),%rax
  808c87:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  808c8b:	72 cd                	jb     808c5a <addUnknownChunks+0x4a>
  }
  return 0;
}
  808c8d:	44 89 e0             	mov    %r12d,%eax
  808c90:	48 83 c4 28          	add    $0x28,%rsp
  808c94:	5b                   	pop    %rbx
  808c95:	41 5c                	pop    %r12
  808c97:	41 5d                	pop    %r13
  808c99:	41 5e                	pop    %r14
  808c9b:	41 5f                	pop    %r15
  808c9d:	5d                   	pop    %rbp
  808c9e:	c3                   	ret    
  return 0;
  808c9f:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  808ca5:	eb e6                	jmp    808c8d <addUnknownChunks+0x7d>

0000000000808ca7 <lodepng_chunk_create>:
                              const char* type, const unsigned char* data) {
  808ca7:	55                   	push   %rbp
  808ca8:	48 89 e5             	mov    %rsp,%rbp
  808cab:	41 57                	push   %r15
  808cad:	41 56                	push   %r14
  808caf:	41 55                	push   %r13
  808cb1:	41 54                	push   %r12
  808cb3:	53                   	push   %rbx
  808cb4:	48 83 ec 18          	sub    $0x18,%rsp
  808cb8:	49 89 f4             	mov    %rsi,%r12
  808cbb:	89 d3                	mov    %edx,%ebx
  808cbd:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  size_t new_length = *outlength;
  808cc1:	48 8b 36             	mov    (%rsi),%rsi
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
  808cc4:	89 d0                	mov    %edx,%eax
  808cc6:	48 89 c2             	mov    %rax,%rdx
  808cc9:	b8 4d 00 00 00       	mov    $0x4d,%eax
  808cce:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  808cd2:	48 01 f2             	add    %rsi,%rdx
  808cd5:	0f 82 bc 00 00 00    	jb     808d97 <lodepng_chunk_create+0xf0>
  808cdb:	49 89 fe             	mov    %rdi,%r14
  808cde:	49 89 cd             	mov    %rcx,%r13
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
  808ce1:	4c 8d 7a 0c          	lea    0xc(%rdx),%r15
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
  808ce5:	48 83 fa f4          	cmp    $0xfffffffffffffff4,%rdx
  808ce9:	0f 83 a8 00 00 00    	jae    808d97 <lodepng_chunk_create+0xf0>
  new_buffer = (unsigned char*)lodepng_reallocate(*out, *outlength, new_length);
  808cef:	4c 89 fa             	mov    %r15,%rdx
  808cf2:	48 8b 3f             	mov    (%rdi),%rdi
  808cf5:	48 b8 b5 45 80 00 00 	movabs $0x8045b5,%rax
  808cfc:	00 00 00 
  808cff:	ff d0                	call   *%rax
  if(!new_buffer) return 83; /*alloc fail*/
  808d01:	48 85 c0             	test   %rax,%rax
  808d04:	0f 84 9c 00 00 00    	je     808da6 <lodepng_chunk_create+0xff>
  (*out) = new_buffer;
  808d0a:	49 89 06             	mov    %rax,(%r14)
  (*outlength) = new_length;
  808d0d:	4d 89 3c 24          	mov    %r15,(%r12)
  chunk = &(*out)[(*outlength) - length - 12];
  808d11:	4c 2b 7d c8          	sub    -0x38(%rbp),%r15
  808d15:	49 8b 06             	mov    (%r14),%rax
  808d18:	4e 8d 64 38 f4       	lea    -0xc(%rax,%r15,1),%r12
  lodepng_set32bitInt(chunk, (unsigned)length);
  808d1d:	89 de                	mov    %ebx,%esi
  808d1f:	4c 89 e7             	mov    %r12,%rdi
  808d22:	48 b8 0c 29 80 00 00 	movabs $0x80290c,%rax
  808d29:	00 00 00 
  808d2c:	ff d0                	call   *%rax
  chunk[4] = (unsigned char)type[0];
  808d2e:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
  808d33:	41 88 44 24 04       	mov    %al,0x4(%r12)
  chunk[5] = (unsigned char)type[1];
  808d38:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
  808d3d:	41 88 44 24 05       	mov    %al,0x5(%r12)
  chunk[6] = (unsigned char)type[2];
  808d42:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
  808d47:	41 88 44 24 06       	mov    %al,0x6(%r12)
  chunk[7] = (unsigned char)type[3];
  808d4c:	41 0f b6 45 03       	movzbl 0x3(%r13),%eax
  808d51:	41 88 44 24 07       	mov    %al,0x7(%r12)
  for(i = 0; i != length; ++i) chunk[8 + i] = data[i];
  808d56:	85 db                	test   %ebx,%ebx
  808d58:	74 29                	je     808d83 <lodepng_chunk_create+0xdc>
  808d5a:	8d 43 ff             	lea    -0x1(%rbx),%eax
  808d5d:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  808d61:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
  808d66:	48 89 d8             	mov    %rbx,%rax
  808d69:	be 08 00 00 00       	mov    $0x8,%esi
  808d6e:	29 de                	sub    %ebx,%esi
  808d70:	0f b6 08             	movzbl (%rax),%ecx
  808d73:	8d 14 06             	lea    (%rsi,%rax,1),%edx
  808d76:	41 88 0c 14          	mov    %cl,(%r12,%rdx,1)
  808d7a:	48 83 c0 01          	add    $0x1,%rax
  808d7e:	48 39 f8             	cmp    %rdi,%rax
  808d81:	75 ed                	jne    808d70 <lodepng_chunk_create+0xc9>
  lodepng_chunk_generate_crc(chunk);
  808d83:	4c 89 e7             	mov    %r12,%rdi
  808d86:	48 b8 0a 89 80 00 00 	movabs $0x80890a,%rax
  808d8d:	00 00 00 
  808d90:	ff d0                	call   *%rax
  return 0;
  808d92:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808d97:	48 83 c4 18          	add    $0x18,%rsp
  808d9b:	5b                   	pop    %rbx
  808d9c:	41 5c                	pop    %r12
  808d9e:	41 5d                	pop    %r13
  808da0:	41 5e                	pop    %r14
  808da2:	41 5f                	pop    %r15
  808da4:	5d                   	pop    %rbp
  808da5:	c3                   	ret    
  if(!new_buffer) return 83; /*alloc fail*/
  808da6:	b8 53 00 00 00       	mov    $0x53,%eax
  808dab:	eb ea                	jmp    808d97 <lodepng_chunk_create+0xf0>

0000000000808dad <addChunk>:
static unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length) {
  808dad:	55                   	push   %rbp
  808dae:	48 89 e5             	mov    %rsp,%rbp
  808db1:	53                   	push   %rbx
  808db2:	48 83 ec 08          	sub    $0x8,%rsp
  808db6:	48 89 fb             	mov    %rdi,%rbx
  808db9:	49 89 d0             	mov    %rdx,%r8
  808dbc:	48 89 ca             	mov    %rcx,%rdx
  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));
  808dbf:	48 8d 47 08          	lea    0x8(%rdi),%rax
  808dc3:	48 89 f1             	mov    %rsi,%rcx
  808dc6:	48 89 c6             	mov    %rax,%rsi
  808dc9:	48 b8 a7 8c 80 00 00 	movabs $0x808ca7,%rax
  808dd0:	00 00 00 
  808dd3:	ff d0                	call   *%rax
  808dd5:	85 c0                	test   %eax,%eax
  808dd7:	75 08                	jne    808de1 <addChunk+0x34>
  out->allocsize = out->size; /*fix the allocsize again*/
  808dd9:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  808ddd:	48 89 53 10          	mov    %rdx,0x10(%rbx)
}
  808de1:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  808de5:	c9                   	leave  
  808de6:	c3                   	ret    

0000000000808de7 <addChunk_PLTE>:
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
  808de7:	55                   	push   %rbp
  808de8:	48 89 e5             	mov    %rsp,%rbp
  808deb:	41 56                	push   %r14
  808ded:	41 55                	push   %r13
  808def:	41 54                	push   %r12
  808df1:	53                   	push   %rbx
  808df2:	48 83 ec 20          	sub    $0x20,%rsp
  808df6:	49 89 fe             	mov    %rdi,%r14
  p->data = NULL;
  808df9:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  808e00:	00 
  p->size = p->allocsize = 0;
  808e01:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  808e08:	00 
  808e09:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  808e10:	00 
  for(i = 0; i != info->palettesize * 4; ++i) {
  808e11:	48 8b 46 10          	mov    0x10(%rsi),%rax
  808e15:	48 c1 e0 02          	shl    $0x2,%rax
  808e19:	74 44                	je     808e5f <addChunk_PLTE+0x78>
  808e1b:	49 89 f4             	mov    %rsi,%r12
  808e1e:	bb 00 00 00 00       	mov    $0x0,%ebx
    if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);
  808e23:	49 bd 78 46 80 00 00 	movabs $0x804678,%r13
  808e2a:	00 00 00 
  808e2d:	eb 12                	jmp    808e41 <addChunk_PLTE+0x5a>
  for(i = 0; i != info->palettesize * 4; ++i) {
  808e2f:	48 83 c3 01          	add    $0x1,%rbx
  808e33:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  808e38:	48 c1 e0 02          	shl    $0x2,%rax
  808e3c:	48 39 d8             	cmp    %rbx,%rax
  808e3f:	74 1e                	je     808e5f <addChunk_PLTE+0x78>
    if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);
  808e41:	48 89 d8             	mov    %rbx,%rax
  808e44:	83 e0 03             	and    $0x3,%eax
  808e47:	48 83 f8 03          	cmp    $0x3,%rax
  808e4b:	74 e2                	je     808e2f <addChunk_PLTE+0x48>
  808e4d:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  808e52:	0f b6 34 18          	movzbl (%rax,%rbx,1),%esi
  808e56:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  808e5a:	41 ff d5             	call   *%r13
  808e5d:	eb d0                	jmp    808e2f <addChunk_PLTE+0x48>
  error = addChunk(out, "PLTE", PLTE.data, PLTE.size);
  808e5f:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  808e63:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  808e67:	48 be 94 26 81 00 00 	movabs $0x812694,%rsi
  808e6e:	00 00 00 
  808e71:	4c 89 f7             	mov    %r14,%rdi
  808e74:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  808e7b:	00 00 00 
  808e7e:	ff d0                	call   *%rax
  808e80:	89 c3                	mov    %eax,%ebx
  ucvector_cleanup(&PLTE);
  808e82:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  808e86:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  808e8d:	00 00 00 
  808e90:	ff d0                	call   *%rax
}
  808e92:	89 d8                	mov    %ebx,%eax
  808e94:	48 83 c4 20          	add    $0x20,%rsp
  808e98:	5b                   	pop    %rbx
  808e99:	41 5c                	pop    %r12
  808e9b:	41 5d                	pop    %r13
  808e9d:	41 5e                	pop    %r14
  808e9f:	5d                   	pop    %rbp
  808ea0:	c3                   	ret    

0000000000808ea1 <addChunk_tRNS>:
static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
  808ea1:	55                   	push   %rbp
  808ea2:	48 89 e5             	mov    %rsp,%rbp
  808ea5:	41 57                	push   %r15
  808ea7:	41 56                	push   %r14
  808ea9:	41 55                	push   %r13
  808eab:	41 54                	push   %r12
  808ead:	53                   	push   %rbx
  808eae:	48 83 ec 28          	sub    $0x28,%rsp
  808eb2:	49 89 fe             	mov    %rdi,%r14
  808eb5:	49 89 f4             	mov    %rsi,%r12
  p->data = NULL;
  808eb8:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  808ebf:	00 
  p->size = p->allocsize = 0;
  808ec0:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  808ec7:	00 
  808ec8:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  808ecf:	00 
  if(info->colortype == LCT_PALETTE) {
  808ed0:	8b 06                	mov    (%rsi),%eax
  808ed2:	83 f8 03             	cmp    $0x3,%eax
  808ed5:	74 30                	je     808f07 <addChunk_tRNS+0x66>
  } else if(info->colortype == LCT_GREY) {
  808ed7:	85 c0                	test   %eax,%eax
  808ed9:	0f 85 bc 00 00 00    	jne    808f9b <addChunk_tRNS+0xfa>
    if(info->key_defined) {
  808edf:	83 7e 18 00          	cmpl   $0x0,0x18(%rsi)
  808ee3:	74 72                	je     808f57 <addChunk_tRNS+0xb6>
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r >> 8));
  808ee5:	0f b6 76 1d          	movzbl 0x1d(%rsi),%esi
  808ee9:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808eed:	48 bb 78 46 80 00 00 	movabs $0x804678,%rbx
  808ef4:	00 00 00 
  808ef7:	ff d3                	call   *%rbx
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r & 255));
  808ef9:	41 0f b6 74 24 1c    	movzbl 0x1c(%r12),%esi
  808eff:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808f03:	ff d3                	call   *%rbx
  808f05:	eb 50                	jmp    808f57 <addChunk_tRNS+0xb6>
    size_t amount = info->palettesize;
  808f07:	48 8b 46 10          	mov    0x10(%rsi),%rax
    for(i = info->palettesize; i != 0; --i) {
  808f0b:	48 85 c0             	test   %rax,%rax
  808f0e:	74 47                	je     808f57 <addChunk_tRNS+0xb6>
      if(info->palette[4 * (i - 1) + 3] == 255) --amount;
  808f10:	48 8b 56 08          	mov    0x8(%rsi),%rdx
  808f14:	49 89 c5             	mov    %rax,%r13
  808f17:	48 83 e8 01          	sub    $0x1,%rax
  808f1b:	80 7c 82 03 ff       	cmpb   $0xff,0x3(%rdx,%rax,4)
  808f20:	75 07                	jne    808f29 <addChunk_tRNS+0x88>
    for(i = info->palettesize; i != 0; --i) {
  808f22:	48 85 c0             	test   %rax,%rax
  808f25:	75 ed                	jne    808f14 <addChunk_tRNS+0x73>
  808f27:	eb 2e                	jmp    808f57 <addChunk_tRNS+0xb6>
    for(i = 0; i != amount; ++i) ucvector_push_back(&tRNS, info->palette[4 * i + 3]);
  808f29:	4d 85 ed             	test   %r13,%r13
  808f2c:	74 29                	je     808f57 <addChunk_tRNS+0xb6>
  808f2e:	bb 00 00 00 00       	mov    $0x0,%ebx
  808f33:	49 bf 78 46 80 00 00 	movabs $0x804678,%r15
  808f3a:	00 00 00 
  808f3d:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  808f42:	0f b6 74 98 03       	movzbl 0x3(%rax,%rbx,4),%esi
  808f47:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808f4b:	41 ff d7             	call   *%r15
  808f4e:	48 83 c3 01          	add    $0x1,%rbx
  808f52:	4c 39 eb             	cmp    %r13,%rbx
  808f55:	75 e6                	jne    808f3d <addChunk_tRNS+0x9c>
  error = addChunk(out, "tRNS", tRNS.data, tRNS.size);
  808f57:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  808f5b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  808f5f:	48 be 99 26 81 00 00 	movabs $0x812699,%rsi
  808f66:	00 00 00 
  808f69:	4c 89 f7             	mov    %r14,%rdi
  808f6c:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  808f73:	00 00 00 
  808f76:	ff d0                	call   *%rax
  808f78:	89 c3                	mov    %eax,%ebx
  ucvector_cleanup(&tRNS);
  808f7a:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808f7e:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  808f85:	00 00 00 
  808f88:	ff d0                	call   *%rax
}
  808f8a:	89 d8                	mov    %ebx,%eax
  808f8c:	48 83 c4 28          	add    $0x28,%rsp
  808f90:	5b                   	pop    %rbx
  808f91:	41 5c                	pop    %r12
  808f93:	41 5d                	pop    %r13
  808f95:	41 5e                	pop    %r14
  808f97:	41 5f                	pop    %r15
  808f99:	5d                   	pop    %rbp
  808f9a:	c3                   	ret    
  } else if(info->colortype == LCT_RGB) {
  808f9b:	83 f8 02             	cmp    $0x2,%eax
  808f9e:	75 b7                	jne    808f57 <addChunk_tRNS+0xb6>
    if(info->key_defined) {
  808fa0:	83 7e 18 00          	cmpl   $0x0,0x18(%rsi)
  808fa4:	74 b1                	je     808f57 <addChunk_tRNS+0xb6>
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r >> 8));
  808fa6:	0f b6 76 1d          	movzbl 0x1d(%rsi),%esi
  808faa:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808fae:	48 bb 78 46 80 00 00 	movabs $0x804678,%rbx
  808fb5:	00 00 00 
  808fb8:	ff d3                	call   *%rbx
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r & 255));
  808fba:	41 0f b6 74 24 1c    	movzbl 0x1c(%r12),%esi
  808fc0:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808fc4:	ff d3                	call   *%rbx
      ucvector_push_back(&tRNS, (unsigned char)(info->key_g >> 8));
  808fc6:	41 0f b6 74 24 21    	movzbl 0x21(%r12),%esi
  808fcc:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808fd0:	ff d3                	call   *%rbx
      ucvector_push_back(&tRNS, (unsigned char)(info->key_g & 255));
  808fd2:	41 0f b6 74 24 20    	movzbl 0x20(%r12),%esi
  808fd8:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808fdc:	ff d3                	call   *%rbx
      ucvector_push_back(&tRNS, (unsigned char)(info->key_b >> 8));
  808fde:	41 0f b6 74 24 25    	movzbl 0x25(%r12),%esi
  808fe4:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808fe8:	ff d3                	call   *%rbx
      ucvector_push_back(&tRNS, (unsigned char)(info->key_b & 255));
  808fea:	41 0f b6 74 24 24    	movzbl 0x24(%r12),%esi
  808ff0:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  808ff4:	ff d3                	call   *%rbx
  808ff6:	e9 5c ff ff ff       	jmp    808f57 <addChunk_tRNS+0xb6>

0000000000808ffb <addChunk_tEXt>:
static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
  808ffb:	55                   	push   %rbp
  808ffc:	48 89 e5             	mov    %rsp,%rbp
  808fff:	41 57                	push   %r15
  809001:	41 56                	push   %r14
  809003:	41 55                	push   %r13
  809005:	41 54                	push   %r12
  809007:	53                   	push   %rbx
  809008:	48 83 ec 28          	sub    $0x28,%rsp
  80900c:	49 89 f5             	mov    %rsi,%r13
  p->data = NULL;
  80900f:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  809016:	00 
  p->size = p->allocsize = 0;
  809017:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80901e:	00 
  80901f:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  809026:	00 
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)keyword[i]);
  809027:	0f b6 36             	movzbl (%rsi),%esi
  80902a:	40 84 f6             	test   %sil,%sil
  80902d:	0f 84 c7 00 00 00    	je     8090fa <addChunk_tEXt+0xff>
  809033:	49 89 ff             	mov    %rdi,%r15
  809036:	49 89 d4             	mov    %rdx,%r12
  809039:	bb 00 00 00 00       	mov    $0x0,%ebx
  80903e:	49 be 78 46 80 00 00 	movabs $0x804678,%r14
  809045:	00 00 00 
  809048:	40 0f b6 f6          	movzbl %sil,%esi
  80904c:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  809050:	41 ff d6             	call   *%r14
  809053:	48 89 d8             	mov    %rbx,%rax
  809056:	48 83 c3 01          	add    $0x1,%rbx
  80905a:	41 0f b6 74 1d 00    	movzbl 0x0(%r13,%rbx,1),%esi
  809060:	40 84 f6             	test   %sil,%sil
  809063:	75 e3                	jne    809048 <addChunk_tEXt+0x4d>
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  809065:	bb 59 00 00 00       	mov    $0x59,%ebx
  80906a:	48 83 f8 4e          	cmp    $0x4e,%rax
  80906e:	77 79                	ja     8090e9 <addChunk_tEXt+0xee>
  ucvector_push_back(&text, 0); /*0 termination char*/
  809070:	be 00 00 00 00       	mov    $0x0,%esi
  809075:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  809079:	48 b8 78 46 80 00 00 	movabs $0x804678,%rax
  809080:	00 00 00 
  809083:	ff d0                	call   *%rax
  for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)textstring[i]);
  809085:	41 0f b6 34 24       	movzbl (%r12),%esi
  80908a:	40 84 f6             	test   %sil,%sil
  80908d:	74 27                	je     8090b6 <addChunk_tEXt+0xbb>
  80908f:	49 83 c4 01          	add    $0x1,%r12
  809093:	48 bb 78 46 80 00 00 	movabs $0x804678,%rbx
  80909a:	00 00 00 
  80909d:	40 0f b6 f6          	movzbl %sil,%esi
  8090a1:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  8090a5:	ff d3                	call   *%rbx
  8090a7:	49 83 c4 01          	add    $0x1,%r12
  8090ab:	41 0f b6 74 24 ff    	movzbl -0x1(%r12),%esi
  8090b1:	40 84 f6             	test   %sil,%sil
  8090b4:	75 e7                	jne    80909d <addChunk_tEXt+0xa2>
  error = addChunk(out, "tEXt", text.data, text.size);
  8090b6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8090ba:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8090be:	48 be 9e 26 81 00 00 	movabs $0x81269e,%rsi
  8090c5:	00 00 00 
  8090c8:	4c 89 ff             	mov    %r15,%rdi
  8090cb:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  8090d2:	00 00 00 
  8090d5:	ff d0                	call   *%rax
  8090d7:	89 c3                	mov    %eax,%ebx
  ucvector_cleanup(&text);
  8090d9:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  8090dd:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  8090e4:	00 00 00 
  8090e7:	ff d0                	call   *%rax
}
  8090e9:	89 d8                	mov    %ebx,%eax
  8090eb:	48 83 c4 28          	add    $0x28,%rsp
  8090ef:	5b                   	pop    %rbx
  8090f0:	41 5c                	pop    %r12
  8090f2:	41 5d                	pop    %r13
  8090f4:	41 5e                	pop    %r14
  8090f6:	41 5f                	pop    %r15
  8090f8:	5d                   	pop    %rbp
  8090f9:	c3                   	ret    
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  8090fa:	bb 59 00 00 00       	mov    $0x59,%ebx
  8090ff:	eb e8                	jmp    8090e9 <addChunk_tEXt+0xee>

0000000000809101 <lodepng_color_mode_init>:
  info->key_defined = 0;
  809101:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
  info->key_r = info->key_g = info->key_b = 0;
  809108:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%rdi)
  80910f:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%rdi)
  809116:	c7 47 1c 00 00 00 00 	movl   $0x0,0x1c(%rdi)
  info->colortype = LCT_RGBA;
  80911d:	c7 07 06 00 00 00    	movl   $0x6,(%rdi)
  info->bitdepth = 8;
  809123:	c7 47 04 08 00 00 00 	movl   $0x8,0x4(%rdi)
  info->palette = 0;
  80912a:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  809131:	00 
  info->palettesize = 0;
  809132:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  809139:	00 
}
  80913a:	c3                   	ret    

000000000080913b <lodepng_color_mode_make>:
LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
  80913b:	55                   	push   %rbp
  80913c:	48 89 e5             	mov    %rsp,%rbp
  80913f:	41 55                	push   %r13
  809141:	41 54                	push   %r12
  809143:	53                   	push   %rbx
  809144:	48 83 ec 38          	sub    $0x38,%rsp
  809148:	48 89 fb             	mov    %rdi,%rbx
  80914b:	41 89 f5             	mov    %esi,%r13d
  80914e:	41 89 d4             	mov    %edx,%r12d
  lodepng_color_mode_init(&result);
  809151:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  809155:	48 b8 01 91 80 00 00 	movabs $0x809101,%rax
  80915c:	00 00 00 
  80915f:	ff d0                	call   *%rax
  result.colortype = colortype;
  809161:	44 89 6d b8          	mov    %r13d,-0x48(%rbp)
  result.bitdepth = bitdepth;
  809165:	44 89 65 bc          	mov    %r12d,-0x44(%rbp)
  return result;
  809169:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80916d:	48 89 03             	mov    %rax,(%rbx)
  809170:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  809174:	48 89 43 08          	mov    %rax,0x8(%rbx)
  809178:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80917c:	48 89 43 10          	mov    %rax,0x10(%rbx)
  809180:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  809184:	48 89 43 18          	mov    %rax,0x18(%rbx)
  809188:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80918c:	48 89 43 20          	mov    %rax,0x20(%rbx)
}
  809190:	48 89 d8             	mov    %rbx,%rax
  809193:	48 83 c4 38          	add    $0x38,%rsp
  809197:	5b                   	pop    %rbx
  809198:	41 5c                	pop    %r12
  80919a:	41 5d                	pop    %r13
  80919c:	5d                   	pop    %rbp
  80919d:	c3                   	ret    

000000000080919e <lodepng_palette_clear>:
void lodepng_palette_clear(LodePNGColorMode* info) {
  80919e:	55                   	push   %rbp
  80919f:	48 89 e5             	mov    %rsp,%rbp
  8091a2:	53                   	push   %rbx
  8091a3:	48 83 ec 08          	sub    $0x8,%rsp
  8091a7:	48 89 fb             	mov    %rdi,%rbx
  if(info->palette) lodepng_free(info->palette);
  8091aa:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  8091ae:	48 85 ff             	test   %rdi,%rdi
  8091b1:	74 0c                	je     8091bf <lodepng_palette_clear+0x21>
    jos_free(ptr);
  8091b3:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8091ba:	00 00 00 
  8091bd:	ff d0                	call   *%rax
  info->palette = 0;
  8091bf:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  8091c6:	00 
  info->palettesize = 0;
  8091c7:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  8091ce:	00 
}
  8091cf:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8091d3:	c9                   	leave  
  8091d4:	c3                   	ret    

00000000008091d5 <lodepng_color_mode_cleanup>:
void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
  8091d5:	55                   	push   %rbp
  8091d6:	48 89 e5             	mov    %rsp,%rbp
  lodepng_palette_clear(info);
  8091d9:	48 b8 9e 91 80 00 00 	movabs $0x80919e,%rax
  8091e0:	00 00 00 
  8091e3:	ff d0                	call   *%rax
}
  8091e5:	5d                   	pop    %rbp
  8091e6:	c3                   	ret    

00000000008091e7 <lodepng_color_mode_copy>:
unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
  8091e7:	55                   	push   %rbp
  8091e8:	48 89 e5             	mov    %rsp,%rbp
  8091eb:	41 54                	push   %r12
  8091ed:	53                   	push   %rbx
  8091ee:	49 89 fc             	mov    %rdi,%r12
  8091f1:	48 89 f3             	mov    %rsi,%rbx
  lodepng_palette_clear(info);
  8091f4:	48 b8 9e 91 80 00 00 	movabs $0x80919e,%rax
  8091fb:	00 00 00 
  8091fe:	ff d0                	call   *%rax
  memcpy(dst, src, size);
  809200:	ba 28 00 00 00       	mov    $0x28,%edx
  809205:	48 89 de             	mov    %rbx,%rsi
  809208:	4c 89 e7             	mov    %r12,%rdi
  80920b:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  809212:	00 00 00 
  809215:	ff d0                	call   *%rax
  return 0;
  809217:	b8 00 00 00 00       	mov    $0x0,%eax
  if(source->palette) {
  80921c:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  809221:	74 3f                	je     809262 <lodepng_color_mode_copy+0x7b>
  return jos_malloc(size);
  809223:	bf 00 04 00 00       	mov    $0x400,%edi
  809228:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80922f:	00 00 00 
  809232:	ff d0                	call   *%rax
  809234:	48 89 c7             	mov    %rax,%rdi
    dest->palette = (unsigned char*)lodepng_malloc(1024);
  809237:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
  80923c:	48 85 c0             	test   %rax,%rax
  80923f:	74 26                	je     809267 <lodepng_color_mode_copy+0x80>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
  809241:	48 8b 43 10          	mov    0x10(%rbx),%rax
  809245:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  80924c:	00 
  memcpy(dst, src, size);
  80924d:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  809251:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  809258:	00 00 00 
  80925b:	ff d0                	call   *%rax
  return 0;
  80925d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  809262:	5b                   	pop    %rbx
  809263:	41 5c                	pop    %r12
  809265:	5d                   	pop    %rbp
  809266:	c3                   	ret    
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
  809267:	b8 53 00 00 00       	mov    $0x53,%eax
  80926c:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  809271:	74 ce                	je     809241 <lodepng_color_mode_copy+0x5a>
  809273:	eb ed                	jmp    809262 <lodepng_color_mode_copy+0x7b>

0000000000809275 <lodepng_palette_add>:
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  809275:	55                   	push   %rbp
  809276:	48 89 e5             	mov    %rsp,%rbp
  809279:	41 57                	push   %r15
  80927b:	41 56                	push   %r14
  80927d:	41 55                	push   %r13
  80927f:	41 54                	push   %r12
  809281:	53                   	push   %rbx
  809282:	48 83 ec 08          	sub    $0x8,%rsp
  809286:	48 89 fb             	mov    %rdi,%rbx
  809289:	41 89 f7             	mov    %esi,%r15d
  80928c:	41 89 d6             	mov    %edx,%r14d
  80928f:	41 89 cd             	mov    %ecx,%r13d
  809292:	45 89 c4             	mov    %r8d,%r12d
  if(!info->palette) /*allocate palette if empty*/ {
  809295:	48 83 7f 08 00       	cmpq   $0x0,0x8(%rdi)
  80929a:	74 5a                	je     8092f6 <lodepng_palette_add+0x81>
  if(info->palettesize >= 256) {
  80929c:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    return 108; /*too many palette values*/
  8092a0:	b8 6c 00 00 00       	mov    $0x6c,%eax
  if(info->palettesize >= 256) {
  8092a5:	48 81 fa ff 00 00 00 	cmp    $0xff,%rdx
  8092ac:	77 39                	ja     8092e7 <lodepng_palette_add+0x72>
  info->palette[4 * info->palettesize + 0] = r;
  8092ae:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8092b2:	44 88 3c 90          	mov    %r15b,(%rax,%rdx,4)
  info->palette[4 * info->palettesize + 1] = g;
  8092b6:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  8092ba:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8092be:	44 88 74 90 01       	mov    %r14b,0x1(%rax,%rdx,4)
  info->palette[4 * info->palettesize + 2] = b;
  8092c3:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  8092c7:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8092cb:	44 88 6c 90 02       	mov    %r13b,0x2(%rax,%rdx,4)
  info->palette[4 * info->palettesize + 3] = a;
  8092d0:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  8092d4:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8092d8:	44 88 64 90 03       	mov    %r12b,0x3(%rax,%rdx,4)
  ++info->palettesize;
  8092dd:	48 83 43 10 01       	addq   $0x1,0x10(%rbx)
  return 0;
  8092e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8092e7:	48 83 c4 08          	add    $0x8,%rsp
  8092eb:	5b                   	pop    %rbx
  8092ec:	41 5c                	pop    %r12
  8092ee:	41 5d                	pop    %r13
  8092f0:	41 5e                	pop    %r14
  8092f2:	41 5f                	pop    %r15
  8092f4:	5d                   	pop    %rbp
  8092f5:	c3                   	ret    
    lodepng_color_mode_alloc_palette(info);
  8092f6:	48 b8 04 5a 80 00 00 	movabs $0x805a04,%rax
  8092fd:	00 00 00 
  809300:	ff d0                	call   *%rax
    if(!info->palette) return 83; /*alloc fail*/
  809302:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  809307:	75 93                	jne    80929c <lodepng_palette_add+0x27>
  809309:	b8 53 00 00 00       	mov    $0x53,%eax
  80930e:	eb d7                	jmp    8092e7 <lodepng_palette_add+0x72>

0000000000809310 <lodepng_get_bpp>:
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
  809310:	55                   	push   %rbp
  809311:	48 89 e5             	mov    %rsp,%rbp
  809314:	53                   	push   %rbx
  809315:	48 83 ec 08          	sub    $0x8,%rsp
  809319:	48 89 fb             	mov    %rdi,%rbx
  return getNumColorChannels(colortype) * bitdepth;
  80931c:	8b 3f                	mov    (%rdi),%edi
  80931e:	48 b8 c3 2e 80 00 00 	movabs $0x802ec3,%rax
  809325:	00 00 00 
  809328:	ff d0                	call   *%rax
  80932a:	0f af 43 04          	imul   0x4(%rbx),%eax
}
  80932e:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  809332:	c9                   	leave  
  809333:	c3                   	ret    

0000000000809334 <filter>:
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
  809334:	55                   	push   %rbp
  809335:	48 89 e5             	mov    %rsp,%rbp
  809338:	41 57                	push   %r15
  80933a:	41 56                	push   %r14
  80933c:	41 55                	push   %r13
  80933e:	41 54                	push   %r12
  809340:	53                   	push   %rbx
  809341:	48 81 ec d8 04 00 00 	sub    $0x4d8,%rsp
  809348:	48 89 bd 68 fb ff ff 	mov    %rdi,-0x498(%rbp)
  80934f:	48 89 f3             	mov    %rsi,%rbx
  809352:	41 89 d6             	mov    %edx,%r14d
  809355:	89 8d 60 fb ff ff    	mov    %ecx,-0x4a0(%rbp)
  80935b:	4d 89 c7             	mov    %r8,%r15
  80935e:	4d 89 cc             	mov    %r9,%r12
  unsigned bpp = lodepng_get_bpp(color);
  809361:	4c 89 c7             	mov    %r8,%rdi
  809364:	48 b8 10 93 80 00 00 	movabs $0x809310,%rax
  80936b:	00 00 00 
  80936e:	ff d0                	call   *%rax
  809370:	41 89 c5             	mov    %eax,%r13d
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
  809373:	89 c2                	mov    %eax,%edx
  809375:	be 01 00 00 00       	mov    $0x1,%esi
  80937a:	44 89 f7             	mov    %r14d,%edi
  80937d:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  809384:	00 00 00 
  809387:	ff d0                	call   *%rax
  809389:	48 89 85 48 fb ff ff 	mov    %rax,-0x4b8(%rbp)
  809390:	4c 8d 70 ff          	lea    -0x1(%rax),%r14
  size_t bytewidth = (bpp + 7u) / 8u;
  809394:	41 8d 45 07          	lea    0x7(%r13),%eax
  809398:	c1 e8 03             	shr    $0x3,%eax
  80939b:	89 c0                	mov    %eax,%eax
  80939d:	48 89 85 58 fb ff ff 	mov    %rax,-0x4a8(%rbp)
  if(settings->filter_palette_zero &&
  8093a4:	41 83 7c 24 34 00    	cmpl   $0x0,0x34(%r12)
  8093aa:	74 15                	je     8093c1 <filter+0x8d>
  8093ac:	41 83 3f 03          	cmpl   $0x3,(%r15)
  8093b0:	0f 84 b2 08 00 00    	je     809c68 <filter+0x934>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
  8093b6:	41 83 7f 04 07       	cmpl   $0x7,0x4(%r15)
  8093bb:	0f 86 a7 08 00 00    	jbe    809c68 <filter+0x934>
  if(bpp == 0) return 31; /*error: invalid color type*/
  8093c1:	41 bf 1f 00 00 00    	mov    $0x1f,%r15d
  8093c7:	45 85 ed             	test   %r13d,%r13d
  8093ca:	0f 84 3f 09 00 00    	je     809d0f <filter+0x9db>
  LodePNGFilterStrategy strategy = settings->filter_strategy;
  8093d0:	41 8b 44 24 38       	mov    0x38(%r12),%eax
  8093d5:	89 85 50 fb ff ff    	mov    %eax,-0x4b0(%rbp)
  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
  8093db:	83 f8 04             	cmp    $0x4,%eax
  8093de:	0f 86 9d 08 00 00    	jbe    809c81 <filter+0x94d>
  } else if(strategy == LFS_MINSUM) {
  8093e4:	83 bd 50 fb ff ff 05 	cmpl   $0x5,-0x4b0(%rbp)
  8093eb:	0f 84 fc 00 00 00    	je     8094ed <filter+0x1b9>
  } else if(strategy == LFS_ENTROPY) {
  8093f1:	83 bd 50 fb ff ff 06 	cmpl   $0x6,-0x4b0(%rbp)
  8093f8:	0f 84 25 03 00 00    	je     809723 <filter+0x3ef>
  } else if(strategy == LFS_PREDEFINED) {
  8093fe:	83 bd 50 fb ff ff 08 	cmpl   $0x8,-0x4b0(%rbp)
  809405:	0f 84 0b 06 00 00    	je     809a16 <filter+0x6e2>
  else return 88; /* unknown filter strategy */
  80940b:	41 bf 58 00 00 00    	mov    $0x58,%r15d
  } else if(strategy == LFS_BRUTE_FORCE) {
  809411:	83 bd 50 fb ff ff 07 	cmpl   $0x7,-0x4b0(%rbp)
  809418:	0f 85 f1 08 00 00    	jne    809d0f <filter+0x9db>
  memcpy(dst, src, size);
  80941e:	ba 30 00 00 00       	mov    $0x30,%edx
  809423:	4c 89 e6             	mov    %r12,%rsi
  809426:	48 8d bd d0 fb ff ff 	lea    -0x430(%rbp),%rdi
  80942d:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  809434:	00 00 00 
  809437:	ff d0                	call   *%rax
    zlibsettings.btype = 1;
  809439:	c7 85 d0 fb ff ff 01 	movl   $0x1,-0x430(%rbp)
  809440:	00 00 00 
    zlibsettings.custom_zlib = 0;
  809443:	48 c7 85 e8 fb ff ff 	movq   $0x0,-0x418(%rbp)
  80944a:	00 00 00 00 
    zlibsettings.custom_deflate = 0;
  80944e:	48 c7 85 f0 fb ff ff 	movq   $0x0,-0x410(%rbp)
  809455:	00 00 00 00 
    for(type = 0; type != 5; ++type) {
  809459:	4c 8d ad a8 fb ff ff 	lea    -0x458(%rbp),%r13
    zlibsettings.custom_deflate = 0;
  809460:	4d 89 ec             	mov    %r13,%r12
  unsigned error = 0;
  809463:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  return jos_malloc(size);
  809469:	44 89 f7             	mov    %r14d,%edi
  80946c:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  809473:	00 00 00 
  809476:	ff d0                	call   *%rax
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
  809478:	49 89 04 24          	mov    %rax,(%r12)
      if(!attempt[type]) error = 83; /*alloc fail*/
  80947c:	48 85 c0             	test   %rax,%rax
  80947f:	b8 53 00 00 00       	mov    $0x53,%eax
  809484:	44 0f 44 f8          	cmove  %eax,%r15d
    for(type = 0; type != 5; ++type) {
  809488:	49 83 c4 08          	add    $0x8,%r12
  80948c:	48 8d 85 d0 fb ff ff 	lea    -0x430(%rbp),%rax
  809493:	4c 39 e0             	cmp    %r12,%rax
  809496:	75 d1                	jne    809469 <filter+0x135>
    if(!error) {
  809498:	45 85 ff             	test   %r15d,%r15d
  80949b:	0f 85 82 07 00 00    	jne    809c23 <filter+0x8ef>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
  8094a1:	83 bd 60 fb ff ff 00 	cmpl   $0x0,-0x4a0(%rbp)
  8094a8:	0f 84 75 07 00 00    	je     809c23 <filter+0x8ef>
  8094ae:	48 89 9d 38 fb ff ff 	mov    %rbx,-0x4c8(%rbp)
    unsigned type = 0, bestType = 0;
  8094b5:	44 89 bd 28 fb ff ff 	mov    %r15d,-0x4d8(%rbp)
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
  8094bc:	44 89 bd 44 fb ff ff 	mov    %r15d,-0x4bc(%rbp)
  8094c3:	b8 01 00 00 00       	mov    $0x1,%eax
    size_t smallest = 0;
  8094c8:	48 c7 85 30 fb ff ff 	movq   $0x0,-0x4d0(%rbp)
  8094cf:	00 00 00 00 
  const unsigned char* prevline = 0;
  8094d3:	48 c7 85 50 fb ff ff 	movq   $0x0,-0x4b0(%rbp)
  8094da:	00 00 00 00 
  8094de:	4c 89 ad 08 fb ff ff 	mov    %r13,-0x4f8(%rbp)
  8094e5:	49 89 c5             	mov    %rax,%r13
  8094e8:	e9 fb 06 00 00       	jmp    809be8 <filter+0x8b4>
  8094ed:	48 8d 85 d0 fb ff ff 	lea    -0x430(%rbp),%rax
  8094f4:	48 89 85 10 fb ff ff 	mov    %rax,-0x4f0(%rbp)
  } else if(strategy == LFS_MINSUM) {
  8094fb:	49 89 c4             	mov    %rax,%r12
  unsigned error = 0;
  8094fe:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  return jos_malloc(size);
  809504:	49 bd f8 0d 81 00 00 	movabs $0x810df8,%r13
  80950b:	00 00 00 
  80950e:	44 89 f7             	mov    %r14d,%edi
  809511:	41 ff d5             	call   *%r13
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
  809514:	49 89 04 24          	mov    %rax,(%r12)
      if(!attempt[type]) error = 83; /*alloc fail*/
  809518:	48 85 c0             	test   %rax,%rax
  80951b:	b8 53 00 00 00       	mov    $0x53,%eax
  809520:	44 0f 44 f8          	cmove  %eax,%r15d
    for(type = 0; type != 5; ++type) {
  809524:	49 83 c4 08          	add    $0x8,%r12
  809528:	48 8d 85 f8 fb ff ff 	lea    -0x408(%rbp),%rax
  80952f:	49 39 c4             	cmp    %rax,%r12
  809532:	75 da                	jne    80950e <filter+0x1da>
    if(!error) {
  809534:	45 85 ff             	test   %r15d,%r15d
  809537:	0f 85 ba 01 00 00    	jne    8096f7 <filter+0x3c3>
      for(y = 0; y != h; ++y) {
  80953d:	83 bd 60 fb ff ff 00 	cmpl   $0x0,-0x4a0(%rbp)
  809544:	0f 84 ad 01 00 00    	je     8096f7 <filter+0x3c3>
  80954a:	48 89 9d 18 fb ff ff 	mov    %rbx,-0x4e8(%rbp)
  809551:	44 89 bd 20 fb ff ff 	mov    %r15d,-0x4e0(%rbp)
  809558:	b8 01 00 00 00       	mov    $0x1,%eax
    unsigned char type, bestType = 0;
  80955d:	c6 85 28 fb ff ff 00 	movb   $0x0,-0x4d8(%rbp)
    size_t smallest = 0;
  809564:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  const unsigned char* prevline = 0;
  80956a:	48 c7 85 50 fb ff ff 	movq   $0x0,-0x4b0(%rbp)
  809571:	00 00 00 00 
  809575:	44 89 bd 44 fb ff ff 	mov    %r15d,-0x4bc(%rbp)
  80957c:	49 89 c7             	mov    %rax,%r15
  80957f:	e9 45 01 00 00       	jmp    8096c9 <filter+0x395>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
  809584:	4d 85 f6             	test   %r14,%r14
  809587:	0f 84 d3 06 00 00    	je     809c60 <filter+0x92c>
  80958d:	8b 95 44 fb ff ff    	mov    -0x4bc(%rbp),%edx
          size_t sum = 0;
  809593:	41 bd 00 00 00 00    	mov    $0x0,%r13d
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
  809599:	b8 00 00 00 00       	mov    $0x0,%eax
  80959e:	0f b6 04 03          	movzbl (%rbx,%rax,1),%eax
  8095a2:	49 01 c5             	add    %rax,%r13
  8095a5:	83 c2 01             	add    $0x1,%edx
  8095a8:	89 d0                	mov    %edx,%eax
  8095aa:	4c 39 f0             	cmp    %r14,%rax
  8095ad:	75 ef                	jne    80959e <filter+0x26a>
          size_t sum = 0;
  8095af:	0f b6 85 38 fb ff ff 	movzbl -0x4c8(%rbp),%eax
  8095b6:	88 85 28 fb ff ff    	mov    %al,-0x4d8(%rbp)
  8095bc:	eb 29                	jmp    8095e7 <filter+0x2b3>
              sum += s < 128 ? s : (255U - s);
  8095be:	48 01 f1             	add    %rsi,%rcx
            for(x = 0; x != linebytes; ++x) {
  8095c1:	83 c2 01             	add    $0x1,%edx
  8095c4:	89 d0                	mov    %edx,%eax
  8095c6:	4c 39 f0             	cmp    %r14,%rax
  8095c9:	74 17                	je     8095e2 <filter+0x2ae>
              unsigned char s = attempt[type][x];
  8095cb:	0f b6 04 03          	movzbl (%rbx,%rax,1),%eax
              sum += s < 128 ? s : (255U - s);
  8095cf:	0f b6 f0             	movzbl %al,%esi
  8095d2:	84 c0                	test   %al,%al
  8095d4:	79 e8                	jns    8095be <filter+0x28a>
  8095d6:	0f b6 c0             	movzbl %al,%eax
  8095d9:	be ff 00 00 00       	mov    $0xff,%esi
  8095de:	29 c6                	sub    %eax,%esi
  8095e0:	eb dc                	jmp    8095be <filter+0x28a>
          if(type == 0 || sum < smallest) {
  8095e2:	4c 39 e9             	cmp    %r13,%rcx
  8095e5:	72 66                	jb     80964d <filter+0x319>
        for(type = 0; type != 5; ++type) {
  8095e7:	49 83 c4 01          	add    $0x1,%r12
  8095eb:	49 83 fc 05          	cmp    $0x5,%r12
  8095ef:	74 6e                	je     80965f <filter+0x32b>
  8095f1:	44 88 a5 38 fb ff ff 	mov    %r12b,-0x4c8(%rbp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
  8095f8:	4a 8b 9c e5 d0 fb ff 	mov    -0x430(%rbp,%r12,8),%rbx
  8095ff:	ff 
  809600:	45 89 e1             	mov    %r12d,%r9d
  809603:	4c 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%r8
  80960a:	4c 89 f1             	mov    %r14,%rcx
  80960d:	48 8b 95 30 fb ff ff 	mov    -0x4d0(%rbp),%rdx
  809614:	48 8b b5 50 fb ff ff 	mov    -0x4b0(%rbp),%rsi
  80961b:	48 89 df             	mov    %rbx,%rdi
  80961e:	48 b8 86 41 80 00 00 	movabs $0x804186,%rax
  809625:	00 00 00 
  809628:	ff d0                	call   *%rax
          if(type == 0) {
  80962a:	45 84 e4             	test   %r12b,%r12b
  80962d:	0f 84 51 ff ff ff    	je     809584 <filter+0x250>
            for(x = 0; x != linebytes; ++x) {
  809633:	8b 95 44 fb ff ff    	mov    -0x4bc(%rbp),%edx
          size_t sum = 0;
  809639:	b9 00 00 00 00       	mov    $0x0,%ecx
            for(x = 0; x != linebytes; ++x) {
  80963e:	b8 00 00 00 00       	mov    $0x0,%eax
  809643:	4d 85 f6             	test   %r14,%r14
  809646:	75 83                	jne    8095cb <filter+0x297>
          size_t sum = 0;
  809648:	4c 89 f1             	mov    %r14,%rcx
  80964b:	eb 95                	jmp    8095e2 <filter+0x2ae>
          if(type == 0 || sum < smallest) {
  80964d:	0f b6 85 38 fb ff ff 	movzbl -0x4c8(%rbp),%eax
  809654:	88 85 28 fb ff ff    	mov    %al,-0x4d8(%rbp)
  80965a:	49 89 cd             	mov    %rcx,%r13
  80965d:	eb 88                	jmp    8095e7 <filter+0x2b3>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
  80965f:	48 8b 9d 68 fb ff ff 	mov    -0x498(%rbp),%rbx
  809666:	0f b6 85 28 fb ff ff 	movzbl -0x4d8(%rbp),%eax
  80966d:	42 88 44 3b ff       	mov    %al,-0x1(%rbx,%r15,1)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
  809672:	4d 85 f6             	test   %r14,%r14
  809675:	74 2f                	je     8096a6 <filter+0x372>
  809677:	0f b6 c0             	movzbl %al,%eax
  80967a:	48 8b b4 c5 d0 fb ff 	mov    -0x430(%rbp,%rax,8),%rsi
  809681:	ff 
  809682:	8b 95 44 fb ff ff    	mov    -0x4bc(%rbp),%edx
  809688:	b8 00 00 00 00       	mov    $0x0,%eax
  80968d:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
  809691:	48 03 85 68 fb ff ff 	add    -0x498(%rbp),%rax
  809698:	42 88 0c 38          	mov    %cl,(%rax,%r15,1)
  80969c:	83 c2 01             	add    $0x1,%edx
  80969f:	89 d0                	mov    %edx,%eax
  8096a1:	4c 39 f0             	cmp    %r14,%rax
  8096a4:	75 e7                	jne    80968d <filter+0x359>
      for(y = 0; y != h; ++y) {
  8096a6:	83 85 20 fb ff ff 01 	addl   $0x1,-0x4e0(%rbp)
  8096ad:	8b 85 20 fb ff ff    	mov    -0x4e0(%rbp),%eax
  8096b3:	4c 01 b5 18 fb ff ff 	add    %r14,-0x4e8(%rbp)
  8096ba:	4c 03 bd 48 fb ff ff 	add    -0x4b8(%rbp),%r15
  8096c1:	39 85 60 fb ff ff    	cmp    %eax,-0x4a0(%rbp)
  8096c7:	74 27                	je     8096f0 <filter+0x3bc>
        for(type = 0; type != 5; ++type) {
  8096c9:	48 8b 85 50 fb ff ff 	mov    -0x4b0(%rbp),%rax
  8096d0:	48 89 85 30 fb ff ff 	mov    %rax,-0x4d0(%rbp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
  8096d7:	48 8b 85 18 fb ff ff 	mov    -0x4e8(%rbp),%rax
  8096de:	48 89 85 50 fb ff ff 	mov    %rax,-0x4b0(%rbp)
  8096e5:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  8096eb:	e9 01 ff ff ff       	jmp    8095f1 <filter+0x2bd>
  8096f0:	44 8b bd 44 fb ff ff 	mov    -0x4bc(%rbp),%r15d
    jos_free(ptr);
  8096f7:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  8096fe:	00 00 00 
  809701:	4c 8b a5 10 fb ff ff 	mov    -0x4f0(%rbp),%r12
  809708:	49 8b 3c 24          	mov    (%r12),%rdi
  80970c:	ff d3                	call   *%rbx
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  80970e:	49 83 c4 08          	add    $0x8,%r12
  809712:	48 8d 85 f8 fb ff ff 	lea    -0x408(%rbp),%rax
  809719:	4c 39 e0             	cmp    %r12,%rax
  80971c:	75 ea                	jne    809708 <filter+0x3d4>
  80971e:	e9 ec 05 00 00       	jmp    809d0f <filter+0x9db>
  809723:	48 8d 85 a8 fb ff ff 	lea    -0x458(%rbp),%rax
  80972a:	48 89 85 08 fb ff ff 	mov    %rax,-0x4f8(%rbp)
  } else if(strategy == LFS_ENTROPY) {
  809731:	49 89 c4             	mov    %rax,%r12
  unsigned error = 0;
  809734:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  return jos_malloc(size);
  80973a:	49 bd f8 0d 81 00 00 	movabs $0x810df8,%r13
  809741:	00 00 00 
  809744:	44 89 f7             	mov    %r14d,%edi
  809747:	41 ff d5             	call   *%r13
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
  80974a:	49 89 04 24          	mov    %rax,(%r12)
      if(!attempt[type]) error = 83; /*alloc fail*/
  80974e:	48 85 c0             	test   %rax,%rax
  809751:	b8 53 00 00 00       	mov    $0x53,%eax
  809756:	44 0f 44 f8          	cmove  %eax,%r15d
    for(type = 0; type != 5; ++type) {
  80975a:	49 83 c4 08          	add    $0x8,%r12
  80975e:	48 8d 85 d0 fb ff ff 	lea    -0x430(%rbp),%rax
  809765:	49 39 c4             	cmp    %rax,%r12
  809768:	75 da                	jne    809744 <filter+0x410>
    if(!error) {
  80976a:	45 85 ff             	test   %r15d,%r15d
  80976d:	0f 85 77 02 00 00    	jne    8099ea <filter+0x6b6>
      for(y = 0; y != h; ++y) {
  809773:	83 bd 60 fb ff ff 00 	cmpl   $0x0,-0x4a0(%rbp)
  80977a:	0f 84 6a 02 00 00    	je     8099ea <filter+0x6b6>
  809780:	48 89 9d 30 fb ff ff 	mov    %rbx,-0x4d0(%rbp)
    unsigned type, bestType = 0;
  809787:	44 89 bd 18 fb ff ff 	mov    %r15d,-0x4e8(%rbp)
      for(y = 0; y != h; ++y) {
  80978e:	44 89 bd 38 fb ff ff 	mov    %r15d,-0x4c8(%rbp)
  809795:	48 c7 85 28 fb ff ff 	movq   $0x0,-0x4d8(%rbp)
  80979c:	00 00 00 00 
    size_t bestSum = 0;
  8097a0:	48 c7 85 20 fb ff ff 	movq   $0x0,-0x4e0(%rbp)
  8097a7:	00 00 00 00 
  const unsigned char* prevline = 0;
  8097ab:	48 c7 85 50 fb ff ff 	movq   $0x0,-0x4b0(%rbp)
  8097b2:	00 00 00 00 
  return i * l + ((i - ((size_t) 1u << l)) << 1u);
  8097b6:	bb 01 00 00 00       	mov    $0x1,%ebx
  8097bb:	e9 03 02 00 00       	jmp    8099c3 <filter+0x68f>
  while(i >= 256) { result += 8; i >>= 8; }
  8097c0:	48 81 fa ff 00 00 00 	cmp    $0xff,%rdx
  8097c7:	0f 86 8c 00 00 00    	jbe    809859 <filter+0x525>
  8097cd:	48 89 d0             	mov    %rdx,%rax
  size_t result = 0;
  8097d0:	b9 00 00 00 00       	mov    $0x0,%ecx
  while(i >= 256) { result += 8; i >>= 8; }
  8097d5:	48 83 c1 08          	add    $0x8,%rcx
  8097d9:	48 c1 e8 08          	shr    $0x8,%rax
  8097dd:	48 3d ff 00 00 00    	cmp    $0xff,%rax
  8097e3:	77 f0                	ja     8097d5 <filter+0x4a1>
  while(i >= 16) { result += 4; i >>= 4; }
  8097e5:	48 83 f8 0f          	cmp    $0xf,%rax
  8097e9:	76 08                	jbe    8097f3 <filter+0x4bf>
  8097eb:	48 83 c1 04          	add    $0x4,%rcx
  8097ef:	48 c1 e8 04          	shr    $0x4,%rax
  while(i >= 2) { result += 1; i >>= 1; }
  8097f3:	48 83 f8 01          	cmp    $0x1,%rax
  8097f7:	76 0d                	jbe    809806 <filter+0x4d2>
  8097f9:	48 83 c1 01          	add    $0x1,%rcx
  8097fd:	48 d1 e8             	shr    %rax
  809800:	48 83 f8 01          	cmp    $0x1,%rax
  809804:	77 f3                	ja     8097f9 <filter+0x4c5>
  return i * l + ((i - ((size_t) 1u << l)) << 1u);
  809806:	49 89 d9             	mov    %rbx,%r9
  809809:	49 d3 e1             	shl    %cl,%r9
  80980c:	48 89 d0             	mov    %rdx,%rax
  80980f:	4c 29 c8             	sub    %r9,%rax
  809812:	48 0f af ca          	imul   %rdx,%rcx
  809816:	48 8d 14 41          	lea    (%rcx,%rax,2),%rdx
            sum += ilog2i(count[x]);
  80981a:	48 01 d7             	add    %rdx,%rdi
          for(x = 0; x != 256; ++x) {
  80981d:	48 83 c6 04          	add    $0x4,%rsi
  809821:	4c 39 c6             	cmp    %r8,%rsi
  809824:	74 54                	je     80987a <filter+0x546>
            sum += ilog2i(count[x]);
  809826:	8b 16                	mov    (%rsi),%edx
  if(i == 0) return 0;
  809828:	48 85 d2             	test   %rdx,%rdx
  80982b:	74 ed                	je     80981a <filter+0x4e6>
  while(i >= 65536) { result += 16; i >>= 16; }
  80982d:	48 81 fa ff ff 00 00 	cmp    $0xffff,%rdx
  809834:	76 8a                	jbe    8097c0 <filter+0x48c>
  809836:	48 89 d0             	mov    %rdx,%rax
  809839:	48 c1 e8 10          	shr    $0x10,%rax
  80983d:	b9 10 00 00 00       	mov    $0x10,%ecx
  while(i >= 256) { result += 8; i >>= 8; }
  809842:	48 81 fa ff ff ff 00 	cmp    $0xffffff,%rdx
  809849:	76 16                	jbe    809861 <filter+0x52d>
  80984b:	48 89 d0             	mov    %rdx,%rax
  80984e:	48 c1 e8 18          	shr    $0x18,%rax
  809852:	b9 18 00 00 00       	mov    $0x18,%ecx
  809857:	eb 8c                	jmp    8097e5 <filter+0x4b1>
  809859:	48 89 d0             	mov    %rdx,%rax
  size_t result = 0;
  80985c:	b9 00 00 00 00       	mov    $0x0,%ecx
  while(i >= 16) { result += 4; i >>= 4; }
  809861:	48 83 f8 0f          	cmp    $0xf,%rax
  809865:	76 8c                	jbe    8097f3 <filter+0x4bf>
  809867:	48 83 c1 04          	add    $0x4,%rcx
  80986b:	48 c1 e8 04          	shr    $0x4,%rax
  80986f:	48 83 f8 0f          	cmp    $0xf,%rax
  809873:	77 f2                	ja     809867 <filter+0x533>
  809875:	e9 79 ff ff ff       	jmp    8097f3 <filter+0x4bf>
          if(type == 0 || sum > bestSum) {
  80987a:	83 bd 44 fb ff ff 00 	cmpl   $0x0,-0x4bc(%rbp)
  809881:	0f 84 b3 00 00 00    	je     80993a <filter+0x606>
  809887:	48 3b bd 20 fb ff ff 	cmp    -0x4e0(%rbp),%rdi
  80988e:	0f 87 a6 00 00 00    	ja     80993a <filter+0x606>
        for(type = 0; type != 5; ++type) {
  809894:	49 83 c5 01          	add    $0x1,%r13
  809898:	49 83 fd 05          	cmp    $0x5,%r13
  80989c:	0f 84 b0 00 00 00    	je     809952 <filter+0x61e>
  8098a2:	44 89 ad 44 fb ff ff 	mov    %r13d,-0x4bc(%rbp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
  8098a9:	4e 8b a4 ed a8 fb ff 	mov    -0x458(%rbp,%r13,8),%r12
  8098b0:	ff 
  8098b1:	45 89 e9             	mov    %r13d,%r9d
  8098b4:	4c 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%r8
  8098bb:	4c 89 f1             	mov    %r14,%rcx
  8098be:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8098c5:	48 8b b5 50 fb ff ff 	mov    -0x4b0(%rbp),%rsi
  8098cc:	4c 89 e7             	mov    %r12,%rdi
  8098cf:	48 b8 86 41 80 00 00 	movabs $0x804186,%rax
  8098d6:	00 00 00 
  8098d9:	ff d0                	call   *%rax
  memset(dst, value, num);
  8098db:	ba 00 04 00 00       	mov    $0x400,%edx
  8098e0:	be 00 00 00 00       	mov    $0x0,%esi
  8098e5:	48 8d bd d0 fb ff ff 	lea    -0x430(%rbp),%rdi
  8098ec:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  8098f3:	00 00 00 
  8098f6:	ff d0                	call   *%rax
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
  8098f8:	4d 85 f6             	test   %r14,%r14
  8098fb:	74 1f                	je     80991c <filter+0x5e8>
  8098fd:	44 89 fa             	mov    %r15d,%edx
  809900:	b8 00 00 00 00       	mov    $0x0,%eax
  809905:	41 0f b6 04 04       	movzbl (%r12,%rax,1),%eax
  80990a:	83 84 85 d0 fb ff ff 	addl   $0x1,-0x430(%rbp,%rax,4)
  809911:	01 
  809912:	83 c2 01             	add    $0x1,%edx
  809915:	89 d0                	mov    %edx,%eax
  809917:	4c 39 f0             	cmp    %r14,%rax
  80991a:	75 e9                	jne    809905 <filter+0x5d1>
          ++count[type]; /*the filter type itself is part of the scanline*/
  80991c:	42 83 84 ad d0 fb ff 	addl   $0x1,-0x430(%rbp,%r13,4)
  809923:	ff 01 
          for(x = 0; x != 256; ++x) {
  809925:	48 8d b5 d0 fb ff ff 	lea    -0x430(%rbp),%rsi
  80992c:	4c 8d 45 d0          	lea    -0x30(%rbp),%r8
          size_t sum = 0;
  809930:	bf 00 00 00 00       	mov    $0x0,%edi
  809935:	e9 ec fe ff ff       	jmp    809826 <filter+0x4f2>
          if(type == 0 || sum > bestSum) {
  80993a:	8b 85 44 fb ff ff    	mov    -0x4bc(%rbp),%eax
  809940:	89 85 18 fb ff ff    	mov    %eax,-0x4e8(%rbp)
            sum += ilog2i(count[x]);
  809946:	48 89 bd 20 fb ff ff 	mov    %rdi,-0x4e0(%rbp)
  80994d:	e9 42 ff ff ff       	jmp    809894 <filter+0x560>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
  809952:	48 8b b5 68 fb ff ff 	mov    -0x498(%rbp),%rsi
  809959:	48 8b bd 28 fb ff ff 	mov    -0x4d8(%rbp),%rdi
  809960:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  809966:	88 04 3e             	mov    %al,(%rsi,%rdi,1)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
  809969:	4d 85 f6             	test   %r14,%r14
  80996c:	74 2b                	je     809999 <filter+0x665>
  80996e:	89 c0                	mov    %eax,%eax
  809970:	48 8b b4 c5 a8 fb ff 	mov    -0x458(%rbp,%rax,8),%rsi
  809977:	ff 
  809978:	44 89 fa             	mov    %r15d,%edx
  80997b:	b8 00 00 00 00       	mov    $0x0,%eax
  809980:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
  809984:	48 03 85 68 fb ff ff 	add    -0x498(%rbp),%rax
  80998b:	88 4c 07 01          	mov    %cl,0x1(%rdi,%rax,1)
  80998f:	83 c2 01             	add    $0x1,%edx
  809992:	89 d0                	mov    %edx,%eax
  809994:	4c 39 f0             	cmp    %r14,%rax
  809997:	75 e7                	jne    809980 <filter+0x64c>
      for(y = 0; y != h; ++y) {
  809999:	83 85 38 fb ff ff 01 	addl   $0x1,-0x4c8(%rbp)
  8099a0:	8b 85 38 fb ff ff    	mov    -0x4c8(%rbp),%eax
  8099a6:	4c 01 b5 30 fb ff ff 	add    %r14,-0x4d0(%rbp)
  8099ad:	48 8b b5 48 fb ff ff 	mov    -0x4b8(%rbp),%rsi
  8099b4:	48 01 b5 28 fb ff ff 	add    %rsi,-0x4d8(%rbp)
  8099bb:	39 85 60 fb ff ff    	cmp    %eax,-0x4a0(%rbp)
  8099c1:	74 27                	je     8099ea <filter+0x6b6>
        for(type = 0; type != 5; ++type) {
  8099c3:	48 8b 85 50 fb ff ff 	mov    -0x4b0(%rbp),%rax
  8099ca:	48 89 85 10 fb ff ff 	mov    %rax,-0x4f0(%rbp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
  8099d1:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
  8099d8:	48 89 85 50 fb ff ff 	mov    %rax,-0x4b0(%rbp)
  8099df:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  8099e5:	e9 b8 fe ff ff       	jmp    8098a2 <filter+0x56e>
    jos_free(ptr);
  8099ea:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  8099f1:	00 00 00 
  8099f4:	4c 8b a5 08 fb ff ff 	mov    -0x4f8(%rbp),%r12
  8099fb:	49 8b 3c 24          	mov    (%r12),%rdi
  8099ff:	ff d3                	call   *%rbx
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  809a01:	49 83 c4 08          	add    $0x8,%r12
  809a05:	48 8d 85 d0 fb ff ff 	lea    -0x430(%rbp),%rax
  809a0c:	4c 39 e0             	cmp    %r12,%rax
  809a0f:	75 ea                	jne    8099fb <filter+0x6c7>
  809a11:	e9 f9 02 00 00       	jmp    809d0f <filter+0x9db>
    for(y = 0; y != h; ++y) {
  809a16:	8b 85 60 fb ff ff    	mov    -0x4a0(%rbp),%eax
  809a1c:	85 c0                	test   %eax,%eax
  809a1e:	0f 84 30 02 00 00    	je     809c54 <filter+0x920>
  809a24:	4c 8b bd 68 fb ff ff 	mov    -0x498(%rbp),%r15
  809a2b:	49 83 c7 01          	add    $0x1,%r15
  809a2f:	89 c0                	mov    %eax,%eax
  809a31:	48 89 85 60 fb ff ff 	mov    %rax,-0x4a0(%rbp)
  809a38:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  const unsigned char* prevline = 0;
  809a3e:	48 c7 85 68 fb ff ff 	movq   $0x0,-0x498(%rbp)
  809a45:	00 00 00 00 
      unsigned char type = settings->predefined_filters[y];
  809a49:	49 8b 44 24 40       	mov    0x40(%r12),%rax
  809a4e:	46 0f b6 0c 28       	movzbl (%rax,%r13,1),%r9d
      out[outindex] = type; /*filter type byte*/
  809a53:	45 88 4f ff          	mov    %r9b,-0x1(%r15)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
  809a57:	48 8b 95 68 fb ff ff 	mov    -0x498(%rbp),%rdx
  809a5e:	48 89 9d 68 fb ff ff 	mov    %rbx,-0x498(%rbp)
  809a65:	45 0f b6 c9          	movzbl %r9b,%r9d
  809a69:	4c 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%r8
  809a70:	4c 89 f1             	mov    %r14,%rcx
  809a73:	48 89 de             	mov    %rbx,%rsi
  809a76:	4c 89 ff             	mov    %r15,%rdi
  809a79:	48 b8 86 41 80 00 00 	movabs $0x804186,%rax
  809a80:	00 00 00 
  809a83:	ff d0                	call   *%rax
    for(y = 0; y != h; ++y) {
  809a85:	49 83 c5 01          	add    $0x1,%r13
  809a89:	4c 01 f3             	add    %r14,%rbx
  809a8c:	4c 03 bd 48 fb ff ff 	add    -0x4b8(%rbp),%r15
  809a93:	4c 3b ad 60 fb ff ff 	cmp    -0x4a0(%rbp),%r13
  809a9a:	75 ad                	jne    809a49 <filter+0x715>
  unsigned error = 0;
  809a9c:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  809aa2:	e9 68 02 00 00       	jmp    809d0f <filter+0x9db>
            smallest = size[type];
  809aa7:	48 8b 85 18 fb ff ff 	mov    -0x4e8(%rbp),%rax
  809aae:	48 8b 00             	mov    (%rax),%rax
  809ab1:	48 89 85 30 fb ff ff 	mov    %rax,-0x4d0(%rbp)
  809ab8:	8b 85 20 fb ff ff    	mov    -0x4e0(%rbp),%eax
  809abe:	89 85 28 fb ff ff    	mov    %eax,-0x4d8(%rbp)
        for(type = 0; type != 5; ++type) {
  809ac4:	48 83 c3 01          	add    $0x1,%rbx
  809ac8:	49 83 c4 08          	add    $0x8,%r12
  809acc:	48 83 fb 05          	cmp    $0x5,%rbx
  809ad0:	0f 84 a6 00 00 00    	je     809b7c <filter+0x848>
  809ad6:	89 9d 20 fb ff ff    	mov    %ebx,-0x4e0(%rbp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
  809adc:	4c 8b ac dd a8 fb ff 	mov    -0x458(%rbp,%rbx,8),%r13
  809ae3:	ff 
  809ae4:	41 89 d9             	mov    %ebx,%r9d
  809ae7:	4c 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%r8
  809aee:	4c 89 f1             	mov    %r14,%rcx
  809af1:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  809af8:	48 8b b5 50 fb ff ff 	mov    -0x4b0(%rbp),%rsi
  809aff:	4c 89 ef             	mov    %r13,%rdi
  809b02:	48 b8 86 41 80 00 00 	movabs $0x804186,%rax
  809b09:	00 00 00 
  809b0c:	ff d0                	call   *%rax
          size[type] = 0;
  809b0e:	4c 89 a5 18 fb ff ff 	mov    %r12,-0x4e8(%rbp)
  809b15:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
  809b1c:	00 
          dummy = 0;
  809b1d:	48 c7 85 78 fb ff ff 	movq   $0x0,-0x488(%rbp)
  809b24:	00 00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
  809b28:	44 89 f1             	mov    %r14d,%ecx
  809b2b:	4c 8d 85 d0 fb ff ff 	lea    -0x430(%rbp),%r8
  809b32:	4c 89 ea             	mov    %r13,%rdx
  809b35:	4c 89 e6             	mov    %r12,%rsi
  809b38:	48 8d bd 78 fb ff ff 	lea    -0x488(%rbp),%rdi
  809b3f:	48 b8 2a 87 80 00 00 	movabs $0x80872a,%rax
  809b46:	00 00 00 
  809b49:	ff d0                	call   *%rax
    jos_free(ptr);
  809b4b:	48 8b bd 78 fb ff ff 	mov    -0x488(%rbp),%rdi
  809b52:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  809b59:	00 00 00 
  809b5c:	ff d0                	call   *%rax
          if(type == 0 || size[type] < smallest) {
  809b5e:	85 db                	test   %ebx,%ebx
  809b60:	0f 84 41 ff ff ff    	je     809aa7 <filter+0x773>
  809b66:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
  809b6d:	49 39 04 24          	cmp    %rax,(%r12)
  809b71:	0f 83 4d ff ff ff    	jae    809ac4 <filter+0x790>
  809b77:	e9 2b ff ff ff       	jmp    809aa7 <filter+0x773>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
  809b7c:	4c 8b ad 00 fb ff ff 	mov    -0x500(%rbp),%r13
  809b83:	48 8b 9d 68 fb ff ff 	mov    -0x498(%rbp),%rbx
  809b8a:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  809b90:	42 88 44 2b ff       	mov    %al,-0x1(%rbx,%r13,1)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
  809b95:	4d 85 f6             	test   %r14,%r14
  809b98:	74 2b                	je     809bc5 <filter+0x891>
  809b9a:	89 c0                	mov    %eax,%eax
  809b9c:	48 8b b4 c5 a8 fb ff 	mov    -0x458(%rbp,%rax,8),%rsi
  809ba3:	ff 
  809ba4:	44 89 fa             	mov    %r15d,%edx
  809ba7:	b8 00 00 00 00       	mov    $0x0,%eax
  809bac:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
  809bb0:	48 03 85 68 fb ff ff 	add    -0x498(%rbp),%rax
  809bb7:	42 88 0c 28          	mov    %cl,(%rax,%r13,1)
  809bbb:	83 c2 01             	add    $0x1,%edx
  809bbe:	89 d0                	mov    %edx,%eax
  809bc0:	4c 39 f0             	cmp    %r14,%rax
  809bc3:	75 e7                	jne    809bac <filter+0x878>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
  809bc5:	83 85 44 fb ff ff 01 	addl   $0x1,-0x4bc(%rbp)
  809bcc:	8b 85 44 fb ff ff    	mov    -0x4bc(%rbp),%eax
  809bd2:	4c 01 b5 38 fb ff ff 	add    %r14,-0x4c8(%rbp)
  809bd9:	4c 03 ad 48 fb ff ff 	add    -0x4b8(%rbp),%r13
  809be0:	39 85 60 fb ff ff    	cmp    %eax,-0x4a0(%rbp)
  809be6:	74 34                	je     809c1c <filter+0x8e8>
        for(type = 0; type != 5; ++type) {
  809be8:	48 8b 85 50 fb ff ff 	mov    -0x4b0(%rbp),%rax
  809bef:	48 89 85 10 fb ff ff 	mov    %rax,-0x4f0(%rbp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
  809bf6:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  809bfd:	48 89 85 50 fb ff ff 	mov    %rax,-0x4b0(%rbp)
  809c04:	4c 8d a5 80 fb ff ff 	lea    -0x480(%rbp),%r12
  809c0b:	bb 00 00 00 00       	mov    $0x0,%ebx
  809c10:	4c 89 ad 00 fb ff ff 	mov    %r13,-0x500(%rbp)
  809c17:	e9 ba fe ff ff       	jmp    809ad6 <filter+0x7a2>
  809c1c:	4c 8b ad 08 fb ff ff 	mov    -0x4f8(%rbp),%r13
    jos_free(ptr);
  809c23:	48 bb be 0e 81 00 00 	movabs $0x810ebe,%rbx
  809c2a:	00 00 00 
  809c2d:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  809c31:	ff d3                	call   *%rbx
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  809c33:	49 83 c5 08          	add    $0x8,%r13
  809c37:	48 8d 85 d0 fb ff ff 	lea    -0x430(%rbp),%rax
  809c3e:	4c 39 e8             	cmp    %r13,%rax
  809c41:	75 ea                	jne    809c2d <filter+0x8f9>
  809c43:	e9 c7 00 00 00       	jmp    809d0f <filter+0x9db>
  unsigned error = 0;
  809c48:	44 8b bd 60 fb ff ff 	mov    -0x4a0(%rbp),%r15d
  809c4f:	e9 bb 00 00 00       	jmp    809d0f <filter+0x9db>
  809c54:	44 8b bd 60 fb ff ff 	mov    -0x4a0(%rbp),%r15d
  809c5b:	e9 af 00 00 00       	jmp    809d0f <filter+0x9db>
          size_t sum = 0;
  809c60:	4d 89 f5             	mov    %r14,%r13
  809c63:	e9 47 f9 ff ff       	jmp    8095af <filter+0x27b>
  if(bpp == 0) return 31; /*error: invalid color type*/
  809c68:	41 bf 1f 00 00 00    	mov    $0x1f,%r15d
  809c6e:	45 85 ed             	test   %r13d,%r13d
  809c71:	0f 84 98 00 00 00    	je     809d0f <filter+0x9db>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
  809c77:	c7 85 50 fb ff ff 00 	movl   $0x0,-0x4b0(%rbp)
  809c7e:	00 00 00 
    unsigned char type = (unsigned char)strategy;
  809c81:	0f b6 85 50 fb ff ff 	movzbl -0x4b0(%rbp),%eax
  809c88:	88 85 44 fb ff ff    	mov    %al,-0x4bc(%rbp)
    for(y = 0; y != h; ++y) {
  809c8e:	83 bd 60 fb ff ff 00 	cmpl   $0x0,-0x4a0(%rbp)
  809c95:	74 b1                	je     809c48 <filter+0x914>
  809c97:	4c 8b a5 68 fb ff ff 	mov    -0x498(%rbp),%r12
  809c9e:	49 83 c4 01          	add    $0x1,%r12
  809ca2:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  const unsigned char* prevline = 0;
  809ca8:	48 c7 85 68 fb ff ff 	movq   $0x0,-0x498(%rbp)
  809caf:	00 00 00 00 
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
  809cb3:	49 bf 86 41 80 00 00 	movabs $0x804186,%r15
  809cba:	00 00 00 
      out[outindex] = type; /*filter type byte*/
  809cbd:	0f b6 85 44 fb ff ff 	movzbl -0x4bc(%rbp),%eax
  809cc4:	41 88 44 24 ff       	mov    %al,-0x1(%r12)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
  809cc9:	48 8b 95 68 fb ff ff 	mov    -0x498(%rbp),%rdx
  809cd0:	48 89 9d 68 fb ff ff 	mov    %rbx,-0x498(%rbp)
  809cd7:	44 0f b6 8d 50 fb ff 	movzbl -0x4b0(%rbp),%r9d
  809cde:	ff 
  809cdf:	4c 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%r8
  809ce6:	4c 89 f1             	mov    %r14,%rcx
  809ce9:	48 89 de             	mov    %rbx,%rsi
  809cec:	4c 89 e7             	mov    %r12,%rdi
  809cef:	41 ff d7             	call   *%r15
    for(y = 0; y != h; ++y) {
  809cf2:	41 83 c5 01          	add    $0x1,%r13d
  809cf6:	4c 01 f3             	add    %r14,%rbx
  809cf9:	4c 03 a5 48 fb ff ff 	add    -0x4b8(%rbp),%r12
  809d00:	44 39 ad 60 fb ff ff 	cmp    %r13d,-0x4a0(%rbp)
  809d07:	75 b4                	jne    809cbd <filter+0x989>
  unsigned error = 0;
  809d09:	41 bf 00 00 00 00    	mov    $0x0,%r15d
}
  809d0f:	44 89 f8             	mov    %r15d,%eax
  809d12:	48 81 c4 d8 04 00 00 	add    $0x4d8,%rsp
  809d19:	5b                   	pop    %rbx
  809d1a:	41 5c                	pop    %r12
  809d1c:	41 5d                	pop    %r13
  809d1e:	41 5e                	pop    %r14
  809d20:	41 5f                	pop    %r15
  809d22:	5d                   	pop    %rbp
  809d23:	c3                   	ret    

0000000000809d24 <preProcessScanlines>:
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
  809d24:	55                   	push   %rbp
  809d25:	48 89 e5             	mov    %rsp,%rbp
  809d28:	41 57                	push   %r15
  809d2a:	41 56                	push   %r14
  809d2c:	41 55                	push   %r13
  809d2e:	41 54                	push   %r12
  809d30:	53                   	push   %rbx
  809d31:	48 81 ec 78 02 00 00 	sub    $0x278,%rsp
  809d38:	48 89 bd 70 fd ff ff 	mov    %rdi,-0x290(%rbp)
  809d3f:	49 89 f5             	mov    %rsi,%r13
  809d42:	48 89 95 c8 fd ff ff 	mov    %rdx,-0x238(%rbp)
  809d49:	41 89 ce             	mov    %ecx,%r14d
  809d4c:	89 8d c4 fd ff ff    	mov    %ecx,-0x23c(%rbp)
  809d52:	45 89 c4             	mov    %r8d,%r12d
  809d55:	4c 89 cb             	mov    %r9,%rbx
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  809d58:	49 8d 41 10          	lea    0x10(%r9),%rax
  809d5c:	48 89 85 68 fd ff ff 	mov    %rax,-0x298(%rbp)
  809d63:	48 89 c7             	mov    %rax,%rdi
  809d66:	48 b8 10 93 80 00 00 	movabs $0x809310,%rax
  809d6d:	00 00 00 
  809d70:	ff d0                	call   *%rax
  809d72:	41 89 c7             	mov    %eax,%r15d
  if(info_png->interlace_method == 0) {
  809d75:	83 7b 08 00          	cmpl   $0x0,0x8(%rbx)
  809d79:	0f 85 28 01 00 00    	jne    809ea7 <preProcessScanlines+0x183>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
  809d7f:	44 0f af f0          	imul   %eax,%r14d
  809d83:	44 89 b5 b8 fd ff ff 	mov    %r14d,-0x248(%rbp)
  809d8a:	41 8d 5e 07          	lea    0x7(%r14),%ebx
  809d8e:	89 9d b0 fd ff ff    	mov    %ebx,-0x250(%rbp)
  809d94:	c1 eb 03             	shr    $0x3,%ebx
  809d97:	41 89 de             	mov    %ebx,%r14d
  809d9a:	41 83 c6 01          	add    $0x1,%r14d
  809d9e:	45 0f af f4          	imul   %r12d,%r14d
  809da2:	44 89 f1             	mov    %r14d,%ecx
  809da5:	49 89 4d 00          	mov    %rcx,0x0(%r13)
  return jos_malloc(size);
  809da9:	44 89 f7             	mov    %r14d,%edi
  809dac:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  809db3:	00 00 00 
  809db6:	ff d0                	call   *%rax
  809db8:	48 89 c7             	mov    %rax,%rdi
    *out = (unsigned char*)lodepng_malloc(*outsize);
  809dbb:	48 8b 85 70 fd ff ff 	mov    -0x290(%rbp),%rax
  809dc2:	48 89 38             	mov    %rdi,(%rax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
  809dc5:	48 85 ff             	test   %rdi,%rdi
  809dc8:	74 4b                	je     809e15 <preProcessScanlines+0xf1>
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
  809dca:	41 83 ff 07          	cmp    $0x7,%r15d
  809dce:	77 17                	ja     809de7 <preProcessScanlines+0xc3>
  809dd0:	44 8b ad b0 fd ff ff 	mov    -0x250(%rbp),%r13d
  809dd7:	41 83 e5 f8          	and    $0xfffffff8,%r13d
  809ddb:	44 8b bd b8 fd ff ff 	mov    -0x248(%rbp),%r15d
  809de2:	45 39 ef             	cmp    %r13d,%r15d
  809de5:	75 3f                	jne    809e26 <preProcessScanlines+0x102>
        error = filter(*out, in, w, h, &info_png->color, settings);
  809de7:	4c 8b 4d 10          	mov    0x10(%rbp),%r9
  809deb:	4c 8b 85 68 fd ff ff 	mov    -0x298(%rbp),%r8
  809df2:	44 89 e1             	mov    %r12d,%ecx
  809df5:	8b 95 c4 fd ff ff    	mov    -0x23c(%rbp),%edx
  809dfb:	48 8b b5 c8 fd ff ff 	mov    -0x238(%rbp),%rsi
  809e02:	48 b8 34 93 80 00 00 	movabs $0x809334,%rax
  809e09:	00 00 00 
  809e0c:	ff d0                	call   *%rax
  809e0e:	89 c3                	mov    %eax,%ebx
  809e10:	e9 31 01 00 00       	jmp    809f46 <preProcessScanlines+0x222>
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
  809e15:	bb 53 00 00 00       	mov    $0x53,%ebx
  809e1a:	49 83 7d 00 00       	cmpq   $0x0,0x0(%r13)
  809e1f:	74 a9                	je     809dca <preProcessScanlines+0xa6>
  809e21:	e9 20 01 00 00       	jmp    809f46 <preProcessScanlines+0x222>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
  809e26:	44 89 f7             	mov    %r14d,%edi
  809e29:	44 29 e7             	sub    %r12d,%edi
  return jos_malloc(size);
  809e2c:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  809e33:	00 00 00 
  809e36:	ff d0                	call   *%rax
  809e38:	49 89 c6             	mov    %rax,%r14
        if(!padded) error = 83; /*alloc fail*/
  809e3b:	bb 53 00 00 00       	mov    $0x53,%ebx
  809e40:	48 85 c0             	test   %rax,%rax
  809e43:	74 4e                	je     809e93 <preProcessScanlines+0x16f>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
  809e45:	44 89 f9             	mov    %r15d,%ecx
  809e48:	44 89 ea             	mov    %r13d,%edx
  809e4b:	45 89 e0             	mov    %r12d,%r8d
  809e4e:	48 8b b5 c8 fd ff ff 	mov    -0x238(%rbp),%rsi
  809e55:	48 89 c7             	mov    %rax,%rdi
  809e58:	48 b8 e7 43 80 00 00 	movabs $0x8043e7,%rax
  809e5f:	00 00 00 
  809e62:	ff d0                	call   *%rax
          error = filter(*out, padded, w, h, &info_png->color, settings);
  809e64:	4c 8b 4d 10          	mov    0x10(%rbp),%r9
  809e68:	4c 8b 85 68 fd ff ff 	mov    -0x298(%rbp),%r8
  809e6f:	44 89 e1             	mov    %r12d,%ecx
  809e72:	8b 95 c4 fd ff ff    	mov    -0x23c(%rbp),%edx
  809e78:	4c 89 f6             	mov    %r14,%rsi
  809e7b:	48 8b 85 70 fd ff ff 	mov    -0x290(%rbp),%rax
  809e82:	48 8b 38             	mov    (%rax),%rdi
  809e85:	48 b8 34 93 80 00 00 	movabs $0x809334,%rax
  809e8c:	00 00 00 
  809e8f:	ff d0                	call   *%rax
  809e91:	89 c3                	mov    %eax,%ebx
    jos_free(ptr);
  809e93:	4c 89 f7             	mov    %r14,%rdi
  809e96:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  809e9d:	00 00 00 
  809ea0:	ff d0                	call   *%rax
}
  809ea2:	e9 9f 00 00 00       	jmp    809f46 <preProcessScanlines+0x222>
    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
  809ea7:	50                   	push   %rax
  809ea8:	41 54                	push   %r12
  809eaa:	44 8b 8d c4 fd ff ff 	mov    -0x23c(%rbp),%r9d
  809eb1:	4c 8d 85 d0 fe ff ff 	lea    -0x130(%rbp),%r8
  809eb8:	48 8d 8d 90 fe ff ff 	lea    -0x170(%rbp),%rcx
  809ebf:	48 8d 95 50 fe ff ff 	lea    -0x1b0(%rbp),%rdx
  809ec6:	48 8d b5 fc fd ff ff 	lea    -0x204(%rbp),%rsi
  809ecd:	48 8d bd e0 fd ff ff 	lea    -0x220(%rbp),%rdi
  809ed4:	48 b8 d5 35 80 00 00 	movabs $0x8035d5,%rax
  809edb:	00 00 00 
  809ede:	ff d0                	call   *%rax
    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
  809ee0:	48 8b bd 88 fe ff ff 	mov    -0x178(%rbp),%rdi
  809ee7:	49 89 7d 00          	mov    %rdi,0x0(%r13)
  return jos_malloc(size);
  809eeb:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  809ef2:	00 00 00 
  809ef5:	ff d0                	call   *%rax
    *out = (unsigned char*)lodepng_malloc(*outsize);
  809ef7:	48 8b 9d 70 fd ff ff 	mov    -0x290(%rbp),%rbx
  809efe:	48 89 03             	mov    %rax,(%rbx)
    if(!(*out)) error = 83; /*alloc fail*/
  809f01:	48 83 c4 10          	add    $0x10,%rsp
  809f05:	48 85 c0             	test   %rax,%rax
  809f08:	0f 84 1c 05 00 00    	je     80a42a <preProcessScanlines+0x706>
  return jos_malloc(size);
  809f0e:	8b bd 08 ff ff ff    	mov    -0xf8(%rbp),%edi
  809f14:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  809f1b:	00 00 00 
  809f1e:	ff d0                	call   *%rax
  809f20:	49 89 c5             	mov    %rax,%r13
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
  809f23:	48 85 c0             	test   %rax,%rax
  809f26:	75 2f                	jne    809f57 <preProcessScanlines+0x233>
  809f28:	48 83 bd 08 ff ff ff 	cmpq   $0x0,-0xf8(%rbp)
  809f2f:	00 
  809f30:	74 25                	je     809f57 <preProcessScanlines+0x233>
  809f32:	bb 53 00 00 00       	mov    $0x53,%ebx
    jos_free(ptr);
  809f37:	4c 89 ef             	mov    %r13,%rdi
  809f3a:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  809f41:	00 00 00 
  809f44:	ff d0                	call   *%rax
}
  809f46:	89 d8                	mov    %ebx,%eax
  809f48:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  809f4c:	5b                   	pop    %rbx
  809f4d:	41 5c                	pop    %r12
  809f4f:	41 5d                	pop    %r13
  809f51:	41 5e                	pop    %r14
  809f53:	41 5f                	pop    %r15
  809f55:	5d                   	pop    %rbp
  809f56:	c3                   	ret    
  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
  809f57:	41 57                	push   %r15
  809f59:	41 54                	push   %r12
  809f5b:	44 8b 8d c4 fd ff ff 	mov    -0x23c(%rbp),%r9d
  809f62:	4c 8d 45 90          	lea    -0x70(%rbp),%r8
  809f66:	48 8d 8d 50 ff ff ff 	lea    -0xb0(%rbp),%rcx
  809f6d:	48 8d 95 10 ff ff ff 	lea    -0xf0(%rbp),%rdx
  809f74:	48 8d b5 34 fe ff ff 	lea    -0x1cc(%rbp),%rsi
  809f7b:	48 8d bd 18 fe ff ff 	lea    -0x1e8(%rbp),%rdi
  809f82:	48 b8 d5 35 80 00 00 	movabs $0x8035d5,%rax
  809f89:	00 00 00 
  809f8c:	ff d0                	call   *%rax
  if(bpp >= 8) {
  809f8e:	48 83 c4 10          	add    $0x10,%rsp
  809f92:	41 83 ff 07          	cmp    $0x7,%r15d
  809f96:	0f 86 45 01 00 00    	jbe    80a0e1 <preProcessScanlines+0x3bd>
      size_t bytewidth = bpp / 8u;
  809f9c:	44 89 ff             	mov    %r15d,%edi
  809f9f:	c1 ef 03             	shr    $0x3,%edi
  809fa2:	89 ff                	mov    %edi,%edi
  809fa4:	4c 8d a5 18 fe ff ff 	lea    -0x1e8(%rbp),%r12
  809fab:	bb 00 00 00 00       	mov    $0x0,%ebx
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
  809fb0:	44 89 bd a0 fd ff ff 	mov    %r15d,-0x260(%rbp)
  809fb7:	4c 8b b5 c8 fd ff ff 	mov    -0x238(%rbp),%r14
  809fbe:	e9 ad 00 00 00       	jmp    80a070 <preProcessScanlines+0x34c>
      for(y = 0; y < passh[i]; ++y)
  809fc3:	41 83 c1 01          	add    $0x1,%r9d
  809fc7:	44 3b 8c 2b 34 fe ff 	cmp    -0x1cc(%rbx,%rbp,1),%r9d
  809fce:	ff 
  809fcf:	0f 83 8d 00 00 00    	jae    80a062 <preProcessScanlines+0x33e>
      for(x = 0; x < passw[i]; ++x) {
  809fd5:	4d 89 e2             	mov    %r12,%r10
  809fd8:	41 8b 04 24          	mov    (%r12),%eax
  809fdc:	85 c0                	test   %eax,%eax
  809fde:	74 e3                	je     809fc3 <preProcessScanlines+0x29f>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
  809fe0:	48 8b 8d b8 fd ff ff 	mov    -0x248(%rbp),%rcx
  809fe7:	44 8b 19             	mov    (%rcx),%r11d
  809fea:	48 8b 8d b0 fd ff ff 	mov    -0x250(%rbp),%rcx
  809ff1:	44 89 ce             	mov    %r9d,%esi
  809ff4:	0f af 31             	imul   (%rcx),%esi
  809ff7:	48 8b 8d a8 fd ff ff 	mov    -0x258(%rbp),%rcx
  809ffe:	03 31                	add    (%rcx),%esi
  80a000:	0f af b5 c4 fd ff ff 	imul   -0x23c(%rbp),%esi
  80a007:	41 03 37             	add    (%r15),%esi
      for(x = 0; x < passw[i]; ++x) {
  80a00a:	b9 00 00 00 00       	mov    $0x0,%ecx
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
  80a00f:	89 f2                	mov    %esi,%edx
  80a011:	48 0f af d7          	imul   %rdi,%rdx
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
  80a015:	41 0f af c1          	imul   %r9d,%eax
  80a019:	01 c8                	add    %ecx,%eax
  80a01b:	89 c0                	mov    %eax,%eax
  80a01d:	48 0f af c7          	imul   %rdi,%rax
  80a021:	48 03 44 5d 90       	add    -0x70(%rbp,%rbx,2),%rax
  80a026:	41 b8 00 00 00 00    	mov    $0x0,%r8d
          out[pixeloutstart + b] = in[pixelinstart + b];
  80a02c:	4c 01 f2             	add    %r14,%rdx
  80a02f:	4c 01 e8             	add    %r13,%rax
  80a032:	89 8d c8 fd ff ff    	mov    %ecx,-0x238(%rbp)
  80a038:	42 0f b6 0c 02       	movzbl (%rdx,%r8,1),%ecx
  80a03d:	42 88 0c 00          	mov    %cl,(%rax,%r8,1)
        for(b = 0; b < bytewidth; ++b) {
  80a041:	49 83 c0 01          	add    $0x1,%r8
  80a045:	49 39 f8             	cmp    %rdi,%r8
  80a048:	75 ee                	jne    80a038 <preProcessScanlines+0x314>
      for(x = 0; x < passw[i]; ++x) {
  80a04a:	8b 8d c8 fd ff ff    	mov    -0x238(%rbp),%ecx
  80a050:	83 c1 01             	add    $0x1,%ecx
  80a053:	41 8b 02             	mov    (%r10),%eax
  80a056:	44 01 de             	add    %r11d,%esi
  80a059:	39 c8                	cmp    %ecx,%eax
  80a05b:	77 b2                	ja     80a00f <preProcessScanlines+0x2eb>
  80a05d:	e9 61 ff ff ff       	jmp    809fc3 <preProcessScanlines+0x29f>
    for(i = 0; i != 7; ++i) {
  80a062:	49 83 c4 04          	add    $0x4,%r12
  80a066:	48 83 c3 04          	add    $0x4,%rbx
  80a06a:	48 83 fb 1c          	cmp    $0x1c,%rbx
  80a06e:	74 5f                	je     80a0cf <preProcessScanlines+0x3ab>
      for(y = 0; y < passh[i]; ++y)
  80a070:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80a076:	83 bc 2b 34 fe ff ff 	cmpl   $0x0,-0x1cc(%rbx,%rbp,1)
  80a07d:	00 
  80a07e:	74 e2                	je     80a062 <preProcessScanlines+0x33e>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
  80a080:	48 b8 70 1f 81 00 00 	movabs $0x811f70,%rax
  80a087:	00 00 00 
  80a08a:	48 01 d8             	add    %rbx,%rax
  80a08d:	48 89 85 b8 fd ff ff 	mov    %rax,-0x248(%rbp)
  80a094:	48 b8 50 1f 81 00 00 	movabs $0x811f50,%rax
  80a09b:	00 00 00 
  80a09e:	48 01 d8             	add    %rbx,%rax
  80a0a1:	48 89 85 b0 fd ff ff 	mov    %rax,-0x250(%rbp)
  80a0a8:	48 b8 90 1f 81 00 00 	movabs $0x811f90,%rax
  80a0af:	00 00 00 
  80a0b2:	48 01 d8             	add    %rbx,%rax
  80a0b5:	48 89 85 a8 fd ff ff 	mov    %rax,-0x258(%rbp)
  80a0bc:	48 b8 b0 1f 81 00 00 	movabs $0x811fb0,%rax
  80a0c3:	00 00 00 
  80a0c6:	4c 8d 3c 03          	lea    (%rbx,%rax,1),%r15
  80a0ca:	e9 06 ff ff ff       	jmp    809fd5 <preProcessScanlines+0x2b1>
  80a0cf:	44 8b bd a0 fd ff ff 	mov    -0x260(%rbp),%r15d
      for(i = 0; i != 7; ++i) {
  80a0d6:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80a0dc:	e9 87 02 00 00       	jmp    80a368 <preProcessScanlines+0x644>
      unsigned olinebits = bpp * w;
  80a0e1:	8b 85 c4 fd ff ff    	mov    -0x23c(%rbp),%eax
  80a0e7:	41 0f af c7          	imul   %r15d,%eax
  80a0eb:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%rbp)
  80a0f1:	48 8d 85 18 fe ff ff 	lea    -0x1e8(%rbp),%rax
  80a0f8:	48 89 85 60 fd ff ff 	mov    %rax,-0x2a0(%rbp)
  80a0ff:	48 b8 90 1f 81 00 00 	movabs $0x811f90,%rax
  80a106:	00 00 00 
  80a109:	48 89 85 a0 fd ff ff 	mov    %rax,-0x260(%rbp)
  80a110:	48 b8 50 1f 81 00 00 	movabs $0x811f50,%rax
  80a117:	00 00 00 
  80a11a:	48 89 85 98 fd ff ff 	mov    %rax,-0x268(%rbp)
  80a121:	48 b8 b0 1f 81 00 00 	movabs $0x811fb0,%rax
  80a128:	00 00 00 
  80a12b:	48 89 85 90 fd ff ff 	mov    %rax,-0x270(%rbp)
  80a132:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  80a136:	48 89 85 88 fd ff ff 	mov    %rax,-0x278(%rbp)
  80a13d:	48 c7 85 80 fd ff ff 	movq   $0x0,-0x280(%rbp)
  80a144:	00 00 00 00 
          unsigned char bit = readBitFromReversedStream(&ibp, in);
  80a148:	4d 89 ee             	mov    %r13,%r14
  80a14b:	e9 62 01 00 00       	jmp    80a2b2 <preProcessScanlines+0x58e>
  80a150:	48 8b b5 c8 fd ff ff 	mov    -0x238(%rbp),%rsi
  80a157:	48 8d bd d8 fd ff ff 	lea    -0x228(%rbp),%rdi
  80a15e:	48 b8 78 2d 80 00 00 	movabs $0x802d78,%rax
  80a165:	00 00 00 
  80a168:	ff d0                	call   *%rax
          setBitOfReversedStream(&obp, out, bit);
  80a16a:	0f b6 d0             	movzbl %al,%edx
  80a16d:	4c 89 f6             	mov    %r14,%rsi
  80a170:	48 8d bd d0 fd ff ff 	lea    -0x230(%rbp),%rdi
  80a177:	41 ff d5             	call   *%r13
        for(b = 0; b < bpp; ++b) {
  80a17a:	83 c3 01             	add    $0x1,%ebx
  80a17d:	41 39 df             	cmp    %ebx,%r15d
  80a180:	75 ce                	jne    80a150 <preProcessScanlines+0x42c>
      for(x = 0; x < passw[i]; ++x) {
  80a182:	41 83 c4 01          	add    $0x1,%r12d
  80a186:	44 01 bd c4 fd ff ff 	add    %r15d,-0x23c(%rbp)
  80a18d:	48 8b 85 b0 fd ff ff 	mov    -0x250(%rbp),%rax
  80a194:	44 3b 20             	cmp    (%rax),%r12d
  80a197:	73 71                	jae    80a20a <preProcessScanlines+0x4e6>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
  80a199:	48 8b 8d 98 fd ff ff 	mov    -0x268(%rbp),%rcx
  80a1a0:	8b 85 b8 fd ff ff    	mov    -0x248(%rbp),%eax
  80a1a6:	0f af 01             	imul   (%rcx),%eax
  80a1a9:	48 8b 8d a0 fd ff ff 	mov    -0x260(%rbp),%rcx
  80a1b0:	03 01                	add    (%rcx),%eax
  80a1b2:	0f af 85 c0 fd ff ff 	imul   -0x240(%rbp),%eax
  80a1b9:	89 c2                	mov    %eax,%edx
  80a1bb:	48 8b b5 a8 fd ff ff 	mov    -0x258(%rbp),%rsi
  80a1c2:	44 89 e0             	mov    %r12d,%eax
  80a1c5:	0f af 06             	imul   (%rsi),%eax
  80a1c8:	48 8b 8d 90 fd ff ff 	mov    -0x270(%rbp),%rcx
  80a1cf:	03 01                	add    (%rcx),%eax
  80a1d1:	41 0f af c7          	imul   %r15d,%eax
  80a1d5:	01 d0                	add    %edx,%eax
  80a1d7:	89 c0                	mov    %eax,%eax
  80a1d9:	48 89 85 d8 fd ff ff 	mov    %rax,-0x228(%rbp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
  80a1e0:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
  80a1e7:	48 8b 10             	mov    (%rax),%rdx
  80a1ea:	8b 85 c4 fd ff ff    	mov    -0x23c(%rbp),%eax
  80a1f0:	48 8d 04 d0          	lea    (%rax,%rdx,8),%rax
  80a1f4:	48 89 85 d0 fd ff ff 	mov    %rax,-0x230(%rbp)
        for(b = 0; b < bpp; ++b) {
  80a1fb:	45 85 ff             	test   %r15d,%r15d
  80a1fe:	74 82                	je     80a182 <preProcessScanlines+0x45e>
  80a200:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a205:	e9 46 ff ff ff       	jmp    80a150 <preProcessScanlines+0x42c>
      for(y = 0; y < passh[i]; ++y)
  80a20a:	83 85 b8 fd ff ff 01 	addl   $0x1,-0x248(%rbp)
  80a211:	8b 85 b8 fd ff ff    	mov    -0x248(%rbp),%eax
  80a217:	8b 8d 78 fd ff ff    	mov    -0x288(%rbp),%ecx
  80a21d:	01 8d 7c fd ff ff    	add    %ecx,-0x284(%rbp)
  80a223:	48 8b 8d 80 fd ff ff 	mov    -0x280(%rbp),%rcx
  80a22a:	3b 84 0d 34 fe ff ff 	cmp    -0x1cc(%rbp,%rcx,1),%eax
  80a231:	73 3c                	jae    80a26f <preProcessScanlines+0x54b>
      for(x = 0; x < passw[i]; ++x) {
  80a233:	8b 85 7c fd ff ff    	mov    -0x284(%rbp),%eax
  80a239:	89 85 c4 fd ff ff    	mov    %eax,-0x23c(%rbp)
  80a23f:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
  80a245:	48 b8 70 1f 81 00 00 	movabs $0x811f70,%rax
  80a24c:	00 00 00 
  80a24f:	48 03 85 80 fd ff ff 	add    -0x280(%rbp),%rax
  80a256:	48 89 85 a8 fd ff ff 	mov    %rax,-0x258(%rbp)
      for(x = 0; x < passw[i]; ++x) {
  80a25d:	48 8b 85 b0 fd ff ff 	mov    -0x250(%rbp),%rax
  80a264:	83 38 00             	cmpl   $0x0,(%rax)
  80a267:	0f 85 2c ff ff ff    	jne    80a199 <preProcessScanlines+0x475>
  80a26d:	eb 9b                	jmp    80a20a <preProcessScanlines+0x4e6>
    for(i = 0; i != 7; ++i) {
  80a26f:	48 83 85 60 fd ff ff 	addq   $0x4,-0x2a0(%rbp)
  80a276:	04 
  80a277:	48 8b 85 60 fd ff ff 	mov    -0x2a0(%rbp),%rax
  80a27e:	48 83 85 a0 fd ff ff 	addq   $0x4,-0x260(%rbp)
  80a285:	04 
  80a286:	48 83 85 98 fd ff ff 	addq   $0x4,-0x268(%rbp)
  80a28d:	04 
  80a28e:	48 83 85 90 fd ff ff 	addq   $0x4,-0x270(%rbp)
  80a295:	04 
  80a296:	48 83 85 88 fd ff ff 	addq   $0x8,-0x278(%rbp)
  80a29d:	08 
  80a29e:	48 83 85 80 fd ff ff 	addq   $0x4,-0x280(%rbp)
  80a2a5:	04 
  80a2a6:	48 8d 9d 34 fe ff ff 	lea    -0x1cc(%rbp),%rbx
  80a2ad:	48 39 d8             	cmp    %rbx,%rax
  80a2b0:	74 52                	je     80a304 <preProcessScanlines+0x5e0>
      unsigned ilinebits = bpp * passw[i];
  80a2b2:	48 8b 85 60 fd ff ff 	mov    -0x2a0(%rbp),%rax
  80a2b9:	48 89 85 b0 fd ff ff 	mov    %rax,-0x250(%rbp)
  80a2c0:	44 89 fb             	mov    %r15d,%ebx
  80a2c3:	0f af 18             	imul   (%rax),%ebx
  80a2c6:	89 9d 78 fd ff ff    	mov    %ebx,-0x288(%rbp)
      for(y = 0; y < passh[i]; ++y)
  80a2cc:	c7 85 7c fd ff ff 00 	movl   $0x0,-0x284(%rbp)
  80a2d3:	00 00 00 
  80a2d6:	c7 85 b8 fd ff ff 00 	movl   $0x0,-0x248(%rbp)
  80a2dd:	00 00 00 
          setBitOfReversedStream(&obp, out, bit);
  80a2e0:	49 bd 00 2e 80 00 00 	movabs $0x802e00,%r13
  80a2e7:	00 00 00 
      for(y = 0; y < passh[i]; ++y)
  80a2ea:	48 8b 85 80 fd ff ff 	mov    -0x280(%rbp),%rax
  80a2f1:	83 bc 05 34 fe ff ff 	cmpl   $0x0,-0x1cc(%rbp,%rax,1)
  80a2f8:	00 
  80a2f9:	0f 85 34 ff ff ff    	jne    80a233 <preProcessScanlines+0x50f>
  80a2ff:	e9 6b ff ff ff       	jmp    80a26f <preProcessScanlines+0x54b>
  80a304:	4d 89 f5             	mov    %r14,%r13
  80a307:	e9 ca fd ff ff       	jmp    80a0d6 <preProcessScanlines+0x3b2>
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
  80a30c:	42 8b 8c 25 fc fd ff 	mov    -0x204(%rbp,%r12,1),%ecx
  80a313:	ff 
  80a314:	42 8b 94 25 e0 fd ff 	mov    -0x220(%rbp,%r12,1),%edx
  80a31b:	ff 
  80a31c:	4c 89 ee             	mov    %r13,%rsi
  80a31f:	4a 03 b4 65 90 fe ff 	add    -0x170(%rbp,%r12,2),%rsi
  80a326:	ff 
  80a327:	4a 8b bc 65 50 fe ff 	mov    -0x1b0(%rbp,%r12,2),%rdi
  80a32e:	ff 
  80a32f:	48 8b 85 70 fd ff ff 	mov    -0x290(%rbp),%rax
  80a336:	48 03 38             	add    (%rax),%rdi
  80a339:	4c 8b 4d 10          	mov    0x10(%rbp),%r9
  80a33d:	4c 8b 85 68 fd ff ff 	mov    -0x298(%rbp),%r8
  80a344:	48 b8 34 93 80 00 00 	movabs $0x809334,%rax
  80a34b:	00 00 00 
  80a34e:	ff d0                	call   *%rax
  80a350:	89 c3                	mov    %eax,%ebx
        if(error) break;
  80a352:	85 db                	test   %ebx,%ebx
  80a354:	0f 85 dd fb ff ff    	jne    809f37 <preProcessScanlines+0x213>
      for(i = 0; i != 7; ++i) {
  80a35a:	49 83 c4 04          	add    $0x4,%r12
  80a35e:	49 83 fc 1c          	cmp    $0x1c,%r12
  80a362:	0f 84 cf fb ff ff    	je     809f37 <preProcessScanlines+0x213>
        if(bpp < 8) {
  80a368:	41 83 ff 07          	cmp    $0x7,%r15d
  80a36c:	77 9e                	ja     80a30c <preProcessScanlines+0x5e8>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
  80a36e:	4a 8b bc 65 98 fe ff 	mov    -0x168(%rbp,%r12,2),%rdi
  80a375:	ff 
  80a376:	4a 2b bc 65 90 fe ff 	sub    -0x170(%rbp,%r12,2),%rdi
  80a37d:	ff 
  return jos_malloc(size);
  80a37e:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80a385:	00 00 00 
  80a388:	ff d0                	call   *%rax
  80a38a:	49 89 c6             	mov    %rax,%r14
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
  80a38d:	48 85 c0             	test   %rax,%rax
  80a390:	0f 84 8a 00 00 00    	je     80a420 <preProcessScanlines+0x6fc>
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
  80a396:	44 89 f8             	mov    %r15d,%eax
  80a399:	42 0f af 84 25 e0 fd 	imul   -0x220(%rbp,%r12,1),%eax
  80a3a0:	ff ff 
          addPaddingBits(padded, &adam7[passstart[i]],
  80a3a2:	89 c1                	mov    %eax,%ecx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
  80a3a4:	83 c0 07             	add    $0x7,%eax
          addPaddingBits(padded, &adam7[passstart[i]],
  80a3a7:	89 c2                	mov    %eax,%edx
  80a3a9:	83 e2 f8             	and    $0xfffffff8,%edx
  80a3ac:	4c 89 ee             	mov    %r13,%rsi
  80a3af:	4a 03 b4 65 d0 fe ff 	add    -0x130(%rbp,%r12,2),%rsi
  80a3b6:	ff 
  80a3b7:	46 8b 84 25 fc fd ff 	mov    -0x204(%rbp,%r12,1),%r8d
  80a3be:	ff 
  80a3bf:	4c 89 f7             	mov    %r14,%rdi
  80a3c2:	48 b8 e7 43 80 00 00 	movabs $0x8043e7,%rax
  80a3c9:	00 00 00 
  80a3cc:	ff d0                	call   *%rax
          error = filter(&(*out)[filter_passstart[i]], padded,
  80a3ce:	42 8b 8c 25 fc fd ff 	mov    -0x204(%rbp,%r12,1),%ecx
  80a3d5:	ff 
  80a3d6:	42 8b 94 25 e0 fd ff 	mov    -0x220(%rbp,%r12,1),%edx
  80a3dd:	ff 
  80a3de:	4a 8b bc 65 50 fe ff 	mov    -0x1b0(%rbp,%r12,2),%rdi
  80a3e5:	ff 
  80a3e6:	48 8b 85 70 fd ff ff 	mov    -0x290(%rbp),%rax
  80a3ed:	48 03 38             	add    (%rax),%rdi
  80a3f0:	4c 8b 4d 10          	mov    0x10(%rbp),%r9
  80a3f4:	4c 8b 85 68 fd ff ff 	mov    -0x298(%rbp),%r8
  80a3fb:	4c 89 f6             	mov    %r14,%rsi
  80a3fe:	48 b8 34 93 80 00 00 	movabs $0x809334,%rax
  80a405:	00 00 00 
  80a408:	ff d0                	call   *%rax
  80a40a:	89 c3                	mov    %eax,%ebx
    jos_free(ptr);
  80a40c:	4c 89 f7             	mov    %r14,%rdi
  80a40f:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  80a416:	00 00 00 
  80a419:	ff d0                	call   *%rax
}
  80a41b:	e9 32 ff ff ff       	jmp    80a352 <preProcessScanlines+0x62e>
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
  80a420:	bb 53 00 00 00       	mov    $0x53,%ebx
  80a425:	e9 0d fb ff ff       	jmp    809f37 <preProcessScanlines+0x213>
  return jos_malloc(size);
  80a42a:	8b bd 08 ff ff ff    	mov    -0xf8(%rbp),%edi
  80a430:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80a437:	00 00 00 
  80a43a:	ff d0                	call   *%rax
  80a43c:	49 89 c5             	mov    %rax,%r13
    if(!(*out)) error = 83; /*alloc fail*/
  80a43f:	bb 53 00 00 00       	mov    $0x53,%ebx
  80a444:	e9 ee fa ff ff       	jmp    809f37 <preProcessScanlines+0x213>

000000000080a449 <lodepng_get_channels>:
unsigned lodepng_get_channels(const LodePNGColorMode* info) {
  80a449:	55                   	push   %rbp
  80a44a:	48 89 e5             	mov    %rsp,%rbp
  return getNumColorChannels(info->colortype);
  80a44d:	8b 3f                	mov    (%rdi),%edi
  80a44f:	48 b8 c3 2e 80 00 00 	movabs $0x802ec3,%rax
  80a456:	00 00 00 
  80a459:	ff d0                	call   *%rax
}
  80a45b:	5d                   	pop    %rbp
  80a45c:	c3                   	ret    

000000000080a45d <lodepng_is_greyscale_type>:
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
  80a45d:	f7 07 fb ff ff ff    	testl  $0xfffffffb,(%rdi)
  80a463:	0f 94 c0             	sete   %al
  80a466:	0f b6 c0             	movzbl %al,%eax
}
  80a469:	c3                   	ret    

000000000080a46a <lodepng_is_alpha_type>:
  return (info->colortype & 4) != 0; /*4 or 6*/
  80a46a:	8b 07                	mov    (%rdi),%eax
  80a46c:	c1 e8 02             	shr    $0x2,%eax
  80a46f:	83 e0 01             	and    $0x1,%eax
}
  80a472:	c3                   	ret    

000000000080a473 <lodepng_is_palette_type>:
  return info->colortype == LCT_PALETTE;
  80a473:	83 3f 03             	cmpl   $0x3,(%rdi)
  80a476:	0f 94 c0             	sete   %al
  80a479:	0f b6 c0             	movzbl %al,%eax
}
  80a47c:	c3                   	ret    

000000000080a47d <lodepng_has_palette_alpha>:
  for(i = 0; i != info->palettesize; ++i) {
  80a47d:	48 8b 57 10          	mov    0x10(%rdi),%rdx
  80a481:	48 85 d2             	test   %rdx,%rdx
  80a484:	74 1f                	je     80a4a5 <lodepng_has_palette_alpha+0x28>
    if(info->palette[i * 4 + 3] < 255) return 1;
  80a486:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
  for(i = 0; i != info->palettesize; ++i) {
  80a48a:	b8 00 00 00 00       	mov    $0x0,%eax
    if(info->palette[i * 4 + 3] < 255) return 1;
  80a48f:	80 7c 81 03 ff       	cmpb   $0xff,0x3(%rcx,%rax,4)
  80a494:	75 15                	jne    80a4ab <lodepng_has_palette_alpha+0x2e>
  for(i = 0; i != info->palettesize; ++i) {
  80a496:	48 83 c0 01          	add    $0x1,%rax
  80a49a:	48 39 d0             	cmp    %rdx,%rax
  80a49d:	75 f0                	jne    80a48f <lodepng_has_palette_alpha+0x12>
  return 0;
  80a49f:	b8 00 00 00 00       	mov    $0x0,%eax
  80a4a4:	c3                   	ret    
  80a4a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a4aa:	c3                   	ret    
    if(info->palette[i * 4 + 3] < 255) return 1;
  80a4ab:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80a4b0:	c3                   	ret    

000000000080a4b1 <lodepng_can_have_alpha>:
      || lodepng_has_palette_alpha(info);
  80a4b1:	b8 01 00 00 00       	mov    $0x1,%eax
  80a4b6:	83 7f 18 00          	cmpl   $0x0,0x18(%rdi)
  80a4ba:	75 05                	jne    80a4c1 <lodepng_can_have_alpha+0x10>
      || lodepng_is_alpha_type(info)
  80a4bc:	f6 07 04             	testb  $0x4,(%rdi)
  80a4bf:	74 01                	je     80a4c2 <lodepng_can_have_alpha+0x11>
}
  80a4c1:	c3                   	ret    
unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  80a4c2:	55                   	push   %rbp
  80a4c3:	48 89 e5             	mov    %rsp,%rbp
      || lodepng_has_palette_alpha(info);
  80a4c6:	48 b8 7d a4 80 00 00 	movabs $0x80a47d,%rax
  80a4cd:	00 00 00 
  80a4d0:	ff d0                	call   *%rax
  80a4d2:	85 c0                	test   %eax,%eax
  80a4d4:	0f 95 c0             	setne  %al
  80a4d7:	0f b6 c0             	movzbl %al,%eax
}
  80a4da:	5d                   	pop    %rbp
  80a4db:	c3                   	ret    

000000000080a4dc <lodepng_get_raw_size>:
size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
  80a4dc:	55                   	push   %rbp
  80a4dd:	48 89 e5             	mov    %rsp,%rbp
  80a4e0:	41 55                	push   %r13
  80a4e2:	41 54                	push   %r12
  80a4e4:	53                   	push   %rbx
  80a4e5:	48 83 ec 08          	sub    $0x8,%rsp
  80a4e9:	89 fb                	mov    %edi,%ebx
  80a4eb:	41 89 f4             	mov    %esi,%r12d
  80a4ee:	49 89 d5             	mov    %rdx,%r13
  return getNumColorChannels(colortype) * bitdepth;
  80a4f1:	8b 3a                	mov    (%rdx),%edi
  80a4f3:	48 b8 c3 2e 80 00 00 	movabs $0x802ec3,%rax
  80a4fa:	00 00 00 
  80a4fd:	ff d0                	call   *%rax
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
  80a4ff:	89 c1                	mov    %eax,%ecx
  80a501:	41 0f af 4d 04       	imul   0x4(%r13),%ecx
  size_t n = (size_t)w * (size_t)h;
  80a506:	89 d8                	mov    %ebx,%eax
  80a508:	45 89 e4             	mov    %r12d,%r12d
  80a50b:	49 0f af c4          	imul   %r12,%rax
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
  80a50f:	48 89 c2             	mov    %rax,%rdx
  80a512:	83 e2 07             	and    $0x7,%edx
  80a515:	48 0f af d1          	imul   %rcx,%rdx
  80a519:	48 83 c2 07          	add    $0x7,%rdx
  80a51d:	48 c1 ea 03          	shr    $0x3,%rdx
  80a521:	48 c1 e8 03          	shr    $0x3,%rax
  80a525:	48 0f af c1          	imul   %rcx,%rax
  80a529:	48 01 d0             	add    %rdx,%rax
}
  80a52c:	48 83 c4 08          	add    $0x8,%rsp
  80a530:	5b                   	pop    %rbx
  80a531:	41 5c                	pop    %r12
  80a533:	41 5d                	pop    %r13
  80a535:	5d                   	pop    %rbp
  80a536:	c3                   	ret    

000000000080a537 <lodepng_clear_text>:
void lodepng_clear_text(LodePNGInfo* info) {
  80a537:	55                   	push   %rbp
  80a538:	48 89 e5             	mov    %rsp,%rbp
  LodePNGText_cleanup(info);
  80a53b:	48 b8 8f 51 80 00 00 	movabs $0x80518f,%rax
  80a542:	00 00 00 
  80a545:	ff d0                	call   *%rax
}
  80a547:	5d                   	pop    %rbp
  80a548:	c3                   	ret    

000000000080a549 <lodepng_add_text>:
unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
  80a549:	55                   	push   %rbp
  80a54a:	48 89 e5             	mov    %rsp,%rbp
  80a54d:	41 57                	push   %r15
  80a54f:	41 56                	push   %r14
  80a551:	41 55                	push   %r13
  80a553:	41 54                	push   %r12
  80a555:	53                   	push   %rbx
  80a556:	48 83 ec 08          	sub    $0x8,%rsp
  80a55a:	48 89 fb             	mov    %rdi,%rbx
  80a55d:	49 89 f5             	mov    %rsi,%r13
  80a560:	49 89 d6             	mov    %rdx,%r14
  char** new_keys = (char**)(lodepng_reallocate(info->text_keys, sizeof(char*) * info->text_num, sizeof(char*) * (info->text_num + 1)));
  80a563:	48 8b 77 48          	mov    0x48(%rdi),%rsi
  80a567:	48 8d 14 f5 08 00 00 	lea    0x8(,%rsi,8),%rdx
  80a56e:	00 
  80a56f:	48 c1 e6 03          	shl    $0x3,%rsi
  80a573:	48 8b 7f 50          	mov    0x50(%rdi),%rdi
  80a577:	49 bf b5 45 80 00 00 	movabs $0x8045b5,%r15
  80a57e:	00 00 00 
  80a581:	41 ff d7             	call   *%r15
  80a584:	49 89 c4             	mov    %rax,%r12
  char** new_strings = (char**)(lodepng_reallocate(info->text_strings, sizeof(char*) * info->text_num, sizeof(char*) * (info->text_num + 1)));
  80a587:	48 8b 73 48          	mov    0x48(%rbx),%rsi
  80a58b:	48 8d 14 f5 08 00 00 	lea    0x8(,%rsi,8),%rdx
  80a592:	00 
  80a593:	48 c1 e6 03          	shl    $0x3,%rsi
  80a597:	48 8b 7b 58          	mov    0x58(%rbx),%rdi
  80a59b:	41 ff d7             	call   *%r15
  if(new_keys) info->text_keys = new_keys;
  80a59e:	4d 85 e4             	test   %r12,%r12
  80a5a1:	74 66                	je     80a609 <lodepng_add_text+0xc0>
  80a5a3:	4c 89 63 50          	mov    %r12,0x50(%rbx)
  if(!new_keys || !new_strings) return 83; /*alloc fail*/
  80a5a7:	ba 53 00 00 00       	mov    $0x53,%edx
  if(new_strings) info->text_strings = new_strings;
  80a5ac:	48 85 c0             	test   %rax,%rax
  80a5af:	74 47                	je     80a5f8 <lodepng_add_text+0xaf>
  80a5b1:	48 89 43 58          	mov    %rax,0x58(%rbx)
  ++info->text_num;
  80a5b5:	48 8b 43 48          	mov    0x48(%rbx),%rax
  80a5b9:	48 83 c0 01          	add    $0x1,%rax
  80a5bd:	48 89 43 48          	mov    %rax,0x48(%rbx)
  info->text_keys[info->text_num - 1] = alloc_string(key);
  80a5c1:	48 8b 53 50          	mov    0x50(%rbx),%rdx
  80a5c5:	4c 8d 7c c2 f8       	lea    -0x8(%rdx,%rax,8),%r15
  80a5ca:	4c 89 ef             	mov    %r13,%rdi
  80a5cd:	49 bc ac 59 80 00 00 	movabs $0x8059ac,%r12
  80a5d4:	00 00 00 
  80a5d7:	41 ff d4             	call   *%r12
  80a5da:	49 89 07             	mov    %rax,(%r15)
  info->text_strings[info->text_num - 1] = alloc_string(str);
  80a5dd:	48 8b 53 48          	mov    0x48(%rbx),%rdx
  80a5e1:	48 8b 43 58          	mov    0x58(%rbx),%rax
  80a5e5:	48 8d 5c d0 f8       	lea    -0x8(%rax,%rdx,8),%rbx
  80a5ea:	4c 89 f7             	mov    %r14,%rdi
  80a5ed:	41 ff d4             	call   *%r12
  80a5f0:	48 89 03             	mov    %rax,(%rbx)
  return 0;
  80a5f3:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80a5f8:	89 d0                	mov    %edx,%eax
  80a5fa:	48 83 c4 08          	add    $0x8,%rsp
  80a5fe:	5b                   	pop    %rbx
  80a5ff:	41 5c                	pop    %r12
  80a601:	41 5d                	pop    %r13
  80a603:	41 5e                	pop    %r14
  80a605:	41 5f                	pop    %r15
  80a607:	5d                   	pop    %rbp
  80a608:	c3                   	ret    
  if(!new_keys || !new_strings) return 83; /*alloc fail*/
  80a609:	ba 53 00 00 00       	mov    $0x53,%edx
  if(new_strings) info->text_strings = new_strings;
  80a60e:	48 85 c0             	test   %rax,%rax
  80a611:	74 e5                	je     80a5f8 <lodepng_add_text+0xaf>
  80a613:	48 89 43 58          	mov    %rax,0x58(%rbx)
  if(!new_keys || !new_strings) return 83; /*alloc fail*/
  80a617:	4d 85 e4             	test   %r12,%r12
  80a61a:	75 99                	jne    80a5b5 <lodepng_add_text+0x6c>
  80a61c:	eb da                	jmp    80a5f8 <lodepng_add_text+0xaf>

000000000080a61e <readChunk_tEXt>:
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
  80a61e:	55                   	push   %rbp
  80a61f:	48 89 e5             	mov    %rsp,%rbp
  80a622:	41 57                	push   %r15
  80a624:	41 56                	push   %r14
  80a626:	41 55                	push   %r13
  80a628:	41 54                	push   %r12
  80a62a:	53                   	push   %rbx
  80a62b:	48 83 ec 28          	sub    $0x28,%rsp
  80a62f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80a633:	49 89 f4             	mov    %rsi,%r12
  80a636:	49 89 d5             	mov    %rdx,%r13
    length = 0;
  80a639:	b8 00 00 00 00       	mov    $0x0,%eax
    while(length < chunkLength && data[length] != 0) ++length;
  80a63e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a643:	48 85 d2             	test   %rdx,%rdx
  80a646:	0f 84 db 00 00 00    	je     80a727 <readChunk_tEXt+0x109>
  80a64c:	41 80 3c 1c 00       	cmpb   $0x0,(%r12,%rbx,1)
  80a651:	74 0a                	je     80a65d <readChunk_tEXt+0x3f>
  80a653:	83 c0 01             	add    $0x1,%eax
  80a656:	89 c3                	mov    %eax,%ebx
  80a658:	4c 39 eb             	cmp    %r13,%rbx
  80a65b:	72 ef                	jb     80a64c <readChunk_tEXt+0x2e>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
  80a65d:	44 8d 78 ff          	lea    -0x1(%rax),%r15d
  80a661:	41 83 ff 4e          	cmp    $0x4e,%r15d
  80a665:	0f 87 ca 00 00 00    	ja     80a735 <readChunk_tEXt+0x117>
    key = (char*)lodepng_malloc(length + 1);
  80a66b:	8d 78 01             	lea    0x1(%rax),%edi
  80a66e:	89 7d bc             	mov    %edi,-0x44(%rbp)
  80a671:	89 f8                	mov    %edi,%eax
  80a673:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  return jos_malloc(size);
  80a677:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80a67e:	00 00 00 
  80a681:	ff d0                	call   *%rax
  80a683:	49 89 c6             	mov    %rax,%r14
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
  80a686:	48 85 c0             	test   %rax,%rax
  80a689:	0f 84 df 00 00 00    	je     80a76e <readChunk_tEXt+0x150>
    key[length] = 0;
  80a68f:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
    for(i = 0; i != length; ++i) key[i] = (char)data[i];
  80a693:	45 89 ff             	mov    %r15d,%r15d
    key[length] = 0;
  80a696:	b8 00 00 00 00       	mov    $0x0,%eax
    for(i = 0; i != length; ++i) key[i] = (char)data[i];
  80a69b:	41 0f b6 14 04       	movzbl (%r12,%rax,1),%edx
  80a6a0:	41 88 14 06          	mov    %dl,(%r14,%rax,1)
  80a6a4:	48 89 c2             	mov    %rax,%rdx
  80a6a7:	48 83 c0 01          	add    $0x1,%rax
  80a6ab:	4c 39 fa             	cmp    %r15,%rdx
  80a6ae:	75 eb                	jne    80a69b <readChunk_tEXt+0x7d>
    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
  80a6b0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80a6b4:	4c 39 e8             	cmp    %r13,%rax
  80a6b7:	0f 87 c4 00 00 00    	ja     80a781 <readChunk_tEXt+0x163>
  80a6bd:	49 29 c5             	sub    %rax,%r13
    str = (char*)lodepng_malloc(length + 1);
  80a6c0:	41 8d 7d 01          	lea    0x1(%r13),%edi
  return jos_malloc(size);
  80a6c4:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80a6cb:	00 00 00 
  80a6ce:	ff d0                	call   *%rax
  80a6d0:	48 89 c3             	mov    %rax,%rbx
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
  80a6d3:	48 85 c0             	test   %rax,%rax
  80a6d6:	0f 84 9d 00 00 00    	je     80a779 <readChunk_tEXt+0x15b>
    str[length] = 0;
  80a6dc:	44 89 e8             	mov    %r13d,%eax
  80a6df:	c6 04 03 00          	movb   $0x0,(%rbx,%rax,1)
    for(i = 0; i != length; ++i) str[i] = (char)data[string2_begin + i];
  80a6e3:	45 85 ed             	test   %r13d,%r13d
  80a6e6:	74 24                	je     80a70c <readChunk_tEXt+0xee>
  80a6e8:	41 8d 45 ff          	lea    -0x1(%r13),%eax
  80a6ec:	48 8d 74 03 01       	lea    0x1(%rbx,%rax,1),%rsi
  80a6f1:	48 89 d8             	mov    %rbx,%rax
  80a6f4:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  80a6f7:	29 d9                	sub    %ebx,%ecx
  80a6f9:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  80a6fc:	41 0f b6 14 14       	movzbl (%r12,%rdx,1),%edx
  80a701:	88 10                	mov    %dl,(%rax)
  80a703:	48 83 c0 01          	add    $0x1,%rax
  80a707:	48 39 f0             	cmp    %rsi,%rax
  80a70a:	75 ed                	jne    80a6f9 <readChunk_tEXt+0xdb>
    error = lodepng_add_text(info, key, str);
  80a70c:	48 89 da             	mov    %rbx,%rdx
  80a70f:	4c 89 f6             	mov    %r14,%rsi
  80a712:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  80a716:	48 b8 49 a5 80 00 00 	movabs $0x80a549,%rax
  80a71d:	00 00 00 
  80a720:	ff d0                	call   *%rax
  80a722:	41 89 c5             	mov    %eax,%r13d
    break;
  80a725:	eb 1f                	jmp    80a746 <readChunk_tEXt+0x128>
  char *key = 0, *str = 0;
  80a727:	41 be 00 00 00 00    	mov    $0x0,%r14d
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
  80a72d:	41 bd 59 00 00 00    	mov    $0x59,%r13d
  80a733:	eb 11                	jmp    80a746 <readChunk_tEXt+0x128>
  char *key = 0, *str = 0;
  80a735:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a73a:	41 be 00 00 00 00    	mov    $0x0,%r14d
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
  80a740:	41 bd 59 00 00 00    	mov    $0x59,%r13d
    jos_free(ptr);
  80a746:	4c 89 f7             	mov    %r14,%rdi
  80a749:	49 bc be 0e 81 00 00 	movabs $0x810ebe,%r12
  80a750:	00 00 00 
  80a753:	41 ff d4             	call   *%r12
  80a756:	48 89 df             	mov    %rbx,%rdi
  80a759:	41 ff d4             	call   *%r12
}
  80a75c:	44 89 e8             	mov    %r13d,%eax
  80a75f:	48 83 c4 28          	add    $0x28,%rsp
  80a763:	5b                   	pop    %rbx
  80a764:	41 5c                	pop    %r12
  80a766:	41 5d                	pop    %r13
  80a768:	41 5e                	pop    %r14
  80a76a:	41 5f                	pop    %r15
  80a76c:	5d                   	pop    %rbp
  80a76d:	c3                   	ret    
  char *key = 0, *str = 0;
  80a76e:	48 89 c3             	mov    %rax,%rbx
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
  80a771:	41 bd 53 00 00 00    	mov    $0x53,%r13d
  80a777:	eb cd                	jmp    80a746 <readChunk_tEXt+0x128>
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
  80a779:	41 bd 53 00 00 00    	mov    $0x53,%r13d
  80a77f:	eb c5                	jmp    80a746 <readChunk_tEXt+0x128>
  return jos_malloc(size);
  80a781:	bf 01 00 00 00       	mov    $0x1,%edi
  80a786:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80a78d:	00 00 00 
  80a790:	ff d0                	call   *%rax
  80a792:	48 89 c3             	mov    %rax,%rbx
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
  80a795:	41 bd 53 00 00 00    	mov    $0x53,%r13d
  80a79b:	48 85 c0             	test   %rax,%rax
  80a79e:	74 a6                	je     80a746 <readChunk_tEXt+0x128>
    str[length] = 0;
  80a7a0:	c6 03 00             	movb   $0x0,(%rbx)
    for(i = 0; i != length; ++i) str[i] = (char)data[string2_begin + i];
  80a7a3:	e9 64 ff ff ff       	jmp    80a70c <readChunk_tEXt+0xee>

000000000080a7a8 <readChunk_zTXt>:
                               const unsigned char* data, size_t chunkLength) {
  80a7a8:	55                   	push   %rbp
  80a7a9:	48 89 e5             	mov    %rsp,%rbp
  80a7ac:	41 57                	push   %r15
  80a7ae:	41 56                	push   %r14
  80a7b0:	41 55                	push   %r13
  80a7b2:	41 54                	push   %r12
  80a7b4:	53                   	push   %rbx
  80a7b5:	48 83 ec 58          	sub    $0x58,%rsp
  80a7b9:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80a7bd:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
  80a7c1:	49 89 d4             	mov    %rdx,%r12
  80a7c4:	49 89 cd             	mov    %rcx,%r13
  p->data = NULL;
  80a7c7:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80a7ce:	00 
  p->size = p->allocsize = 0;
  80a7cf:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80a7d6:	00 
  80a7d7:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80a7de:	00 
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
  80a7df:	bf 00 00 00 00       	mov    $0x0,%edi
  80a7e4:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a7e9:	48 85 c9             	test   %rcx,%rcx
  80a7ec:	74 6b                	je     80a859 <readChunk_zTXt+0xb1>
  80a7ee:	41 80 3c 1c 00       	cmpb   $0x0,(%r12,%rbx,1)
  80a7f3:	74 0a                	je     80a7ff <readChunk_zTXt+0x57>
  80a7f5:	83 c7 01             	add    $0x1,%edi
  80a7f8:	89 fb                	mov    %edi,%ebx
  80a7fa:	4c 39 eb             	cmp    %r13,%rbx
  80a7fd:	72 ef                	jb     80a7ee <readChunk_zTXt+0x46>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
  80a7ff:	44 8d 7f 02          	lea    0x2(%rdi),%r15d
  80a803:	44 89 f8             	mov    %r15d,%eax
  80a806:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80a80a:	4c 39 e8             	cmp    %r13,%rax
  80a80d:	0f 83 0b 01 00 00    	jae    80a91e <readChunk_zTXt+0x176>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
  80a813:	8d 47 ff             	lea    -0x1(%rdi),%eax
  80a816:	89 45 94             	mov    %eax,-0x6c(%rbp)
  80a819:	83 f8 4e             	cmp    $0x4e,%eax
  80a81c:	76 48                	jbe    80a866 <readChunk_zTXt+0xbe>
  char *key = 0;
  80a81e:	41 be 00 00 00 00    	mov    $0x0,%r14d
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
  80a824:	bb 59 00 00 00       	mov    $0x59,%ebx
    jos_free(ptr);
  80a829:	4c 89 f7             	mov    %r14,%rdi
  80a82c:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  80a833:	00 00 00 
  80a836:	ff d0                	call   *%rax
  ucvector_cleanup(&decoded);
  80a838:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80a83c:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  80a843:	00 00 00 
  80a846:	ff d0                	call   *%rax
}
  80a848:	89 d8                	mov    %ebx,%eax
  80a84a:	48 83 c4 58          	add    $0x58,%rsp
  80a84e:	5b                   	pop    %rbx
  80a84f:	41 5c                	pop    %r12
  80a851:	41 5d                	pop    %r13
  80a853:	41 5e                	pop    %r14
  80a855:	41 5f                	pop    %r15
  80a857:	5d                   	pop    %rbp
  80a858:	c3                   	ret    
  char *key = 0;
  80a859:	41 be 00 00 00 00    	mov    $0x0,%r14d
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
  80a85f:	bb 4b 00 00 00       	mov    $0x4b,%ebx
  80a864:	eb c3                	jmp    80a829 <readChunk_zTXt+0x81>
    key = (char*)lodepng_malloc(length + 1);
  80a866:	83 c7 01             	add    $0x1,%edi
  80a869:	89 fe                	mov    %edi,%esi
  80a86b:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
  return jos_malloc(size);
  80a86f:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80a876:	00 00 00 
  80a879:	ff d0                	call   *%rax
  80a87b:	49 89 c6             	mov    %rax,%r14
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
  80a87e:	48 85 c0             	test   %rax,%rax
  80a881:	0f 84 a7 00 00 00    	je     80a92e <readChunk_zTXt+0x186>
    key[length] = 0;
  80a887:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
    for(i = 0; i != length; ++i) key[i] = (char)data[i];
  80a88b:	8b 4d 94             	mov    -0x6c(%rbp),%ecx
    key[length] = 0;
  80a88e:	b8 00 00 00 00       	mov    $0x0,%eax
    for(i = 0; i != length; ++i) key[i] = (char)data[i];
  80a893:	41 0f b6 14 04       	movzbl (%r12,%rax,1),%edx
  80a898:	41 88 14 06          	mov    %dl,(%r14,%rax,1)
  80a89c:	48 89 c2             	mov    %rax,%rdx
  80a89f:	48 83 c0 01          	add    $0x1,%rax
  80a8a3:	48 39 d1             	cmp    %rdx,%rcx
  80a8a6:	75 eb                	jne    80a893 <readChunk_zTXt+0xeb>
    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
  80a8a8:	bb 48 00 00 00       	mov    $0x48,%ebx
  80a8ad:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80a8b1:	41 80 3c 04 00       	cmpb   $0x0,(%r12,%rax,1)
  80a8b6:	0f 85 6d ff ff ff    	jne    80a829 <readChunk_zTXt+0x81>
    error = zlib_decompress(&decoded.data, &decoded.size,
  80a8bc:	44 89 e9             	mov    %r13d,%ecx
  80a8bf:	44 29 f9             	sub    %r15d,%ecx
  80a8c2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80a8c6:	4c 01 e2             	add    %r12,%rdx
  80a8c9:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  80a8cd:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  80a8d1:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80a8d5:	48 b8 75 85 80 00 00 	movabs $0x808575,%rax
  80a8dc:	00 00 00 
  80a8df:	ff d0                	call   *%rax
  80a8e1:	89 c3                	mov    %eax,%ebx
    if(error) break;
  80a8e3:	85 c0                	test   %eax,%eax
  80a8e5:	0f 85 3e ff ff ff    	jne    80a829 <readChunk_zTXt+0x81>
    ucvector_push_back(&decoded, 0);
  80a8eb:	be 00 00 00 00       	mov    $0x0,%esi
  80a8f0:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80a8f4:	48 b8 78 46 80 00 00 	movabs $0x804678,%rax
  80a8fb:	00 00 00 
  80a8fe:	ff d0                	call   *%rax
    error = lodepng_add_text(info, key, (char*)decoded.data);
  80a900:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80a904:	4c 89 f6             	mov    %r14,%rsi
  80a907:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  80a90b:	48 b8 49 a5 80 00 00 	movabs $0x80a549,%rax
  80a912:	00 00 00 
  80a915:	ff d0                	call   *%rax
  80a917:	89 c3                	mov    %eax,%ebx
    break;
  80a919:	e9 0b ff ff ff       	jmp    80a829 <readChunk_zTXt+0x81>
  char *key = 0;
  80a91e:	41 be 00 00 00 00    	mov    $0x0,%r14d
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
  80a924:	bb 4b 00 00 00       	mov    $0x4b,%ebx
  80a929:	e9 fb fe ff ff       	jmp    80a829 <readChunk_zTXt+0x81>
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
  80a92e:	bb 53 00 00 00       	mov    $0x53,%ebx
  80a933:	e9 f1 fe ff ff       	jmp    80a829 <readChunk_zTXt+0x81>

000000000080a938 <lodepng_clear_itext>:
void lodepng_clear_itext(LodePNGInfo* info) {
  80a938:	55                   	push   %rbp
  80a939:	48 89 e5             	mov    %rsp,%rbp
  LodePNGIText_cleanup(info);
  80a93c:	48 b8 c5 50 80 00 00 	movabs $0x8050c5,%rax
  80a943:	00 00 00 
  80a946:	ff d0                	call   *%rax
}
  80a948:	5d                   	pop    %rbp
  80a949:	c3                   	ret    

000000000080a94a <lodepng_add_itext>:
                           const char* transkey, const char* str) {
  80a94a:	55                   	push   %rbp
  80a94b:	48 89 e5             	mov    %rsp,%rbp
  80a94e:	41 57                	push   %r15
  80a950:	41 56                	push   %r14
  80a952:	41 55                	push   %r13
  80a954:	41 54                	push   %r12
  80a956:	53                   	push   %rbx
  80a957:	48 83 ec 28          	sub    $0x28,%rsp
  80a95b:	48 89 fb             	mov    %rdi,%rbx
  80a95e:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  80a962:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80a966:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  80a96a:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
  char** new_keys = (char**)(lodepng_reallocate(info->itext_keys, sizeof(char*) * info->itext_num, sizeof(char*) * (info->itext_num + 1)));
  80a96e:	48 8b 77 60          	mov    0x60(%rdi),%rsi
  80a972:	48 8d 14 f5 08 00 00 	lea    0x8(,%rsi,8),%rdx
  80a979:	00 
  80a97a:	48 c1 e6 03          	shl    $0x3,%rsi
  80a97e:	48 8b 7f 68          	mov    0x68(%rdi),%rdi
  80a982:	49 bf b5 45 80 00 00 	movabs $0x8045b5,%r15
  80a989:	00 00 00 
  80a98c:	41 ff d7             	call   *%r15
  80a98f:	49 89 c4             	mov    %rax,%r12
  char** new_langtags = (char**)(lodepng_reallocate(info->itext_langtags, sizeof(char*) * info->itext_num, sizeof(char*) * (info->itext_num + 1)));
  80a992:	48 8b 73 60          	mov    0x60(%rbx),%rsi
  80a996:	48 8d 14 f5 08 00 00 	lea    0x8(,%rsi,8),%rdx
  80a99d:	00 
  80a99e:	48 c1 e6 03          	shl    $0x3,%rsi
  80a9a2:	48 8b 7b 70          	mov    0x70(%rbx),%rdi
  80a9a6:	41 ff d7             	call   *%r15
  80a9a9:	49 89 c5             	mov    %rax,%r13
  char** new_transkeys = (char**)(lodepng_reallocate(info->itext_transkeys, sizeof(char*) * info->itext_num, sizeof(char*) * (info->itext_num + 1)));
  80a9ac:	48 8b 73 60          	mov    0x60(%rbx),%rsi
  80a9b0:	48 8d 14 f5 08 00 00 	lea    0x8(,%rsi,8),%rdx
  80a9b7:	00 
  80a9b8:	48 c1 e6 03          	shl    $0x3,%rsi
  80a9bc:	48 8b 7b 78          	mov    0x78(%rbx),%rdi
  80a9c0:	41 ff d7             	call   *%r15
  80a9c3:	49 89 c6             	mov    %rax,%r14
  char** new_strings = (char**)(lodepng_reallocate(info->itext_strings, sizeof(char*) * info->itext_num, sizeof(char*) * (info->itext_num + 1)));
  80a9c6:	48 8b 73 60          	mov    0x60(%rbx),%rsi
  80a9ca:	48 8d 14 f5 08 00 00 	lea    0x8(,%rsi,8),%rdx
  80a9d1:	00 
  80a9d2:	48 c1 e6 03          	shl    $0x3,%rsi
  80a9d6:	48 8b bb 80 00 00 00 	mov    0x80(%rbx),%rdi
  80a9dd:	41 ff d7             	call   *%r15
  if(new_keys) info->itext_keys = new_keys;
  80a9e0:	4d 85 e4             	test   %r12,%r12
  80a9e3:	74 04                	je     80a9e9 <lodepng_add_itext+0x9f>
  80a9e5:	4c 89 63 68          	mov    %r12,0x68(%rbx)
  if(new_langtags) info->itext_langtags = new_langtags;
  80a9e9:	4d 85 ed             	test   %r13,%r13
  80a9ec:	74 04                	je     80a9f2 <lodepng_add_itext+0xa8>
  80a9ee:	4c 89 6b 70          	mov    %r13,0x70(%rbx)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
  80a9f2:	4d 85 f6             	test   %r14,%r14
  80a9f5:	74 04                	je     80a9fb <lodepng_add_itext+0xb1>
  80a9f7:	4c 89 73 78          	mov    %r14,0x78(%rbx)
  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
  80a9fb:	ba 53 00 00 00       	mov    $0x53,%edx
  if(new_strings) info->itext_strings = new_strings;
  80aa00:	48 85 c0             	test   %rax,%rax
  80aa03:	0f 84 9b 00 00 00    	je     80aaa4 <lodepng_add_itext+0x15a>
  80aa09:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
  80aa10:	4d 85 e4             	test   %r12,%r12
  80aa13:	0f 84 9c 00 00 00    	je     80aab5 <lodepng_add_itext+0x16b>
  80aa19:	4d 85 ed             	test   %r13,%r13
  80aa1c:	0f 84 93 00 00 00    	je     80aab5 <lodepng_add_itext+0x16b>
  80aa22:	4d 85 f6             	test   %r14,%r14
  80aa25:	0f 84 91 00 00 00    	je     80aabc <lodepng_add_itext+0x172>
  ++info->itext_num;
  80aa2b:	48 8b 43 60          	mov    0x60(%rbx),%rax
  80aa2f:	48 83 c0 01          	add    $0x1,%rax
  80aa33:	48 89 43 60          	mov    %rax,0x60(%rbx)
  info->itext_keys[info->itext_num - 1] = alloc_string(key);
  80aa37:	48 8b 53 68          	mov    0x68(%rbx),%rdx
  80aa3b:	4c 8d 64 c2 f8       	lea    -0x8(%rdx,%rax,8),%r12
  80aa40:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  80aa44:	49 bd ac 59 80 00 00 	movabs $0x8059ac,%r13
  80aa4b:	00 00 00 
  80aa4e:	41 ff d5             	call   *%r13
  80aa51:	49 89 04 24          	mov    %rax,(%r12)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
  80aa55:	48 8b 53 60          	mov    0x60(%rbx),%rdx
  80aa59:	48 8b 43 70          	mov    0x70(%rbx),%rax
  80aa5d:	4c 8d 64 d0 f8       	lea    -0x8(%rax,%rdx,8),%r12
  80aa62:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  80aa66:	41 ff d5             	call   *%r13
  80aa69:	49 89 04 24          	mov    %rax,(%r12)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
  80aa6d:	48 8b 53 60          	mov    0x60(%rbx),%rdx
  80aa71:	48 8b 43 78          	mov    0x78(%rbx),%rax
  80aa75:	4c 8d 64 d0 f8       	lea    -0x8(%rax,%rdx,8),%r12
  80aa7a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80aa7e:	41 ff d5             	call   *%r13
  80aa81:	49 89 04 24          	mov    %rax,(%r12)
  info->itext_strings[info->itext_num - 1] = alloc_string(str);
  80aa85:	48 8b 53 60          	mov    0x60(%rbx),%rdx
  80aa89:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
  80aa90:	48 8d 5c d0 f8       	lea    -0x8(%rax,%rdx,8),%rbx
  80aa95:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  80aa99:	41 ff d5             	call   *%r13
  80aa9c:	48 89 03             	mov    %rax,(%rbx)
  return 0;
  80aa9f:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80aaa4:	89 d0                	mov    %edx,%eax
  80aaa6:	48 83 c4 28          	add    $0x28,%rsp
  80aaaa:	5b                   	pop    %rbx
  80aaab:	41 5c                	pop    %r12
  80aaad:	41 5d                	pop    %r13
  80aaaf:	41 5e                	pop    %r14
  80aab1:	41 5f                	pop    %r15
  80aab3:	5d                   	pop    %rbp
  80aab4:	c3                   	ret    
  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
  80aab5:	ba 53 00 00 00       	mov    $0x53,%edx
  80aaba:	eb e8                	jmp    80aaa4 <lodepng_add_itext+0x15a>
  80aabc:	ba 53 00 00 00       	mov    $0x53,%edx
  80aac1:	eb e1                	jmp    80aaa4 <lodepng_add_itext+0x15a>

000000000080aac3 <readChunk_iTXt>:
                               const unsigned char* data, size_t chunkLength) {
  80aac3:	55                   	push   %rbp
  80aac4:	48 89 e5             	mov    %rsp,%rbp
  80aac7:	41 57                	push   %r15
  80aac9:	41 56                	push   %r14
  80aacb:	41 55                	push   %r13
  80aacd:	41 54                	push   %r12
  80aacf:	53                   	push   %rbx
  80aad0:	48 83 ec 58          	sub    $0x58,%rsp
  80aad4:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80aad8:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  p->data = NULL;
  80aadc:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80aae3:	00 
  p->size = p->allocsize = 0;
  80aae4:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80aaeb:	00 
  80aaec:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80aaf3:	00 
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
  80aaf4:	48 83 f9 04          	cmp    $0x4,%rcx
  80aaf8:	0f 86 8a 02 00 00    	jbe    80ad88 <readChunk_iTXt+0x2c5>
  80aafe:	49 89 d5             	mov    %rdx,%r13
  80ab01:	49 89 ce             	mov    %rcx,%r14
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
  80ab04:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ab09:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80ab0f:	43 80 7c 25 00 00    	cmpb   $0x0,0x0(%r13,%r12,1)
  80ab15:	74 0b                	je     80ab22 <readChunk_iTXt+0x5f>
  80ab17:	83 c3 01             	add    $0x1,%ebx
  80ab1a:	41 89 dc             	mov    %ebx,%r12d
  80ab1d:	4d 39 f4             	cmp    %r14,%r12
  80ab20:	72 ed                	jb     80ab0f <readChunk_iTXt+0x4c>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
  80ab22:	8d 43 03             	lea    0x3(%rbx),%eax
  80ab25:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  80ab28:	41 89 c7             	mov    %eax,%r15d
  80ab2b:	4d 39 f7             	cmp    %r14,%r15
  80ab2e:	0f 83 ab 02 00 00    	jae    80addf <readChunk_iTXt+0x31c>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
  80ab34:	8d 43 ff             	lea    -0x1(%rbx),%eax
  80ab37:	89 45 a0             	mov    %eax,-0x60(%rbp)
  80ab3a:	83 f8 4e             	cmp    $0x4e,%eax
  80ab3d:	76 1e                	jbe    80ab5d <readChunk_iTXt+0x9a>
  char *key = 0, *langtag = 0, *transkey = 0;
  80ab3f:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80ab45:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  80ab4b:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80ab52:	00 
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
  80ab53:	bb 59 00 00 00       	mov    $0x59,%ebx
  80ab58:	e9 44 02 00 00       	jmp    80ada1 <readChunk_iTXt+0x2de>
    key = (char*)lodepng_malloc(length + 1);
  80ab5d:	8d 4b 01             	lea    0x1(%rbx),%ecx
  80ab60:	89 4d 8c             	mov    %ecx,-0x74(%rbp)
  return jos_malloc(size);
  80ab63:	89 cf                	mov    %ecx,%edi
  80ab65:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80ab6c:	00 00 00 
  80ab6f:	ff d0                	call   *%rax
  80ab71:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
  80ab75:	48 85 c0             	test   %rax,%rax
  80ab78:	0f 84 7c 02 00 00    	je     80adfa <readChunk_iTXt+0x337>
    key[length] = 0;
  80ab7e:	42 c6 04 20 00       	movb   $0x0,(%rax,%r12,1)
    for(i = 0; i != length; ++i) key[i] = (char)data[i];
  80ab83:	8b 4d a0             	mov    -0x60(%rbp),%ecx
    key[length] = 0;
  80ab86:	b8 00 00 00 00       	mov    $0x0,%eax
    for(i = 0; i != length; ++i) key[i] = (char)data[i];
  80ab8b:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  80ab91:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  80ab95:	88 14 06             	mov    %dl,(%rsi,%rax,1)
  80ab98:	48 89 c2             	mov    %rax,%rdx
  80ab9b:	48 83 c0 01          	add    $0x1,%rax
  80ab9f:	48 39 ca             	cmp    %rcx,%rdx
  80aba2:	75 e7                	jne    80ab8b <readChunk_iTXt+0xc8>
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
  80aba4:	8d 43 02             	lea    0x2(%rbx),%eax
    length = 0;
  80aba7:	41 bc 00 00 00 00    	mov    $0x0,%r12d
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
  80abad:	41 80 7c 05 00 00    	cmpb   $0x0,0x0(%r13,%rax,1)
  80abb3:	0f 85 4f 02 00 00    	jne    80ae08 <readChunk_iTXt+0x345>
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
  80abb9:	43 80 7c 3d 00 00    	cmpb   $0x0,0x0(%r13,%r15,1)
  80abbf:	74 10                	je     80abd1 <readChunk_iTXt+0x10e>
  80abc1:	41 83 c4 01          	add    $0x1,%r12d
  80abc5:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80abc8:	46 8d 3c 20          	lea    (%rax,%r12,1),%r15d
  80abcc:	4d 39 f7             	cmp    %r14,%r15
  80abcf:	72 e8                	jb     80abb9 <readChunk_iTXt+0xf6>
    key = (char*)lodepng_malloc(length + 1);
  80abd1:	8b 45 8c             	mov    -0x74(%rbp),%eax
    compressed = data[length + 1];
  80abd4:	41 0f b6 44 05 00    	movzbl 0x0(%r13,%rax,1),%eax
  80abda:	88 45 a0             	mov    %al,-0x60(%rbp)
    langtag = (char*)lodepng_malloc(length + 1);
  80abdd:	41 8d 7c 24 01       	lea    0x1(%r12),%edi
  return jos_malloc(size);
  80abe2:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80abe9:	00 00 00 
  80abec:	ff d0                	call   *%rax
  80abee:	49 89 c7             	mov    %rax,%r15
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
  80abf1:	48 85 c0             	test   %rax,%rax
  80abf4:	0f 84 21 02 00 00    	je     80ae1b <readChunk_iTXt+0x358>
    langtag[length] = 0;
  80abfa:	44 89 e0             	mov    %r12d,%eax
  80abfd:	41 c6 04 07 00       	movb   $0x0,(%r15,%rax,1)
    for(i = 0; i != length; ++i) langtag[i] = (char)data[begin + i];
  80ac02:	45 85 e4             	test   %r12d,%r12d
  80ac05:	74 27                	je     80ac2e <readChunk_iTXt+0x16b>
  80ac07:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
  80ac0c:	49 8d 74 07 01       	lea    0x1(%r15,%rax,1),%rsi
  80ac11:	4c 89 f8             	mov    %r15,%rax
  80ac14:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80ac17:	44 29 fa             	sub    %r15d,%edx
  80ac1a:	8d 0c 02             	lea    (%rdx,%rax,1),%ecx
  80ac1d:	41 0f b6 4c 0d 00    	movzbl 0x0(%r13,%rcx,1),%ecx
  80ac23:	88 08                	mov    %cl,(%rax)
  80ac25:	48 83 c0 01          	add    $0x1,%rax
  80ac29:	48 39 f0             	cmp    %rsi,%rax
  80ac2c:	75 ec                	jne    80ac1a <readChunk_iTXt+0x157>
    begin += length + 1;
  80ac2e:	42 8d 44 23 04       	lea    0x4(%rbx,%r12,1),%eax
  80ac33:	89 45 a4             	mov    %eax,-0x5c(%rbp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
  80ac36:	89 c0                	mov    %eax,%eax
    length = 0;
  80ac38:	bb 00 00 00 00       	mov    $0x0,%ebx
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
  80ac3d:	49 39 c6             	cmp    %rax,%r14
  80ac40:	76 17                	jbe    80ac59 <readChunk_iTXt+0x196>
  80ac42:	41 80 7c 05 00 00    	cmpb   $0x0,0x0(%r13,%rax,1)
  80ac48:	74 0f                	je     80ac59 <readChunk_iTXt+0x196>
  80ac4a:	83 c3 01             	add    $0x1,%ebx
  80ac4d:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80ac50:	01 d8                	add    %ebx,%eax
  80ac52:	89 c0                	mov    %eax,%eax
  80ac54:	4c 39 f0             	cmp    %r14,%rax
  80ac57:	72 e9                	jb     80ac42 <readChunk_iTXt+0x17f>
    transkey = (char*)lodepng_malloc(length + 1);
  80ac59:	8d 7b 01             	lea    0x1(%rbx),%edi
  return jos_malloc(size);
  80ac5c:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80ac63:	00 00 00 
  80ac66:	ff d0                	call   *%rax
  80ac68:	49 89 c4             	mov    %rax,%r12
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
  80ac6b:	48 85 c0             	test   %rax,%rax
  80ac6e:	0f 84 b4 01 00 00    	je     80ae28 <readChunk_iTXt+0x365>
    transkey[length] = 0;
  80ac74:	89 d8                	mov    %ebx,%eax
  80ac76:	41 c6 04 04 00       	movb   $0x0,(%r12,%rax,1)
    for(i = 0; i != length; ++i) transkey[i] = (char)data[begin + i];
  80ac7b:	85 db                	test   %ebx,%ebx
  80ac7d:	74 25                	je     80aca4 <readChunk_iTXt+0x1e1>
  80ac7f:	8d 43 ff             	lea    -0x1(%rbx),%eax
  80ac82:	49 8d 74 04 01       	lea    0x1(%r12,%rax,1),%rsi
  80ac87:	4c 89 e0             	mov    %r12,%rax
  80ac8a:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
  80ac8d:	44 29 e1             	sub    %r12d,%ecx
  80ac90:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  80ac93:	41 0f b6 54 15 00    	movzbl 0x0(%r13,%rdx,1),%edx
  80ac99:	88 10                	mov    %dl,(%rax)
  80ac9b:	48 83 c0 01          	add    $0x1,%rax
  80ac9f:	48 39 f0             	cmp    %rsi,%rax
  80aca2:	75 ec                	jne    80ac90 <readChunk_iTXt+0x1cd>
    begin += length + 1;
  80aca4:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80aca7:	8d 74 18 01          	lea    0x1(%rax,%rbx,1),%esi
  80acab:	89 75 a4             	mov    %esi,-0x5c(%rbp)
    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
  80acae:	44 89 f0             	mov    %r14d,%eax
  80acb1:	29 f0                	sub    %esi,%eax
  80acb3:	44 39 f6             	cmp    %r14d,%esi
  80acb6:	41 be 00 00 00 00    	mov    $0x0,%r14d
  80acbc:	44 0f 46 f0          	cmovbe %eax,%r14d
    if(compressed) {
  80acc0:	80 7d a0 00          	cmpb   $0x0,-0x60(%rbp)
  80acc4:	74 4f                	je     80ad15 <readChunk_iTXt+0x252>
      error = zlib_decompress(&decoded.data, &decoded.size,
  80acc6:	44 89 f1             	mov    %r14d,%ecx
  80acc9:	89 f2                	mov    %esi,%edx
  80accb:	4c 01 ea             	add    %r13,%rdx
  80acce:	4c 8b 45 90          	mov    -0x70(%rbp),%r8
  80acd2:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  80acd6:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80acda:	48 b8 75 85 80 00 00 	movabs $0x808575,%rax
  80ace1:	00 00 00 
  80ace4:	ff d0                	call   *%rax
  80ace6:	89 c3                	mov    %eax,%ebx
      if(error) break;
  80ace8:	85 c0                	test   %eax,%eax
  80acea:	0f 85 b1 00 00 00    	jne    80ada1 <readChunk_iTXt+0x2de>
      if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;
  80acf0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80acf4:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  80acf8:	73 04                	jae    80acfe <readChunk_iTXt+0x23b>
  80acfa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      ucvector_push_back(&decoded, 0);
  80acfe:	be 00 00 00 00       	mov    $0x0,%esi
  80ad03:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80ad07:	48 b8 78 46 80 00 00 	movabs $0x804678,%rax
  80ad0e:	00 00 00 
  80ad11:	ff d0                	call   *%rax
  80ad13:	eb 51                	jmp    80ad66 <readChunk_iTXt+0x2a3>
      if(!ucvector_resize(&decoded, length + 1)) CERROR_BREAK(error, 83 /*alloc fail*/);
  80ad15:	41 8d 76 01          	lea    0x1(%r14),%esi
  80ad19:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80ad1d:	48 b8 0c 46 80 00 00 	movabs $0x80460c,%rax
  80ad24:	00 00 00 
  80ad27:	ff d0                	call   *%rax
  80ad29:	bb 53 00 00 00       	mov    $0x53,%ebx
  80ad2e:	85 c0                	test   %eax,%eax
  80ad30:	74 6f                	je     80ada1 <readChunk_iTXt+0x2de>
      decoded.data[length] = 0;
  80ad32:	44 89 f0             	mov    %r14d,%eax
  80ad35:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80ad39:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
      for(i = 0; i != length; ++i) decoded.data[i] = data[begin + i];
  80ad3d:	45 85 f6             	test   %r14d,%r14d
  80ad40:	74 24                	je     80ad66 <readChunk_iTXt+0x2a3>
  80ad42:	45 89 f6             	mov    %r14d,%r14d
  80ad45:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad4a:	8b 75 a4             	mov    -0x5c(%rbp),%esi
  80ad4d:	8d 14 06             	lea    (%rsi,%rax,1),%edx
  80ad50:	41 0f b6 4c 15 00    	movzbl 0x0(%r13,%rdx,1),%ecx
  80ad56:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80ad5a:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  80ad5d:	48 83 c0 01          	add    $0x1,%rax
  80ad61:	49 39 c6             	cmp    %rax,%r14
  80ad64:	75 e4                	jne    80ad4a <readChunk_iTXt+0x287>
    error = lodepng_add_itext(info, key, langtag, transkey, (char*)decoded.data);
  80ad66:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  80ad6a:	4c 89 e1             	mov    %r12,%rcx
  80ad6d:	4c 89 fa             	mov    %r15,%rdx
  80ad70:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  80ad74:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  80ad78:	48 b8 4a a9 80 00 00 	movabs $0x80a94a,%rax
  80ad7f:	00 00 00 
  80ad82:	ff d0                	call   *%rax
  80ad84:	89 c3                	mov    %eax,%ebx
    break;
  80ad86:	eb 19                	jmp    80ada1 <readChunk_iTXt+0x2de>
  char *key = 0, *langtag = 0, *transkey = 0;
  80ad88:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80ad8e:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  80ad94:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80ad9b:	00 
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
  80ad9c:	bb 1e 00 00 00       	mov    $0x1e,%ebx
    jos_free(ptr);
  80ada1:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  80ada5:	49 bd be 0e 81 00 00 	movabs $0x810ebe,%r13
  80adac:	00 00 00 
  80adaf:	41 ff d5             	call   *%r13
  80adb2:	4c 89 ff             	mov    %r15,%rdi
  80adb5:	41 ff d5             	call   *%r13
  80adb8:	4c 89 e7             	mov    %r12,%rdi
  80adbb:	41 ff d5             	call   *%r13
  ucvector_cleanup(&decoded);
  80adbe:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80adc2:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  80adc9:	00 00 00 
  80adcc:	ff d0                	call   *%rax
}
  80adce:	89 d8                	mov    %ebx,%eax
  80add0:	48 83 c4 58          	add    $0x58,%rsp
  80add4:	5b                   	pop    %rbx
  80add5:	41 5c                	pop    %r12
  80add7:	41 5d                	pop    %r13
  80add9:	41 5e                	pop    %r14
  80addb:	41 5f                	pop    %r15
  80addd:	5d                   	pop    %rbp
  80adde:	c3                   	ret    
  char *key = 0, *langtag = 0, *transkey = 0;
  80addf:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80ade5:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  80adeb:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80adf2:	00 
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
  80adf3:	bb 4b 00 00 00       	mov    $0x4b,%ebx
  80adf8:	eb a7                	jmp    80ada1 <readChunk_iTXt+0x2de>
  char *key = 0, *langtag = 0, *transkey = 0;
  80adfa:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
  80adfe:	4d 89 fc             	mov    %r15,%r12
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
  80ae01:	bb 53 00 00 00       	mov    $0x53,%ebx
  80ae06:	eb 99                	jmp    80ada1 <readChunk_iTXt+0x2de>
  char *key = 0, *langtag = 0, *transkey = 0;
  80ae08:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80ae0e:	41 bf 00 00 00 00    	mov    $0x0,%r15d
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
  80ae14:	bb 48 00 00 00       	mov    $0x48,%ebx
  80ae19:	eb 86                	jmp    80ada1 <readChunk_iTXt+0x2de>
  char *key = 0, *langtag = 0, *transkey = 0;
  80ae1b:	49 89 c4             	mov    %rax,%r12
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
  80ae1e:	bb 53 00 00 00       	mov    $0x53,%ebx
  80ae23:	e9 79 ff ff ff       	jmp    80ada1 <readChunk_iTXt+0x2de>
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
  80ae28:	bb 53 00 00 00       	mov    $0x53,%ebx
  80ae2d:	e9 6f ff ff ff       	jmp    80ada1 <readChunk_iTXt+0x2de>

000000000080ae32 <lodepng_clear_icc>:
void lodepng_clear_icc(LodePNGInfo* info) {
  80ae32:	55                   	push   %rbp
  80ae33:	48 89 e5             	mov    %rsp,%rbp
  80ae36:	41 54                	push   %r12
  80ae38:	53                   	push   %rbx
  80ae39:	48 89 fb             	mov    %rdi,%rbx
    jos_free(ptr);
  80ae3c:	48 8b bf f0 00 00 00 	mov    0xf0(%rdi),%rdi
  80ae43:	49 bc be 0e 81 00 00 	movabs $0x810ebe,%r12
  80ae4a:	00 00 00 
  80ae4d:	41 ff d4             	call   *%r12
  *out = NULL;
  80ae50:	48 c7 83 f0 00 00 00 	movq   $0x0,0xf0(%rbx)
  80ae57:	00 00 00 00 
    jos_free(ptr);
  80ae5b:	48 8b bb f8 00 00 00 	mov    0xf8(%rbx),%rdi
  80ae62:	41 ff d4             	call   *%r12
  info->iccp_profile = NULL;
  80ae65:	48 c7 83 f8 00 00 00 	movq   $0x0,0xf8(%rbx)
  80ae6c:	00 00 00 00 
  info->iccp_profile_size = 0;
  80ae70:	c7 83 00 01 00 00 00 	movl   $0x0,0x100(%rbx)
  80ae77:	00 00 00 
  info->iccp_defined = 0;
  80ae7a:	c7 83 e8 00 00 00 00 	movl   $0x0,0xe8(%rbx)
  80ae81:	00 00 00 
}
  80ae84:	5b                   	pop    %rbx
  80ae85:	41 5c                	pop    %r12
  80ae87:	5d                   	pop    %rbp
  80ae88:	c3                   	ret    

000000000080ae89 <lodepng_set_icc>:
unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
  80ae89:	55                   	push   %rbp
  80ae8a:	48 89 e5             	mov    %rsp,%rbp
  80ae8d:	41 56                	push   %r14
  80ae8f:	41 55                	push   %r13
  80ae91:	41 54                	push   %r12
  80ae93:	53                   	push   %rbx
  80ae94:	48 89 fb             	mov    %rdi,%rbx
  80ae97:	49 89 f4             	mov    %rsi,%r12
  80ae9a:	49 89 d5             	mov    %rdx,%r13
  80ae9d:	41 89 ce             	mov    %ecx,%r14d
  if(info->iccp_name) lodepng_clear_icc(info);
  80aea0:	48 83 bf f0 00 00 00 	cmpq   $0x0,0xf0(%rdi)
  80aea7:	00 
  80aea8:	74 0c                	je     80aeb6 <lodepng_set_icc+0x2d>
  80aeaa:	48 b8 32 ae 80 00 00 	movabs $0x80ae32,%rax
  80aeb1:	00 00 00 
  80aeb4:	ff d0                	call   *%rax
  info->iccp_defined = 1;
  80aeb6:	c7 83 e8 00 00 00 01 	movl   $0x1,0xe8(%rbx)
  80aebd:	00 00 00 
  return lodepng_assign_icc(info, name, profile, profile_size);
  80aec0:	44 89 f1             	mov    %r14d,%ecx
  80aec3:	4c 89 ea             	mov    %r13,%rdx
  80aec6:	4c 89 e6             	mov    %r12,%rsi
  80aec9:	48 89 df             	mov    %rbx,%rdi
  80aecc:	48 b8 52 5b 80 00 00 	movabs $0x805b52,%rax
  80aed3:	00 00 00 
  80aed6:	ff d0                	call   *%rax
}
  80aed8:	5b                   	pop    %rbx
  80aed9:	41 5c                	pop    %r12
  80aedb:	41 5d                	pop    %r13
  80aedd:	41 5e                	pop    %r14
  80aedf:	5d                   	pop    %rbp
  80aee0:	c3                   	ret    

000000000080aee1 <readChunk_iCCP>:
                               const unsigned char* data, size_t chunkLength) {
  80aee1:	55                   	push   %rbp
  80aee2:	48 89 e5             	mov    %rsp,%rbp
  80aee5:	41 57                	push   %r15
  80aee7:	41 56                	push   %r14
  80aee9:	41 55                	push   %r13
  80aeeb:	41 54                	push   %r12
  80aeed:	53                   	push   %rbx
  80aeee:	48 83 ec 48          	sub    $0x48,%rsp
  80aef2:	49 89 fe             	mov    %rdi,%r14
  80aef5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80aef9:	49 89 d4             	mov    %rdx,%r12
  80aefc:	49 89 cd             	mov    %rcx,%r13
  info->iccp_defined = 1;
  80aeff:	c7 87 e8 00 00 00 01 	movl   $0x1,0xe8(%rdi)
  80af06:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
  80af09:	48 83 bf f0 00 00 00 	cmpq   $0x0,0xf0(%rdi)
  80af10:	00 
  80af11:	74 0c                	je     80af1f <readChunk_iCCP+0x3e>
  80af13:	48 b8 32 ae 80 00 00 	movabs $0x80ae32,%rax
  80af1a:	00 00 00 
  80af1d:	ff d0                	call   *%rax
  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
  80af1f:	bf 00 00 00 00       	mov    $0x0,%edi
  80af24:	bb 00 00 00 00       	mov    $0x0,%ebx
  80af29:	4d 85 ed             	test   %r13,%r13
  80af2c:	0f 84 0f 01 00 00    	je     80b041 <readChunk_iCCP+0x160>
  80af32:	41 80 3c 1c 00       	cmpb   $0x0,(%r12,%rbx,1)
  80af37:	74 0a                	je     80af43 <readChunk_iCCP+0x62>
  80af39:	83 c7 01             	add    $0x1,%edi
  80af3c:	89 fb                	mov    %edi,%ebx
  80af3e:	4c 39 eb             	cmp    %r13,%rbx
  80af41:	72 ef                	jb     80af32 <readChunk_iCCP+0x51>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
  80af43:	44 8d 7f 02          	lea    0x2(%rdi),%r15d
  80af47:	44 89 f8             	mov    %r15d,%eax
  80af4a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80af4e:	4c 39 e8             	cmp    %r13,%rax
  80af51:	0f 83 34 01 00 00    	jae    80b08b <readChunk_iCCP+0x1aa>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
  80af57:	8d 47 ff             	lea    -0x1(%rdi),%eax
  80af5a:	c7 45 ac 59 00 00 00 	movl   $0x59,-0x54(%rbp)
  80af61:	89 45 a8             	mov    %eax,-0x58(%rbp)
  80af64:	83 f8 4e             	cmp    $0x4e,%eax
  80af67:	0f 87 c2 00 00 00    	ja     80b02f <readChunk_iCCP+0x14e>
  info->iccp_name = (char*)lodepng_malloc(length + 1);
  80af6d:	83 c7 01             	add    $0x1,%edi
  80af70:	89 fe                	mov    %edi,%esi
  80af72:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  return jos_malloc(size);
  80af76:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80af7d:	00 00 00 
  80af80:	ff d0                	call   *%rax
  info->iccp_name = (char*)lodepng_malloc(length + 1);
  80af82:	49 89 86 f0 00 00 00 	mov    %rax,0xf0(%r14)
  if(!info->iccp_name) return 83; /*alloc fail*/
  80af89:	48 85 c0             	test   %rax,%rax
  80af8c:	0f 84 02 01 00 00    	je     80b094 <readChunk_iCCP+0x1b3>
  info->iccp_name[length] = 0;
  80af92:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
  80af96:	8b 75 a8             	mov    -0x58(%rbp),%esi
  info->iccp_name[length] = 0;
  80af99:	b8 00 00 00 00       	mov    $0x0,%eax
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
  80af9e:	49 8b 96 f0 00 00 00 	mov    0xf0(%r14),%rdx
  80afa5:	41 0f b6 0c 04       	movzbl (%r12,%rax,1),%ecx
  80afaa:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  80afad:	48 89 c2             	mov    %rax,%rdx
  80afb0:	48 83 c0 01          	add    $0x1,%rax
  80afb4:	48 39 d6             	cmp    %rdx,%rsi
  80afb7:	75 e5                	jne    80af9e <readChunk_iCCP+0xbd>
  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
  80afb9:	c7 45 ac 48 00 00 00 	movl   $0x48,-0x54(%rbp)
  80afc0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80afc4:	41 80 3c 04 00       	cmpb   $0x0,(%r12,%rax,1)
  80afc9:	75 64                	jne    80b02f <readChunk_iCCP+0x14e>
  p->data = NULL;
  80afcb:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80afd2:	00 
  p->size = p->allocsize = 0;
  80afd3:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80afda:	00 
  80afdb:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80afe2:	00 
  error = zlib_decompress(&decoded.data, &decoded.size,
  80afe3:	44 89 e9             	mov    %r13d,%ecx
  80afe6:	44 29 f9             	sub    %r15d,%ecx
  80afe9:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80afed:	4c 01 e2             	add    %r12,%rdx
  80aff0:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  80aff4:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  80aff8:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80affc:	48 b8 75 85 80 00 00 	movabs $0x808575,%rax
  80b003:	00 00 00 
  80b006:	ff d0                	call   *%rax
  80b008:	89 45 ac             	mov    %eax,-0x54(%rbp)
  if(!error) {
  80b00b:	85 c0                	test   %eax,%eax
  80b00d:	75 10                	jne    80b01f <readChunk_iCCP+0x13e>
    if(decoded.size) {
  80b00f:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  80b013:	48 85 ff             	test   %rdi,%rdi
  80b016:	75 32                	jne    80b04a <readChunk_iCCP+0x169>
      error = 100; /*invalid ICC profile size*/
  80b018:	c7 45 ac 64 00 00 00 	movl   $0x64,-0x54(%rbp)
  ucvector_cleanup(&decoded);
  80b01f:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  80b023:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  80b02a:	00 00 00 
  80b02d:	ff d0                	call   *%rax
}
  80b02f:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80b032:	48 83 c4 48          	add    $0x48,%rsp
  80b036:	5b                   	pop    %rbx
  80b037:	41 5c                	pop    %r12
  80b039:	41 5d                	pop    %r13
  80b03b:	41 5e                	pop    %r14
  80b03d:	41 5f                	pop    %r15
  80b03f:	5d                   	pop    %rbp
  80b040:	c3                   	ret    
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
  80b041:	c7 45 ac 4b 00 00 00 	movl   $0x4b,-0x54(%rbp)
  80b048:	eb e5                	jmp    80b02f <readChunk_iCCP+0x14e>
      info->iccp_profile_size = decoded.size;
  80b04a:	41 89 be 00 01 00 00 	mov    %edi,0x100(%r14)
  return jos_malloc(size);
  80b051:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80b058:	00 00 00 
  80b05b:	ff d0                	call   *%rax
      info->iccp_profile = (unsigned char*)lodepng_malloc(decoded.size);
  80b05d:	49 89 86 f8 00 00 00 	mov    %rax,0xf8(%r14)
      if(info->iccp_profile) {
  80b064:	48 85 c0             	test   %rax,%rax
  80b067:	74 19                	je     80b082 <readChunk_iCCP+0x1a1>
  memcpy(dst, src, size);
  80b069:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80b06d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80b071:	48 89 c7             	mov    %rax,%rdi
  80b074:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  80b07b:	00 00 00 
  80b07e:	ff d0                	call   *%rax
}
  80b080:	eb 9d                	jmp    80b01f <readChunk_iCCP+0x13e>
        error = 83; /* alloc fail */
  80b082:	c7 45 ac 53 00 00 00 	movl   $0x53,-0x54(%rbp)
  80b089:	eb 94                	jmp    80b01f <readChunk_iCCP+0x13e>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
  80b08b:	c7 45 ac 4b 00 00 00 	movl   $0x4b,-0x54(%rbp)
  80b092:	eb 9b                	jmp    80b02f <readChunk_iCCP+0x14e>
  if(!info->iccp_name) return 83; /*alloc fail*/
  80b094:	c7 45 ac 53 00 00 00 	movl   $0x53,-0x54(%rbp)
  80b09b:	eb 92                	jmp    80b02f <readChunk_iCCP+0x14e>

000000000080b09d <lodepng_info_init>:
void lodepng_info_init(LodePNGInfo* info) {
  80b09d:	55                   	push   %rbp
  80b09e:	48 89 e5             	mov    %rsp,%rbp
  80b0a1:	53                   	push   %rbx
  80b0a2:	48 83 ec 08          	sub    $0x8,%rsp
  80b0a6:	48 89 fb             	mov    %rdi,%rbx
  lodepng_color_mode_init(&info->color);
  80b0a9:	48 8d 7f 10          	lea    0x10(%rdi),%rdi
  80b0ad:	48 b8 01 91 80 00 00 	movabs $0x809101,%rax
  80b0b4:	00 00 00 
  80b0b7:	ff d0                	call   *%rax
  info->interlace_method = 0;
  80b0b9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%rbx)
  info->compression_method = 0;
  80b0c0:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
  info->filter_method = 0;
  80b0c6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%rbx)
  info->background_defined = 0;
  80b0cd:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%rbx)
  info->background_r = info->background_g = info->background_b = 0;
  80b0d4:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%rbx)
  80b0db:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
  80b0e2:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%rbx)
  info->text_num = 0;
  80b0e9:	48 c7 43 48 00 00 00 	movq   $0x0,0x48(%rbx)
  80b0f0:	00 
  info->text_keys = NULL;
  80b0f1:	48 c7 43 50 00 00 00 	movq   $0x0,0x50(%rbx)
  80b0f8:	00 
  info->text_strings = NULL;
  80b0f9:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
  80b100:	00 
  info->itext_num = 0;
  80b101:	48 c7 43 60 00 00 00 	movq   $0x0,0x60(%rbx)
  80b108:	00 
  info->itext_keys = NULL;
  80b109:	48 c7 43 68 00 00 00 	movq   $0x0,0x68(%rbx)
  80b110:	00 
  info->itext_langtags = NULL;
  80b111:	48 c7 43 70 00 00 00 	movq   $0x0,0x70(%rbx)
  80b118:	00 
  info->itext_transkeys = NULL;
  80b119:	48 c7 43 78 00 00 00 	movq   $0x0,0x78(%rbx)
  80b120:	00 
  info->itext_strings = NULL;
  80b121:	48 c7 83 80 00 00 00 	movq   $0x0,0x80(%rbx)
  80b128:	00 00 00 00 
  info->time_defined = 0;
  80b12c:	c7 83 88 00 00 00 00 	movl   $0x0,0x88(%rbx)
  80b133:	00 00 00 
  info->phys_defined = 0;
  80b136:	c7 83 a4 00 00 00 00 	movl   $0x0,0xa4(%rbx)
  80b13d:	00 00 00 
  info->gama_defined = 0;
  80b140:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%rbx)
  80b147:	00 00 00 
  info->chrm_defined = 0;
  80b14a:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%rbx)
  80b151:	00 00 00 
  info->srgb_defined = 0;
  80b154:	c7 83 e0 00 00 00 00 	movl   $0x0,0xe0(%rbx)
  80b15b:	00 00 00 
  info->iccp_defined = 0;
  80b15e:	c7 83 e8 00 00 00 00 	movl   $0x0,0xe8(%rbx)
  80b165:	00 00 00 
  info->iccp_name = NULL;
  80b168:	48 c7 83 f0 00 00 00 	movq   $0x0,0xf0(%rbx)
  80b16f:	00 00 00 00 
  info->iccp_profile = NULL;
  80b173:	48 c7 83 f8 00 00 00 	movq   $0x0,0xf8(%rbx)
  80b17a:	00 00 00 00 
  LodePNGUnknownChunks_init(info);
  80b17e:	48 89 df             	mov    %rbx,%rdi
  80b181:	48 b8 a1 2f 80 00 00 	movabs $0x802fa1,%rax
  80b188:	00 00 00 
  80b18b:	ff d0                	call   *%rax
}
  80b18d:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80b191:	c9                   	leave  
  80b192:	c3                   	ret    

000000000080b193 <lodepng_info_cleanup>:
void lodepng_info_cleanup(LodePNGInfo* info) {
  80b193:	55                   	push   %rbp
  80b194:	48 89 e5             	mov    %rsp,%rbp
  80b197:	41 54                	push   %r12
  80b199:	53                   	push   %rbx
  80b19a:	48 89 fb             	mov    %rdi,%rbx
  lodepng_color_mode_cleanup(&info->color);
  80b19d:	48 8d 7f 10          	lea    0x10(%rdi),%rdi
  lodepng_palette_clear(info);
  80b1a1:	48 b8 9e 91 80 00 00 	movabs $0x80919e,%rax
  80b1a8:	00 00 00 
  80b1ab:	ff d0                	call   *%rax
  LodePNGText_cleanup(info);
  80b1ad:	48 89 df             	mov    %rbx,%rdi
  80b1b0:	48 b8 8f 51 80 00 00 	movabs $0x80518f,%rax
  80b1b7:	00 00 00 
  80b1ba:	ff d0                	call   *%rax
  LodePNGIText_cleanup(info);
  80b1bc:	48 89 df             	mov    %rbx,%rdi
  80b1bf:	48 b8 c5 50 80 00 00 	movabs $0x8050c5,%rax
  80b1c6:	00 00 00 
  80b1c9:	ff d0                	call   *%rax
  lodepng_clear_icc(info);
  80b1cb:	48 89 df             	mov    %rbx,%rdi
  80b1ce:	48 b8 32 ae 80 00 00 	movabs $0x80ae32,%rax
  80b1d5:	00 00 00 
  80b1d8:	ff d0                	call   *%rax
    jos_free(ptr);
  80b1da:	48 8b bb 08 01 00 00 	mov    0x108(%rbx),%rdi
  80b1e1:	49 bc be 0e 81 00 00 	movabs $0x810ebe,%r12
  80b1e8:	00 00 00 
  80b1eb:	41 ff d4             	call   *%r12
  80b1ee:	48 8b bb 10 01 00 00 	mov    0x110(%rbx),%rdi
  80b1f5:	41 ff d4             	call   *%r12
  80b1f8:	48 8b bb 18 01 00 00 	mov    0x118(%rbx),%rdi
  80b1ff:	41 ff d4             	call   *%r12
}
  80b202:	5b                   	pop    %rbx
  80b203:	41 5c                	pop    %r12
  80b205:	5d                   	pop    %rbp
  80b206:	c3                   	ret    

000000000080b207 <lodepng_info_copy>:
unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  80b207:	55                   	push   %rbp
  80b208:	48 89 e5             	mov    %rsp,%rbp
  80b20b:	41 57                	push   %r15
  80b20d:	41 56                	push   %r14
  80b20f:	41 55                	push   %r13
  80b211:	41 54                	push   %r12
  80b213:	53                   	push   %rbx
  80b214:	48 83 ec 18          	sub    $0x18,%rsp
  80b218:	48 89 fb             	mov    %rdi,%rbx
  80b21b:	49 89 f4             	mov    %rsi,%r12
  lodepng_info_cleanup(dest);
  80b21e:	48 b8 93 b1 80 00 00 	movabs $0x80b193,%rax
  80b225:	00 00 00 
  80b228:	ff d0                	call   *%rax
  memcpy(dst, src, size);
  80b22a:	ba 38 01 00 00       	mov    $0x138,%edx
  80b22f:	4c 89 e6             	mov    %r12,%rsi
  80b232:	48 89 df             	mov    %rbx,%rdi
  80b235:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  80b23c:	00 00 00 
  80b23f:	ff d0                	call   *%rax
  lodepng_color_mode_init(&dest->color);
  80b241:	4c 8d 6b 10          	lea    0x10(%rbx),%r13
  80b245:	4c 89 ef             	mov    %r13,%rdi
  80b248:	48 b8 01 91 80 00 00 	movabs $0x809101,%rax
  80b24f:	00 00 00 
  80b252:	ff d0                	call   *%rax
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
  80b254:	49 8d 74 24 10       	lea    0x10(%r12),%rsi
  80b259:	4c 89 ef             	mov    %r13,%rdi
  80b25c:	48 b8 e7 91 80 00 00 	movabs $0x8091e7,%rax
  80b263:	00 00 00 
  80b266:	ff d0                	call   *%rax
  80b268:	41 89 c5             	mov    %eax,%r13d
  80b26b:	85 c0                	test   %eax,%eax
  80b26d:	74 12                	je     80b281 <lodepng_info_copy+0x7a>
}
  80b26f:	44 89 e8             	mov    %r13d,%eax
  80b272:	48 83 c4 18          	add    $0x18,%rsp
  80b276:	5b                   	pop    %rbx
  80b277:	41 5c                	pop    %r12
  80b279:	41 5d                	pop    %r13
  80b27b:	41 5e                	pop    %r14
  80b27d:	41 5f                	pop    %r15
  80b27f:	5d                   	pop    %rbp
  80b280:	c3                   	ret    
  dest->text_keys = 0;
  80b281:	48 c7 43 50 00 00 00 	movq   $0x0,0x50(%rbx)
  80b288:	00 
  dest->text_strings = 0;
  80b289:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
  80b290:	00 
  dest->text_num = 0;
  80b291:	48 c7 43 48 00 00 00 	movq   $0x0,0x48(%rbx)
  80b298:	00 
  for(i = 0; i != source->text_num; ++i) {
  80b299:	49 83 7c 24 48 00    	cmpq   $0x0,0x48(%r12)
  80b29f:	74 3b                	je     80b2dc <lodepng_info_copy+0xd5>
  80b2a1:	41 be 00 00 00 00    	mov    $0x0,%r14d
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  80b2a7:	49 bf 49 a5 80 00 00 	movabs $0x80a549,%r15
  80b2ae:	00 00 00 
  80b2b1:	49 8b 44 24 58       	mov    0x58(%r12),%rax
  80b2b6:	4a 8b 14 f0          	mov    (%rax,%r14,8),%rdx
  80b2ba:	49 8b 44 24 50       	mov    0x50(%r12),%rax
  80b2bf:	4a 8b 34 f0          	mov    (%rax,%r14,8),%rsi
  80b2c3:	48 89 df             	mov    %rbx,%rdi
  80b2c6:	41 ff d7             	call   *%r15
  80b2c9:	85 c0                	test   %eax,%eax
  80b2cb:	0f 85 8a 01 00 00    	jne    80b45b <lodepng_info_copy+0x254>
  for(i = 0; i != source->text_num; ++i) {
  80b2d1:	49 83 c6 01          	add    $0x1,%r14
  80b2d5:	4d 3b 74 24 48       	cmp    0x48(%r12),%r14
  80b2da:	75 d5                	jne    80b2b1 <lodepng_info_copy+0xaa>
  dest->itext_keys = 0;
  80b2dc:	48 c7 43 68 00 00 00 	movq   $0x0,0x68(%rbx)
  80b2e3:	00 
  dest->itext_langtags = 0;
  80b2e4:	48 c7 43 70 00 00 00 	movq   $0x0,0x70(%rbx)
  80b2eb:	00 
  dest->itext_transkeys = 0;
  80b2ec:	48 c7 43 78 00 00 00 	movq   $0x0,0x78(%rbx)
  80b2f3:	00 
  dest->itext_strings = 0;
  80b2f4:	48 c7 83 80 00 00 00 	movq   $0x0,0x80(%rbx)
  80b2fb:	00 00 00 00 
  dest->itext_num = 0;
  80b2ff:	48 c7 43 60 00 00 00 	movq   $0x0,0x60(%rbx)
  80b306:	00 
  for(i = 0; i != source->itext_num; ++i) {
  80b307:	41 be 00 00 00 00    	mov    $0x0,%r14d
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
  80b30d:	49 bf 4a a9 80 00 00 	movabs $0x80a94a,%r15
  80b314:	00 00 00 
  for(i = 0; i != source->itext_num; ++i) {
  80b317:	49 83 7c 24 60 00    	cmpq   $0x0,0x60(%r12)
  80b31d:	74 40                	je     80b35f <lodepng_info_copy+0x158>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
  80b31f:	49 8b 84 24 80 00 00 	mov    0x80(%r12),%rax
  80b326:	00 
  80b327:	49 8b 54 24 78       	mov    0x78(%r12),%rdx
  80b32c:	4a 8b 0c f2          	mov    (%rdx,%r14,8),%rcx
  80b330:	49 8b 54 24 70       	mov    0x70(%r12),%rdx
  80b335:	4a 8b 14 f2          	mov    (%rdx,%r14,8),%rdx
  80b339:	49 8b 74 24 68       	mov    0x68(%r12),%rsi
  80b33e:	4a 8b 34 f6          	mov    (%rsi,%r14,8),%rsi
  80b342:	4e 8b 04 f0          	mov    (%rax,%r14,8),%r8
  80b346:	48 89 df             	mov    %rbx,%rdi
  80b349:	41 ff d7             	call   *%r15
  80b34c:	85 c0                	test   %eax,%eax
  80b34e:	0f 85 0f 01 00 00    	jne    80b463 <lodepng_info_copy+0x25c>
  for(i = 0; i != source->itext_num; ++i) {
  80b354:	49 83 c6 01          	add    $0x1,%r14
  80b358:	4d 3b 74 24 60       	cmp    0x60(%r12),%r14
  80b35d:	75 c0                	jne    80b31f <lodepng_info_copy+0x118>
  if(source->iccp_defined) {
  80b35f:	41 83 bc 24 e8 00 00 	cmpl   $0x0,0xe8(%r12)
  80b366:	00 00 
  80b368:	75 54                	jne    80b3be <lodepng_info_copy+0x1b7>
  LodePNGUnknownChunks_init(dest);
  80b36a:	48 89 df             	mov    %rbx,%rdi
  80b36d:	48 b8 a1 2f 80 00 00 	movabs $0x802fa1,%rax
  80b374:	00 00 00 
  80b377:	ff d0                	call   *%rax
    jos_free(ptr);
  80b379:	48 8b bb 08 01 00 00 	mov    0x108(%rbx),%rdi
  80b380:	49 be be 0e 81 00 00 	movabs $0x810ebe,%r14
  80b387:	00 00 00 
  80b38a:	41 ff d6             	call   *%r14
  80b38d:	48 8b bb 10 01 00 00 	mov    0x110(%rbx),%rdi
  80b394:	41 ff d6             	call   *%r14
  80b397:	48 8b bb 18 01 00 00 	mov    0x118(%rbx),%rdi
  80b39e:	41 ff d6             	call   *%r14
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
  80b3a1:	48 81 c3 08 01 00 00 	add    $0x108,%rbx
  80b3a8:	4d 8d bc 24 20 01 00 	lea    0x120(%r12),%r15
  80b3af:	00 
  80b3b0:	49 8d 84 24 38 01 00 	lea    0x138(%r12),%rax
  80b3b7:	00 
  80b3b8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80b3bc:	eb 6a                	jmp    80b428 <lodepng_info_copy+0x221>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
  80b3be:	41 8b 8c 24 00 01 00 	mov    0x100(%r12),%ecx
  80b3c5:	00 
  80b3c6:	49 8b 94 24 f8 00 00 	mov    0xf8(%r12),%rdx
  80b3cd:	00 
  80b3ce:	49 8b b4 24 f0 00 00 	mov    0xf0(%r12),%rsi
  80b3d5:	00 
  80b3d6:	48 89 df             	mov    %rbx,%rdi
  80b3d9:	48 b8 52 5b 80 00 00 	movabs $0x805b52,%rax
  80b3e0:	00 00 00 
  80b3e3:	ff d0                	call   *%rax
  80b3e5:	85 c0                	test   %eax,%eax
  80b3e7:	74 81                	je     80b36a <lodepng_info_copy+0x163>
  80b3e9:	41 89 c5             	mov    %eax,%r13d
  80b3ec:	e9 7e fe ff ff       	jmp    80b26f <lodepng_info_copy+0x68>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
  80b3f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3f6:	49 83 3c 24 00       	cmpq   $0x0,(%r12)
  80b3fb:	74 19                	je     80b416 <lodepng_info_copy+0x20f>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
  80b3fd:	49 8b 54 24 e8       	mov    -0x18(%r12),%rdx
  80b402:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  80b406:	49 8b 16             	mov    (%r14),%rdx
  80b409:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
  80b40c:	48 83 c0 01          	add    $0x1,%rax
  80b410:	49 3b 04 24          	cmp    (%r12),%rax
  80b414:	72 e7                	jb     80b3fd <lodepng_info_copy+0x1f6>
  for(i = 0; i != 3; ++i) {
  80b416:	48 83 c3 08          	add    $0x8,%rbx
  80b41a:	49 83 c7 08          	add    $0x8,%r15
  80b41e:	4c 3b 7d c8          	cmp    -0x38(%rbp),%r15
  80b422:	0f 84 47 fe ff ff    	je     80b26f <lodepng_info_copy+0x68>
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
  80b428:	4d 89 fc             	mov    %r15,%r12
  80b42b:	49 8b 3f             	mov    (%r15),%rdi
  80b42e:	49 89 de             	mov    %rbx,%r14
  80b431:	48 89 7b 18          	mov    %rdi,0x18(%rbx)
  return jos_malloc(size);
  80b435:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80b43c:	00 00 00 
  80b43f:	ff d0                	call   *%rax
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
  80b441:	48 89 03             	mov    %rax,(%rbx)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
  80b444:	48 85 c0             	test   %rax,%rax
  80b447:	75 a8                	jne    80b3f1 <lodepng_info_copy+0x1ea>
  80b449:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  80b44e:	74 a1                	je     80b3f1 <lodepng_info_copy+0x1ea>
  80b450:	41 bd 53 00 00 00    	mov    $0x53,%r13d
  80b456:	e9 14 fe ff ff       	jmp    80b26f <lodepng_info_copy+0x68>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  80b45b:	41 89 c5             	mov    %eax,%r13d
  80b45e:	e9 0c fe ff ff       	jmp    80b26f <lodepng_info_copy+0x68>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
  80b463:	41 89 c5             	mov    %eax,%r13d
  80b466:	e9 04 fe ff ff       	jmp    80b26f <lodepng_info_copy+0x68>

000000000080b46b <lodepng_convert>:
                         unsigned w, unsigned h) {
  80b46b:	55                   	push   %rbp
  80b46c:	48 89 e5             	mov    %rsp,%rbp
  80b46f:	41 57                	push   %r15
  80b471:	41 56                	push   %r14
  80b473:	41 55                	push   %r13
  80b475:	41 54                	push   %r12
  80b477:	53                   	push   %rbx
  80b478:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  80b47f:	49 89 ff             	mov    %rdi,%r15
  80b482:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  80b489:	49 89 d6             	mov    %rdx,%r14
  80b48c:	48 89 8d 28 ff ff ff 	mov    %rcx,-0xd8(%rbp)
  80b493:	44 89 85 18 ff ff ff 	mov    %r8d,-0xe8(%rbp)
  80b49a:	44 89 8d 10 ff ff ff 	mov    %r9d,-0xf0(%rbp)
  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
  80b4a1:	8b 19                	mov    (%rcx),%ebx
  80b4a3:	83 fb 03             	cmp    $0x3,%ebx
  80b4a6:	0f 84 b6 00 00 00    	je     80b562 <lodepng_convert+0xf7>
  if(lodepng_color_mode_equal(mode_out, mode_in)) {
  80b4ac:	48 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%rsi
  80b4b3:	4c 89 f7             	mov    %r14,%rdi
  80b4b6:	48 b8 fc 2e 80 00 00 	movabs $0x802efc,%rax
  80b4bd:	00 00 00 
  80b4c0:	ff d0                	call   *%rax
  80b4c2:	85 c0                	test   %eax,%eax
  80b4c4:	0f 85 ae 00 00 00    	jne    80b578 <lodepng_convert+0x10d>
  if(mode_out->colortype == LCT_PALETTE) {
  80b4ca:	41 83 3e 03          	cmpl   $0x3,(%r14)
  80b4ce:	0f 84 12 01 00 00    	je     80b5e6 <lodepng_convert+0x17b>
  size_t numpixels = (size_t)w * (size_t)h;
  80b4d4:	44 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%r8d
  80b4db:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  80b4e1:	4c 0f af c0          	imul   %rax,%r8
  80b4e5:	4c 89 85 18 ff ff ff 	mov    %r8,-0xe8(%rbp)
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
  80b4ec:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80b4f3:	8b 48 04             	mov    0x4(%rax),%ecx
  80b4f6:	83 f9 10             	cmp    $0x10,%ecx
  80b4f9:	0f 84 e2 01 00 00    	je     80b6e1 <lodepng_convert+0x276>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
  80b4ff:	49 8b 06             	mov    (%r14),%rax
  80b502:	48 ba 06 00 00 00 08 	movabs $0x800000006,%rdx
  80b509:	00 00 00 
  80b50c:	48 39 d0             	cmp    %rdx,%rax
  80b50f:	0f 84 54 03 00 00    	je     80b869 <lodepng_convert+0x3fe>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
  80b515:	48 ba 02 00 00 00 08 	movabs $0x800000002,%rdx
  80b51c:	00 00 00 
  80b51f:	48 39 d0             	cmp    %rdx,%rax
  80b522:	0f 84 ed 08 00 00    	je     80be15 <lodepng_convert+0x9aa>
      unsigned char r = 0, g = 0, b = 0, a = 0;
  80b528:	c6 85 3a ff ff ff 00 	movb   $0x0,-0xc6(%rbp)
  80b52f:	c6 85 3c ff ff ff 00 	movb   $0x0,-0xc4(%rbp)
  80b536:	c6 85 3e ff ff ff 00 	movb   $0x0,-0xc2(%rbp)
  80b53d:	c6 85 40 ff ff ff 00 	movb   $0x0,-0xc0(%rbp)
      for(i = 0; i != numpixels; ++i) {
  80b544:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  80b54b:	00 
  80b54c:	0f 84 f7 0e 00 00    	je     80c449 <lodepng_convert+0xfde>
  80b552:	4d 89 fc             	mov    %r15,%r12
  80b555:	4d 89 fd             	mov    %r15,%r13
  80b558:	bb 00 00 00 00       	mov    $0x0,%ebx
  80b55d:	e9 fe 0c 00 00       	jmp    80c260 <lodepng_convert+0xdf5>
  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
  80b562:	48 83 79 08 00       	cmpq   $0x0,0x8(%rcx)
  80b567:	0f 85 3f ff ff ff    	jne    80b4ac <lodepng_convert+0x41>
    return 107; /* error: must provide palette if input mode is palette */
  80b56d:	41 bc 6b 00 00 00    	mov    $0x6b,%r12d
  80b573:	e9 54 0f 00 00       	jmp    80c4cc <lodepng_convert+0x1061>
      cprintf("here\n");
  80b578:	48 bf a3 26 81 00 00 	movabs $0x8126a3,%rdi
  80b57f:	00 00 00 
  80b582:	b8 00 00 00 00       	mov    $0x0,%eax
  80b587:	48 ba 67 04 80 00 00 	movabs $0x800467,%rdx
  80b58e:	00 00 00 
  80b591:	ff d2                	call   *%rdx
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
  80b593:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80b59a:	8b b5 10 ff ff ff    	mov    -0xf0(%rbp),%esi
  80b5a0:	8b bd 18 ff ff ff    	mov    -0xe8(%rbp),%edi
  80b5a6:	48 b8 dc a4 80 00 00 	movabs $0x80a4dc,%rax
  80b5ad:	00 00 00 
  80b5b0:	ff d0                	call   *%rax
  80b5b2:	48 89 c1             	mov    %rax,%rcx
    for(i = 0; i != numbytes; ++i) out[i] = in[i];
  80b5b5:	48 85 c0             	test   %rax,%rax
  80b5b8:	0f 84 ed 0e 00 00    	je     80c4ab <lodepng_convert+0x1040>
  80b5be:	b8 00 00 00 00       	mov    $0x0,%eax
  80b5c3:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80b5ca:	0f b6 14 06          	movzbl (%rsi,%rax,1),%edx
  80b5ce:	41 88 14 07          	mov    %dl,(%r15,%rax,1)
  80b5d2:	48 83 c0 01          	add    $0x1,%rax
  80b5d6:	48 39 c1             	cmp    %rax,%rcx
  80b5d9:	75 ef                	jne    80b5ca <lodepng_convert+0x15f>
    return 0;
  80b5db:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80b5e1:	e9 e6 0e 00 00       	jmp    80c4cc <lodepng_convert+0x1061>
    size_t palettesize = mode_out->palettesize;
  80b5e6:	4d 8b 66 10          	mov    0x10(%r14),%r12
    const unsigned char* palette = mode_out->palette;
  80b5ea:	4d 8b 6e 08          	mov    0x8(%r14),%r13
    size_t palsize = (size_t)1u << mode_out->bitdepth;
  80b5ee:	41 8b 4e 04          	mov    0x4(%r14),%ecx
  80b5f2:	b8 01 00 00 00       	mov    $0x1,%eax
  80b5f7:	48 d3 e0             	shl    %cl,%rax
  80b5fa:	48 89 c2             	mov    %rax,%rdx
    if(palettesize == 0) {
  80b5fd:	4d 85 e4             	test   %r12,%r12
  80b600:	0f 85 d3 00 00 00    	jne    80b6d9 <lodepng_convert+0x26e>
      palettesize = mode_in->palettesize;
  80b606:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
  80b60d:	48 8b 47 10          	mov    0x10(%rdi),%rax
      palette = mode_in->palette;
  80b611:	4c 8b 6f 08          	mov    0x8(%rdi),%r13
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
  80b615:	83 fb 03             	cmp    $0x3,%ebx
  80b618:	74 6f                	je     80b689 <lodepng_convert+0x21e>
    if(palettesize < palsize) palsize = palettesize;
  80b61a:	48 39 d0             	cmp    %rdx,%rax
  80b61d:	49 89 d4             	mov    %rdx,%r12
  80b620:	4c 0f 46 e0          	cmovbe %rax,%r12
    color_tree_init(&tree);
  80b624:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80b62b:	48 b8 aa 44 80 00 00 	movabs $0x8044aa,%rax
  80b632:	00 00 00 
  80b635:	ff d0                	call   *%rax
    for(i = 0; i != palsize; ++i) {
  80b637:	4d 85 e4             	test   %r12,%r12
  80b63a:	0f 84 94 fe ff ff    	je     80b4d4 <lodepng_convert+0x69>
  80b640:	bb 00 00 00 00       	mov    $0x0,%ebx
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
  80b645:	41 0f b6 4c 9d 02    	movzbl 0x2(%r13,%rbx,4),%ecx
  80b64b:	41 0f b6 54 9d 01    	movzbl 0x1(%r13,%rbx,4),%edx
  80b651:	41 0f b6 74 9d 00    	movzbl 0x0(%r13,%rbx,4),%esi
  80b657:	41 89 d9             	mov    %ebx,%r9d
  80b65a:	45 0f b6 44 9d 03    	movzbl 0x3(%r13,%rbx,4),%r8d
  80b660:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80b667:	48 b8 e1 58 80 00 00 	movabs $0x8058e1,%rax
  80b66e:	00 00 00 
  80b671:	ff d0                	call   *%rax
      if(error) break;
  80b673:	85 c0                	test   %eax,%eax
  80b675:	0f 85 16 0e 00 00    	jne    80c491 <lodepng_convert+0x1026>
    for(i = 0; i != palsize; ++i) {
  80b67b:	48 83 c3 01          	add    $0x1,%rbx
  80b67f:	49 39 dc             	cmp    %rbx,%r12
  80b682:	75 c1                	jne    80b645 <lodepng_convert+0x1da>
  80b684:	e9 4b fe ff ff       	jmp    80b4d4 <lodepng_convert+0x69>
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
  80b689:	3b 4f 04             	cmp    0x4(%rdi),%ecx
  80b68c:	75 8c                	jne    80b61a <lodepng_convert+0x1af>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
  80b68e:	48 89 fa             	mov    %rdi,%rdx
  80b691:	8b b5 10 ff ff ff    	mov    -0xf0(%rbp),%esi
  80b697:	8b bd 18 ff ff ff    	mov    -0xe8(%rbp),%edi
  80b69d:	48 b8 dc a4 80 00 00 	movabs $0x80a4dc,%rax
  80b6a4:	00 00 00 
  80b6a7:	ff d0                	call   *%rax
  80b6a9:	48 89 c2             	mov    %rax,%rdx
        for(i = 0; i != numbytes; ++i) out[i] = in[i];
  80b6ac:	48 85 c0             	test   %rax,%rax
  80b6af:	0f 84 fe 0d 00 00    	je     80c4b3 <lodepng_convert+0x1048>
  80b6b5:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
  80b6bc:	42 0f b6 04 21       	movzbl (%rcx,%r12,1),%eax
  80b6c1:	43 88 04 27          	mov    %al,(%r15,%r12,1)
  80b6c5:	49 83 c4 01          	add    $0x1,%r12
  80b6c9:	4c 39 e2             	cmp    %r12,%rdx
  80b6cc:	75 ee                	jne    80b6bc <lodepng_convert+0x251>
        return 0;
  80b6ce:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80b6d4:	e9 f3 0d 00 00       	jmp    80c4cc <lodepng_convert+0x1061>
    size_t palettesize = mode_out->palettesize;
  80b6d9:	4c 89 e0             	mov    %r12,%rax
  80b6dc:	e9 39 ff ff ff       	jmp    80b61a <lodepng_convert+0x1af>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
  80b6e1:	41 83 7e 04 10       	cmpl   $0x10,0x4(%r14)
  80b6e6:	0f 85 13 fe ff ff    	jne    80b4ff <lodepng_convert+0x94>
      for(i = 0; i != numpixels; ++i) {
  80b6ec:	4d 85 c0             	test   %r8,%r8
  80b6ef:	0f 84 64 0d 00 00    	je     80c459 <lodepng_convert+0xfee>
  80b6f5:	4d 89 fc             	mov    %r15,%r12
  80b6f8:	bb 00 00 00 00       	mov    $0x0,%ebx
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
  80b6fd:	49 bd d3 33 80 00 00 	movabs $0x8033d3,%r13
  80b704:	00 00 00 
  80b707:	e9 ad 00 00 00       	jmp    80b7b9 <lodepng_convert+0x34e>
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
  80b70c:	0f b7 8d 3e ff ff ff 	movzwl -0xc2(%rbp),%ecx
  80b713:	0f b7 b5 3c ff ff ff 	movzwl -0xc4(%rbp),%esi
  } else if(mode->colortype == LCT_RGB) {
  80b71a:	83 f8 02             	cmp    $0x2,%eax
  80b71d:	74 56                	je     80b775 <lodepng_convert+0x30a>
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
  80b71f:	0f b7 bd 40 ff ff ff 	movzwl -0xc0(%rbp),%edi
  } else if(mode->colortype == LCT_GREY_ALPHA) {
  80b726:	83 f8 04             	cmp    $0x4,%eax
  80b729:	0f 84 0b 01 00 00    	je     80b83a <lodepng_convert+0x3cf>
  } else if(mode->colortype == LCT_RGBA) {
  80b72f:	83 f8 06             	cmp    $0x6,%eax
  80b732:	75 70                	jne    80b7a4 <lodepng_convert+0x339>
    out[i * 8 + 0] = (r >> 8) & 255;
  80b734:	89 d0                	mov    %edx,%eax
  80b736:	66 c1 e8 08          	shr    $0x8,%ax
  80b73a:	41 88 04 df          	mov    %al,(%r15,%rbx,8)
    out[i * 8 + 1] = r & 255;
  80b73e:	41 88 54 df 01       	mov    %dl,0x1(%r15,%rbx,8)
    out[i * 8 + 2] = (g >> 8) & 255;
  80b743:	89 f0                	mov    %esi,%eax
  80b745:	66 c1 e8 08          	shr    $0x8,%ax
  80b749:	41 88 44 df 02       	mov    %al,0x2(%r15,%rbx,8)
    out[i * 8 + 3] = g & 255;
  80b74e:	41 88 74 df 03       	mov    %sil,0x3(%r15,%rbx,8)
    out[i * 8 + 4] = (b >> 8) & 255;
  80b753:	89 c8                	mov    %ecx,%eax
  80b755:	66 c1 e8 08          	shr    $0x8,%ax
  80b759:	41 88 44 df 04       	mov    %al,0x4(%r15,%rbx,8)
    out[i * 8 + 5] = b & 255;
  80b75e:	41 88 4c df 05       	mov    %cl,0x5(%r15,%rbx,8)
    out[i * 8 + 6] = (a >> 8) & 255;
  80b763:	89 f8                	mov    %edi,%eax
  80b765:	66 c1 e8 08          	shr    $0x8,%ax
  80b769:	41 88 44 df 06       	mov    %al,0x6(%r15,%rbx,8)
    out[i * 8 + 7] = a & 255;
  80b76e:	41 88 7c df 07       	mov    %dil,0x7(%r15,%rbx,8)
  80b773:	eb 2f                	jmp    80b7a4 <lodepng_convert+0x339>
    out[i * 6 + 0] = (r >> 8) & 255;
  80b775:	89 d0                	mov    %edx,%eax
  80b777:	66 c1 e8 08          	shr    $0x8,%ax
  80b77b:	41 88 04 24          	mov    %al,(%r12)
    out[i * 6 + 1] = r & 255;
  80b77f:	41 88 54 24 01       	mov    %dl,0x1(%r12)
    out[i * 6 + 2] = (g >> 8) & 255;
  80b784:	89 f0                	mov    %esi,%eax
  80b786:	66 c1 e8 08          	shr    $0x8,%ax
  80b78a:	41 88 44 24 02       	mov    %al,0x2(%r12)
    out[i * 6 + 3] = g & 255;
  80b78f:	41 88 74 24 03       	mov    %sil,0x3(%r12)
    out[i * 6 + 4] = (b >> 8) & 255;
  80b794:	89 c8                	mov    %ecx,%eax
  80b796:	66 c1 e8 08          	shr    $0x8,%ax
  80b79a:	41 88 44 24 04       	mov    %al,0x4(%r12)
    out[i * 6 + 5] = b & 255;
  80b79f:	41 88 4c 24 05       	mov    %cl,0x5(%r12)
      for(i = 0; i != numpixels; ++i) {
  80b7a4:	48 83 c3 01          	add    $0x1,%rbx
  80b7a8:	49 83 c4 06          	add    $0x6,%r12
  80b7ac:	48 39 9d 18 ff ff ff 	cmp    %rbx,-0xe8(%rbp)
  80b7b3:	0f 84 a5 00 00 00    	je     80b85e <lodepng_convert+0x3f3>
        unsigned short r = 0, g = 0, b = 0, a = 0;
  80b7b9:	66 c7 85 3a ff ff ff 	movw   $0x0,-0xc6(%rbp)
  80b7c0:	00 00 
  80b7c2:	66 c7 85 3c ff ff ff 	movw   $0x0,-0xc4(%rbp)
  80b7c9:	00 00 
  80b7cb:	66 c7 85 3e ff ff ff 	movw   $0x0,-0xc2(%rbp)
  80b7d2:	00 00 
  80b7d4:	66 c7 85 40 ff ff ff 	movw   $0x0,-0xc0(%rbp)
  80b7db:	00 00 
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
  80b7dd:	48 83 ec 08          	sub    $0x8,%rsp
  80b7e1:	ff b5 28 ff ff ff    	push   -0xd8(%rbp)
  80b7e7:	49 89 d9             	mov    %rbx,%r9
  80b7ea:	4c 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%r8
  80b7f1:	48 8d 8d 40 ff ff ff 	lea    -0xc0(%rbp),%rcx
  80b7f8:	48 8d 95 3e ff ff ff 	lea    -0xc2(%rbp),%rdx
  80b7ff:	48 8d b5 3c ff ff ff 	lea    -0xc4(%rbp),%rsi
  80b806:	48 8d bd 3a ff ff ff 	lea    -0xc6(%rbp),%rdi
  80b80d:	41 ff d5             	call   *%r13
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
  80b810:	0f b7 95 3a ff ff ff 	movzwl -0xc6(%rbp),%edx
  if(mode->colortype == LCT_GREY) {
  80b817:	41 8b 06             	mov    (%r14),%eax
  80b81a:	48 83 c4 10          	add    $0x10,%rsp
  80b81e:	85 c0                	test   %eax,%eax
  80b820:	0f 85 e6 fe ff ff    	jne    80b70c <lodepng_convert+0x2a1>
    out[i * 2 + 0] = (gray >> 8) & 255;
  80b826:	89 d0                	mov    %edx,%eax
  80b828:	66 c1 e8 08          	shr    $0x8,%ax
  80b82c:	41 88 04 5f          	mov    %al,(%r15,%rbx,2)
    out[i * 2 + 1] = gray & 255;
  80b830:	41 88 54 5f 01       	mov    %dl,0x1(%r15,%rbx,2)
  80b835:	e9 6a ff ff ff       	jmp    80b7a4 <lodepng_convert+0x339>
    out[i * 4 + 0] = (gray >> 8) & 255;
  80b83a:	89 d0                	mov    %edx,%eax
  80b83c:	66 c1 e8 08          	shr    $0x8,%ax
  80b840:	41 88 04 9f          	mov    %al,(%r15,%rbx,4)
    out[i * 4 + 1] = gray & 255;
  80b844:	41 88 54 9f 01       	mov    %dl,0x1(%r15,%rbx,4)
    out[i * 4 + 2] = (a >> 8) & 255;
  80b849:	89 f8                	mov    %edi,%eax
  80b84b:	66 c1 e8 08          	shr    $0x8,%ax
  80b84f:	41 88 44 9f 02       	mov    %al,0x2(%r15,%rbx,4)
    out[i * 4 + 3] = a & 255;
  80b854:	41 88 7c 9f 03       	mov    %dil,0x3(%r15,%rbx,4)
  80b859:	e9 46 ff ff ff       	jmp    80b7a4 <lodepng_convert+0x339>
  80b85e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80b864:	e9 5d 0c 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
  if(mode->colortype == LCT_GREY) {
  80b869:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80b870:	44 8b 20             	mov    (%rax),%r12d
  80b873:	45 85 e4             	test   %r12d,%r12d
  80b876:	0f 85 c5 01 00 00    	jne    80ba41 <lodepng_convert+0x5d6>
    if(mode->bitdepth == 8) {
  80b87c:	83 f9 08             	cmp    $0x8,%ecx
  80b87f:	74 5b                	je     80b8dc <lodepng_convert+0x471>
    } else if(mode->bitdepth == 16) {
  80b881:	83 f9 10             	cmp    $0x10,%ecx
  80b884:	0f 84 d6 00 00 00    	je     80b960 <lodepng_convert+0x4f5>
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
  80b88a:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  80b890:	41 d3 e5             	shl    %cl,%r13d
  80b893:	41 8d 7d ff          	lea    -0x1(%r13),%edi
      size_t j = 0;
  80b897:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  80b89e:	00 00 00 00 
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80b8a2:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  80b8a9:	00 
  80b8aa:	0f 84 16 0c 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80b8b0:	bb 00 00 00 00       	mov    $0x0,%ebx
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80b8b5:	49 bd 9a 2d 80 00 00 	movabs $0x802d9a,%r13
  80b8bc:	00 00 00 
  80b8bf:	44 89 a5 10 ff ff ff 	mov    %r12d,-0xf0(%rbp)
  80b8c6:	4c 89 b5 08 ff ff ff 	mov    %r14,-0xf8(%rbp)
  80b8cd:	41 89 fe             	mov    %edi,%r14d
  80b8d0:	4c 8b a5 28 ff ff ff 	mov    -0xd8(%rbp),%r12
  80b8d7:	e9 06 01 00 00       	jmp    80b9e2 <lodepng_convert+0x577>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80b8dc:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80b8e3:	48 85 c0             	test   %rax,%rax
  80b8e6:	0f 84 da 0b 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80b8ec:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80b8f3:	48 89 f2             	mov    %rsi,%rdx
  80b8f6:	48 01 c6             	add    %rax,%rsi
  80b8f9:	4c 89 f8             	mov    %r15,%rax
        buffer[0] = buffer[1] = buffer[2] = in[i];
  80b8fc:	0f b6 0a             	movzbl (%rdx),%ecx
  80b8ff:	88 48 02             	mov    %cl,0x2(%rax)
  80b902:	88 48 01             	mov    %cl,0x1(%rax)
  80b905:	88 08                	mov    %cl,(%rax)
        buffer[3] = 255;
  80b907:	c6 40 03 ff          	movb   $0xff,0x3(%rax)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80b90b:	48 83 c0 04          	add    $0x4,%rax
  80b90f:	48 83 c2 01          	add    $0x1,%rdx
  80b913:	48 39 f2             	cmp    %rsi,%rdx
  80b916:	75 e4                	jne    80b8fc <lodepng_convert+0x491>
      if(mode->key_defined) {
  80b918:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80b91f:	8b 40 18             	mov    0x18(%rax),%eax
  80b922:	85 c0                	test   %eax,%eax
  80b924:	0f 84 91 0b 00 00    	je     80c4bb <lodepng_convert+0x1050>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
  80b92a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80b931:	8b 48 1c             	mov    0x1c(%rax),%ecx
  80b934:	b8 00 00 00 00       	mov    $0x0,%eax
  80b939:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  80b940:	eb 0d                	jmp    80b94f <lodepng_convert+0x4e4>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80b942:	48 83 c0 01          	add    $0x1,%rax
  80b946:	48 39 c6             	cmp    %rax,%rsi
  80b949:	0f 84 77 0b 00 00    	je     80c4c6 <lodepng_convert+0x105b>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
  80b94f:	41 0f b6 14 87       	movzbl (%r15,%rax,4),%edx
  80b954:	39 ca                	cmp    %ecx,%edx
  80b956:	75 ea                	jne    80b942 <lodepng_convert+0x4d7>
  80b958:	41 c6 44 87 03 00    	movb   $0x0,0x3(%r15,%rax,4)
  80b95e:	eb e2                	jmp    80b942 <lodepng_convert+0x4d7>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80b960:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80b967:	48 85 c0             	test   %rax,%rax
  80b96a:	0f 84 56 0b 00 00    	je     80c4c6 <lodepng_convert+0x105b>
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
  80b970:	4c 8b 8d 28 ff ff ff 	mov    -0xd8(%rbp),%r9
  80b977:	41 8b 79 18          	mov    0x18(%r9),%edi
  80b97b:	48 8b 9d 20 ff ff ff 	mov    -0xe0(%rbp),%rbx
  80b982:	48 89 da             	mov    %rbx,%rdx
  80b985:	4c 8d 04 43          	lea    (%rbx,%rax,2),%r8
  80b989:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80b98e:	eb 15                	jmp    80b9a5 <lodepng_convert+0x53a>
  80b990:	41 88 4f 03          	mov    %cl,0x3(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80b994:	49 83 c7 04          	add    $0x4,%r15
  80b998:	48 83 c2 02          	add    $0x2,%rdx
  80b99c:	49 39 d0             	cmp    %rdx,%r8
  80b99f:	0f 84 21 0b 00 00    	je     80c4c6 <lodepng_convert+0x105b>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
  80b9a5:	0f b6 02             	movzbl (%rdx),%eax
  80b9a8:	41 88 47 02          	mov    %al,0x2(%r15)
  80b9ac:	41 88 47 01          	mov    %al,0x1(%r15)
  80b9b0:	41 88 07             	mov    %al,(%r15)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
  80b9b3:	89 f1                	mov    %esi,%ecx
  80b9b5:	85 ff                	test   %edi,%edi
  80b9b7:	74 d7                	je     80b990 <lodepng_convert+0x525>
  80b9b9:	0f b6 c0             	movzbl %al,%eax
  80b9bc:	c1 e0 08             	shl    $0x8,%eax
  80b9bf:	0f b6 4a 01          	movzbl 0x1(%rdx),%ecx
  80b9c3:	01 c8                	add    %ecx,%eax
  80b9c5:	41 3b 41 1c          	cmp    0x1c(%r9),%eax
  80b9c9:	0f 95 c1             	setne  %cl
  80b9cc:	f7 d9                	neg    %ecx
  80b9ce:	eb c0                	jmp    80b990 <lodepng_convert+0x525>
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
  80b9d0:	41 88 44 9f 03       	mov    %al,0x3(%r15,%rbx,4)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80b9d5:	48 83 c3 01          	add    $0x1,%rbx
  80b9d9:	48 39 9d 18 ff ff ff 	cmp    %rbx,-0xe8(%rbp)
  80b9e0:	74 4c                	je     80ba2e <lodepng_convert+0x5c3>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80b9e2:	41 8b 54 24 04       	mov    0x4(%r12),%edx
  80b9e7:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80b9ee:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80b9f5:	41 ff d5             	call   *%r13
  80b9f8:	89 c1                	mov    %eax,%ecx
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
  80b9fa:	c1 e0 08             	shl    $0x8,%eax
  80b9fd:	29 c8                	sub    %ecx,%eax
  80b9ff:	ba 00 00 00 00       	mov    $0x0,%edx
  80ba04:	41 f7 f6             	div    %r14d
  80ba07:	41 88 44 9f 02       	mov    %al,0x2(%r15,%rbx,4)
  80ba0c:	41 88 44 9f 01       	mov    %al,0x1(%r15,%rbx,4)
  80ba11:	41 88 04 9f          	mov    %al,(%r15,%rbx,4)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
  80ba15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ba1a:	41 83 7c 24 18 00    	cmpl   $0x0,0x18(%r12)
  80ba20:	74 ae                	je     80b9d0 <lodepng_convert+0x565>
  80ba22:	41 39 4c 24 1c       	cmp    %ecx,0x1c(%r12)
  80ba27:	0f 95 c0             	setne  %al
  80ba2a:	f7 d8                	neg    %eax
  80ba2c:	eb a2                	jmp    80b9d0 <lodepng_convert+0x565>
  80ba2e:	44 8b a5 10 ff ff ff 	mov    -0xf0(%rbp),%r12d
  80ba35:	4c 8b b5 08 ff ff ff 	mov    -0xf8(%rbp),%r14
  80ba3c:	e9 85 0a 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
  } else if(mode->colortype == LCT_RGB) {
  80ba41:	41 83 fc 02          	cmp    $0x2,%r12d
  80ba45:	74 29                	je     80ba70 <lodepng_convert+0x605>
  } else if(mode->colortype == LCT_PALETTE) {
  80ba47:	41 83 fc 03          	cmp    $0x3,%r12d
  80ba4b:	0f 84 9c 01 00 00    	je     80bbed <lodepng_convert+0x782>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
  80ba51:	41 83 fc 04          	cmp    $0x4,%r12d
  80ba55:	0f 84 92 02 00 00    	je     80bced <lodepng_convert+0x882>
  } else if(mode->colortype == LCT_RGBA) {
  80ba5b:	41 83 fc 06          	cmp    $0x6,%r12d
  80ba5f:	0f 84 28 03 00 00    	je     80bd8d <lodepng_convert+0x922>
  80ba65:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80ba6b:	e9 56 0a 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80ba70:	83 f9 08             	cmp    $0x8,%ecx
  80ba73:	74 3b                	je     80bab0 <lodepng_convert+0x645>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80ba75:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80ba7b:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  80ba82:	00 
  80ba83:	0f 84 3d 0a 00 00    	je     80c4c6 <lodepng_convert+0x105b>
        buffer[3] = mode->key_defined
  80ba89:	4c 8b 9d 28 ff ff ff 	mov    -0xd8(%rbp),%r11
  80ba90:	45 8b 43 18          	mov    0x18(%r11),%r8d
  80ba94:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80ba9b:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80baa2:	4d 8d 14 87          	lea    (%r15,%rax,4),%r10
  80baa6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80baab:	e9 d8 00 00 00       	jmp    80bb88 <lodepng_convert+0x71d>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bab0:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80bab7:	48 85 c0             	test   %rax,%rax
  80baba:	0f 84 a1 09 00 00    	je     80c461 <lodepng_convert+0xff6>
  80bac0:	48 8b bd 20 ff ff ff 	mov    -0xe0(%rbp),%rdi
  80bac7:	48 89 fb             	mov    %rdi,%rbx
  80baca:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  80bace:	48 01 f8             	add    %rdi,%rax
  80bad1:	4d 89 fc             	mov    %r15,%r12
  memcpy(dst, src, size);
  80bad4:	49 bd 08 10 80 00 00 	movabs $0x801008,%r13
  80badb:	00 00 00 
  80bade:	4c 89 bd 20 ff ff ff 	mov    %r15,-0xe0(%rbp)
  80bae5:	49 89 c7             	mov    %rax,%r15
  80bae8:	ba 03 00 00 00       	mov    $0x3,%edx
  80baed:	48 89 de             	mov    %rbx,%rsi
  80baf0:	4c 89 e7             	mov    %r12,%rdi
  80baf3:	41 ff d5             	call   *%r13
        buffer[3] = 255;
  80baf6:	41 c6 44 24 03 ff    	movb   $0xff,0x3(%r12)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bafc:	49 83 c4 04          	add    $0x4,%r12
  80bb00:	48 83 c3 03          	add    $0x3,%rbx
  80bb04:	4c 39 fb             	cmp    %r15,%rbx
  80bb07:	75 df                	jne    80bae8 <lodepng_convert+0x67d>
  80bb09:	4c 8b bd 20 ff ff ff 	mov    -0xe0(%rbp),%r15
      if(mode->key_defined) {
  80bb10:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80bb17:	44 8b 60 18          	mov    0x18(%rax),%r12d
  80bb1b:	45 85 e4             	test   %r12d,%r12d
  80bb1e:	0f 84 a2 09 00 00    	je     80c4c6 <lodepng_convert+0x105b>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
  80bb24:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
  80bb2b:	8b 4f 1c             	mov    0x1c(%rdi),%ecx
  80bb2e:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb33:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  80bb3a:	eb 09                	jmp    80bb45 <lodepng_convert+0x6da>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bb3c:	48 83 c0 01          	add    $0x1,%rax
  80bb40:	48 39 c6             	cmp    %rax,%rsi
  80bb43:	74 27                	je     80bb6c <lodepng_convert+0x701>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
  80bb45:	41 0f b6 14 87       	movzbl (%r15,%rax,4),%edx
  80bb4a:	39 ca                	cmp    %ecx,%edx
  80bb4c:	75 ee                	jne    80bb3c <lodepng_convert+0x6d1>
  80bb4e:	41 0f b6 54 87 01    	movzbl 0x1(%r15,%rax,4),%edx
  80bb54:	3b 57 20             	cmp    0x20(%rdi),%edx
  80bb57:	75 e3                	jne    80bb3c <lodepng_convert+0x6d1>
  80bb59:	41 0f b6 54 87 02    	movzbl 0x2(%r15,%rax,4),%edx
  80bb5f:	3b 57 24             	cmp    0x24(%rdi),%edx
  80bb62:	75 d8                	jne    80bb3c <lodepng_convert+0x6d1>
  80bb64:	41 c6 44 87 03 00    	movb   $0x0,0x3(%r15,%rax,4)
  80bb6a:	eb d0                	jmp    80bb3c <lodepng_convert+0x6d1>
  80bb6c:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bb72:	e9 4f 09 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
        buffer[3] = mode->key_defined
  80bb77:	41 88 5f 03          	mov    %bl,0x3(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bb7b:	49 83 c7 04          	add    $0x4,%r15
  80bb7f:	48 83 c6 06          	add    $0x6,%rsi
  80bb83:	4d 39 fa             	cmp    %r15,%r10
  80bb86:	74 5a                	je     80bbe2 <lodepng_convert+0x777>
        buffer[0] = in[i * 6 + 0];
  80bb88:	0f b6 06             	movzbl (%rsi),%eax
  80bb8b:	41 88 07             	mov    %al,(%r15)
        buffer[1] = in[i * 6 + 2];
  80bb8e:	0f b6 56 02          	movzbl 0x2(%rsi),%edx
  80bb92:	41 88 57 01          	mov    %dl,0x1(%r15)
        buffer[2] = in[i * 6 + 4];
  80bb96:	0f b6 4e 04          	movzbl 0x4(%rsi),%ecx
  80bb9a:	41 88 4f 02          	mov    %cl,0x2(%r15)
        buffer[3] = mode->key_defined
  80bb9e:	89 fb                	mov    %edi,%ebx
  80bba0:	45 85 c0             	test   %r8d,%r8d
  80bba3:	74 d2                	je     80bb77 <lodepng_convert+0x70c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
  80bba5:	0f b6 c0             	movzbl %al,%eax
  80bba8:	c1 e0 08             	shl    $0x8,%eax
  80bbab:	0f b6 5e 01          	movzbl 0x1(%rsi),%ebx
  80bbaf:	01 d8                	add    %ebx,%eax
        buffer[3] = mode->key_defined
  80bbb1:	89 fb                	mov    %edi,%ebx
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
  80bbb3:	41 3b 43 1c          	cmp    0x1c(%r11),%eax
  80bbb7:	75 be                	jne    80bb77 <lodepng_convert+0x70c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
  80bbb9:	0f b6 c2             	movzbl %dl,%eax
  80bbbc:	c1 e0 08             	shl    $0x8,%eax
  80bbbf:	0f b6 56 03          	movzbl 0x3(%rsi),%edx
  80bbc3:	01 d0                	add    %edx,%eax
  80bbc5:	41 3b 43 20          	cmp    0x20(%r11),%eax
  80bbc9:	75 ac                	jne    80bb77 <lodepng_convert+0x70c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
  80bbcb:	0f b6 c1             	movzbl %cl,%eax
  80bbce:	c1 e0 08             	shl    $0x8,%eax
  80bbd1:	0f b6 56 05          	movzbl 0x5(%rsi),%edx
  80bbd5:	01 d0                	add    %edx,%eax
  80bbd7:	41 3b 43 24          	cmp    0x24(%r11),%eax
  80bbdb:	0f 95 c3             	setne  %bl
  80bbde:	f7 db                	neg    %ebx
  80bbe0:	eb 95                	jmp    80bb77 <lodepng_convert+0x70c>
  80bbe2:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bbe8:	e9 d9 08 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80bbed:	83 f9 08             	cmp    $0x8,%ecx
  80bbf0:	0f 84 8c 00 00 00    	je     80bc82 <lodepng_convert+0x817>
      size_t j = 0;
  80bbf6:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  80bbfd:	00 00 00 00 
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bc01:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  80bc08:	00 
  80bc09:	74 6c                	je     80bc77 <lodepng_convert+0x80c>
  80bc0b:	bb 00 00 00 00       	mov    $0x0,%ebx
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80bc10:	49 bc 9a 2d 80 00 00 	movabs $0x802d9a,%r12
  80bc17:	00 00 00 
  memcpy(dst, src, size);
  80bc1a:	49 bd 08 10 80 00 00 	movabs $0x801008,%r13
  80bc21:	00 00 00 
  80bc24:	4c 89 b5 10 ff ff ff 	mov    %r14,-0xf0(%rbp)
  80bc2b:	4c 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%r14
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80bc32:	41 8b 56 04          	mov    0x4(%r14),%edx
  80bc36:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80bc3d:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80bc44:	41 ff d4             	call   *%r12
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
  80bc47:	8d 34 85 00 00 00 00 	lea    0x0(,%rax,4),%esi
  80bc4e:	89 f6                	mov    %esi,%esi
  80bc50:	49 03 76 08          	add    0x8(%r14),%rsi
  memcpy(dst, src, size);
  80bc54:	ba 04 00 00 00       	mov    $0x4,%edx
  80bc59:	4c 89 ff             	mov    %r15,%rdi
  80bc5c:	41 ff d5             	call   *%r13
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bc5f:	48 83 c3 01          	add    $0x1,%rbx
  80bc63:	49 83 c7 04          	add    $0x4,%r15
  80bc67:	48 39 9d 18 ff ff ff 	cmp    %rbx,-0xe8(%rbp)
  80bc6e:	75 c2                	jne    80bc32 <lodepng_convert+0x7c7>
  80bc70:	4c 8b b5 10 ff ff ff 	mov    -0xf0(%rbp),%r14
  80bc77:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bc7d:	e9 44 08 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bc82:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80bc89:	48 85 c0             	test   %rax,%rax
  80bc8c:	0f 84 d7 07 00 00    	je     80c469 <lodepng_convert+0xffe>
  80bc92:	4c 8b ad 20 ff ff ff 	mov    -0xe0(%rbp),%r13
  80bc99:	4c 89 eb             	mov    %r13,%rbx
  80bc9c:	49 01 c5             	add    %rax,%r13
  memcpy(dst, src, size);
  80bc9f:	49 bc 08 10 80 00 00 	movabs $0x801008,%r12
  80bca6:	00 00 00 
  80bca9:	4c 89 b5 20 ff ff ff 	mov    %r14,-0xe0(%rbp)
  80bcb0:	4c 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%r14
        unsigned index = in[i];
  80bcb7:	0f b6 33             	movzbl (%rbx),%esi
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
  80bcba:	c1 e6 02             	shl    $0x2,%esi
  80bcbd:	89 f6                	mov    %esi,%esi
  80bcbf:	49 03 76 08          	add    0x8(%r14),%rsi
  memcpy(dst, src, size);
  80bcc3:	ba 04 00 00 00       	mov    $0x4,%edx
  80bcc8:	4c 89 ff             	mov    %r15,%rdi
  80bccb:	41 ff d4             	call   *%r12
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bcce:	49 83 c7 04          	add    $0x4,%r15
  80bcd2:	48 83 c3 01          	add    $0x1,%rbx
  80bcd6:	4c 39 eb             	cmp    %r13,%rbx
  80bcd9:	75 dc                	jne    80bcb7 <lodepng_convert+0x84c>
  80bcdb:	4c 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%r14
  80bce2:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bce8:	e9 d9 07 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80bced:	83 f9 08             	cmp    $0x8,%ecx
  80bcf0:	74 4f                	je     80bd41 <lodepng_convert+0x8d6>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bcf2:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80bcf9:	48 8b bd 18 ff ff ff 	mov    -0xe8(%rbp),%rdi
  80bd00:	49 8d 0c bf          	lea    (%r15,%rdi,4),%rcx
  80bd04:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bd0a:	48 85 ff             	test   %rdi,%rdi
  80bd0d:	0f 84 b3 07 00 00    	je     80c4c6 <lodepng_convert+0x105b>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
  80bd13:	0f b6 10             	movzbl (%rax),%edx
  80bd16:	41 88 57 02          	mov    %dl,0x2(%r15)
  80bd1a:	41 88 57 01          	mov    %dl,0x1(%r15)
  80bd1e:	41 88 17             	mov    %dl,(%r15)
        buffer[3] = in[i * 4 + 2];
  80bd21:	0f b6 50 02          	movzbl 0x2(%rax),%edx
  80bd25:	41 88 57 03          	mov    %dl,0x3(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bd29:	49 83 c7 04          	add    $0x4,%r15
  80bd2d:	48 83 c0 04          	add    $0x4,%rax
  80bd31:	49 39 cf             	cmp    %rcx,%r15
  80bd34:	75 dd                	jne    80bd13 <lodepng_convert+0x8a8>
  80bd36:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bd3c:	e9 85 07 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bd41:	48 8b bd 18 ff ff ff 	mov    -0xe8(%rbp),%rdi
  80bd48:	48 85 ff             	test   %rdi,%rdi
  80bd4b:	0f 84 20 07 00 00    	je     80c471 <lodepng_convert+0x1006>
  80bd51:	48 8b 9d 20 ff ff ff 	mov    -0xe0(%rbp),%rbx
  80bd58:	48 89 d8             	mov    %rbx,%rax
  80bd5b:	48 8d 0c 7b          	lea    (%rbx,%rdi,2),%rcx
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
  80bd5f:	0f b6 10             	movzbl (%rax),%edx
  80bd62:	41 88 57 02          	mov    %dl,0x2(%r15)
  80bd66:	41 88 57 01          	mov    %dl,0x1(%r15)
  80bd6a:	41 88 17             	mov    %dl,(%r15)
        buffer[3] = in[i * 2 + 1];
  80bd6d:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80bd71:	41 88 57 03          	mov    %dl,0x3(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bd75:	49 83 c7 04          	add    $0x4,%r15
  80bd79:	48 83 c0 02          	add    $0x2,%rax
  80bd7d:	48 39 c8             	cmp    %rcx,%rax
  80bd80:	75 dd                	jne    80bd5f <lodepng_convert+0x8f4>
  80bd82:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bd88:	e9 39 07 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80bd8d:	83 f9 08             	cmp    $0x8,%ecx
  80bd90:	74 57                	je     80bde9 <lodepng_convert+0x97e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bd92:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80bd99:	48 8b bd 18 ff ff ff 	mov    -0xe8(%rbp),%rdi
  80bda0:	49 8d 0c bf          	lea    (%r15,%rdi,4),%rcx
  80bda4:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bdaa:	48 85 ff             	test   %rdi,%rdi
  80bdad:	0f 84 13 07 00 00    	je     80c4c6 <lodepng_convert+0x105b>
        buffer[0] = in[i * 8 + 0];
  80bdb3:	0f b6 10             	movzbl (%rax),%edx
  80bdb6:	41 88 17             	mov    %dl,(%r15)
        buffer[1] = in[i * 8 + 2];
  80bdb9:	0f b6 50 02          	movzbl 0x2(%rax),%edx
  80bdbd:	41 88 57 01          	mov    %dl,0x1(%r15)
        buffer[2] = in[i * 8 + 4];
  80bdc1:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80bdc5:	41 88 57 02          	mov    %dl,0x2(%r15)
        buffer[3] = in[i * 8 + 6];
  80bdc9:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  80bdcd:	41 88 57 03          	mov    %dl,0x3(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bdd1:	49 83 c7 04          	add    $0x4,%r15
  80bdd5:	48 83 c0 08          	add    $0x8,%rax
  80bdd9:	4c 39 f9             	cmp    %r15,%rcx
  80bddc:	75 d5                	jne    80bdb3 <lodepng_convert+0x948>
  80bdde:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bde4:	e9 dd 06 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      lodepng_memcpy(buffer, in, numpixels * 4);
  80bde9:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80bdf0:	48 c1 e2 02          	shl    $0x2,%rdx
  memcpy(dst, src, size);
  80bdf4:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80bdfb:	4c 89 ff             	mov    %r15,%rdi
  80bdfe:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  80be05:	00 00 00 
  80be08:	ff d0                	call   *%rax
}
  80be0a:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80be10:	e9 b1 06 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
  if(mode->colortype == LCT_GREY) {
  80be15:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80be1c:	44 8b 20             	mov    (%rax),%r12d
  80be1f:	45 85 e4             	test   %r12d,%r12d
  80be22:	0f 85 26 01 00 00    	jne    80bf4e <lodepng_convert+0xae3>
    if(mode->bitdepth == 8) {
  80be28:	83 f9 08             	cmp    $0x8,%ecx
  80be2b:	0f 84 a1 00 00 00    	je     80bed2 <lodepng_convert+0xa67>
    } else if(mode->bitdepth == 16) {
  80be31:	83 f9 10             	cmp    $0x10,%ecx
  80be34:	0f 84 d6 00 00 00    	je     80bf10 <lodepng_convert+0xaa5>
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
  80be3a:	bb 01 00 00 00       	mov    $0x1,%ebx
  80be3f:	d3 e3                	shl    %cl,%ebx
  80be41:	8d 7b ff             	lea    -0x1(%rbx),%edi
      size_t j = 0;
  80be44:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  80be4b:	00 00 00 00 
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80be4f:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80be56:	48 85 c0             	test   %rax,%rax
  80be59:	0f 84 67 06 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80be5f:	4c 8d 2c 40          	lea    (%rax,%rax,2),%r13
  80be63:	4d 01 fd             	add    %r15,%r13
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80be66:	48 bb 9a 2d 80 00 00 	movabs $0x802d9a,%rbx
  80be6d:	00 00 00 
  80be70:	44 89 a5 18 ff ff ff 	mov    %r12d,-0xe8(%rbp)
  80be77:	41 89 fc             	mov    %edi,%r12d
  80be7a:	4c 89 b5 10 ff ff ff 	mov    %r14,-0xf0(%rbp)
  80be81:	4c 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%r14
  80be88:	41 8b 56 04          	mov    0x4(%r14),%edx
  80be8c:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80be93:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80be9a:	ff d3                	call   *%rbx
  80be9c:	89 c2                	mov    %eax,%edx
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
  80be9e:	c1 e0 08             	shl    $0x8,%eax
  80bea1:	29 d0                	sub    %edx,%eax
  80bea3:	ba 00 00 00 00       	mov    $0x0,%edx
  80bea8:	41 f7 f4             	div    %r12d
  80beab:	41 88 47 02          	mov    %al,0x2(%r15)
  80beaf:	41 88 47 01          	mov    %al,0x1(%r15)
  80beb3:	41 88 07             	mov    %al,(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80beb6:	49 83 c7 03          	add    $0x3,%r15
  80beba:	4d 39 fd             	cmp    %r15,%r13
  80bebd:	75 c9                	jne    80be88 <lodepng_convert+0xa1d>
  80bebf:	44 8b a5 18 ff ff ff 	mov    -0xe8(%rbp),%r12d
  80bec6:	4c 8b b5 10 ff ff ff 	mov    -0xf0(%rbp),%r14
  80becd:	e9 f4 05 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bed2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80bed9:	48 85 c0             	test   %rax,%rax
  80bedc:	0f 84 e4 05 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80bee2:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80bee9:	48 8d 14 40          	lea    (%rax,%rax,2),%rdx
  80beed:	4c 01 fa             	add    %r15,%rdx
        buffer[0] = buffer[1] = buffer[2] = in[i];
  80bef0:	0f b6 06             	movzbl (%rsi),%eax
  80bef3:	41 88 47 02          	mov    %al,0x2(%r15)
  80bef7:	41 88 47 01          	mov    %al,0x1(%r15)
  80befb:	41 88 07             	mov    %al,(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80befe:	49 83 c7 03          	add    $0x3,%r15
  80bf02:	48 83 c6 01          	add    $0x1,%rsi
  80bf06:	4c 39 fa             	cmp    %r15,%rdx
  80bf09:	75 e5                	jne    80bef0 <lodepng_convert+0xa85>
  80bf0b:	e9 b6 05 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bf10:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80bf17:	48 85 c0             	test   %rax,%rax
  80bf1a:	0f 84 a6 05 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80bf20:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80bf27:	48 8d 14 40          	lea    (%rax,%rax,2),%rdx
  80bf2b:	4c 01 fa             	add    %r15,%rdx
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
  80bf2e:	0f b6 06             	movzbl (%rsi),%eax
  80bf31:	41 88 47 02          	mov    %al,0x2(%r15)
  80bf35:	41 88 47 01          	mov    %al,0x1(%r15)
  80bf39:	41 88 07             	mov    %al,(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bf3c:	49 83 c7 03          	add    $0x3,%r15
  80bf40:	48 83 c6 02          	add    $0x2,%rsi
  80bf44:	49 39 d7             	cmp    %rdx,%r15
  80bf47:	75 e5                	jne    80bf2e <lodepng_convert+0xac3>
  80bf49:	e9 78 05 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
  } else if(mode->colortype == LCT_RGB) {
  80bf4e:	41 83 fc 02          	cmp    $0x2,%r12d
  80bf52:	74 29                	je     80bf7d <lodepng_convert+0xb12>
  } else if(mode->colortype == LCT_PALETTE) {
  80bf54:	41 83 fc 03          	cmp    $0x3,%r12d
  80bf58:	0f 84 a7 00 00 00    	je     80c005 <lodepng_convert+0xb9a>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
  80bf5e:	41 83 fc 04          	cmp    $0x4,%r12d
  80bf62:	0f 84 99 01 00 00    	je     80c101 <lodepng_convert+0xc96>
  } else if(mode->colortype == LCT_RGBA) {
  80bf68:	41 83 fc 06          	cmp    $0x6,%r12d
  80bf6c:	0f 84 27 02 00 00    	je     80c199 <lodepng_convert+0xd2e>
  80bf72:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bf78:	e9 49 05 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80bf7d:	83 f9 08             	cmp    $0x8,%ecx
  80bf80:	74 57                	je     80bfd9 <lodepng_convert+0xb6e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bf82:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bf88:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  80bf8f:	00 
  80bf90:	0f 84 30 05 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80bf96:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80bf9d:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80bfa4:	48 8d 14 40          	lea    (%rax,%rax,2),%rdx
  80bfa8:	4c 01 fa             	add    %r15,%rdx
        buffer[0] = in[i * 6 + 0];
  80bfab:	0f b6 06             	movzbl (%rsi),%eax
  80bfae:	41 88 07             	mov    %al,(%r15)
        buffer[1] = in[i * 6 + 2];
  80bfb1:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
  80bfb5:	41 88 47 01          	mov    %al,0x1(%r15)
        buffer[2] = in[i * 6 + 4];
  80bfb9:	0f b6 46 04          	movzbl 0x4(%rsi),%eax
  80bfbd:	41 88 47 02          	mov    %al,0x2(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80bfc1:	49 83 c7 03          	add    $0x3,%r15
  80bfc5:	48 83 c6 06          	add    $0x6,%rsi
  80bfc9:	49 39 d7             	cmp    %rdx,%r15
  80bfcc:	75 dd                	jne    80bfab <lodepng_convert+0xb40>
  80bfce:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80bfd4:	e9 ed 04 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      lodepng_memcpy(buffer, in, numpixels * 3);
  80bfd9:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80bfe0:	48 8d 14 40          	lea    (%rax,%rax,2),%rdx
  memcpy(dst, src, size);
  80bfe4:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80bfeb:	4c 89 ff             	mov    %r15,%rdi
  80bfee:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  80bff5:	00 00 00 
  80bff8:	ff d0                	call   *%rax
}
  80bffa:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c000:	e9 c1 04 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80c005:	83 f9 08             	cmp    $0x8,%ecx
  80c008:	0f 84 87 00 00 00    	je     80c095 <lodepng_convert+0xc2a>
      size_t j = 0;
  80c00e:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  80c015:	00 00 00 00 
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c019:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80c020:	48 85 c0             	test   %rax,%rax
  80c023:	74 65                	je     80c08a <lodepng_convert+0xc1f>
  80c025:	4c 8d 2c 40          	lea    (%rax,%rax,2),%r13
  80c029:	4d 01 fd             	add    %r15,%r13
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80c02c:	48 bb 9a 2d 80 00 00 	movabs $0x802d9a,%rbx
  80c033:	00 00 00 
  memcpy(dst, src, size);
  80c036:	49 bc 08 10 80 00 00 	movabs $0x801008,%r12
  80c03d:	00 00 00 
  80c040:	4c 89 b5 18 ff ff ff 	mov    %r14,-0xe8(%rbp)
  80c047:	4c 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%r14
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
  80c04e:	41 8b 56 04          	mov    0x4(%r14),%edx
  80c052:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80c059:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80c060:	ff d3                	call   *%rbx
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
  80c062:	8d 34 85 00 00 00 00 	lea    0x0(,%rax,4),%esi
  80c069:	89 f6                	mov    %esi,%esi
  80c06b:	49 03 76 08          	add    0x8(%r14),%rsi
  memcpy(dst, src, size);
  80c06f:	ba 03 00 00 00       	mov    $0x3,%edx
  80c074:	4c 89 ff             	mov    %r15,%rdi
  80c077:	41 ff d4             	call   *%r12
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c07a:	49 83 c7 03          	add    $0x3,%r15
  80c07e:	4d 39 fd             	cmp    %r15,%r13
  80c081:	75 cb                	jne    80c04e <lodepng_convert+0xbe3>
  80c083:	4c 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%r14
  80c08a:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c090:	e9 31 04 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c095:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80c09c:	48 85 c0             	test   %rax,%rax
  80c09f:	0f 84 d4 03 00 00    	je     80c479 <lodepng_convert+0x100e>
  80c0a5:	48 8b 9d 20 ff ff ff 	mov    -0xe0(%rbp),%rbx
  80c0ac:	4c 8d 2c 40          	lea    (%rax,%rax,2),%r13
  80c0b0:	4d 01 fd             	add    %r15,%r13
  memcpy(dst, src, size);
  80c0b3:	49 bc 08 10 80 00 00 	movabs $0x801008,%r12
  80c0ba:	00 00 00 
  80c0bd:	4c 89 b5 20 ff ff ff 	mov    %r14,-0xe0(%rbp)
  80c0c4:	4c 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%r14
        unsigned index = in[i];
  80c0cb:	0f b6 33             	movzbl (%rbx),%esi
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
  80c0ce:	c1 e6 02             	shl    $0x2,%esi
  80c0d1:	89 f6                	mov    %esi,%esi
  80c0d3:	49 03 76 08          	add    0x8(%r14),%rsi
  memcpy(dst, src, size);
  80c0d7:	ba 03 00 00 00       	mov    $0x3,%edx
  80c0dc:	4c 89 ff             	mov    %r15,%rdi
  80c0df:	41 ff d4             	call   *%r12
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c0e2:	49 83 c7 03          	add    $0x3,%r15
  80c0e6:	48 83 c3 01          	add    $0x1,%rbx
  80c0ea:	4d 39 fd             	cmp    %r15,%r13
  80c0ed:	75 dc                	jne    80c0cb <lodepng_convert+0xc60>
  80c0ef:	4c 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%r14
  80c0f6:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c0fc:	e9 c5 03 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80c101:	83 f9 08             	cmp    $0x8,%ecx
  80c104:	74 4f                	je     80c155 <lodepng_convert+0xcea>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c106:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c10c:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  80c113:	00 
  80c114:	0f 84 ac 03 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80c11a:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  80c121:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80c128:	48 8d 0c 40          	lea    (%rax,%rax,2),%rcx
  80c12c:	4c 01 f9             	add    %r15,%rcx
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
  80c12f:	0f b6 02             	movzbl (%rdx),%eax
  80c132:	41 88 47 02          	mov    %al,0x2(%r15)
  80c136:	41 88 47 01          	mov    %al,0x1(%r15)
  80c13a:	41 88 07             	mov    %al,(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c13d:	49 83 c7 03          	add    $0x3,%r15
  80c141:	48 83 c2 04          	add    $0x4,%rdx
  80c145:	49 39 cf             	cmp    %rcx,%r15
  80c148:	75 e5                	jne    80c12f <lodepng_convert+0xcc4>
  80c14a:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c150:	e9 71 03 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c155:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80c15c:	48 85 c0             	test   %rax,%rax
  80c15f:	0f 84 1c 03 00 00    	je     80c481 <lodepng_convert+0x1016>
  80c165:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  80c16c:	48 8d 0c 40          	lea    (%rax,%rax,2),%rcx
  80c170:	4c 01 f9             	add    %r15,%rcx
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
  80c173:	0f b6 02             	movzbl (%rdx),%eax
  80c176:	41 88 47 02          	mov    %al,0x2(%r15)
  80c17a:	41 88 47 01          	mov    %al,0x1(%r15)
  80c17e:	41 88 07             	mov    %al,(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c181:	49 83 c7 03          	add    $0x3,%r15
  80c185:	48 83 c2 02          	add    $0x2,%rdx
  80c189:	4c 39 f9             	cmp    %r15,%rcx
  80c18c:	75 e5                	jne    80c173 <lodepng_convert+0xd08>
  80c18e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c194:	e9 2d 03 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) {
  80c199:	83 f9 08             	cmp    $0x8,%ecx
  80c19c:	74 57                	je     80c1f5 <lodepng_convert+0xd8a>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c19e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c1a4:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  80c1ab:	00 
  80c1ac:	0f 84 14 03 00 00    	je     80c4c6 <lodepng_convert+0x105b>
  80c1b2:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80c1b9:	48 8b bd 18 ff ff ff 	mov    -0xe8(%rbp),%rdi
  80c1c0:	48 8d 0c 7f          	lea    (%rdi,%rdi,2),%rcx
  80c1c4:	4c 01 f9             	add    %r15,%rcx
        buffer[0] = in[i * 8 + 0];
  80c1c7:	0f b6 10             	movzbl (%rax),%edx
  80c1ca:	41 88 17             	mov    %dl,(%r15)
        buffer[1] = in[i * 8 + 2];
  80c1cd:	0f b6 50 02          	movzbl 0x2(%rax),%edx
  80c1d1:	41 88 57 01          	mov    %dl,0x1(%r15)
        buffer[2] = in[i * 8 + 4];
  80c1d5:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80c1d9:	41 88 57 02          	mov    %dl,0x2(%r15)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c1dd:	49 83 c7 03          	add    $0x3,%r15
  80c1e1:	48 83 c0 08          	add    $0x8,%rax
  80c1e5:	49 39 cf             	cmp    %rcx,%r15
  80c1e8:	75 dd                	jne    80c1c7 <lodepng_convert+0xd5c>
  80c1ea:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c1f0:	e9 d1 02 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c1f5:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80c1fc:	48 85 c0             	test   %rax,%rax
  80c1ff:	0f 84 84 02 00 00    	je     80c489 <lodepng_convert+0x101e>
  80c205:	48 8b 9d 20 ff ff ff 	mov    -0xe0(%rbp),%rbx
  80c20c:	4c 8d 24 40          	lea    (%rax,%rax,2),%r12
  80c210:	4d 01 fc             	add    %r15,%r12
  memcpy(dst, src, size);
  80c213:	49 bd 08 10 80 00 00 	movabs $0x801008,%r13
  80c21a:	00 00 00 
  80c21d:	ba 03 00 00 00       	mov    $0x3,%edx
  80c222:	48 89 de             	mov    %rbx,%rsi
  80c225:	4c 89 ff             	mov    %r15,%rdi
  80c228:	41 ff d5             	call   *%r13
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c22b:	49 83 c7 03          	add    $0x3,%r15
  80c22f:	48 83 c3 04          	add    $0x4,%rbx
  80c233:	4d 39 e7             	cmp    %r12,%r15
  80c236:	75 e5                	jne    80c21d <lodepng_convert+0xdb2>
  80c238:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c23e:	e9 83 02 00 00       	jmp    80c4c6 <lodepng_convert+0x105b>
    if(mode->bitdepth == 8) out[i] = gray;
  80c243:	41 88 34 1f          	mov    %sil,(%r15,%rbx,1)
      for(i = 0; i != numpixels; ++i) {
  80c247:	48 83 c3 01          	add    $0x1,%rbx
  80c24b:	49 83 c4 06          	add    $0x6,%r12
  80c24f:	49 83 c5 03          	add    $0x3,%r13
  80c253:	48 39 9d 18 ff ff ff 	cmp    %rbx,-0xe8(%rbp)
  80c25a:	0f 84 60 02 00 00    	je     80c4c0 <lodepng_convert+0x1055>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
  80c260:	48 83 ec 08          	sub    $0x8,%rsp
  80c264:	ff b5 28 ff ff ff    	push   -0xd8(%rbp)
  80c26a:	49 89 d9             	mov    %rbx,%r9
  80c26d:	4c 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%r8
  80c274:	48 8d 8d 40 ff ff ff 	lea    -0xc0(%rbp),%rcx
  80c27b:	48 8d 95 3e ff ff ff 	lea    -0xc2(%rbp),%rdx
  80c282:	48 8d b5 3c ff ff ff 	lea    -0xc4(%rbp),%rsi
  80c289:	48 8d bd 3a ff ff ff 	lea    -0xc6(%rbp),%rdi
  80c290:	48 b8 b0 30 80 00 00 	movabs $0x8030b0,%rax
  80c297:	00 00 00 
  80c29a:	ff d0                	call   *%rax
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
  80c29c:	0f b6 b5 3a ff ff ff 	movzbl -0xc6(%rbp),%esi
  if(mode->colortype == LCT_GREY) {
  80c2a3:	41 8b 06             	mov    (%r14),%eax
  80c2a6:	48 83 c4 10          	add    $0x10,%rsp
  80c2aa:	85 c0                	test   %eax,%eax
  80c2ac:	75 50                	jne    80c2fe <lodepng_convert+0xe93>
    if(mode->bitdepth == 8) out[i] = gray;
  80c2ae:	41 8b 56 04          	mov    0x4(%r14),%edx
  80c2b2:	83 fa 08             	cmp    $0x8,%edx
  80c2b5:	74 8c                	je     80c243 <lodepng_convert+0xdd8>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
  80c2b7:	83 fa 10             	cmp    $0x10,%edx
  80c2ba:	75 0b                	jne    80c2c7 <lodepng_convert+0xe5c>
  80c2bc:	41 88 74 5f 01       	mov    %sil,0x1(%r15,%rbx,2)
  80c2c1:	41 88 34 5f          	mov    %sil,(%r15,%rbx,2)
  80c2c5:	eb 80                	jmp    80c247 <lodepng_convert+0xddc>
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
  80c2c7:	40 0f b6 f6          	movzbl %sil,%esi
  80c2cb:	b9 08 00 00 00       	mov    $0x8,%ecx
  80c2d0:	29 d1                	sub    %edx,%ecx
  80c2d2:	d3 ee                	shr    %cl,%esi
  80c2d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c2d9:	89 d1                	mov    %edx,%ecx
  80c2db:	d3 e0                	shl    %cl,%eax
  80c2dd:	89 c1                	mov    %eax,%ecx
  80c2df:	f7 d1                	not    %ecx
  80c2e1:	21 ce                	and    %ecx,%esi
      addColorBits(out, i, mode->bitdepth, gray);
  80c2e3:	40 0f b6 ce          	movzbl %sil,%ecx
  80c2e7:	48 89 de             	mov    %rbx,%rsi
  80c2ea:	4c 89 ff             	mov    %r15,%rdi
  80c2ed:	48 b8 e4 2f 80 00 00 	movabs $0x802fe4,%rax
  80c2f4:	00 00 00 
  80c2f7:	ff d0                	call   *%rax
  80c2f9:	e9 49 ff ff ff       	jmp    80c247 <lodepng_convert+0xddc>
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
  80c2fe:	0f b6 8d 3e ff ff ff 	movzbl -0xc2(%rbp),%ecx
  80c305:	0f b6 95 3c ff ff ff 	movzbl -0xc4(%rbp),%edx
  } else if(mode->colortype == LCT_RGB) {
  80c30c:	83 f8 02             	cmp    $0x2,%eax
  80c30f:	74 5a                	je     80c36b <lodepng_convert+0xf00>
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
  80c311:	44 0f b6 85 40 ff ff 	movzbl -0xc0(%rbp),%r8d
  80c318:	ff 
  } else if(mode->colortype == LCT_PALETTE) {
  80c319:	83 f8 03             	cmp    $0x3,%eax
  80c31c:	0f 84 83 00 00 00    	je     80c3a5 <lodepng_convert+0xf3a>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
  80c322:	83 f8 04             	cmp    $0x4,%eax
  80c325:	0f 84 ce 00 00 00    	je     80c3f9 <lodepng_convert+0xf8e>
  } else if(mode->colortype == LCT_RGBA) {
  80c32b:	83 f8 06             	cmp    $0x6,%eax
  80c32e:	0f 85 13 ff ff ff    	jne    80c247 <lodepng_convert+0xddc>
    if(mode->bitdepth == 8) {
  80c334:	41 83 7e 04 08       	cmpl   $0x8,0x4(%r14)
  80c339:	0f 84 f2 00 00 00    	je     80c431 <lodepng_convert+0xfc6>
      out[i * 8 + 0] = out[i * 8 + 1] = r;
  80c33f:	41 88 74 df 01       	mov    %sil,0x1(%r15,%rbx,8)
  80c344:	41 88 34 df          	mov    %sil,(%r15,%rbx,8)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
  80c348:	41 88 54 df 03       	mov    %dl,0x3(%r15,%rbx,8)
  80c34d:	41 88 54 df 02       	mov    %dl,0x2(%r15,%rbx,8)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
  80c352:	41 88 4c df 05       	mov    %cl,0x5(%r15,%rbx,8)
  80c357:	41 88 4c df 04       	mov    %cl,0x4(%r15,%rbx,8)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
  80c35c:	45 88 44 df 07       	mov    %r8b,0x7(%r15,%rbx,8)
  80c361:	45 88 44 df 06       	mov    %r8b,0x6(%r15,%rbx,8)
  80c366:	e9 dc fe ff ff       	jmp    80c247 <lodepng_convert+0xddc>
    if(mode->bitdepth == 8) {
  80c36b:	41 83 7e 04 08       	cmpl   $0x8,0x4(%r14)
  80c370:	74 22                	je     80c394 <lodepng_convert+0xf29>
      out[i * 6 + 0] = out[i * 6 + 1] = r;
  80c372:	41 88 74 24 01       	mov    %sil,0x1(%r12)
  80c377:	41 88 34 24          	mov    %sil,(%r12)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
  80c37b:	41 88 54 24 03       	mov    %dl,0x3(%r12)
  80c380:	41 88 54 24 02       	mov    %dl,0x2(%r12)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
  80c385:	41 88 4c 24 05       	mov    %cl,0x5(%r12)
  80c38a:	41 88 4c 24 04       	mov    %cl,0x4(%r12)
  80c38f:	e9 b3 fe ff ff       	jmp    80c247 <lodepng_convert+0xddc>
      out[i * 3 + 0] = r;
  80c394:	41 88 75 00          	mov    %sil,0x0(%r13)
      out[i * 3 + 1] = g;
  80c398:	41 88 55 01          	mov    %dl,0x1(%r13)
      out[i * 3 + 2] = b;
  80c39c:	41 88 4d 02          	mov    %cl,0x2(%r13)
  80c3a0:	e9 a2 fe ff ff       	jmp    80c247 <lodepng_convert+0xddc>
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
  80c3a5:	0f b6 c9             	movzbl %cl,%ecx
  80c3a8:	0f b6 d2             	movzbl %dl,%edx
  80c3ab:	40 0f b6 f6          	movzbl %sil,%esi
    int index = color_tree_get(tree, r, g, b, a);
  80c3af:	45 0f b6 c0          	movzbl %r8b,%r8d
  80c3b3:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80c3ba:	48 b8 49 30 80 00 00 	movabs $0x803049,%rax
  80c3c1:	00 00 00 
  80c3c4:	ff d0                	call   *%rax
    if(index < 0) return 82; /*color not in palette*/
  80c3c6:	85 c0                	test   %eax,%eax
  80c3c8:	0f 88 83 00 00 00    	js     80c451 <lodepng_convert+0xfe6>
    if(mode->bitdepth == 8) out[i] = index;
  80c3ce:	41 8b 56 04          	mov    0x4(%r14),%edx
  80c3d2:	83 fa 08             	cmp    $0x8,%edx
  80c3d5:	75 09                	jne    80c3e0 <lodepng_convert+0xf75>
  80c3d7:	41 88 04 1f          	mov    %al,(%r15,%rbx,1)
  80c3db:	e9 67 fe ff ff       	jmp    80c247 <lodepng_convert+0xddc>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
  80c3e0:	89 c1                	mov    %eax,%ecx
  80c3e2:	48 89 de             	mov    %rbx,%rsi
  80c3e5:	4c 89 ff             	mov    %r15,%rdi
  80c3e8:	48 b8 e4 2f 80 00 00 	movabs $0x802fe4,%rax
  80c3ef:	00 00 00 
  80c3f2:	ff d0                	call   *%rax
  80c3f4:	e9 4e fe ff ff       	jmp    80c247 <lodepng_convert+0xddc>
    if(mode->bitdepth == 8) {
  80c3f9:	41 8b 46 04          	mov    0x4(%r14),%eax
  80c3fd:	83 f8 08             	cmp    $0x8,%eax
  80c400:	74 21                	je     80c423 <lodepng_convert+0xfb8>
    } else if(mode->bitdepth == 16) {
  80c402:	83 f8 10             	cmp    $0x10,%eax
  80c405:	0f 85 3c fe ff ff    	jne    80c247 <lodepng_convert+0xddc>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
  80c40b:	41 88 74 9f 01       	mov    %sil,0x1(%r15,%rbx,4)
  80c410:	41 88 34 9f          	mov    %sil,(%r15,%rbx,4)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
  80c414:	45 88 44 9f 03       	mov    %r8b,0x3(%r15,%rbx,4)
  80c419:	45 88 44 9f 02       	mov    %r8b,0x2(%r15,%rbx,4)
  80c41e:	e9 24 fe ff ff       	jmp    80c247 <lodepng_convert+0xddc>
      out[i * 2 + 0] = gray;
  80c423:	41 88 34 5f          	mov    %sil,(%r15,%rbx,2)
      out[i * 2 + 1] = a;
  80c427:	45 88 44 5f 01       	mov    %r8b,0x1(%r15,%rbx,2)
  80c42c:	e9 16 fe ff ff       	jmp    80c247 <lodepng_convert+0xddc>
      out[i * 4 + 0] = r;
  80c431:	41 88 34 9f          	mov    %sil,(%r15,%rbx,4)
      out[i * 4 + 1] = g;
  80c435:	41 88 54 9f 01       	mov    %dl,0x1(%r15,%rbx,4)
      out[i * 4 + 2] = b;
  80c43a:	41 88 4c 9f 02       	mov    %cl,0x2(%r15,%rbx,4)
      out[i * 4 + 3] = a;
  80c43f:	45 88 44 9f 03       	mov    %r8b,0x3(%r15,%rbx,4)
  80c444:	e9 fe fd ff ff       	jmp    80c247 <lodepng_convert+0xddc>
      for(i = 0; i != numpixels; ++i) {
  80c449:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c44f:	eb 75                	jmp    80c4c6 <lodepng_convert+0x105b>
    if(index < 0) return 82; /*color not in palette*/
  80c451:	41 bc 52 00 00 00    	mov    $0x52,%r12d
  80c457:	eb 6d                	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i) {
  80c459:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c45f:	eb 65                	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c461:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c467:	eb 5d                	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c469:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c46f:	eb 55                	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c471:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c477:	eb 4d                	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c479:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c47f:	eb 45                	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c481:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c487:	eb 3d                	jmp    80c4c6 <lodepng_convert+0x105b>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
  80c489:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c48f:	eb 35                	jmp    80c4c6 <lodepng_convert+0x105b>
  80c491:	41 89 c4             	mov    %eax,%r12d
  80c494:	eb 30                	jmp    80c4c6 <lodepng_convert+0x105b>
    color_tree_cleanup(&tree);
  80c496:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80c49d:	48 b8 75 50 80 00 00 	movabs $0x805075,%rax
  80c4a4:	00 00 00 
  80c4a7:	ff d0                	call   *%rax
  80c4a9:	eb 21                	jmp    80c4cc <lodepng_convert+0x1061>
    return 0;
  80c4ab:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c4b1:	eb 19                	jmp    80c4cc <lodepng_convert+0x1061>
        return 0;
  80c4b3:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80c4b9:	eb 11                	jmp    80c4cc <lodepng_convert+0x1061>
      if(mode->key_defined) {
  80c4bb:	41 89 c4             	mov    %eax,%r12d
  80c4be:	eb 06                	jmp    80c4c6 <lodepng_convert+0x105b>
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
  80c4c0:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  if(mode_out->colortype == LCT_PALETTE) {
  80c4c6:	41 83 3e 03          	cmpl   $0x3,(%r14)
  80c4ca:	74 ca                	je     80c496 <lodepng_convert+0x102b>
}
  80c4cc:	44 89 e0             	mov    %r12d,%eax
  80c4cf:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  80c4d3:	5b                   	pop    %rbx
  80c4d4:	41 5c                	pop    %r12
  80c4d6:	41 5d                	pop    %r13
  80c4d8:	41 5e                	pop    %r14
  80c4da:	41 5f                	pop    %r15
  80c4dc:	5d                   	pop    %rbp
  80c4dd:	c3                   	ret    

000000000080c4de <lodepng_convert_rgb>:
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
  80c4de:	55                   	push   %rbp
  80c4df:	48 89 e5             	mov    %rsp,%rbp
  80c4e2:	41 55                	push   %r13
  80c4e4:	41 54                	push   %r12
  80c4e6:	53                   	push   %rbx
  80c4e7:	49 89 f3             	mov    %rsi,%r11
  80c4ea:	49 89 d2             	mov    %rdx,%r10
  80c4ed:	89 ce                	mov    %ecx,%esi
  80c4ef:	48 8b 5d 10          	mov    0x10(%rbp),%rbx
  80c4f3:	4c 8b 65 18          	mov    0x18(%rbp),%r12
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
  80c4f7:	41 8b 4c 24 04       	mov    0x4(%r12),%ecx
  80c4fc:	b8 01 00 00 00       	mov    $0x1,%eax
  80c501:	d3 e0                	shl    %cl,%eax
  80c503:	8d 48 ff             	lea    -0x1(%rax),%ecx
  80c506:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80c50b:	ba 00 00 00 00       	mov    $0x0,%edx
  80c510:	f7 f1                	div    %ecx
  unsigned shift = 16 - mode_out->bitdepth;
  80c512:	b9 10 00 00 00       	mov    $0x10,%ecx
  80c517:	2b 4b 04             	sub    0x4(%rbx),%ecx
  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
  80c51a:	41 8b 14 24          	mov    (%r12),%edx
  80c51e:	41 89 d5             	mov    %edx,%r13d
  80c521:	41 83 e5 fb          	and    $0xfffffffb,%r13d
  80c525:	75 1f                	jne    80c546 <lodepng_convert_rgb+0x68>
    r = g = b = r_in * mul;
  80c527:	0f af c6             	imul   %esi,%eax
  80c52a:	89 c2                	mov    %eax,%edx
  80c52c:	41 89 c1             	mov    %eax,%r9d
  80c52f:	41 89 c0             	mov    %eax,%r8d
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
  80c532:	8b 33                	mov    (%rbx),%esi
  80c534:	89 f0                	mov    %esi,%eax
  80c536:	83 e0 fb             	and    $0xfffffffb,%eax
  80c539:	75 7b                	jne    80c5b6 <lodepng_convert_rgb+0xd8>
    *r_out = r >> shift ;
  80c53b:	d3 ea                	shr    %cl,%edx
  80c53d:	89 17                	mov    %edx,(%rdi)
}
  80c53f:	5b                   	pop    %rbx
  80c540:	41 5c                	pop    %r12
  80c542:	41 5d                	pop    %r13
  80c544:	5d                   	pop    %rbp
  80c545:	c3                   	ret    
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
  80c546:	41 83 fd 02          	cmp    $0x2,%r13d
  80c54a:	75 0f                	jne    80c55b <lodepng_convert_rgb+0x7d>
    r = r_in * mul;
  80c54c:	0f af f0             	imul   %eax,%esi
  80c54f:	89 f2                	mov    %esi,%edx
    g = g_in * mul;
  80c551:	44 0f af c0          	imul   %eax,%r8d
    b = b_in * mul;
  80c555:	44 0f af c8          	imul   %eax,%r9d
  80c559:	eb d7                	jmp    80c532 <lodepng_convert_rgb+0x54>
    return 31;
  80c55b:	b8 1f 00 00 00       	mov    $0x1f,%eax
  } else if(mode_in->colortype == LCT_PALETTE) {
  80c560:	83 fa 03             	cmp    $0x3,%edx
  80c563:	75 da                	jne    80c53f <lodepng_convert_rgb+0x61>
    if(r_in >= mode_in->palettesize) return 82;
  80c565:	89 f2                	mov    %esi,%edx
  80c567:	b8 52 00 00 00       	mov    $0x52,%eax
  80c56c:	49 3b 54 24 10       	cmp    0x10(%r12),%rdx
  80c571:	73 cc                	jae    80c53f <lodepng_convert_rgb+0x61>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
  80c573:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  80c578:	c1 e6 02             	shl    $0x2,%esi
  80c57b:	89 f2                	mov    %esi,%edx
  80c57d:	0f b6 14 10          	movzbl (%rax,%rdx,1),%edx
  80c581:	41 89 d0             	mov    %edx,%r8d
  80c584:	41 c1 e0 08          	shl    $0x8,%r8d
  80c588:	44 01 c2             	add    %r8d,%edx
    g = mode_in->palette[r_in * 4 + 1] * 257u;
  80c58b:	44 8d 46 01          	lea    0x1(%rsi),%r8d
  80c58f:	46 0f b6 04 00       	movzbl (%rax,%r8,1),%r8d
  80c594:	45 89 c1             	mov    %r8d,%r9d
  80c597:	41 c1 e1 08          	shl    $0x8,%r9d
  80c59b:	45 01 c8             	add    %r9d,%r8d
    b = mode_in->palette[r_in * 4 + 2] * 257u;
  80c59e:	83 c6 02             	add    $0x2,%esi
  80c5a1:	89 f6                	mov    %esi,%esi
  80c5a3:	0f b6 04 30          	movzbl (%rax,%rsi,1),%eax
  80c5a7:	41 89 c1             	mov    %eax,%r9d
  80c5aa:	41 c1 e1 08          	shl    $0x8,%r9d
  80c5ae:	41 01 c1             	add    %eax,%r9d
  80c5b1:	e9 7c ff ff ff       	jmp    80c532 <lodepng_convert_rgb+0x54>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
  80c5b6:	83 f8 02             	cmp    $0x2,%eax
  80c5b9:	75 1a                	jne    80c5d5 <lodepng_convert_rgb+0xf7>
    *r_out = r >> shift ;
  80c5bb:	d3 ea                	shr    %cl,%edx
  80c5bd:	89 17                	mov    %edx,(%rdi)
    *g_out = g >> shift ;
  80c5bf:	41 d3 e8             	shr    %cl,%r8d
  80c5c2:	45 89 03             	mov    %r8d,(%r11)
    *b_out = b >> shift ;
  80c5c5:	41 d3 e9             	shr    %cl,%r9d
  80c5c8:	45 89 0a             	mov    %r9d,(%r10)
  return 0;
  80c5cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5d0:	e9 6a ff ff ff       	jmp    80c53f <lodepng_convert_rgb+0x61>
    return 31;
  80c5d5:	b8 1f 00 00 00       	mov    $0x1f,%eax
  } else if(mode_out->colortype == LCT_PALETTE) {
  80c5da:	83 fe 03             	cmp    $0x3,%esi
  80c5dd:	0f 85 5c ff ff ff    	jne    80c53f <lodepng_convert_rgb+0x61>
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
  80c5e3:	89 d6                	mov    %edx,%esi
  80c5e5:	c1 ee 08             	shr    $0x8,%esi
  80c5e8:	0f b6 d2             	movzbl %dl,%edx
  80c5eb:	b8 52 00 00 00       	mov    $0x52,%eax
  80c5f0:	39 d6                	cmp    %edx,%esi
  80c5f2:	0f 85 47 ff ff ff    	jne    80c53f <lodepng_convert_rgb+0x61>
  80c5f8:	45 89 c2             	mov    %r8d,%r10d
  80c5fb:	41 c1 ea 08          	shr    $0x8,%r10d
  80c5ff:	45 0f b6 c0          	movzbl %r8b,%r8d
  80c603:	45 39 c2             	cmp    %r8d,%r10d
  80c606:	0f 85 33 ff ff ff    	jne    80c53f <lodepng_convert_rgb+0x61>
  80c60c:	45 89 cb             	mov    %r9d,%r11d
  80c60f:	41 c1 eb 08          	shr    $0x8,%r11d
  80c613:	45 0f b6 c9          	movzbl %r9b,%r9d
  80c617:	45 39 cb             	cmp    %r9d,%r11d
  80c61a:	0f 85 1f ff ff ff    	jne    80c53f <lodepng_convert_rgb+0x61>
    for(i = 0; i < mode_out->palettesize; i++) {
  80c620:	4c 8b 4b 10          	mov    0x10(%rbx),%r9
  80c624:	4d 85 c9             	test   %r9,%r9
  80c627:	74 58                	je     80c681 <lodepng_convert_rgb+0x1a3>
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
  80c629:	4c 8b 43 08          	mov    0x8(%rbx),%r8
  80c62d:	b8 00 00 00 00       	mov    $0x0,%eax
    for(i = 0; i < mode_out->palettesize; i++) {
  80c632:	ba 00 00 00 00       	mov    $0x0,%edx
  80c637:	eb 0d                	jmp    80c646 <lodepng_convert_rgb+0x168>
  80c639:	83 c2 01             	add    $0x1,%edx
  80c63c:	83 c0 04             	add    $0x4,%eax
  80c63f:	89 d1                	mov    %edx,%ecx
  80c641:	4c 39 c9             	cmp    %r9,%rcx
  80c644:	73 31                	jae    80c677 <lodepng_convert_rgb+0x199>
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
  80c646:	89 c1                	mov    %eax,%ecx
  80c648:	41 0f b6 0c 08       	movzbl (%r8,%rcx,1),%ecx
  80c64d:	39 ce                	cmp    %ecx,%esi
  80c64f:	75 e8                	jne    80c639 <lodepng_convert_rgb+0x15b>
  80c651:	8d 48 01             	lea    0x1(%rax),%ecx
  80c654:	41 0f b6 0c 08       	movzbl (%r8,%rcx,1),%ecx
  80c659:	41 39 ca             	cmp    %ecx,%r10d
  80c65c:	75 db                	jne    80c639 <lodepng_convert_rgb+0x15b>
          (b >> 8) == mode_out->palette[j + 2]) {
  80c65e:	8d 48 02             	lea    0x2(%rax),%ecx
  80c661:	41 0f b6 0c 08       	movzbl (%r8,%rcx,1),%ecx
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
  80c666:	41 39 cb             	cmp    %ecx,%r11d
  80c669:	75 ce                	jne    80c639 <lodepng_convert_rgb+0x15b>
        *r_out = i;
  80c66b:	89 17                	mov    %edx,(%rdi)
        return 0;
  80c66d:	b8 00 00 00 00       	mov    $0x0,%eax
  80c672:	e9 c8 fe ff ff       	jmp    80c53f <lodepng_convert_rgb+0x61>
    return 82;
  80c677:	b8 52 00 00 00       	mov    $0x52,%eax
  80c67c:	e9 be fe ff ff       	jmp    80c53f <lodepng_convert_rgb+0x61>
  80c681:	b8 52 00 00 00       	mov    $0x52,%eax
  80c686:	e9 b4 fe ff ff       	jmp    80c53f <lodepng_convert_rgb+0x61>

000000000080c68b <lodepng_color_stats_init>:
  stats->colored = 0;
  80c68b:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
  stats->key = 0;
  80c691:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%rdi)
  stats->key_r = stats->key_g = stats->key_b = 0;
  80c698:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%rdi)
  80c69e:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%rdi)
  80c6a4:	66 c7 47 08 00 00    	movw   $0x0,0x8(%rdi)
  stats->alpha = 0;
  80c6aa:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%rdi)
  stats->numcolors = 0;
  80c6b1:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%rdi)
  stats->bits = 1;
  80c6b8:	c7 87 18 04 00 00 01 	movl   $0x1,0x418(%rdi)
  80c6bf:	00 00 00 
  stats->numpixels = 0;
  80c6c2:	48 c7 87 20 04 00 00 	movq   $0x0,0x420(%rdi)
  80c6c9:	00 00 00 00 
  stats->allow_palette = 1;
  80c6cd:	c7 87 28 04 00 00 01 	movl   $0x1,0x428(%rdi)
  80c6d4:	00 00 00 
  stats->allow_greyscale = 1;
  80c6d7:	c7 87 2c 04 00 00 01 	movl   $0x1,0x42c(%rdi)
  80c6de:	00 00 00 
}
  80c6e1:	c3                   	ret    

000000000080c6e2 <lodepng_compute_color_stats>:
                                     const LodePNGColorMode* mode_in) {
  80c6e2:	55                   	push   %rbp
  80c6e3:	48 89 e5             	mov    %rsp,%rbp
  80c6e6:	41 57                	push   %r15
  80c6e8:	41 56                	push   %r14
  80c6ea:	41 55                	push   %r13
  80c6ec:	41 54                	push   %r12
  80c6ee:	53                   	push   %rbx
  80c6ef:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  80c6f6:	49 89 ff             	mov    %rdi,%r15
  80c6f9:	48 89 b5 28 ff ff ff 	mov    %rsi,-0xd8(%rbp)
  80c700:	4c 89 c3             	mov    %r8,%rbx
  80c703:	4c 89 85 20 ff ff ff 	mov    %r8,-0xe0(%rbp)
  size_t numpixels = (size_t)w * (size_t)h;
  80c70a:	89 d2                	mov    %edx,%edx
  80c70c:	89 c9                	mov    %ecx,%ecx
  80c70e:	48 0f af d1          	imul   %rcx,%rdx
  80c712:	48 89 95 30 ff ff ff 	mov    %rdx,-0xd0(%rbp)
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
  80c719:	4c 89 c7             	mov    %r8,%rdi
  80c71c:	48 b8 5d a4 80 00 00 	movabs $0x80a45d,%rax
  80c723:	00 00 00 
  80c726:	ff d0                	call   *%rax
  80c728:	41 89 c5             	mov    %eax,%r13d
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
  80c72b:	48 89 df             	mov    %rbx,%rdi
  80c72e:	48 b8 b1 a4 80 00 00 	movabs $0x80a4b1,%rax
  80c735:	00 00 00 
  80c738:	ff d0                	call   *%rax
  80c73a:	41 89 c6             	mov    %eax,%r14d
  unsigned bpp = lodepng_get_bpp(mode_in);
  80c73d:	48 89 df             	mov    %rbx,%rdi
  80c740:	48 b8 10 93 80 00 00 	movabs $0x809310,%rax
  80c747:	00 00 00 
  80c74a:	ff d0                	call   *%rax
  80c74c:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
  80c752:	45 8b a7 18 04 00 00 	mov    0x418(%r15),%r12d
  unsigned maxnumcolors = 257;
  80c759:	c7 85 04 ff ff ff 01 	movl   $0x101,-0xfc(%rbp)
  80c760:	01 00 00 
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
  80c763:	83 f8 08             	cmp    $0x8,%eax
  80c766:	77 24                	ja     80c78c <lodepng_compute_color_stats+0xaa>
  80c768:	89 c3                	mov    %eax,%ebx
  80c76a:	b8 01 00 00 00       	mov    $0x1,%eax
  80c76f:	89 d9                	mov    %ebx,%ecx
  80c771:	d3 e0                	shl    %cl,%eax
  80c773:	41 03 47 14          	add    0x14(%r15),%eax
  80c777:	89 c3                	mov    %eax,%ebx
  80c779:	3d 01 01 00 00       	cmp    $0x101,%eax
  80c77e:	b8 01 01 00 00       	mov    $0x101,%eax
  80c783:	0f 46 c3             	cmovbe %ebx,%eax
  80c786:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  stats->numpixels += numpixels;
  80c78c:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  80c793:	49 01 87 20 04 00 00 	add    %rax,0x420(%r15)
  if(!stats->allow_palette) numcolors_done = 1;
  80c79a:	41 8b 9f 28 04 00 00 	mov    0x428(%r15),%ebx
  color_tree_init(&tree);
  80c7a1:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80c7a8:	48 b8 aa 44 80 00 00 	movabs $0x8044aa,%rax
  80c7af:	00 00 00 
  80c7b2:	ff d0                	call   *%rax
  if(stats->alpha) alpha_done = 1;
  80c7b4:	b8 01 00 00 00       	mov    $0x1,%eax
  80c7b9:	41 83 7f 10 00       	cmpl   $0x0,0x10(%r15)
  80c7be:	75 06                	jne    80c7c6 <lodepng_compute_color_stats+0xe4>
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
  80c7c0:	45 85 f6             	test   %r14d,%r14d
  80c7c3:	0f 94 c0             	sete   %al
  80c7c6:	44 0f b6 f0          	movzbl %al,%r14d
  if(stats->colored) colored_done = 1;
  80c7ca:	45 0b 2f             	or     (%r15),%r13d
  80c7cd:	41 0f 95 c5          	setne  %r13b
  80c7d1:	45 0f b6 ed          	movzbl %r13b,%r13d
  if(stats->bits == 16) numcolors_done = 1;
  80c7d5:	41 8b 97 18 04 00 00 	mov    0x418(%r15),%edx
  80c7dc:	b9 01 00 00 00       	mov    $0x1,%ecx
  80c7e1:	83 fa 10             	cmp    $0x10,%edx
  80c7e4:	74 05                	je     80c7eb <lodepng_compute_color_stats+0x109>
  if(!stats->allow_palette) numcolors_done = 1;
  80c7e6:	85 db                	test   %ebx,%ebx
  80c7e8:	0f 94 c1             	sete   %cl
  if(stats->bits >= bpp) bits_done = 1;
  80c7eb:	b8 01 00 00 00       	mov    $0x1,%eax
  80c7f0:	8b 9d 38 ff ff ff    	mov    -0xc8(%rbp),%ebx
  80c7f6:	39 da                	cmp    %ebx,%edx
  80c7f8:	73 0f                	jae    80c809 <lodepng_compute_color_stats+0x127>
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
  80c7fa:	83 fb 01             	cmp    $0x1,%ebx
  80c7fd:	0f 94 c0             	sete   %al
  80c800:	41 83 fc 01          	cmp    $0x1,%r12d
  80c804:	0f 94 c2             	sete   %dl
  80c807:	21 d0                	and    %edx,%eax
  80c809:	0f b6 c0             	movzbl %al,%eax
  80c80c:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%rbp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
  80c812:	41 8b 47 14          	mov    0x14(%r15),%eax
  80c816:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  80c81c:	3b 85 04 ff ff ff    	cmp    -0xfc(%rbp),%eax
  80c822:	73 5d                	jae    80c881 <lodepng_compute_color_stats+0x19f>
  if(!numcolors_done) {
  80c824:	84 c9                	test   %cl,%cl
  80c826:	0f 85 b8 00 00 00    	jne    80c8e4 <lodepng_compute_color_stats+0x202>
    for(i = 0; i < stats->numcolors; i++) {
  80c82c:	85 c0                	test   %eax,%eax
  80c82e:	74 5b                	je     80c88b <lodepng_compute_color_stats+0x1a9>
  80c830:	bb 00 00 00 00       	mov    $0x0,%ebx
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
  80c835:	49 bc e1 58 80 00 00 	movabs $0x8058e1,%r12
  80c83c:	00 00 00 
  80c83f:	41 0f b6 4c 9f 1a    	movzbl 0x1a(%r15,%rbx,4),%ecx
  80c845:	41 0f b6 54 9f 19    	movzbl 0x19(%r15,%rbx,4),%edx
  80c84b:	41 0f b6 74 9f 18    	movzbl 0x18(%r15,%rbx,4),%esi
  80c851:	41 89 d9             	mov    %ebx,%r9d
  80c854:	45 0f b6 44 9f 1b    	movzbl 0x1b(%r15,%rbx,4),%r8d
  80c85a:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80c861:	41 ff d4             	call   *%r12
      if(error) goto cleanup;
  80c864:	85 c0                	test   %eax,%eax
  80c866:	0f 85 d5 08 00 00    	jne    80d141 <lodepng_compute_color_stats+0xa5f>
    for(i = 0; i < stats->numcolors; i++) {
  80c86c:	48 83 c3 01          	add    $0x1,%rbx
  80c870:	41 8b 57 14          	mov    0x14(%r15),%edx
  80c874:	48 39 da             	cmp    %rbx,%rdx
  80c877:	77 c6                	ja     80c83f <lodepng_compute_color_stats+0x15d>
  80c879:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  80c87f:	eb 0a                	jmp    80c88b <lodepng_compute_color_stats+0x1a9>
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
  80c881:	c7 85 1c ff ff ff 01 	movl   $0x1,-0xe4(%rbp)
  80c888:	00 00 00 
  if(mode_in->bitdepth == 16 && !sixteen) {
  80c88b:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80c892:	83 78 04 10          	cmpl   $0x10,0x4(%rax)
  80c896:	74 58                	je     80c8f0 <lodepng_compute_color_stats+0x20e>
    unsigned char r = 0, g = 0, b = 0, a = 0;
  80c898:	c6 85 40 ff ff ff 00 	movb   $0x0,-0xc0(%rbp)
  80c89f:	c6 85 42 ff ff ff 00 	movb   $0x0,-0xbe(%rbp)
  80c8a6:	c6 85 44 ff ff ff 00 	movb   $0x0,-0xbc(%rbp)
  80c8ad:	c6 85 46 ff ff ff 00 	movb   $0x0,-0xba(%rbp)
    for(i = 0; i != numpixels; ++i) {
  80c8b4:	48 83 bd 30 ff ff ff 	cmpq   $0x0,-0xd0(%rbp)
  80c8bb:	00 
  80c8bc:	0f 84 5e 07 00 00    	je     80d020 <lodepng_compute_color_stats+0x93e>
  80c8c2:	41 bc 00 00 00 00    	mov    $0x0,%r12d
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
  80c8c8:	44 89 ad 3c ff ff ff 	mov    %r13d,-0xc4(%rbp)
  80c8cf:	4d 89 e5             	mov    %r12,%r13
  80c8d2:	44 8b a5 18 ff ff ff 	mov    -0xe8(%rbp),%r12d
  80c8d9:	8b 9d 1c ff ff ff    	mov    -0xe4(%rbp),%ebx
  80c8df:	e9 09 05 00 00       	jmp    80cded <lodepng_compute_color_stats+0x70b>
  80c8e4:	c7 85 1c ff ff ff 01 	movl   $0x1,-0xe4(%rbp)
  80c8eb:	00 00 00 
  80c8ee:	eb 9b                	jmp    80c88b <lodepng_compute_color_stats+0x1a9>
    for(i = 0; i != numpixels; ++i) {
  80c8f0:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  80c8f7:	48 85 c0             	test   %rax,%rax
  80c8fa:	74 9c                	je     80c898 <lodepng_compute_color_stats+0x1b6>
  80c8fc:	bb 00 00 00 00       	mov    $0x0,%ebx
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
  80c901:	49 bc d3 33 80 00 00 	movabs $0x8033d3,%r12
  80c908:	00 00 00 
  80c90b:	44 89 ad 3c ff ff ff 	mov    %r13d,-0xc4(%rbp)
  80c912:	44 89 b5 14 ff ff ff 	mov    %r14d,-0xec(%rbp)
  80c919:	4c 89 bd 08 ff ff ff 	mov    %r15,-0xf8(%rbp)
  80c920:	49 89 c7             	mov    %rax,%r15
  80c923:	4c 8b ad 28 ff ff ff 	mov    -0xd8(%rbp),%r13
  80c92a:	4c 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%r14
  80c931:	48 83 ec 08          	sub    $0x8,%rsp
  80c935:	41 56                	push   %r14
  80c937:	49 89 d9             	mov    %rbx,%r9
  80c93a:	4d 89 e8             	mov    %r13,%r8
  80c93d:	48 8d 8d 46 ff ff ff 	lea    -0xba(%rbp),%rcx
  80c944:	48 8d 95 44 ff ff ff 	lea    -0xbc(%rbp),%rdx
  80c94b:	48 8d b5 42 ff ff ff 	lea    -0xbe(%rbp),%rsi
  80c952:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80c959:	41 ff d4             	call   *%r12
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
  80c95c:	0f b7 b5 40 ff ff ff 	movzwl -0xc0(%rbp),%esi
  80c963:	0f b7 8d 42 ff ff ff 	movzwl -0xbe(%rbp),%ecx
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
  80c96a:	0f b7 95 44 ff ff ff 	movzwl -0xbc(%rbp),%edx
  80c971:	0f b7 bd 46 ff ff ff 	movzwl -0xba(%rbp),%edi
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
  80c978:	89 f0                	mov    %esi,%eax
  80c97a:	66 c1 e8 08          	shr    $0x8,%ax
  80c97e:	31 f0                	xor    %esi,%eax
  80c980:	89 ce                	mov    %ecx,%esi
  80c982:	66 c1 ee 08          	shr    $0x8,%si
  80c986:	31 ce                	xor    %ecx,%esi
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
  80c988:	09 f0                	or     %esi,%eax
  80c98a:	89 d1                	mov    %edx,%ecx
  80c98c:	66 c1 e9 08          	shr    $0x8,%cx
  80c990:	31 d1                	xor    %edx,%ecx
  80c992:	09 c8                	or     %ecx,%eax
  80c994:	89 fa                	mov    %edi,%edx
  80c996:	66 c1 ea 08          	shr    $0x8,%dx
  80c99a:	31 fa                	xor    %edi,%edx
  80c99c:	09 d0                	or     %edx,%eax
  80c99e:	48 83 c4 10          	add    $0x10,%rsp
  80c9a2:	84 c0                	test   %al,%al
  80c9a4:	75 23                	jne    80c9c9 <lodepng_compute_color_stats+0x2e7>
    for(i = 0; i != numpixels; ++i) {
  80c9a6:	48 83 c3 01          	add    $0x1,%rbx
  80c9aa:	49 39 df             	cmp    %rbx,%r15
  80c9ad:	75 82                	jne    80c931 <lodepng_compute_color_stats+0x24f>
  80c9af:	44 8b ad 3c ff ff ff 	mov    -0xc4(%rbp),%r13d
  80c9b6:	44 8b b5 14 ff ff ff 	mov    -0xec(%rbp),%r14d
  80c9bd:	4c 8b bd 08 ff ff ff 	mov    -0xf8(%rbp),%r15
  80c9c4:	e9 cf fe ff ff       	jmp    80c898 <lodepng_compute_color_stats+0x1b6>
        stats->bits = 16;
  80c9c9:	44 8b ad 3c ff ff ff 	mov    -0xc4(%rbp),%r13d
  80c9d0:	44 8b b5 14 ff ff ff 	mov    -0xec(%rbp),%r14d
  80c9d7:	4c 8b bd 08 ff ff ff 	mov    -0xf8(%rbp),%r15
  80c9de:	41 c7 87 18 04 00 00 	movl   $0x10,0x418(%r15)
  80c9e5:	10 00 00 00 
    unsigned short r = 0, g = 0, b = 0, a = 0;
  80c9e9:	66 c7 85 40 ff ff ff 	movw   $0x0,-0xc0(%rbp)
  80c9f0:	00 00 
  80c9f2:	66 c7 85 42 ff ff ff 	movw   $0x0,-0xbe(%rbp)
  80c9f9:	00 00 
  80c9fb:	66 c7 85 44 ff ff ff 	movw   $0x0,-0xbc(%rbp)
  80ca02:	00 00 
  80ca04:	66 c7 85 46 ff ff ff 	movw   $0x0,-0xba(%rbp)
  80ca0b:	00 00 
    for(i = 0; i != numpixels; ++i) {
  80ca0d:	bb 00 00 00 00       	mov    $0x0,%ebx
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
  80ca12:	49 bc d3 33 80 00 00 	movabs $0x8033d3,%r12
  80ca19:	00 00 00 
    for(i = 0; i != numpixels; ++i) {
  80ca1c:	48 83 bd 30 ff ff ff 	cmpq   $0x0,-0xd0(%rbp)
  80ca23:	00 
  80ca24:	0f 85 d7 00 00 00    	jne    80cb01 <lodepng_compute_color_stats+0x41f>
    if(stats->key && !stats->alpha) {
  80ca2a:	41 83 7f 04 00       	cmpl   $0x0,0x4(%r15)
  80ca2f:	0f 84 33 02 00 00    	je     80cc68 <lodepng_compute_color_stats+0x586>
  80ca35:	41 83 7f 10 00       	cmpl   $0x0,0x10(%r15)
  80ca3a:	0f 85 28 02 00 00    	jne    80cc68 <lodepng_compute_color_stats+0x586>
      for(i = 0; i != numpixels; ++i) {
  80ca40:	4c 8b ad 30 ff ff ff 	mov    -0xd0(%rbp),%r13
  80ca47:	4d 85 ed             	test   %r13,%r13
  80ca4a:	0f 84 18 02 00 00    	je     80cc68 <lodepng_compute_color_stats+0x586>
  80ca50:	bb 00 00 00 00       	mov    $0x0,%ebx
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
  80ca55:	49 bc d3 33 80 00 00 	movabs $0x8033d3,%r12
  80ca5c:	00 00 00 
  80ca5f:	4c 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%r14
  80ca66:	e9 81 01 00 00       	jmp    80cbec <lodepng_compute_color_stats+0x50a>
      if(!colored_done && (r != g || r != b)) {
  80ca6b:	66 3b 85 44 ff ff ff 	cmp    -0xbc(%rbp),%ax
  80ca72:	0f 85 d9 00 00 00    	jne    80cb51 <lodepng_compute_color_stats+0x46f>
  80ca78:	e9 e1 00 00 00       	jmp    80cb5e <lodepng_compute_color_stats+0x47c>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80ca7d:	0f b7 85 42 ff ff ff 	movzwl -0xbe(%rbp),%eax
  80ca84:	66 41 39 47 0a       	cmp    %ax,0xa(%r15)
  80ca89:	0f 85 ea 00 00 00    	jne    80cb79 <lodepng_compute_color_stats+0x497>
  80ca8f:	0f b7 85 44 ff ff ff 	movzwl -0xbc(%rbp),%eax
  80ca96:	66 41 39 47 0c       	cmp    %ax,0xc(%r15)
  80ca9b:	0f 85 d8 00 00 00    	jne    80cb79 <lodepng_compute_color_stats+0x497>
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
  80caa1:	0f b7 85 46 ff ff ff 	movzwl -0xba(%rbp),%eax
  80caa8:	66 83 f8 ff          	cmp    $0xffff,%ax
  80caac:	75 19                	jne    80cac7 <lodepng_compute_color_stats+0x3e5>
        } else if(a == 65535 && stats->key && matchkey) {
  80caae:	41 83 7f 04 00       	cmpl   $0x0,0x4(%r15)
  80cab3:	74 3b                	je     80caf0 <lodepng_compute_color_stats+0x40e>
          stats->alpha = 1;
  80cab5:	41 c7 47 10 01 00 00 	movl   $0x1,0x10(%r15)
  80cabc:	00 
          stats->key = 0;
  80cabd:	41 c7 47 04 00 00 00 	movl   $0x0,0x4(%r15)
  80cac4:	00 
          alpha_done = 1;
  80cac5:	eb 1a                	jmp    80cae1 <lodepng_compute_color_stats+0x3ff>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80cac7:	b9 01 00 00 00       	mov    $0x1,%ecx
  80cacc:	e9 bc 00 00 00       	jmp    80cb8d <lodepng_compute_color_stats+0x4ab>
          stats->alpha = 1;
  80cad1:	41 c7 47 10 01 00 00 	movl   $0x1,0x10(%r15)
  80cad8:	00 
          stats->key = 0;
  80cad9:	41 c7 47 04 00 00 00 	movl   $0x0,0x4(%r15)
  80cae0:	00 
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
  80cae1:	45 85 ed             	test   %r13d,%r13d
  80cae4:	0f 85 40 ff ff ff    	jne    80ca2a <lodepng_compute_color_stats+0x348>
  80caea:	41 be 01 00 00 00    	mov    $0x1,%r14d
    for(i = 0; i != numpixels; ++i) {
  80caf0:	48 83 c3 01          	add    $0x1,%rbx
  80caf4:	48 39 9d 30 ff ff ff 	cmp    %rbx,-0xd0(%rbp)
  80cafb:	0f 84 29 ff ff ff    	je     80ca2a <lodepng_compute_color_stats+0x348>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
  80cb01:	48 83 ec 08          	sub    $0x8,%rsp
  80cb05:	ff b5 20 ff ff ff    	push   -0xe0(%rbp)
  80cb0b:	49 89 d9             	mov    %rbx,%r9
  80cb0e:	4c 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%r8
  80cb15:	48 8d 8d 46 ff ff ff 	lea    -0xba(%rbp),%rcx
  80cb1c:	48 8d 95 44 ff ff ff 	lea    -0xbc(%rbp),%rdx
  80cb23:	48 8d b5 42 ff ff ff 	lea    -0xbe(%rbp),%rsi
  80cb2a:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80cb31:	41 ff d4             	call   *%r12
      if(!colored_done && (r != g || r != b)) {
  80cb34:	48 83 c4 10          	add    $0x10,%rsp
  80cb38:	45 85 ed             	test   %r13d,%r13d
  80cb3b:	75 21                	jne    80cb5e <lodepng_compute_color_stats+0x47c>
  80cb3d:	0f b7 85 40 ff ff ff 	movzwl -0xc0(%rbp),%eax
  80cb44:	66 3b 85 42 ff ff ff 	cmp    -0xbe(%rbp),%ax
  80cb4b:	0f 84 1a ff ff ff    	je     80ca6b <lodepng_compute_color_stats+0x389>
        stats->colored = 1;
  80cb51:	41 c7 07 01 00 00 00 	movl   $0x1,(%r15)
        colored_done = 1;
  80cb58:	41 bd 01 00 00 00    	mov    $0x1,%r13d
      if(!alpha_done) {
  80cb5e:	45 85 f6             	test   %r14d,%r14d
  80cb61:	0f 85 7a ff ff ff    	jne    80cae1 <lodepng_compute_color_stats+0x3ff>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80cb67:	0f b7 95 40 ff ff ff 	movzwl -0xc0(%rbp),%edx
  80cb6e:	66 41 39 57 08       	cmp    %dx,0x8(%r15)
  80cb73:	0f 84 04 ff ff ff    	je     80ca7d <lodepng_compute_color_stats+0x39b>
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
  80cb79:	0f b7 85 46 ff ff ff 	movzwl -0xba(%rbp),%eax
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80cb80:	44 89 f1             	mov    %r14d,%ecx
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
  80cb83:	66 83 f8 ff          	cmp    $0xffff,%ax
  80cb87:	0f 84 63 ff ff ff    	je     80caf0 <lodepng_compute_color_stats+0x40e>
  80cb8d:	66 85 c0             	test   %ax,%ax
  80cb90:	0f 85 3b ff ff ff    	jne    80cad1 <lodepng_compute_color_stats+0x3ef>
  80cb96:	41 8b 47 04          	mov    0x4(%r15),%eax
  80cb9a:	85 c9                	test   %ecx,%ecx
  80cb9c:	75 08                	jne    80cba6 <lodepng_compute_color_stats+0x4c4>
  80cb9e:	85 c0                	test   %eax,%eax
  80cba0:	0f 85 2b ff ff ff    	jne    80cad1 <lodepng_compute_color_stats+0x3ef>
        } else if(a == 0 && !stats->alpha && !stats->key) {
  80cba6:	41 83 7f 10 00       	cmpl   $0x0,0x10(%r15)
  80cbab:	0f 85 3f ff ff ff    	jne    80caf0 <lodepng_compute_color_stats+0x40e>
  80cbb1:	85 c0                	test   %eax,%eax
  80cbb3:	0f 85 37 ff ff ff    	jne    80caf0 <lodepng_compute_color_stats+0x40e>
          stats->key = 1;
  80cbb9:	41 c7 47 04 01 00 00 	movl   $0x1,0x4(%r15)
  80cbc0:	00 
          stats->key_r = r;
  80cbc1:	66 41 89 57 08       	mov    %dx,0x8(%r15)
          stats->key_g = g;
  80cbc6:	0f b7 85 42 ff ff ff 	movzwl -0xbe(%rbp),%eax
  80cbcd:	66 41 89 47 0a       	mov    %ax,0xa(%r15)
          stats->key_b = b;
  80cbd2:	0f b7 85 44 ff ff ff 	movzwl -0xbc(%rbp),%eax
  80cbd9:	66 41 89 47 0c       	mov    %ax,0xc(%r15)
  80cbde:	e9 0d ff ff ff       	jmp    80caf0 <lodepng_compute_color_stats+0x40e>
      for(i = 0; i != numpixels; ++i) {
  80cbe3:	48 83 c3 01          	add    $0x1,%rbx
  80cbe7:	49 39 dd             	cmp    %rbx,%r13
  80cbea:	74 7c                	je     80cc68 <lodepng_compute_color_stats+0x586>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
  80cbec:	48 83 ec 08          	sub    $0x8,%rsp
  80cbf0:	41 56                	push   %r14
  80cbf2:	49 89 d9             	mov    %rbx,%r9
  80cbf5:	4c 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%r8
  80cbfc:	48 8d 8d 46 ff ff ff 	lea    -0xba(%rbp),%rcx
  80cc03:	48 8d 95 44 ff ff ff 	lea    -0xbc(%rbp),%rdx
  80cc0a:	48 8d b5 42 ff ff ff 	lea    -0xbe(%rbp),%rsi
  80cc11:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80cc18:	41 ff d4             	call   *%r12
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
  80cc1b:	48 83 c4 10          	add    $0x10,%rsp
  80cc1f:	66 83 bd 46 ff ff ff 	cmpw   $0x0,-0xba(%rbp)
  80cc26:	00 
  80cc27:	74 ba                	je     80cbe3 <lodepng_compute_color_stats+0x501>
  80cc29:	0f b7 85 40 ff ff ff 	movzwl -0xc0(%rbp),%eax
  80cc30:	66 41 39 47 08       	cmp    %ax,0x8(%r15)
  80cc35:	75 ac                	jne    80cbe3 <lodepng_compute_color_stats+0x501>
  80cc37:	0f b7 85 42 ff ff ff 	movzwl -0xbe(%rbp),%eax
  80cc3e:	66 41 39 47 0a       	cmp    %ax,0xa(%r15)
  80cc43:	75 9e                	jne    80cbe3 <lodepng_compute_color_stats+0x501>
  80cc45:	0f b7 85 44 ff ff ff 	movzwl -0xbc(%rbp),%eax
  80cc4c:	66 41 39 47 0c       	cmp    %ax,0xc(%r15)
  80cc51:	75 90                	jne    80cbe3 <lodepng_compute_color_stats+0x501>
          stats->alpha = 1;
  80cc53:	41 c7 47 10 01 00 00 	movl   $0x1,0x10(%r15)
  80cc5a:	00 
          stats->key = 0;
  80cc5b:	41 c7 47 04 00 00 00 	movl   $0x0,0x4(%r15)
  80cc62:	00 
          alpha_done = 1;
  80cc63:	e9 7b ff ff ff       	jmp    80cbe3 <lodepng_compute_color_stats+0x501>
  80cc68:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%rbp)
  80cc6f:	00 00 00 
  color_tree_cleanup(&tree);
  80cc72:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80cc79:	48 b8 75 50 80 00 00 	movabs $0x805075,%rax
  80cc80:	00 00 00 
  80cc83:	ff d0                	call   *%rax
}
  80cc85:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  80cc8b:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  80cc8f:	5b                   	pop    %rbx
  80cc90:	41 5c                	pop    %r12
  80cc92:	41 5d                	pop    %r13
  80cc94:	41 5e                	pop    %r14
  80cc96:	41 5f                	pop    %r15
  80cc98:	5d                   	pop    %rbp
  80cc99:	c3                   	ret    
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
  80cc9a:	0f b6 f1             	movzbl %cl,%esi
  80cc9d:	8d 04 76             	lea    (%rsi,%rsi,2),%eax
  80cca0:	c1 e0 06             	shl    $0x6,%eax
  80cca3:	01 f0                	add    %esi,%eax
  80cca5:	66 c1 e8 0e          	shr    $0xe,%ax
  80cca9:	be 55 00 00 00       	mov    $0x55,%esi
  80ccae:	0f af c6             	imul   %esi,%eax
  80ccb1:	29 c1                	sub    %eax,%ecx
  80ccb3:	80 f9 01             	cmp    $0x1,%cl
  80ccb6:	19 f6                	sbb    %esi,%esi
  80ccb8:	83 e6 fe             	and    $0xfffffffe,%esi
  80ccbb:	83 c6 04             	add    $0x4,%esi
  80ccbe:	eb 05                	jmp    80ccc5 <lodepng_compute_color_stats+0x5e3>
  if(value == 0 || value == 255) return 1;
  80ccc0:	be 01 00 00 00       	mov    $0x1,%esi
        if(bits > stats->bits) stats->bits = bits;
  80ccc5:	39 f2                	cmp    %esi,%edx
  80ccc7:	0f 83 b1 01 00 00    	jae    80ce7e <lodepng_compute_color_stats+0x79c>
  80cccd:	e9 a5 01 00 00       	jmp    80ce77 <lodepng_compute_color_stats+0x795>
      if(!colored_done && (r != g || r != b)) {
  80ccd2:	3a 95 44 ff ff ff    	cmp    -0xbc(%rbp),%dl
  80ccd8:	0f 85 d8 01 00 00    	jne    80ceb6 <lodepng_compute_color_stats+0x7d4>
  80ccde:	e9 f4 01 00 00       	jmp    80ced7 <lodepng_compute_color_stats+0x7f5>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80cce3:	0f b6 85 42 ff ff ff 	movzbl -0xbe(%rbp),%eax
  80ccea:	66 41 3b 47 0a       	cmp    0xa(%r15),%ax
  80ccef:	0f 85 fd 01 00 00    	jne    80cef2 <lodepng_compute_color_stats+0x810>
  80ccf5:	0f b6 85 44 ff ff ff 	movzbl -0xbc(%rbp),%eax
  80ccfc:	66 41 3b 47 0c       	cmp    0xc(%r15),%ax
  80cd01:	0f 85 eb 01 00 00    	jne    80cef2 <lodepng_compute_color_stats+0x810>
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
  80cd07:	0f b6 85 46 ff ff ff 	movzbl -0xba(%rbp),%eax
  80cd0e:	3c ff                	cmp    $0xff,%al
  80cd10:	75 32                	jne    80cd44 <lodepng_compute_color_stats+0x662>
        } else if(a == 255 && stats->key && matchkey) {
  80cd12:	41 83 7f 04 00       	cmpl   $0x0,0x4(%r15)
  80cd17:	0f 84 2b 02 00 00    	je     80cf48 <lodepng_compute_color_stats+0x866>
          stats->alpha = 1;
  80cd1d:	41 c7 47 10 01 00 00 	movl   $0x1,0x10(%r15)
  80cd24:	00 
          stats->key = 0;
  80cd25:	41 c7 47 04 00 00 00 	movl   $0x0,0x4(%r15)
  80cd2c:	00 
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
  80cd2d:	41 83 bf 18 04 00 00 	cmpl   $0x7,0x418(%r15)
  80cd34:	07 
  80cd35:	77 3c                	ja     80cd73 <lodepng_compute_color_stats+0x691>
  80cd37:	41 c7 87 18 04 00 00 	movl   $0x8,0x418(%r15)
  80cd3e:	08 00 00 00 
  80cd42:	eb 2f                	jmp    80cd73 <lodepng_compute_color_stats+0x691>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80cd44:	b9 01 00 00 00       	mov    $0x1,%ecx
  80cd49:	e9 b2 01 00 00       	jmp    80cf00 <lodepng_compute_color_stats+0x81e>
          stats->alpha = 1;
  80cd4e:	41 c7 47 10 01 00 00 	movl   $0x1,0x10(%r15)
  80cd55:	00 
          stats->key = 0;
  80cd56:	41 c7 47 04 00 00 00 	movl   $0x0,0x4(%r15)
  80cd5d:	00 
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
  80cd5e:	41 83 bf 18 04 00 00 	cmpl   $0x7,0x418(%r15)
  80cd65:	07 
  80cd66:	77 0b                	ja     80cd73 <lodepng_compute_color_stats+0x691>
  80cd68:	41 c7 87 18 04 00 00 	movl   $0x8,0x418(%r15)
  80cd6f:	08 00 00 00 
      if(!numcolors_done) {
  80cd73:	41 89 de             	mov    %ebx,%r14d
  80cd76:	85 db                	test   %ebx,%ebx
  80cd78:	0f 85 88 02 00 00    	jne    80d006 <lodepng_compute_color_stats+0x924>
  80cd7e:	41 be 01 00 00 00    	mov    $0x1,%r14d
        if(!color_tree_has(&tree, r, g, b, a)) {
  80cd84:	44 0f b6 85 46 ff ff 	movzbl -0xba(%rbp),%r8d
  80cd8b:	ff 
  80cd8c:	44 89 85 18 ff ff ff 	mov    %r8d,-0xe8(%rbp)
  80cd93:	0f b6 8d 44 ff ff ff 	movzbl -0xbc(%rbp),%ecx
  80cd9a:	89 8d 14 ff ff ff    	mov    %ecx,-0xec(%rbp)
  80cda0:	0f b6 95 42 ff ff ff 	movzbl -0xbe(%rbp),%edx
  80cda7:	89 95 08 ff ff ff    	mov    %edx,-0xf8(%rbp)
  80cdad:	0f b6 85 40 ff ff ff 	movzbl -0xc0(%rbp),%eax
  80cdb4:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
  return color_tree_get(tree, r, g, b, a) >= 0;
  80cdba:	89 c6                	mov    %eax,%esi
  80cdbc:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80cdc3:	48 b8 49 30 80 00 00 	movabs $0x803049,%rax
  80cdca:	00 00 00 
  80cdcd:	ff d0                	call   *%rax
  80cdcf:	bb 00 00 00 00       	mov    $0x0,%ebx
        if(!color_tree_has(&tree, r, g, b, a)) {
  80cdd4:	85 c0                	test   %eax,%eax
  80cdd6:	0f 88 7c 01 00 00    	js     80cf58 <lodepng_compute_color_stats+0x876>
    for(i = 0; i != numpixels; ++i) {
  80cddc:	49 83 c5 01          	add    $0x1,%r13
  80cde0:	4c 39 ad 30 ff ff ff 	cmp    %r13,-0xd0(%rbp)
  80cde7:	0f 84 33 02 00 00    	je     80d020 <lodepng_compute_color_stats+0x93e>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
  80cded:	48 83 ec 08          	sub    $0x8,%rsp
  80cdf1:	ff b5 20 ff ff ff    	push   -0xe0(%rbp)
  80cdf7:	4d 89 e9             	mov    %r13,%r9
  80cdfa:	4c 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%r8
  80ce01:	48 8d 8d 46 ff ff ff 	lea    -0xba(%rbp),%rcx
  80ce08:	48 8d 95 44 ff ff ff 	lea    -0xbc(%rbp),%rdx
  80ce0f:	48 8d b5 42 ff ff ff 	lea    -0xbe(%rbp),%rsi
  80ce16:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80ce1d:	48 b8 b0 30 80 00 00 	movabs $0x8030b0,%rax
  80ce24:	00 00 00 
  80ce27:	ff d0                	call   *%rax
      if(!bits_done && stats->bits < 8) {
  80ce29:	48 83 c4 10          	add    $0x10,%rsp
  80ce2d:	45 85 e4             	test   %r12d,%r12d
  80ce30:	75 4c                	jne    80ce7e <lodepng_compute_color_stats+0x79c>
  80ce32:	41 8b 97 18 04 00 00 	mov    0x418(%r15),%edx
  80ce39:	83 fa 07             	cmp    $0x7,%edx
  80ce3c:	77 40                	ja     80ce7e <lodepng_compute_color_stats+0x79c>
        unsigned bits = getValueRequiredBits(r);
  80ce3e:	0f b6 8d 40 ff ff ff 	movzbl -0xc0(%rbp),%ecx
  if(value == 0 || value == 255) return 1;
  80ce45:	8d 41 ff             	lea    -0x1(%rcx),%eax
  80ce48:	3c fd                	cmp    $0xfd,%al
  80ce4a:	0f 87 70 fe ff ff    	ja     80ccc0 <lodepng_compute_color_stats+0x5de>
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
  80ce50:	0f b6 f1             	movzbl %cl,%esi
  80ce53:	89 f0                	mov    %esi,%eax
  80ce55:	c1 e0 04             	shl    $0x4,%eax
  80ce58:	29 f0                	sub    %esi,%eax
  80ce5a:	c1 e0 04             	shl    $0x4,%eax
  80ce5d:	01 f0                	add    %esi,%eax
  80ce5f:	66 c1 e8 0c          	shr    $0xc,%ax
  80ce63:	89 c6                	mov    %eax,%esi
  80ce65:	c1 e6 04             	shl    $0x4,%esi
  80ce68:	01 f0                	add    %esi,%eax
  return 8;
  80ce6a:	be 08 00 00 00       	mov    $0x8,%esi
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
  80ce6f:	38 c1                	cmp    %al,%cl
  80ce71:	0f 84 23 fe ff ff    	je     80cc9a <lodepng_compute_color_stats+0x5b8>
        if(bits > stats->bits) stats->bits = bits;
  80ce77:	41 89 b7 18 04 00 00 	mov    %esi,0x418(%r15)
      bits_done = (stats->bits >= bpp);
  80ce7e:	41 8b 87 18 04 00 00 	mov    0x418(%r15),%eax
  80ce85:	3b 85 38 ff ff ff    	cmp    -0xc8(%rbp),%eax
  80ce8b:	0f 93 85 1c ff ff ff 	setae  -0xe4(%rbp)
  80ce92:	41 0f 93 c4          	setae  %r12b
  80ce96:	45 0f b6 e4          	movzbl %r12b,%r12d
      if(!colored_done && (r != g || r != b)) {
  80ce9a:	83 bd 3c ff ff ff 00 	cmpl   $0x0,-0xc4(%rbp)
  80cea1:	75 34                	jne    80ced7 <lodepng_compute_color_stats+0x7f5>
  80cea3:	0f b6 95 40 ff ff ff 	movzbl -0xc0(%rbp),%edx
  80ceaa:	3a 95 42 ff ff ff    	cmp    -0xbe(%rbp),%dl
  80ceb0:	0f 84 1c fe ff ff    	je     80ccd2 <lodepng_compute_color_stats+0x5f0>
        stats->colored = 1;
  80ceb6:	41 c7 07 01 00 00 00 	movl   $0x1,(%r15)
        colored_done = 1;
  80cebd:	c7 85 3c ff ff ff 01 	movl   $0x1,-0xc4(%rbp)
  80cec4:	00 00 00 
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
  80cec7:	83 f8 07             	cmp    $0x7,%eax
  80ceca:	77 0b                	ja     80ced7 <lodepng_compute_color_stats+0x7f5>
  80cecc:	41 c7 87 18 04 00 00 	movl   $0x8,0x418(%r15)
  80ced3:	08 00 00 00 
      if(!alpha_done) {
  80ced7:	45 85 f6             	test   %r14d,%r14d
  80ceda:	0f 85 93 fe ff ff    	jne    80cd73 <lodepng_compute_color_stats+0x691>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80cee0:	0f b6 95 40 ff ff ff 	movzbl -0xc0(%rbp),%edx
  80cee7:	66 41 3b 57 08       	cmp    0x8(%r15),%dx
  80ceec:	0f 84 f1 fd ff ff    	je     80cce3 <lodepng_compute_color_stats+0x601>
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
  80cef2:	0f b6 85 46 ff ff ff 	movzbl -0xba(%rbp),%eax
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
  80cef9:	44 89 f1             	mov    %r14d,%ecx
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
  80cefc:	3c ff                	cmp    $0xff,%al
  80cefe:	74 48                	je     80cf48 <lodepng_compute_color_stats+0x866>
  80cf00:	84 c0                	test   %al,%al
  80cf02:	0f 85 46 fe ff ff    	jne    80cd4e <lodepng_compute_color_stats+0x66c>
  80cf08:	41 8b 47 04          	mov    0x4(%r15),%eax
  80cf0c:	85 c9                	test   %ecx,%ecx
  80cf0e:	75 08                	jne    80cf18 <lodepng_compute_color_stats+0x836>
  80cf10:	85 c0                	test   %eax,%eax
  80cf12:	0f 85 36 fe ff ff    	jne    80cd4e <lodepng_compute_color_stats+0x66c>
        } else if(a == 0 && !stats->alpha && !stats->key) {
  80cf18:	41 83 7f 10 00       	cmpl   $0x0,0x10(%r15)
  80cf1d:	75 29                	jne    80cf48 <lodepng_compute_color_stats+0x866>
  80cf1f:	85 c0                	test   %eax,%eax
  80cf21:	75 25                	jne    80cf48 <lodepng_compute_color_stats+0x866>
          stats->key = 1;
  80cf23:	41 c7 47 04 01 00 00 	movl   $0x1,0x4(%r15)
  80cf2a:	00 
          stats->key_r = r;
  80cf2b:	66 41 89 57 08       	mov    %dx,0x8(%r15)
          stats->key_g = g;
  80cf30:	0f b6 85 42 ff ff ff 	movzbl -0xbe(%rbp),%eax
  80cf37:	66 41 89 47 0a       	mov    %ax,0xa(%r15)
          stats->key_b = b;
  80cf3c:	0f b6 85 44 ff ff ff 	movzbl -0xbc(%rbp),%eax
  80cf43:	66 41 89 47 0c       	mov    %ax,0xc(%r15)
      if(!numcolors_done) {
  80cf48:	85 db                	test   %ebx,%ebx
  80cf4a:	0f 85 8c fe ff ff    	jne    80cddc <lodepng_compute_color_stats+0x6fa>
  80cf50:	41 89 de             	mov    %ebx,%r14d
  80cf53:	e9 2c fe ff ff       	jmp    80cd84 <lodepng_compute_color_stats+0x6a2>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
  80cf58:	45 8b 4f 14          	mov    0x14(%r15),%r9d
  80cf5c:	44 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%r8d
  80cf63:	8b 8d 14 ff ff ff    	mov    -0xec(%rbp),%ecx
  80cf69:	8b 95 08 ff ff ff    	mov    -0xf8(%rbp),%edx
  80cf6f:	8b b5 10 ff ff ff    	mov    -0xf0(%rbp),%esi
  80cf75:	48 8d bd 48 ff ff ff 	lea    -0xb8(%rbp),%rdi
  80cf7c:	48 b8 e1 58 80 00 00 	movabs $0x8058e1,%rax
  80cf83:	00 00 00 
  80cf86:	ff d0                	call   *%rax
          if(error) goto cleanup;
  80cf88:	85 c0                	test   %eax,%eax
  80cf8a:	0f 85 bc 01 00 00    	jne    80d14c <lodepng_compute_color_stats+0xa6a>
          if(stats->numcolors < 256) {
  80cf90:	41 8b 47 14          	mov    0x14(%r15),%eax
  80cf94:	3d ff 00 00 00       	cmp    $0xff,%eax
  80cf99:	77 40                	ja     80cfdb <lodepng_compute_color_stats+0x8f9>
            p[n * 4 + 0] = r;
  80cf9b:	c1 e0 02             	shl    $0x2,%eax
  80cf9e:	89 c2                	mov    %eax,%edx
  80cfa0:	0f b6 8d 40 ff ff ff 	movzbl -0xc0(%rbp),%ecx
  80cfa7:	41 88 4c 17 18       	mov    %cl,0x18(%r15,%rdx,1)
            p[n * 4 + 1] = g;
  80cfac:	8d 50 01             	lea    0x1(%rax),%edx
  80cfaf:	0f b6 8d 42 ff ff ff 	movzbl -0xbe(%rbp),%ecx
  80cfb6:	41 88 4c 17 18       	mov    %cl,0x18(%r15,%rdx,1)
            p[n * 4 + 2] = b;
  80cfbb:	8d 50 02             	lea    0x2(%rax),%edx
  80cfbe:	89 d2                	mov    %edx,%edx
  80cfc0:	0f b6 8d 44 ff ff ff 	movzbl -0xbc(%rbp),%ecx
  80cfc7:	41 88 4c 17 18       	mov    %cl,0x18(%r15,%rdx,1)
            p[n * 4 + 3] = a;
  80cfcc:	8d 40 03             	lea    0x3(%rax),%eax
  80cfcf:	0f b6 95 46 ff ff ff 	movzbl -0xba(%rbp),%edx
  80cfd6:	41 88 54 07 18       	mov    %dl,0x18(%r15,%rax,1)
          ++stats->numcolors;
  80cfdb:	41 8b 47 14          	mov    0x14(%r15),%eax
  80cfdf:	83 c0 01             	add    $0x1,%eax
  80cfe2:	41 89 47 14          	mov    %eax,0x14(%r15)
          numcolors_done = stats->numcolors >= maxnumcolors;
  80cfe6:	3b 85 04 ff ff ff    	cmp    -0xfc(%rbp),%eax
  80cfec:	0f 93 c0             	setae  %al
  80cfef:	0f 93 c3             	setae  %bl
  80cff2:	0f b6 db             	movzbl %bl,%ebx
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
  80cff5:	45 85 f6             	test   %r14d,%r14d
  80cff8:	0f 84 de fd ff ff    	je     80cddc <lodepng_compute_color_stats+0x6fa>
  80cffe:	84 c0                	test   %al,%al
  80d000:	0f 84 d6 fd ff ff    	je     80cddc <lodepng_compute_color_stats+0x6fa>
  80d006:	83 bd 3c ff ff ff 00 	cmpl   $0x0,-0xc4(%rbp)
  80d00d:	0f 84 c9 fd ff ff    	je     80cddc <lodepng_compute_color_stats+0x6fa>
  80d013:	80 bd 1c ff ff ff 00 	cmpb   $0x0,-0xe4(%rbp)
  80d01a:	0f 84 bc fd ff ff    	je     80cddc <lodepng_compute_color_stats+0x6fa>
    if(stats->key && !stats->alpha) {
  80d020:	41 83 7f 04 00       	cmpl   $0x0,0x4(%r15)
  80d025:	0f 84 d4 00 00 00    	je     80d0ff <lodepng_compute_color_stats+0xa1d>
  80d02b:	41 83 7f 10 00       	cmpl   $0x0,0x10(%r15)
  80d030:	0f 85 c9 00 00 00    	jne    80d0ff <lodepng_compute_color_stats+0xa1d>
      for(i = 0; i != numpixels; ++i) {
  80d036:	4c 8b ad 30 ff ff ff 	mov    -0xd0(%rbp),%r13
  80d03d:	4d 85 ed             	test   %r13,%r13
  80d040:	0f 84 b9 00 00 00    	je     80d0ff <lodepng_compute_color_stats+0xa1d>
  80d046:	bb 00 00 00 00       	mov    $0x0,%ebx
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
  80d04b:	49 bc b0 30 80 00 00 	movabs $0x8030b0,%r12
  80d052:	00 00 00 
  80d055:	4c 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%r14
  80d05c:	eb 0d                	jmp    80d06b <lodepng_compute_color_stats+0x989>
      for(i = 0; i != numpixels; ++i) {
  80d05e:	48 83 c3 01          	add    $0x1,%rbx
  80d062:	49 39 dd             	cmp    %rbx,%r13
  80d065:	0f 84 94 00 00 00    	je     80d0ff <lodepng_compute_color_stats+0xa1d>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
  80d06b:	48 83 ec 08          	sub    $0x8,%rsp
  80d06f:	41 56                	push   %r14
  80d071:	49 89 d9             	mov    %rbx,%r9
  80d074:	4c 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%r8
  80d07b:	48 8d 8d 46 ff ff ff 	lea    -0xba(%rbp),%rcx
  80d082:	48 8d 95 44 ff ff ff 	lea    -0xbc(%rbp),%rdx
  80d089:	48 8d b5 42 ff ff ff 	lea    -0xbe(%rbp),%rsi
  80d090:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  80d097:	41 ff d4             	call   *%r12
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
  80d09a:	48 83 c4 10          	add    $0x10,%rsp
  80d09e:	80 bd 46 ff ff ff 00 	cmpb   $0x0,-0xba(%rbp)
  80d0a5:	74 b7                	je     80d05e <lodepng_compute_color_stats+0x97c>
  80d0a7:	0f b6 85 40 ff ff ff 	movzbl -0xc0(%rbp),%eax
  80d0ae:	66 41 3b 47 08       	cmp    0x8(%r15),%ax
  80d0b3:	75 a9                	jne    80d05e <lodepng_compute_color_stats+0x97c>
  80d0b5:	0f b6 85 42 ff ff ff 	movzbl -0xbe(%rbp),%eax
  80d0bc:	66 41 3b 47 0a       	cmp    0xa(%r15),%ax
  80d0c1:	75 9b                	jne    80d05e <lodepng_compute_color_stats+0x97c>
  80d0c3:	0f b6 85 44 ff ff ff 	movzbl -0xbc(%rbp),%eax
  80d0ca:	66 41 3b 47 0c       	cmp    0xc(%r15),%ax
  80d0cf:	75 8d                	jne    80d05e <lodepng_compute_color_stats+0x97c>
          stats->alpha = 1;
  80d0d1:	41 c7 47 10 01 00 00 	movl   $0x1,0x10(%r15)
  80d0d8:	00 
          stats->key = 0;
  80d0d9:	41 c7 47 04 00 00 00 	movl   $0x0,0x4(%r15)
  80d0e0:	00 
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
  80d0e1:	41 83 bf 18 04 00 00 	cmpl   $0x7,0x418(%r15)
  80d0e8:	07 
  80d0e9:	0f 87 6f ff ff ff    	ja     80d05e <lodepng_compute_color_stats+0x97c>
  80d0ef:	41 c7 87 18 04 00 00 	movl   $0x8,0x418(%r15)
  80d0f6:	08 00 00 00 
  80d0fa:	e9 5f ff ff ff       	jmp    80d05e <lodepng_compute_color_stats+0x97c>
    stats->key_r += (stats->key_r << 8);
  80d0ff:	41 0f b7 57 08       	movzwl 0x8(%r15),%edx
  80d104:	89 d0                	mov    %edx,%eax
  80d106:	c1 e0 08             	shl    $0x8,%eax
  80d109:	01 d0                	add    %edx,%eax
  80d10b:	66 41 89 47 08       	mov    %ax,0x8(%r15)
    stats->key_g += (stats->key_g << 8);
  80d110:	41 0f b7 57 0a       	movzwl 0xa(%r15),%edx
  80d115:	89 d0                	mov    %edx,%eax
  80d117:	c1 e0 08             	shl    $0x8,%eax
  80d11a:	01 d0                	add    %edx,%eax
  80d11c:	66 41 89 47 0a       	mov    %ax,0xa(%r15)
    stats->key_b += (stats->key_b << 8);
  80d121:	41 0f b7 57 0c       	movzwl 0xc(%r15),%edx
  80d126:	89 d0                	mov    %edx,%eax
  80d128:	c1 e0 08             	shl    $0x8,%eax
  80d12b:	01 d0                	add    %edx,%eax
  80d12d:	66 41 89 47 0c       	mov    %ax,0xc(%r15)
  80d132:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%rbp)
  80d139:	00 00 00 
  80d13c:	e9 31 fb ff ff       	jmp    80cc72 <lodepng_compute_color_stats+0x590>
  80d141:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  80d147:	e9 26 fb ff ff       	jmp    80cc72 <lodepng_compute_color_stats+0x590>
  80d14c:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  80d152:	e9 1b fb ff ff       	jmp    80cc72 <lodepng_compute_color_stats+0x590>

000000000080d157 <lodepng_inspect>:
                         const unsigned char* in, size_t insize) {
  80d157:	55                   	push   %rbp
  80d158:	48 89 e5             	mov    %rsp,%rbp
  80d15b:	41 57                	push   %r15
  80d15d:	41 56                	push   %r14
  80d15f:	41 55                	push   %r13
  80d161:	41 54                	push   %r12
  80d163:	53                   	push   %rbx
  80d164:	48 83 ec 18          	sub    $0x18,%rsp
  80d168:	49 89 d4             	mov    %rdx,%r12
  if(insize == 0 || in == 0) {
  80d16b:	4d 85 c0             	test   %r8,%r8
  80d16e:	0f 84 9c 00 00 00    	je     80d210 <lodepng_inspect+0xb9>
  80d174:	49 89 fe             	mov    %rdi,%r14
  80d177:	49 89 f5             	mov    %rsi,%r13
  80d17a:	48 89 cb             	mov    %rcx,%rbx
  80d17d:	48 85 c9             	test   %rcx,%rcx
  80d180:	0f 84 8a 00 00 00    	je     80d210 <lodepng_inspect+0xb9>
  if(insize < 33) {
  80d186:	49 83 f8 20          	cmp    $0x20,%r8
  80d18a:	0f 86 94 00 00 00    	jbe    80d224 <lodepng_inspect+0xcd>
  LodePNGInfo* info = &state->info_png;
  80d190:	4c 8d ba b8 00 00 00 	lea    0xb8(%rdx),%r15
  lodepng_info_cleanup(info);
  80d197:	4c 89 ff             	mov    %r15,%rdi
  80d19a:	48 b8 93 b1 80 00 00 	movabs $0x80b193,%rax
  80d1a1:	00 00 00 
  80d1a4:	ff d0                	call   *%rax
  lodepng_info_init(info);
  80d1a6:	4c 89 ff             	mov    %r15,%rdi
  80d1a9:	48 b8 9d b0 80 00 00 	movabs $0x80b09d,%rax
  80d1b0:	00 00 00 
  80d1b3:	ff d0                	call   *%rax
  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
  80d1b5:	80 3b 89             	cmpb   $0x89,(%rbx)
  80d1b8:	75 7c                	jne    80d236 <lodepng_inspect+0xdf>
  80d1ba:	80 7b 01 50          	cmpb   $0x50,0x1(%rbx)
  80d1be:	75 76                	jne    80d236 <lodepng_inspect+0xdf>
  80d1c0:	80 7b 02 4e          	cmpb   $0x4e,0x2(%rbx)
  80d1c4:	75 70                	jne    80d236 <lodepng_inspect+0xdf>
  80d1c6:	80 7b 03 47          	cmpb   $0x47,0x3(%rbx)
  80d1ca:	75 6a                	jne    80d236 <lodepng_inspect+0xdf>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
  80d1cc:	80 7b 04 0d          	cmpb   $0xd,0x4(%rbx)
  80d1d0:	75 64                	jne    80d236 <lodepng_inspect+0xdf>
  80d1d2:	80 7b 05 0a          	cmpb   $0xa,0x5(%rbx)
  80d1d6:	75 5e                	jne    80d236 <lodepng_inspect+0xdf>
  80d1d8:	80 7b 06 1a          	cmpb   $0x1a,0x6(%rbx)
  80d1dc:	75 58                	jne    80d236 <lodepng_inspect+0xdf>
  80d1de:	80 7b 07 0a          	cmpb   $0xa,0x7(%rbx)
  80d1e2:	75 52                	jne    80d236 <lodepng_inspect+0xdf>
  if(lodepng_chunk_length(in + 8) != 13) {
  80d1e4:	4c 8d 7b 08          	lea    0x8(%rbx),%r15
  return lodepng_read32bitInt(&chunk[0]);
  80d1e8:	4c 89 ff             	mov    %r15,%rdi
  80d1eb:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  80d1f2:	00 00 00 
  80d1f5:	ff d0                	call   *%rax
  if(lodepng_chunk_length(in + 8) != 13) {
  80d1f7:	83 f8 0d             	cmp    $0xd,%eax
  80d1fa:	74 5e                	je     80d25a <lodepng_inspect+0x103>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
  80d1fc:	41 c7 84 24 f0 01 00 	movl   $0x5e,0x1f0(%r12)
  80d203:	00 5e 00 00 00 
  80d208:	41 bd 5e 00 00 00    	mov    $0x5e,%r13d
  80d20e:	eb 38                	jmp    80d248 <lodepng_inspect+0xf1>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
  80d210:	41 c7 84 24 f0 01 00 	movl   $0x30,0x1f0(%r12)
  80d217:	00 30 00 00 00 
  80d21c:	41 bd 30 00 00 00    	mov    $0x30,%r13d
  80d222:	eb 24                	jmp    80d248 <lodepng_inspect+0xf1>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
  80d224:	c7 82 f0 01 00 00 1b 	movl   $0x1b,0x1f0(%rdx)
  80d22b:	00 00 00 
  80d22e:	41 bd 1b 00 00 00    	mov    $0x1b,%r13d
  80d234:	eb 12                	jmp    80d248 <lodepng_inspect+0xf1>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
  80d236:	41 c7 84 24 f0 01 00 	movl   $0x1c,0x1f0(%r12)
  80d23d:	00 1c 00 00 00 
  80d242:	41 bd 1c 00 00 00    	mov    $0x1c,%r13d
}
  80d248:	44 89 e8             	mov    %r13d,%eax
  80d24b:	48 83 c4 18          	add    $0x18,%rsp
  80d24f:	5b                   	pop    %rbx
  80d250:	41 5c                	pop    %r12
  80d252:	41 5d                	pop    %r13
  80d254:	41 5e                	pop    %r14
  80d256:	41 5f                	pop    %r15
  80d258:	5d                   	pop    %rbp
  80d259:	c3                   	ret    
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
  80d25a:	48 be a9 26 81 00 00 	movabs $0x8126a9,%rsi
  80d261:	00 00 00 
  80d264:	4c 89 ff             	mov    %r15,%rdi
  80d267:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d26e:	00 00 00 
  80d271:	ff d0                	call   *%rax
  80d273:	84 c0                	test   %al,%al
  80d275:	0f 84 13 01 00 00    	je     80d38e <lodepng_inspect+0x237>
  width = lodepng_read32bitInt(&in[16]);
  80d27b:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
  80d27f:	49 bf ed 28 80 00 00 	movabs $0x8028ed,%r15
  80d286:	00 00 00 
  80d289:	41 ff d7             	call   *%r15
  80d28c:	89 45 cc             	mov    %eax,-0x34(%rbp)
  height = lodepng_read32bitInt(&in[20]);
  80d28f:	48 8d 7b 14          	lea    0x14(%rbx),%rdi
  80d293:	41 ff d7             	call   *%r15
  if(w) *w = width;
  80d296:	4d 85 f6             	test   %r14,%r14
  80d299:	74 06                	je     80d2a1 <lodepng_inspect+0x14a>
  80d29b:	8b 4d cc             	mov    -0x34(%rbp),%ecx
  80d29e:	41 89 0e             	mov    %ecx,(%r14)
  if(h) *h = height;
  80d2a1:	4d 85 ed             	test   %r13,%r13
  80d2a4:	74 04                	je     80d2aa <lodepng_inspect+0x153>
  80d2a6:	41 89 45 00          	mov    %eax,0x0(%r13)
  info->color.bitdepth = in[24];
  80d2aa:	0f b6 73 18          	movzbl 0x18(%rbx),%esi
  80d2ae:	41 89 b4 24 cc 00 00 	mov    %esi,0xcc(%r12)
  80d2b5:	00 
  info->color.colortype = (LodePNGColorType)in[25];
  80d2b6:	0f b6 7b 19          	movzbl 0x19(%rbx),%edi
  80d2ba:	41 89 bc 24 c8 00 00 	mov    %edi,0xc8(%r12)
  80d2c1:	00 
  info->compression_method = in[26];
  80d2c2:	44 0f b6 7b 1a       	movzbl 0x1a(%rbx),%r15d
  80d2c7:	45 89 bc 24 b8 00 00 	mov    %r15d,0xb8(%r12)
  80d2ce:	00 
  info->filter_method = in[27];
  80d2cf:	44 0f b6 73 1b       	movzbl 0x1b(%rbx),%r14d
  80d2d4:	45 89 b4 24 bc 00 00 	mov    %r14d,0xbc(%r12)
  80d2db:	00 
  info->interlace_method = in[28];
  80d2dc:	0f b6 53 1c          	movzbl 0x1c(%rbx),%edx
  80d2e0:	89 55 c8             	mov    %edx,-0x38(%rbp)
  80d2e3:	41 89 94 24 c0 00 00 	mov    %edx,0xc0(%r12)
  80d2ea:	00 
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
  80d2eb:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80d2ef:	0f 84 b0 00 00 00    	je     80d3a5 <lodepng_inspect+0x24e>
  80d2f5:	85 c0                	test   %eax,%eax
  80d2f7:	0f 84 a8 00 00 00    	je     80d3a5 <lodepng_inspect+0x24e>
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
  80d2fd:	48 b8 3f 2e 80 00 00 	movabs $0x802e3f,%rax
  80d304:	00 00 00 
  80d307:	ff d0                	call   *%rax
  80d309:	41 89 c5             	mov    %eax,%r13d
  80d30c:	41 89 84 24 f0 01 00 	mov    %eax,0x1f0(%r12)
  80d313:	00 
  if(state->error) return state->error;
  80d314:	85 c0                	test   %eax,%eax
  80d316:	0f 85 2c ff ff ff    	jne    80d248 <lodepng_inspect+0xf1>
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
  80d31c:	45 85 ff             	test   %r15d,%r15d
  80d31f:	0f 85 97 00 00 00    	jne    80d3bc <lodepng_inspect+0x265>
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
  80d325:	45 85 f6             	test   %r14d,%r14d
  80d328:	0f 85 a5 00 00 00    	jne    80d3d3 <lodepng_inspect+0x27c>
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
  80d32e:	83 7d c8 01          	cmpl   $0x1,-0x38(%rbp)
  80d332:	0f 87 b2 00 00 00    	ja     80d3ea <lodepng_inspect+0x293>
  if(!state->decoder.ignore_crc) {
  80d338:	45 8b 6c 24 20       	mov    0x20(%r12),%r13d
  80d33d:	45 85 ed             	test   %r13d,%r13d
  80d340:	0f 85 bb 00 00 00    	jne    80d401 <lodepng_inspect+0x2aa>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
  80d346:	48 8d 7b 1d          	lea    0x1d(%rbx),%rdi
  80d34a:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  80d351:	00 00 00 
  80d354:	ff d0                	call   *%rax
  80d356:	41 89 c6             	mov    %eax,%r14d
    unsigned checksum = lodepng_crc32(&in[12], 17);
  80d359:	48 8d 7b 0c          	lea    0xc(%rbx),%rdi
  80d35d:	be 11 00 00 00       	mov    $0x11,%esi
  80d362:	48 b8 b1 87 80 00 00 	movabs $0x8087b1,%rax
  80d369:	00 00 00 
  80d36c:	ff d0                	call   *%rax
    if(CRC != checksum) {
  80d36e:	41 39 c6             	cmp    %eax,%r14d
  80d371:	0f 84 d1 fe ff ff    	je     80d248 <lodepng_inspect+0xf1>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
  80d377:	41 c7 84 24 f0 01 00 	movl   $0x39,0x1f0(%r12)
  80d37e:	00 39 00 00 00 
  80d383:	41 bd 39 00 00 00    	mov    $0x39,%r13d
  80d389:	e9 ba fe ff ff       	jmp    80d248 <lodepng_inspect+0xf1>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
  80d38e:	41 c7 84 24 f0 01 00 	movl   $0x1d,0x1f0(%r12)
  80d395:	00 1d 00 00 00 
  80d39a:	41 bd 1d 00 00 00    	mov    $0x1d,%r13d
  80d3a0:	e9 a3 fe ff ff       	jmp    80d248 <lodepng_inspect+0xf1>
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
  80d3a5:	41 c7 84 24 f0 01 00 	movl   $0x5d,0x1f0(%r12)
  80d3ac:	00 5d 00 00 00 
  80d3b1:	41 bd 5d 00 00 00    	mov    $0x5d,%r13d
  80d3b7:	e9 8c fe ff ff       	jmp    80d248 <lodepng_inspect+0xf1>
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
  80d3bc:	41 c7 84 24 f0 01 00 	movl   $0x20,0x1f0(%r12)
  80d3c3:	00 20 00 00 00 
  80d3c8:	41 bd 20 00 00 00    	mov    $0x20,%r13d
  80d3ce:	e9 75 fe ff ff       	jmp    80d248 <lodepng_inspect+0xf1>
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
  80d3d3:	41 c7 84 24 f0 01 00 	movl   $0x21,0x1f0(%r12)
  80d3da:	00 21 00 00 00 
  80d3df:	41 bd 21 00 00 00    	mov    $0x21,%r13d
  80d3e5:	e9 5e fe ff ff       	jmp    80d248 <lodepng_inspect+0xf1>
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
  80d3ea:	41 c7 84 24 f0 01 00 	movl   $0x22,0x1f0(%r12)
  80d3f1:	00 22 00 00 00 
  80d3f6:	41 bd 22 00 00 00    	mov    $0x22,%r13d
  80d3fc:	e9 47 fe ff ff       	jmp    80d248 <lodepng_inspect+0xf1>
  return state->error;
  80d401:	45 89 f5             	mov    %r14d,%r13d
  80d404:	e9 3f fe ff ff       	jmp    80d248 <lodepng_inspect+0xf1>

000000000080d409 <lodepng_inspect_chunk>:
                               const unsigned char* in, size_t insize) {
  80d409:	55                   	push   %rbp
  80d40a:	48 89 e5             	mov    %rsp,%rbp
  80d40d:	41 57                	push   %r15
  80d40f:	41 56                	push   %r14
  80d411:	41 55                	push   %r13
  80d413:	41 54                	push   %r12
  80d415:	53                   	push   %rbx
  80d416:	48 83 ec 18          	sub    $0x18,%rsp
  80d41a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  const unsigned char* chunk = in + pos;
  80d41e:	4c 8d 34 32          	lea    (%rdx,%rsi,1),%r14
  if(pos + 4 > insize) return 30;
  80d422:	48 83 c6 04          	add    $0x4,%rsi
  80d426:	b8 1e 00 00 00       	mov    $0x1e,%eax
  80d42b:	48 39 ce             	cmp    %rcx,%rsi
  80d42e:	77 78                	ja     80d4a8 <lodepng_inspect_chunk+0x9f>
  80d430:	48 89 d3             	mov    %rdx,%rbx
  80d433:	49 89 cd             	mov    %rcx,%r13
  return lodepng_read32bitInt(&chunk[0]);
  80d436:	4c 89 f7             	mov    %r14,%rdi
  80d439:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  80d440:	00 00 00 
  80d443:	ff d0                	call   *%rax
  if(chunkLength > 2147483647) return 63;
  80d445:	85 c0                	test   %eax,%eax
  80d447:	0f 88 c9 03 00 00    	js     80d816 <lodepng_inspect_chunk+0x40d>
  return &chunk[8];
  80d44d:	4d 8d 7e 08          	lea    0x8(%r14),%r15
  if(data + chunkLength + 4 > in + insize) return 30;
  80d451:	41 89 c4             	mov    %eax,%r12d
  80d454:	4b 8d 54 26 0c       	lea    0xc(%r14,%r12,1),%rdx
  80d459:	4c 01 eb             	add    %r13,%rbx
  80d45c:	b8 1e 00 00 00       	mov    $0x1e,%eax
  80d461:	48 39 da             	cmp    %rbx,%rdx
  80d464:	77 42                	ja     80d4a8 <lodepng_inspect_chunk+0x9f>
  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
  80d466:	48 be 94 26 81 00 00 	movabs $0x812694,%rsi
  80d46d:	00 00 00 
  80d470:	4c 89 f7             	mov    %r14,%rdi
  80d473:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d47a:	00 00 00 
  80d47d:	ff d0                	call   *%rax
  80d47f:	84 c0                	test   %al,%al
  80d481:	74 34                	je     80d4b7 <lodepng_inspect_chunk+0xae>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
  80d483:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80d487:	48 8d b8 c8 00 00 00 	lea    0xc8(%rax),%rdi
  80d48e:	4c 89 e2             	mov    %r12,%rdx
  80d491:	4c 89 fe             	mov    %r15,%rsi
  80d494:	48 b8 6d 5a 80 00 00 	movabs $0x805a6d,%rax
  80d49b:	00 00 00 
  80d49e:	ff d0                	call   *%rax
  if(!error && !unhandled && !state->decoder.ignore_crc) {
  80d4a0:	85 c0                	test   %eax,%eax
  80d4a2:	0f 84 d1 01 00 00    	je     80d679 <lodepng_inspect_chunk+0x270>
}
  80d4a8:	48 83 c4 18          	add    $0x18,%rsp
  80d4ac:	5b                   	pop    %rbx
  80d4ad:	41 5c                	pop    %r12
  80d4af:	41 5d                	pop    %r13
  80d4b1:	41 5e                	pop    %r14
  80d4b3:	41 5f                	pop    %r15
  80d4b5:	5d                   	pop    %rbp
  80d4b6:	c3                   	ret    
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
  80d4b7:	48 be 99 26 81 00 00 	movabs $0x812699,%rsi
  80d4be:	00 00 00 
  80d4c1:	4c 89 f7             	mov    %r14,%rdi
  80d4c4:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d4cb:	00 00 00 
  80d4ce:	ff d0                	call   *%rax
  80d4d0:	84 c0                	test   %al,%al
  80d4d2:	74 1f                	je     80d4f3 <lodepng_inspect_chunk+0xea>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
  80d4d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80d4d8:	48 8d b8 c8 00 00 00 	lea    0xc8(%rax),%rdi
  80d4df:	4c 89 e2             	mov    %r12,%rdx
  80d4e2:	4c 89 fe             	mov    %r15,%rsi
  80d4e5:	48 b8 44 3e 80 00 00 	movabs $0x803e44,%rax
  80d4ec:	00 00 00 
  80d4ef:	ff d0                	call   *%rax
  80d4f1:	eb ad                	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
  80d4f3:	48 be ae 26 81 00 00 	movabs $0x8126ae,%rsi
  80d4fa:	00 00 00 
  80d4fd:	4c 89 f7             	mov    %r14,%rdi
  80d500:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d507:	00 00 00 
  80d50a:	ff d0                	call   *%rax
  80d50c:	84 c0                	test   %al,%al
  80d50e:	74 22                	je     80d532 <lodepng_inspect_chunk+0x129>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
  80d510:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80d514:	48 8d b8 b8 00 00 00 	lea    0xb8(%rax),%rdi
  80d51b:	4c 89 e2             	mov    %r12,%rdx
  80d51e:	4c 89 fe             	mov    %r15,%rsi
  80d521:	48 b8 14 3f 80 00 00 	movabs $0x803f14,%rax
  80d528:	00 00 00 
  80d52b:	ff d0                	call   *%rax
  80d52d:	e9 6e ff ff ff       	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
  80d532:	48 be 9e 26 81 00 00 	movabs $0x81269e,%rsi
  80d539:	00 00 00 
  80d53c:	4c 89 f7             	mov    %r14,%rdi
  80d53f:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d546:	00 00 00 
  80d549:	ff d0                	call   *%rax
  80d54b:	84 c0                	test   %al,%al
  80d54d:	74 22                	je     80d571 <lodepng_inspect_chunk+0x168>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
  80d54f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80d553:	48 8d b8 b8 00 00 00 	lea    0xb8(%rax),%rdi
  80d55a:	4c 89 e2             	mov    %r12,%rdx
  80d55d:	4c 89 fe             	mov    %r15,%rsi
  80d560:	48 b8 1e a6 80 00 00 	movabs $0x80a61e,%rax
  80d567:	00 00 00 
  80d56a:	ff d0                	call   *%rax
  80d56c:	e9 2f ff ff ff       	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
  80d571:	48 be b3 26 81 00 00 	movabs $0x8126b3,%rsi
  80d578:	00 00 00 
  80d57b:	4c 89 f7             	mov    %r14,%rdi
  80d57e:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d585:	00 00 00 
  80d588:	ff d0                	call   *%rax
  80d58a:	84 c0                	test   %al,%al
  80d58c:	74 22                	je     80d5b0 <lodepng_inspect_chunk+0x1a7>
    error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
  80d58e:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80d592:	48 8d be b8 00 00 00 	lea    0xb8(%rsi),%rdi
  80d599:	4c 89 e1             	mov    %r12,%rcx
  80d59c:	4c 89 fa             	mov    %r15,%rdx
  80d59f:	48 b8 a8 a7 80 00 00 	movabs $0x80a7a8,%rax
  80d5a6:	00 00 00 
  80d5a9:	ff d0                	call   *%rax
  80d5ab:	e9 f0 fe ff ff       	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
  80d5b0:	48 be b8 26 81 00 00 	movabs $0x8126b8,%rsi
  80d5b7:	00 00 00 
  80d5ba:	4c 89 f7             	mov    %r14,%rdi
  80d5bd:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d5c4:	00 00 00 
  80d5c7:	ff d0                	call   *%rax
  80d5c9:	84 c0                	test   %al,%al
  80d5cb:	74 22                	je     80d5ef <lodepng_inspect_chunk+0x1e6>
    error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
  80d5cd:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80d5d1:	48 8d be b8 00 00 00 	lea    0xb8(%rsi),%rdi
  80d5d8:	4c 89 e1             	mov    %r12,%rcx
  80d5db:	4c 89 fa             	mov    %r15,%rdx
  80d5de:	48 b8 c3 aa 80 00 00 	movabs $0x80aac3,%rax
  80d5e5:	00 00 00 
  80d5e8:	ff d0                	call   *%rax
  80d5ea:	e9 b1 fe ff ff       	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
  80d5ef:	48 be bd 26 81 00 00 	movabs $0x8126bd,%rsi
  80d5f6:	00 00 00 
  80d5f9:	4c 89 f7             	mov    %r14,%rdi
  80d5fc:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d603:	00 00 00 
  80d606:	ff d0                	call   *%rax
  80d608:	84 c0                	test   %al,%al
  80d60a:	0f 84 9a 00 00 00    	je     80d6aa <lodepng_inspect_chunk+0x2a1>
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
  80d610:	b8 49 00 00 00       	mov    $0x49,%eax
  80d615:	49 83 fc 07          	cmp    $0x7,%r12
  80d619:	0f 85 89 fe ff ff    	jne    80d4a8 <lodepng_inspect_chunk+0x9f>
  info->time_defined = 1;
  80d61f:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80d623:	c7 81 40 01 00 00 01 	movl   $0x1,0x140(%rcx)
  80d62a:	00 00 00 
  info->time.year = 256u * data[0] + data[1];
  80d62d:	41 0f b6 46 08       	movzbl 0x8(%r14),%eax
  80d632:	c1 e0 08             	shl    $0x8,%eax
  80d635:	41 0f b6 56 09       	movzbl 0x9(%r14),%edx
  80d63a:	01 d0                	add    %edx,%eax
  80d63c:	89 81 44 01 00 00    	mov    %eax,0x144(%rcx)
  info->time.month = data[2];
  80d642:	41 0f b6 46 0a       	movzbl 0xa(%r14),%eax
  80d647:	89 81 48 01 00 00    	mov    %eax,0x148(%rcx)
  info->time.day = data[3];
  80d64d:	41 0f b6 46 0b       	movzbl 0xb(%r14),%eax
  80d652:	89 81 4c 01 00 00    	mov    %eax,0x14c(%rcx)
  info->time.hour = data[4];
  80d658:	41 0f b6 46 0c       	movzbl 0xc(%r14),%eax
  80d65d:	89 81 50 01 00 00    	mov    %eax,0x150(%rcx)
  info->time.minute = data[5];
  80d663:	41 0f b6 46 0d       	movzbl 0xd(%r14),%eax
  80d668:	89 81 54 01 00 00    	mov    %eax,0x154(%rcx)
  info->time.second = data[6];
  80d66e:	41 0f b6 46 0e       	movzbl 0xe(%r14),%eax
  80d673:	89 81 58 01 00 00    	mov    %eax,0x158(%rcx)
  return error;
  80d679:	b8 00 00 00 00       	mov    $0x0,%eax
  if(!error && !unhandled && !state->decoder.ignore_crc) {
  80d67e:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80d682:	83 79 20 00          	cmpl   $0x0,0x20(%rcx)
  80d686:	0f 85 1c fe ff ff    	jne    80d4a8 <lodepng_inspect_chunk+0x9f>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
  80d68c:	4c 89 f7             	mov    %r14,%rdi
  80d68f:	48 b8 b5 88 80 00 00 	movabs $0x8088b5,%rax
  80d696:	00 00 00 
  80d699:	ff d0                	call   *%rax
  80d69b:	85 c0                	test   %eax,%eax
  80d69d:	ba 39 00 00 00       	mov    $0x39,%edx
  80d6a2:	0f 45 c2             	cmovne %edx,%eax
  80d6a5:	e9 fe fd ff ff       	jmp    80d4a8 <lodepng_inspect_chunk+0x9f>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
  80d6aa:	48 be c2 26 81 00 00 	movabs $0x8126c2,%rsi
  80d6b1:	00 00 00 
  80d6b4:	4c 89 f7             	mov    %r14,%rdi
  80d6b7:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d6be:	00 00 00 
  80d6c1:	ff d0                	call   *%rax
  80d6c3:	84 c0                	test   %al,%al
  80d6c5:	74 22                	je     80d6e9 <lodepng_inspect_chunk+0x2e0>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
  80d6c7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80d6cb:	48 8d b8 b8 00 00 00 	lea    0xb8(%rax),%rdi
  80d6d2:	4c 89 e2             	mov    %r12,%rdx
  80d6d5:	4c 89 fe             	mov    %r15,%rsi
  80d6d8:	48 b8 d2 3f 80 00 00 	movabs $0x803fd2,%rax
  80d6df:	00 00 00 
  80d6e2:	ff d0                	call   *%rax
  80d6e4:	e9 b7 fd ff ff       	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
  80d6e9:	48 be c7 26 81 00 00 	movabs $0x8126c7,%rsi
  80d6f0:	00 00 00 
  80d6f3:	4c 89 f7             	mov    %r14,%rdi
  80d6f6:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d6fd:	00 00 00 
  80d700:	ff d0                	call   *%rax
  80d702:	84 c0                	test   %al,%al
  80d704:	74 46                	je     80d74c <lodepng_inspect_chunk+0x343>
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
  80d706:	49 83 fc 04          	cmp    $0x4,%r12
  80d70a:	0f 85 10 01 00 00    	jne    80d820 <lodepng_inspect_chunk+0x417>
  info->gama_defined = 1;
  80d710:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80d714:	c7 81 6c 01 00 00 01 	movl   $0x1,0x16c(%rcx)
  80d71b:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
  80d71e:	41 0f b6 46 08       	movzbl 0x8(%r14),%eax
  80d723:	c1 e0 08             	shl    $0x8,%eax
  80d726:	41 0f b6 56 09       	movzbl 0x9(%r14),%edx
  80d72b:	01 d0                	add    %edx,%eax
  80d72d:	c1 e0 08             	shl    $0x8,%eax
  80d730:	41 0f b6 56 0a       	movzbl 0xa(%r14),%edx
  80d735:	01 d0                	add    %edx,%eax
  80d737:	c1 e0 08             	shl    $0x8,%eax
  80d73a:	41 0f b6 56 0b       	movzbl 0xb(%r14),%edx
  80d73f:	01 d0                	add    %edx,%eax
  80d741:	89 81 70 01 00 00    	mov    %eax,0x170(%rcx)
  return 0; /* OK */
  80d747:	e9 2d ff ff ff       	jmp    80d679 <lodepng_inspect_chunk+0x270>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
  80d74c:	48 be cc 26 81 00 00 	movabs $0x8126cc,%rsi
  80d753:	00 00 00 
  80d756:	4c 89 f7             	mov    %r14,%rdi
  80d759:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d760:	00 00 00 
  80d763:	ff d0                	call   *%rax
  80d765:	84 c0                	test   %al,%al
  80d767:	74 22                	je     80d78b <lodepng_inspect_chunk+0x382>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
  80d769:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80d76d:	48 8d b8 b8 00 00 00 	lea    0xb8(%rax),%rdi
  80d774:	4c 89 e2             	mov    %r12,%rdx
  80d777:	4c 89 fe             	mov    %r15,%rsi
  80d77a:	48 b8 40 40 80 00 00 	movabs $0x804040,%rax
  80d781:	00 00 00 
  80d784:	ff d0                	call   *%rax
  80d786:	e9 15 fd ff ff       	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
  80d78b:	48 be d1 26 81 00 00 	movabs $0x8126d1,%rsi
  80d792:	00 00 00 
  80d795:	4c 89 f7             	mov    %r14,%rdi
  80d798:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d79f:	00 00 00 
  80d7a2:	ff d0                	call   *%rax
  80d7a4:	84 c0                	test   %al,%al
  80d7a6:	74 24                	je     80d7cc <lodepng_inspect_chunk+0x3c3>
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
  80d7a8:	49 83 fc 01          	cmp    $0x1,%r12
  80d7ac:	75 7c                	jne    80d82a <lodepng_inspect_chunk+0x421>
  info->srgb_defined = 1;
  80d7ae:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80d7b2:	c7 81 98 01 00 00 01 	movl   $0x1,0x198(%rcx)
  80d7b9:	00 00 00 
  info->srgb_intent = data[0];
  80d7bc:	41 0f b6 46 08       	movzbl 0x8(%r14),%eax
  80d7c1:	89 81 9c 01 00 00    	mov    %eax,0x19c(%rcx)
  return 0; /* OK */
  80d7c7:	e9 ad fe ff ff       	jmp    80d679 <lodepng_inspect_chunk+0x270>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
  80d7cc:	48 be d6 26 81 00 00 	movabs $0x8126d6,%rsi
  80d7d3:	00 00 00 
  80d7d6:	4c 89 f7             	mov    %r14,%rdi
  80d7d9:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80d7e0:	00 00 00 
  80d7e3:	ff d0                	call   *%rax
  80d7e5:	89 c2                	mov    %eax,%edx
  unsigned error = 0;
  80d7e7:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
  80d7ec:	84 d2                	test   %dl,%dl
  80d7ee:	0f 84 b4 fc ff ff    	je     80d4a8 <lodepng_inspect_chunk+0x9f>
    error = readChunk_iCCP(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
  80d7f4:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80d7f8:	48 8d be b8 00 00 00 	lea    0xb8(%rsi),%rdi
  80d7ff:	4c 89 e1             	mov    %r12,%rcx
  80d802:	4c 89 fa             	mov    %r15,%rdx
  80d805:	48 b8 e1 ae 80 00 00 	movabs $0x80aee1,%rax
  80d80c:	00 00 00 
  80d80f:	ff d0                	call   *%rax
  80d811:	e9 8a fc ff ff       	jmp    80d4a0 <lodepng_inspect_chunk+0x97>
  if(chunkLength > 2147483647) return 63;
  80d816:	b8 3f 00 00 00       	mov    $0x3f,%eax
  80d81b:	e9 88 fc ff ff       	jmp    80d4a8 <lodepng_inspect_chunk+0x9f>
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
  80d820:	b8 60 00 00 00       	mov    $0x60,%eax
  80d825:	e9 7e fc ff ff       	jmp    80d4a8 <lodepng_inspect_chunk+0x9f>
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
  80d82a:	b8 62 00 00 00       	mov    $0x62,%eax
  80d82f:	e9 74 fc ff ff       	jmp    80d4a8 <lodepng_inspect_chunk+0x9f>

000000000080d834 <lodepng_decode>:
                        const unsigned char* in, size_t insize) {
  80d834:	55                   	push   %rbp
  80d835:	48 89 e5             	mov    %rsp,%rbp
  80d838:	41 57                	push   %r15
  80d83a:	41 56                	push   %r14
  80d83c:	41 55                	push   %r13
  80d83e:	41 54                	push   %r12
  80d840:	53                   	push   %rbx
  80d841:	48 81 ec b8 02 00 00 	sub    $0x2b8,%rsp
  80d848:	48 89 bd 40 fd ff ff 	mov    %rdi,-0x2c0(%rbp)
  80d84f:	49 89 f4             	mov    %rsi,%r12
  80d852:	48 89 b5 50 fd ff ff 	mov    %rsi,-0x2b0(%rbp)
  80d859:	49 89 d5             	mov    %rdx,%r13
  80d85c:	48 89 95 48 fd ff ff 	mov    %rdx,-0x2b8(%rbp)
  80d863:	48 89 cb             	mov    %rcx,%rbx
  80d866:	48 89 8d 78 fd ff ff 	mov    %rcx,-0x288(%rbp)
  80d86d:	4d 89 c7             	mov    %r8,%r15
  80d870:	4d 89 ce             	mov    %r9,%r14
  *out = 0;
  80d873:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
  unsigned char* scanlines = 0;
  80d87a:	48 c7 85 a8 fd ff ff 	movq   $0x0,-0x258(%rbp)
  80d881:	00 00 00 00 
  size_t scanlines_size = 0, expected_size = 0;
  80d885:	48 c7 85 b0 fd ff ff 	movq   $0x0,-0x250(%rbp)
  80d88c:	00 00 00 00 
  *w = *h = 0;
  80d890:	c7 02 00 00 00 00    	movl   $0x0,(%rdx)
  80d896:	c7 06 00 00 00 00    	movl   $0x0,(%rsi)
  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  80d89c:	4d 89 c8             	mov    %r9,%r8
  80d89f:	4c 89 f9             	mov    %r15,%rcx
  80d8a2:	48 89 da             	mov    %rbx,%rdx
  80d8a5:	4c 89 ee             	mov    %r13,%rsi
  80d8a8:	4c 89 e7             	mov    %r12,%rdi
  80d8ab:	48 b8 57 d1 80 00 00 	movabs $0x80d157,%rax
  80d8b2:	00 00 00 
  80d8b5:	ff d0                	call   *%rax
  80d8b7:	89 83 f0 01 00 00    	mov    %eax,0x1f0(%rbx)
  if(state->error) return;
  80d8bd:	85 c0                	test   %eax,%eax
  80d8bf:	0f 84 1e 01 00 00    	je     80d9e3 <lodepng_decode+0x1af>
  if(state->error) return state->error;
  80d8c5:	48 8b 8d 78 fd ff ff 	mov    -0x288(%rbp),%rcx
  80d8cc:	8b 81 f0 01 00 00    	mov    0x1f0(%rcx),%eax
  80d8d2:	85 c0                	test   %eax,%eax
  80d8d4:	0f 85 fa 00 00 00    	jne    80d9d4 <lodepng_decode+0x1a0>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
  80d8da:	83 79 2c 00          	cmpl   $0x0,0x2c(%rcx)
  80d8de:	0f 84 7c 11 00 00    	je     80ea60 <lodepng_decode+0x122c>
  80d8e4:	4c 8d a1 c8 00 00 00 	lea    0xc8(%rcx),%r12
  80d8eb:	48 8d 99 90 00 00 00 	lea    0x90(%rcx),%rbx
  80d8f2:	4c 89 e6             	mov    %r12,%rsi
  80d8f5:	48 89 df             	mov    %rbx,%rdi
  80d8f8:	48 b8 fc 2e 80 00 00 	movabs $0x802efc,%rax
  80d8ff:	00 00 00 
  80d902:	ff d0                	call   *%rax
  80d904:	85 c0                	test   %eax,%eax
  80d906:	0f 85 bb 00 00 00    	jne    80d9c7 <lodepng_decode+0x193>
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
  80d90c:	48 8b 8d 78 fd ff ff 	mov    -0x288(%rbp),%rcx
  80d913:	8b 81 90 00 00 00    	mov    0x90(%rcx),%eax
  80d919:	89 85 98 fd ff ff    	mov    %eax,-0x268(%rbp)
  80d91f:	83 e0 fb             	and    $0xfffffffb,%eax
  80d922:	83 f8 02             	cmp    $0x2,%eax
  80d925:	74 12                	je     80d939 <lodepng_decode+0x105>
      return 56; /*unsupported color mode conversion*/
  80d927:	b8 38 00 00 00       	mov    $0x38,%eax
       && !(state->info_raw.bitdepth == 8)) {
  80d92c:	83 b9 94 00 00 00 08 	cmpl   $0x8,0x94(%rcx)
  80d933:	0f 85 9b 00 00 00    	jne    80d9d4 <lodepng_decode+0x1a0>
    unsigned char* data = *out;
  80d939:	4c 8b bd 40 fd ff ff 	mov    -0x2c0(%rbp),%r15
  80d940:	4d 8b 2f             	mov    (%r15),%r13
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
  80d943:	48 89 da             	mov    %rbx,%rdx
  80d946:	48 8b 85 48 fd ff ff 	mov    -0x2b8(%rbp),%rax
  80d94d:	8b 30                	mov    (%rax),%esi
  80d94f:	48 8b 85 50 fd ff ff 	mov    -0x2b0(%rbp),%rax
  80d956:	8b 38                	mov    (%rax),%edi
  80d958:	48 b8 dc a4 80 00 00 	movabs $0x80a4dc,%rax
  80d95f:	00 00 00 
  80d962:	ff d0                	call   *%rax
  80d964:	48 89 c7             	mov    %rax,%rdi
  return jos_malloc(size);
  80d967:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80d96e:	00 00 00 
  80d971:	ff d0                	call   *%rax
    *out = (unsigned char*)lodepng_malloc(outsize);
  80d973:	49 89 07             	mov    %rax,(%r15)
    if(!(*out)) {
  80d976:	48 85 c0             	test   %rax,%rax
  80d979:	0f 84 15 11 00 00    	je     80ea94 <lodepng_decode+0x1260>
    else state->error = lodepng_convert(*out, data, &state->info_raw,
  80d97f:	48 8b 8d 48 fd ff ff 	mov    -0x2b8(%rbp),%rcx
  80d986:	44 8b 09             	mov    (%rcx),%r9d
  80d989:	48 8b 8d 50 fd ff ff 	mov    -0x2b0(%rbp),%rcx
  80d990:	44 8b 01             	mov    (%rcx),%r8d
  80d993:	4c 89 e1             	mov    %r12,%rcx
  80d996:	48 89 da             	mov    %rbx,%rdx
  80d999:	4c 89 ee             	mov    %r13,%rsi
  80d99c:	48 89 c7             	mov    %rax,%rdi
  80d99f:	48 b8 6b b4 80 00 00 	movabs $0x80b46b,%rax
  80d9a6:	00 00 00 
  80d9a9:	ff d0                	call   *%rax
  80d9ab:	48 8b 8d 78 fd ff ff 	mov    -0x288(%rbp),%rcx
  80d9b2:	89 81 f0 01 00 00    	mov    %eax,0x1f0(%rcx)
    jos_free(ptr);
  80d9b8:	4c 89 ef             	mov    %r13,%rdi
  80d9bb:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  80d9c2:	00 00 00 
  80d9c5:	ff d0                	call   *%rax
  return state->error;
  80d9c7:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80d9ce:	8b 80 f0 01 00 00    	mov    0x1f0(%rax),%eax
}
  80d9d4:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  80d9d8:	5b                   	pop    %rbx
  80d9d9:	41 5c                	pop    %r12
  80d9db:	41 5d                	pop    %r13
  80d9dd:	41 5e                	pop    %r14
  80d9df:	41 5f                	pop    %r15
  80d9e1:	5d                   	pop    %rbp
  80d9e2:	c3                   	ret    
  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
  80d9e3:	48 89 9d 78 fd ff ff 	mov    %rbx,-0x288(%rbp)
  80d9ea:	48 8d bb c8 00 00 00 	lea    0xc8(%rbx),%rdi
  80d9f1:	48 89 bd 90 fd ff ff 	mov    %rdi,-0x270(%rbp)
  80d9f8:	41 8b 4d 00          	mov    0x0(%r13),%ecx
  80d9fc:	89 8d 98 fd ff ff    	mov    %ecx,-0x268(%rbp)
  80da02:	45 8b 2c 24          	mov    (%r12),%r13d
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
  80da06:	49 bc 10 93 80 00 00 	movabs $0x809310,%r12
  80da0d:	00 00 00 
  80da10:	41 ff d4             	call   *%r12
  80da13:	89 c3                	mov    %eax,%ebx
  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
  80da15:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80da1c:	48 8d b8 90 00 00 00 	lea    0x90(%rax),%rdi
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
  80da23:	41 ff d4             	call   *%r12
  80da26:	39 c3                	cmp    %eax,%ebx
  80da28:	0f 46 d8             	cmovbe %eax,%ebx
  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
  80da2b:	44 8b a5 98 fd ff ff 	mov    -0x268(%rbp),%r12d
  80da32:	44 89 e9             	mov    %r13d,%ecx
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
  80da35:	4c 89 e6             	mov    %r12,%rsi
  80da38:	48 0f af f1          	imul   %rcx,%rsi
  return (a != 0 && *result / a != b);
  80da3c:	48 85 c9             	test   %rcx,%rcx
  80da3f:	0f 84 c6 10 00 00    	je     80eb0b <lodepng_decode+0x12d7>
  80da45:	48 89 f0             	mov    %rsi,%rax
  80da48:	ba 00 00 00 00       	mov    $0x0,%edx
  80da4d:	48 f7 f1             	div    %rcx
  80da50:	49 39 c4             	cmp    %rax,%r12
  80da53:	0f 84 93 10 00 00    	je     80eaec <lodepng_decode+0x12b8>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
  80da59:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80da60:	c7 80 f0 01 00 00 5c 	movl   $0x5c,0x1f0(%rax)
  80da67:	00 00 00 
  80da6a:	e9 56 fe ff ff       	jmp    80d8c5 <lodepng_decode+0x91>
  return (a != 0 && *result / a != b);
  80da6f:	48 89 c8             	mov    %rcx,%rax
  80da72:	ba 00 00 00 00       	mov    $0x0,%edx
  80da77:	48 f7 f6             	div    %rsi
  80da7a:	48 39 c3             	cmp    %rax,%rbx
  80da7d:	75 da                	jne    80da59 <lodepng_decode+0x225>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
  80da7f:	44 89 e8             	mov    %r13d,%eax
  80da82:	83 e0 07             	and    $0x7,%eax
  80da85:	48 0f af c3          	imul   %rbx,%rax
  80da89:	48 83 c0 07          	add    $0x7,%rax
  80da8d:	48 c1 e8 03          	shr    $0x3,%rax
  80da91:	48 01 c1             	add    %rax,%rcx
  80da94:	72 c3                	jb     80da59 <lodepng_decode+0x225>
  80da96:	e9 9d 10 00 00       	jmp    80eb38 <lodepng_decode+0x1304>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
  80da9b:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80daa2:	83 78 28 00          	cmpl   $0x0,0x28(%rax)
  80daa6:	0f 85 f2 00 00 00    	jne    80db9e <lodepng_decode+0x36a>
      CERROR_BREAK(state->error, 30);
  80daac:	c7 80 f0 01 00 00 1e 	movl   $0x1e,0x1f0(%rax)
  80dab3:	00 00 00 
  80dab6:	e9 e3 00 00 00       	jmp    80db9e <lodepng_decode+0x36a>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
  80dabb:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dac2:	83 78 28 00          	cmpl   $0x0,0x28(%rax)
  80dac6:	0f 85 d2 00 00 00    	jne    80db9e <lodepng_decode+0x36a>
      CERROR_BREAK(state->error, 63);
  80dacc:	c7 80 f0 01 00 00 3f 	movl   $0x3f,0x1f0(%rax)
  80dad3:	00 00 00 
  80dad6:	e9 c3 00 00 00       	jmp    80db9e <lodepng_decode+0x36a>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
  80dadb:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dae2:	c7 80 f0 01 00 00 40 	movl   $0x40,0x1f0(%rax)
  80dae9:	00 00 00 
  80daec:	e9 ad 00 00 00       	jmp    80db9e <lodepng_decode+0x36a>
      size_t oldsize = idat.size;
  80daf1:	48 8b 85 d0 fd ff ff 	mov    -0x230(%rbp),%rax
  80daf8:	48 89 85 88 fd ff ff 	mov    %rax,-0x278(%rbp)
      if(lodepng_addofl(oldsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
  80daff:	4c 8b a5 98 fd ff ff 	mov    -0x268(%rbp),%r12
  80db06:	49 01 c4             	add    %rax,%r12
  80db09:	0f 82 40 01 00 00    	jb     80dc4f <lodepng_decode+0x41b>
      if(!ucvector_resize(&idat, newsize)) CERROR_BREAK(state->error, 83 /*alloc fail*/);
  80db0f:	4c 89 e6             	mov    %r12,%rsi
  80db12:	48 8d bd c8 fd ff ff 	lea    -0x238(%rbp),%rdi
  80db19:	48 b8 0c 46 80 00 00 	movabs $0x80460c,%rax
  80db20:	00 00 00 
  80db23:	ff d0                	call   *%rax
  80db25:	85 c0                	test   %eax,%eax
  80db27:	0f 84 47 01 00 00    	je     80dc74 <lodepng_decode+0x440>
      for(i = 0; i != chunkLength; ++i) idat.data[oldsize + i] = data[i];
  80db2d:	48 8b 8d 88 fd ff ff 	mov    -0x278(%rbp),%rcx
  80db34:	48 89 c8             	mov    %rcx,%rax
  80db37:	48 89 de             	mov    %rbx,%rsi
  80db3a:	48 29 ce             	sub    %rcx,%rsi
  80db3d:	48 83 bd 98 fd ff ff 	cmpq   $0x0,-0x268(%rbp)
  80db44:	00 
  80db45:	0f 84 1a 01 00 00    	je     80dc65 <lodepng_decode+0x431>
  80db4b:	0f b6 4c 06 08       	movzbl 0x8(%rsi,%rax,1),%ecx
  80db50:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  80db57:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  80db5a:	48 83 c0 01          	add    $0x1,%rax
  80db5e:	49 39 c4             	cmp    %rax,%r12
  80db61:	75 e8                	jne    80db4b <lodepng_decode+0x317>
      critical_pos = 3;
  80db63:	c7 85 88 fd ff ff 03 	movl   $0x3,-0x278(%rbp)
  80db6a:	00 00 00 
    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
  80db6d:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  80db73:	41 83 7d 20 00       	cmpl   $0x0,0x20(%r13)
  80db78:	0f 85 38 05 00 00    	jne    80e0b6 <lodepng_decode+0x882>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
  80db7e:	48 89 df             	mov    %rbx,%rdi
  80db81:	48 b8 b5 88 80 00 00 	movabs $0x8088b5,%rax
  80db88:	00 00 00 
  80db8b:	ff d0                	call   *%rax
  80db8d:	85 c0                	test   %eax,%eax
  80db8f:	0f 85 82 06 00 00    	jne    80e217 <lodepng_decode+0x9e3>
    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  80db95:	45 84 e4             	test   %r12b,%r12b
  80db98:	0f 84 18 05 00 00    	je     80e0b6 <lodepng_decode+0x882>
  if(state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
  80db9e:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dba5:	83 b8 c8 00 00 00 03 	cmpl   $0x3,0xc8(%rax)
  80dbac:	0f 84 7b 06 00 00    	je     80e22d <lodepng_decode+0x9f9>
  if(state->info_png.interlace_method == 0) {
  80dbb2:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dbb9:	83 b8 c0 00 00 00 00 	cmpl   $0x0,0xc0(%rax)
  80dbc0:	0f 85 84 06 00 00    	jne    80e24a <lodepng_decode+0xa16>
    size_t bpp = lodepng_get_bpp(&state->info_png.color);
  80dbc6:	48 8b bd 90 fd ff ff 	mov    -0x270(%rbp),%rdi
  80dbcd:	48 b8 10 93 80 00 00 	movabs $0x809310,%rax
  80dbd4:	00 00 00 
  80dbd7:	ff d0                	call   *%rax
  80dbd9:	89 c2                	mov    %eax,%edx
    expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
  80dbdb:	48 8b 85 48 fd ff ff 	mov    -0x2b8(%rbp),%rax
  80dbe2:	8b 30                	mov    (%rax),%esi
  80dbe4:	48 8b 85 50 fd ff ff 	mov    -0x2b0(%rbp),%rax
  80dbeb:	8b 38                	mov    (%rax),%edi
  80dbed:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  80dbf4:	00 00 00 
  80dbf7:	ff d0                	call   *%rax
  80dbf9:	49 89 c4             	mov    %rax,%r12
  if(!state->error) {
  80dbfc:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dc03:	83 b8 f0 01 00 00 00 	cmpl   $0x0,0x1f0(%rax)
  80dc0a:	0f 84 c5 07 00 00    	je     80e3d5 <lodepng_decode+0xba1>
  ucvector_cleanup(&idat);
  80dc10:	48 8d bd c8 fd ff ff 	lea    -0x238(%rbp),%rdi
  80dc17:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  80dc1e:	00 00 00 
  80dc21:	ff d0                	call   *%rax
  if(!state->error) {
  80dc23:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dc2a:	83 b8 f0 01 00 00 00 	cmpl   $0x0,0x1f0(%rax)
  80dc31:	0f 84 43 08 00 00    	je     80e47a <lodepng_decode+0xc46>
    jos_free(ptr);
  80dc37:	48 8b bd a8 fd ff ff 	mov    -0x258(%rbp),%rdi
  80dc3e:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  80dc45:	00 00 00 
  80dc48:	ff d0                	call   *%rax
  80dc4a:	e9 76 fc ff ff       	jmp    80d8c5 <lodepng_decode+0x91>
      if(lodepng_addofl(oldsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
  80dc4f:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dc56:	c7 80 f0 01 00 00 5f 	movl   $0x5f,0x1f0(%rax)
  80dc5d:	00 00 00 
  80dc60:	e9 39 ff ff ff       	jmp    80db9e <lodepng_decode+0x36a>
      critical_pos = 3;
  80dc65:	c7 85 88 fd ff ff 03 	movl   $0x3,-0x278(%rbp)
  80dc6c:	00 00 00 
  80dc6f:	e9 f9 fe ff ff       	jmp    80db6d <lodepng_decode+0x339>
      if(!ucvector_resize(&idat, newsize)) CERROR_BREAK(state->error, 83 /*alloc fail*/);
  80dc74:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80dc7b:	c7 80 f0 01 00 00 53 	movl   $0x53,0x1f0(%rax)
  80dc82:	00 00 00 
  80dc85:	e9 14 ff ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
  80dc8a:	48 be 94 26 81 00 00 	movabs $0x812694,%rsi
  80dc91:	00 00 00 
  80dc94:	48 89 df             	mov    %rbx,%rdi
  80dc97:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80dc9e:	00 00 00 
  80dca1:	ff d0                	call   *%rax
  80dca3:	84 c0                	test   %al,%al
  80dca5:	74 3b                	je     80dce2 <lodepng_decode+0x4ae>
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
  80dca7:	48 8b 95 98 fd ff ff 	mov    -0x268(%rbp),%rdx
  80dcae:	4c 89 e6             	mov    %r12,%rsi
  80dcb1:	48 8b bd 90 fd ff ff 	mov    -0x270(%rbp),%rdi
  80dcb8:	48 b8 6d 5a 80 00 00 	movabs $0x805a6d,%rax
  80dcbf:	00 00 00 
  80dcc2:	ff d0                	call   *%rax
  80dcc4:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) break;
  80dccb:	85 c0                	test   %eax,%eax
  80dccd:	0f 85 cb fe ff ff    	jne    80db9e <lodepng_decode+0x36a>
      critical_pos = 2;
  80dcd3:	c7 85 88 fd ff ff 02 	movl   $0x2,-0x278(%rbp)
  80dcda:	00 00 00 
  80dcdd:	e9 8b fe ff ff       	jmp    80db6d <lodepng_decode+0x339>
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
  80dce2:	48 be 99 26 81 00 00 	movabs $0x812699,%rsi
  80dce9:	00 00 00 
  80dcec:	48 89 df             	mov    %rbx,%rdi
  80dcef:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80dcf6:	00 00 00 
  80dcf9:	ff d0                	call   *%rax
  80dcfb:	84 c0                	test   %al,%al
  80dcfd:	74 31                	je     80dd30 <lodepng_decode+0x4fc>
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
  80dcff:	48 8b 95 98 fd ff ff 	mov    -0x268(%rbp),%rdx
  80dd06:	4c 89 e6             	mov    %r12,%rsi
  80dd09:	48 8b bd 90 fd ff ff 	mov    -0x270(%rbp),%rdi
  80dd10:	48 b8 44 3e 80 00 00 	movabs $0x803e44,%rax
  80dd17:	00 00 00 
  80dd1a:	ff d0                	call   *%rax
  80dd1c:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) break;
  80dd23:	85 c0                	test   %eax,%eax
  80dd25:	0f 84 42 fe ff ff    	je     80db6d <lodepng_decode+0x339>
  80dd2b:	e9 6e fe ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
  80dd30:	48 be ae 26 81 00 00 	movabs $0x8126ae,%rsi
  80dd37:	00 00 00 
  80dd3a:	48 89 df             	mov    %rbx,%rdi
  80dd3d:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80dd44:	00 00 00 
  80dd47:	ff d0                	call   *%rax
  80dd49:	84 c0                	test   %al,%al
  80dd4b:	74 31                	je     80dd7e <lodepng_decode+0x54a>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
  80dd4d:	49 8d bd b8 00 00 00 	lea    0xb8(%r13),%rdi
  80dd54:	48 8b 95 98 fd ff ff 	mov    -0x268(%rbp),%rdx
  80dd5b:	4c 89 e6             	mov    %r12,%rsi
  80dd5e:	48 b8 14 3f 80 00 00 	movabs $0x803f14,%rax
  80dd65:	00 00 00 
  80dd68:	ff d0                	call   *%rax
  80dd6a:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) break;
  80dd71:	85 c0                	test   %eax,%eax
  80dd73:	0f 84 f4 fd ff ff    	je     80db6d <lodepng_decode+0x339>
  80dd79:	e9 20 fe ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
  80dd7e:	48 be 9e 26 81 00 00 	movabs $0x81269e,%rsi
  80dd85:	00 00 00 
  80dd88:	48 89 df             	mov    %rbx,%rdi
  80dd8b:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80dd92:	00 00 00 
  80dd95:	ff d0                	call   *%rax
  80dd97:	84 c0                	test   %al,%al
  80dd99:	74 3c                	je     80ddd7 <lodepng_decode+0x5a3>
      if(state->decoder.read_text_chunks) {
  80dd9b:	41 83 7d 30 00       	cmpl   $0x0,0x30(%r13)
  80dda0:	0f 84 c7 fd ff ff    	je     80db6d <lodepng_decode+0x339>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
  80dda6:	49 8d bd b8 00 00 00 	lea    0xb8(%r13),%rdi
  80ddad:	48 8b 95 98 fd ff ff 	mov    -0x268(%rbp),%rdx
  80ddb4:	4c 89 e6             	mov    %r12,%rsi
  80ddb7:	48 b8 1e a6 80 00 00 	movabs $0x80a61e,%rax
  80ddbe:	00 00 00 
  80ddc1:	ff d0                	call   *%rax
  80ddc3:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
        if(state->error) break;
  80ddca:	85 c0                	test   %eax,%eax
  80ddcc:	0f 84 9b fd ff ff    	je     80db6d <lodepng_decode+0x339>
  80ddd2:	e9 c7 fd ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
  80ddd7:	48 be b3 26 81 00 00 	movabs $0x8126b3,%rsi
  80ddde:	00 00 00 
  80dde1:	48 89 df             	mov    %rbx,%rdi
  80dde4:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80ddeb:	00 00 00 
  80ddee:	ff d0                	call   *%rax
  80ddf0:	84 c0                	test   %al,%al
  80ddf2:	74 3f                	je     80de33 <lodepng_decode+0x5ff>
      if(state->decoder.read_text_chunks) {
  80ddf4:	41 83 7d 30 00       	cmpl   $0x0,0x30(%r13)
  80ddf9:	0f 84 6e fd ff ff    	je     80db6d <lodepng_decode+0x339>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
  80ddff:	49 8d bd b8 00 00 00 	lea    0xb8(%r13),%rdi
  80de06:	48 8b 8d 98 fd ff ff 	mov    -0x268(%rbp),%rcx
  80de0d:	4c 89 e2             	mov    %r12,%rdx
  80de10:	4c 89 ee             	mov    %r13,%rsi
  80de13:	48 b8 a8 a7 80 00 00 	movabs $0x80a7a8,%rax
  80de1a:	00 00 00 
  80de1d:	ff d0                	call   *%rax
  80de1f:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
        if(state->error) break;
  80de26:	85 c0                	test   %eax,%eax
  80de28:	0f 84 3f fd ff ff    	je     80db6d <lodepng_decode+0x339>
  80de2e:	e9 6b fd ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
  80de33:	48 be b8 26 81 00 00 	movabs $0x8126b8,%rsi
  80de3a:	00 00 00 
  80de3d:	48 89 df             	mov    %rbx,%rdi
  80de40:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80de47:	00 00 00 
  80de4a:	ff d0                	call   *%rax
  80de4c:	84 c0                	test   %al,%al
  80de4e:	74 3f                	je     80de8f <lodepng_decode+0x65b>
      if(state->decoder.read_text_chunks) {
  80de50:	41 83 7d 30 00       	cmpl   $0x0,0x30(%r13)
  80de55:	0f 84 12 fd ff ff    	je     80db6d <lodepng_decode+0x339>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
  80de5b:	49 8d bd b8 00 00 00 	lea    0xb8(%r13),%rdi
  80de62:	48 8b 8d 98 fd ff ff 	mov    -0x268(%rbp),%rcx
  80de69:	4c 89 e2             	mov    %r12,%rdx
  80de6c:	4c 89 ee             	mov    %r13,%rsi
  80de6f:	48 b8 c3 aa 80 00 00 	movabs $0x80aac3,%rax
  80de76:	00 00 00 
  80de79:	ff d0                	call   *%rax
  80de7b:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
        if(state->error) break;
  80de82:	85 c0                	test   %eax,%eax
  80de84:	0f 84 e3 fc ff ff    	je     80db6d <lodepng_decode+0x339>
  80de8a:	e9 0f fd ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
  80de8f:	48 be bd 26 81 00 00 	movabs $0x8126bd,%rsi
  80de96:	00 00 00 
  80de99:	48 89 df             	mov    %rbx,%rdi
  80de9c:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80dea3:	00 00 00 
  80dea6:	ff d0                	call   *%rax
  80dea8:	84 c0                	test   %al,%al
  80deaa:	74 74                	je     80df20 <lodepng_decode+0x6ec>
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
  80deac:	48 83 bd 98 fd ff ff 	cmpq   $0x7,-0x268(%rbp)
  80deb3:	07 
  80deb4:	0f 85 f0 0b 00 00    	jne    80eaaa <lodepng_decode+0x1276>
  info->time_defined = 1;
  80deba:	41 c7 85 40 01 00 00 	movl   $0x1,0x140(%r13)
  80dec1:	01 00 00 00 
  info->time.year = 256u * data[0] + data[1];
  80dec5:	0f b6 43 08          	movzbl 0x8(%rbx),%eax
  80dec9:	c1 e0 08             	shl    $0x8,%eax
  80decc:	0f b6 53 09          	movzbl 0x9(%rbx),%edx
  80ded0:	01 d0                	add    %edx,%eax
  80ded2:	41 89 85 44 01 00 00 	mov    %eax,0x144(%r13)
  info->time.month = data[2];
  80ded9:	0f b6 43 0a          	movzbl 0xa(%rbx),%eax
  80dedd:	41 89 85 48 01 00 00 	mov    %eax,0x148(%r13)
  info->time.day = data[3];
  80dee4:	0f b6 43 0b          	movzbl 0xb(%rbx),%eax
  80dee8:	41 89 85 4c 01 00 00 	mov    %eax,0x14c(%r13)
  info->time.hour = data[4];
  80deef:	0f b6 43 0c          	movzbl 0xc(%rbx),%eax
  80def3:	41 89 85 50 01 00 00 	mov    %eax,0x150(%r13)
  info->time.minute = data[5];
  80defa:	0f b6 43 0d          	movzbl 0xd(%rbx),%eax
  80defe:	41 89 85 54 01 00 00 	mov    %eax,0x154(%r13)
  info->time.second = data[6];
  80df05:	0f b6 43 0e          	movzbl 0xe(%rbx),%eax
  80df09:	41 89 85 58 01 00 00 	mov    %eax,0x158(%r13)
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
  80df10:	41 c7 85 f0 01 00 00 	movl   $0x0,0x1f0(%r13)
  80df17:	00 00 00 00 
      if(state->error) break;
  80df1b:	e9 4d fc ff ff       	jmp    80db6d <lodepng_decode+0x339>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
  80df20:	48 be c2 26 81 00 00 	movabs $0x8126c2,%rsi
  80df27:	00 00 00 
  80df2a:	48 89 df             	mov    %rbx,%rdi
  80df2d:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80df34:	00 00 00 
  80df37:	ff d0                	call   *%rax
  80df39:	84 c0                	test   %al,%al
  80df3b:	74 31                	je     80df6e <lodepng_decode+0x73a>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
  80df3d:	49 8d bd b8 00 00 00 	lea    0xb8(%r13),%rdi
  80df44:	48 8b 95 98 fd ff ff 	mov    -0x268(%rbp),%rdx
  80df4b:	4c 89 e6             	mov    %r12,%rsi
  80df4e:	48 b8 d2 3f 80 00 00 	movabs $0x803fd2,%rax
  80df55:	00 00 00 
  80df58:	ff d0                	call   *%rax
  80df5a:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) break;
  80df61:	85 c0                	test   %eax,%eax
  80df63:	0f 84 04 fc ff ff    	je     80db6d <lodepng_decode+0x339>
  80df69:	e9 30 fc ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
  80df6e:	48 be c7 26 81 00 00 	movabs $0x8126c7,%rsi
  80df75:	00 00 00 
  80df78:	48 89 df             	mov    %rbx,%rdi
  80df7b:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80df82:	00 00 00 
  80df85:	ff d0                	call   *%rax
  80df87:	84 c0                	test   %al,%al
  80df89:	74 4f                	je     80dfda <lodepng_decode+0x7a6>
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
  80df8b:	48 83 bd 98 fd ff ff 	cmpq   $0x4,-0x268(%rbp)
  80df92:	04 
  80df93:	0f 85 27 0b 00 00    	jne    80eac0 <lodepng_decode+0x128c>
  info->gama_defined = 1;
  80df99:	41 c7 85 6c 01 00 00 	movl   $0x1,0x16c(%r13)
  80dfa0:	01 00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
  80dfa4:	0f b6 43 08          	movzbl 0x8(%rbx),%eax
  80dfa8:	c1 e0 08             	shl    $0x8,%eax
  80dfab:	0f b6 53 09          	movzbl 0x9(%rbx),%edx
  80dfaf:	01 d0                	add    %edx,%eax
  80dfb1:	c1 e0 08             	shl    $0x8,%eax
  80dfb4:	0f b6 53 0a          	movzbl 0xa(%rbx),%edx
  80dfb8:	01 d0                	add    %edx,%eax
  80dfba:	c1 e0 08             	shl    $0x8,%eax
  80dfbd:	0f b6 53 0b          	movzbl 0xb(%rbx),%edx
  80dfc1:	01 d0                	add    %edx,%eax
  80dfc3:	41 89 85 70 01 00 00 	mov    %eax,0x170(%r13)
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
  80dfca:	41 c7 85 f0 01 00 00 	movl   $0x0,0x1f0(%r13)
  80dfd1:	00 00 00 00 
      if(state->error) break;
  80dfd5:	e9 93 fb ff ff       	jmp    80db6d <lodepng_decode+0x339>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
  80dfda:	48 be cc 26 81 00 00 	movabs $0x8126cc,%rsi
  80dfe1:	00 00 00 
  80dfe4:	48 89 df             	mov    %rbx,%rdi
  80dfe7:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80dfee:	00 00 00 
  80dff1:	ff d0                	call   *%rax
  80dff3:	84 c0                	test   %al,%al
  80dff5:	74 31                	je     80e028 <lodepng_decode+0x7f4>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
  80dff7:	49 8d bd b8 00 00 00 	lea    0xb8(%r13),%rdi
  80dffe:	48 8b 95 98 fd ff ff 	mov    -0x268(%rbp),%rdx
  80e005:	4c 89 e6             	mov    %r12,%rsi
  80e008:	48 b8 40 40 80 00 00 	movabs $0x804040,%rax
  80e00f:	00 00 00 
  80e012:	ff d0                	call   *%rax
  80e014:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) break;
  80e01b:	85 c0                	test   %eax,%eax
  80e01d:	0f 84 4a fb ff ff    	je     80db6d <lodepng_decode+0x339>
  80e023:	e9 76 fb ff ff       	jmp    80db9e <lodepng_decode+0x36a>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
  80e028:	48 be d1 26 81 00 00 	movabs $0x8126d1,%rsi
  80e02f:	00 00 00 
  80e032:	48 89 df             	mov    %rbx,%rdi
  80e035:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80e03c:	00 00 00 
  80e03f:	ff d0                	call   *%rax
  80e041:	84 c0                	test   %al,%al
  80e043:	74 34                	je     80e079 <lodepng_decode+0x845>
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
  80e045:	48 83 bd 98 fd ff ff 	cmpq   $0x1,-0x268(%rbp)
  80e04c:	01 
  80e04d:	0f 85 83 0a 00 00    	jne    80ead6 <lodepng_decode+0x12a2>
  info->srgb_defined = 1;
  80e053:	41 c7 85 98 01 00 00 	movl   $0x1,0x198(%r13)
  80e05a:	01 00 00 00 
  info->srgb_intent = data[0];
  80e05e:	0f b6 43 08          	movzbl 0x8(%rbx),%eax
  80e062:	41 89 85 9c 01 00 00 	mov    %eax,0x19c(%r13)
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
  80e069:	41 c7 85 f0 01 00 00 	movl   $0x0,0x1f0(%r13)
  80e070:	00 00 00 00 
      if(state->error) break;
  80e074:	e9 f4 fa ff ff       	jmp    80db6d <lodepng_decode+0x339>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
  80e079:	48 be d6 26 81 00 00 	movabs $0x8126d6,%rsi
  80e080:	00 00 00 
  80e083:	48 89 df             	mov    %rbx,%rdi
  80e086:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80e08d:	00 00 00 
  80e090:	ff d0                	call   *%rax
  80e092:	84 c0                	test   %al,%al
  80e094:	0f 85 f7 00 00 00    	jne    80e191 <lodepng_decode+0x95d>
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
  80e09a:	41 83 7d 24 00       	cmpl   $0x0,0x24(%r13)
  80e09f:	75 0a                	jne    80e0ab <lodepng_decode+0x877>
  80e0a1:	f6 43 04 20          	testb  $0x20,0x4(%rbx)
  80e0a5:	0f 84 1a 01 00 00    	je     80e1c5 <lodepng_decode+0x991>
      if(state->decoder.remember_unknown_chunks) {
  80e0ab:	41 83 7d 34 00       	cmpl   $0x0,0x34(%r13)
  80e0b0:	0f 85 25 01 00 00    	jne    80e1db <lodepng_decode+0x9a7>
    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  80e0b6:	4b 8d 34 37          	lea    (%r15,%r14,1),%rsi
  80e0ba:	48 89 df             	mov    %rbx,%rdi
  80e0bd:	48 b8 c8 89 80 00 00 	movabs $0x8089c8,%rax
  80e0c4:	00 00 00 
  80e0c7:	ff d0                	call   *%rax
  80e0c9:	48 89 c3             	mov    %rax,%rbx
  while(!IEND && !state->error) {
  80e0cc:	41 83 bd f0 01 00 00 	cmpl   $0x0,0x1f0(%r13)
  80e0d3:	00 
  80e0d4:	0f 85 c4 fa ff ff    	jne    80db9e <lodepng_decode+0x36a>
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
  80e0da:	49 89 dc             	mov    %rbx,%r12
  80e0dd:	4d 29 fc             	sub    %r15,%r12
  80e0e0:	49 8d 44 24 0c       	lea    0xc(%r12),%rax
  80e0e5:	49 39 c6             	cmp    %rax,%r14
  80e0e8:	0f 82 ad f9 ff ff    	jb     80da9b <lodepng_decode+0x267>
  80e0ee:	49 39 df             	cmp    %rbx,%r15
  80e0f1:	0f 87 a4 f9 ff ff    	ja     80da9b <lodepng_decode+0x267>
  return lodepng_read32bitInt(&chunk[0]);
  80e0f7:	48 89 df             	mov    %rbx,%rdi
  80e0fa:	48 b8 ed 28 80 00 00 	movabs $0x8028ed,%rax
  80e101:	00 00 00 
  80e104:	ff d0                	call   *%rax
    if(chunkLength > 2147483647) {
  80e106:	85 c0                	test   %eax,%eax
  80e108:	0f 88 ad f9 ff ff    	js     80dabb <lodepng_decode+0x287>
    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
  80e10e:	89 c2                	mov    %eax,%edx
  80e110:	49 8d 54 14 0c       	lea    0xc(%r12,%rdx,1),%rdx
  80e115:	49 39 d6             	cmp    %rdx,%r14
  80e118:	0f 82 bd f9 ff ff    	jb     80dadb <lodepng_decode+0x2a7>
  80e11e:	89 c0                	mov    %eax,%eax
  80e120:	48 89 85 98 fd ff ff 	mov    %rax,-0x268(%rbp)
  80e127:	48 8d 44 03 0c       	lea    0xc(%rbx,%rax,1),%rax
  80e12c:	49 39 c7             	cmp    %rax,%r15
  80e12f:	0f 87 a6 f9 ff ff    	ja     80dadb <lodepng_decode+0x2a7>
  return &chunk[8];
  80e135:	4c 8d 63 08          	lea    0x8(%rbx),%r12
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
  80e139:	48 be db 26 81 00 00 	movabs $0x8126db,%rsi
  80e140:	00 00 00 
  80e143:	48 89 df             	mov    %rbx,%rdi
  80e146:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80e14d:	00 00 00 
  80e150:	ff d0                	call   *%rax
  80e152:	84 c0                	test   %al,%al
  80e154:	0f 85 97 f9 ff ff    	jne    80daf1 <lodepng_decode+0x2bd>
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
  80e15a:	48 be e0 26 81 00 00 	movabs $0x8126e0,%rsi
  80e161:	00 00 00 
  80e164:	48 89 df             	mov    %rbx,%rdi
  80e167:	48 b8 19 88 80 00 00 	movabs $0x808819,%rax
  80e16e:	00 00 00 
  80e171:	ff d0                	call   *%rax
  80e173:	84 c0                	test   %al,%al
  80e175:	0f 84 0f fb ff ff    	je     80dc8a <lodepng_decode+0x456>
    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
  80e17b:	41 83 7d 20 00       	cmpl   $0x0,0x20(%r13)
  80e180:	0f 85 18 fa ff ff    	jne    80db9e <lodepng_decode+0x36a>
      IEND = 1;
  80e186:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  80e18c:	e9 ed f9 ff ff       	jmp    80db7e <lodepng_decode+0x34a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
  80e191:	49 8d bd b8 00 00 00 	lea    0xb8(%r13),%rdi
  80e198:	48 8b 8d 98 fd ff ff 	mov    -0x268(%rbp),%rcx
  80e19f:	4c 89 e2             	mov    %r12,%rdx
  80e1a2:	4c 89 ee             	mov    %r13,%rsi
  80e1a5:	48 b8 e1 ae 80 00 00 	movabs $0x80aee1,%rax
  80e1ac:	00 00 00 
  80e1af:	ff d0                	call   *%rax
  80e1b1:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) break;
  80e1b8:	85 c0                	test   %eax,%eax
  80e1ba:	0f 84 ad f9 ff ff    	je     80db6d <lodepng_decode+0x339>
  80e1c0:	e9 d9 f9 ff ff       	jmp    80db9e <lodepng_decode+0x36a>
        CERROR_BREAK(state->error, 69);
  80e1c5:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80e1cc:	c7 80 f0 01 00 00 45 	movl   $0x45,0x1f0(%rax)
  80e1d3:	00 00 00 
  80e1d6:	e9 c3 f9 ff ff       	jmp    80db9e <lodepng_decode+0x36a>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
  80e1db:	8b 85 88 fd ff ff    	mov    -0x278(%rbp),%eax
  80e1e1:	8d 40 ff             	lea    -0x1(%rax),%eax
  80e1e4:	49 8d b4 c5 d8 01 00 	lea    0x1d8(%r13,%rax,8),%rsi
  80e1eb:	00 
  80e1ec:	49 8d bc c5 c0 01 00 	lea    0x1c0(%r13,%rax,8),%rdi
  80e1f3:	00 
  80e1f4:	48 89 da             	mov    %rbx,%rdx
  80e1f7:	48 b8 6c 8b 80 00 00 	movabs $0x808b6c,%rax
  80e1fe:	00 00 00 
  80e201:	ff d0                	call   *%rax
  80e203:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
        if(state->error) break;
  80e20a:	85 c0                	test   %eax,%eax
  80e20c:	0f 84 a4 fe ff ff    	je     80e0b6 <lodepng_decode+0x882>
  80e212:	e9 87 f9 ff ff       	jmp    80db9e <lodepng_decode+0x36a>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
  80e217:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80e21e:	c7 80 f0 01 00 00 39 	movl   $0x39,0x1f0(%rax)
  80e225:	00 00 00 
  80e228:	e9 71 f9 ff ff       	jmp    80db9e <lodepng_decode+0x36a>
  if(state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
  80e22d:	48 83 b8 d0 00 00 00 	cmpq   $0x0,0xd0(%rax)
  80e234:	00 
  80e235:	0f 85 77 f9 ff ff    	jne    80dbb2 <lodepng_decode+0x37e>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
  80e23b:	c7 80 f0 01 00 00 6a 	movl   $0x6a,0x1f0(%rax)
  80e242:	00 00 00 
  80e245:	e9 68 f9 ff ff       	jmp    80dbb2 <lodepng_decode+0x37e>
    size_t bpp = lodepng_get_bpp(&state->info_png.color);
  80e24a:	48 8b bd 90 fd ff ff 	mov    -0x270(%rbp),%rdi
  80e251:	48 b8 10 93 80 00 00 	movabs $0x809310,%rax
  80e258:	00 00 00 
  80e25b:	ff d0                	call   *%rax
  80e25d:	41 89 c7             	mov    %eax,%r15d
    expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
  80e260:	48 8b 85 48 fd ff ff 	mov    -0x2b8(%rbp),%rax
  80e267:	44 8b 30             	mov    (%rax),%r14d
  80e26a:	45 8d 6e 07          	lea    0x7(%r14),%r13d
  80e26e:	41 c1 ed 03          	shr    $0x3,%r13d
  80e272:	48 8b 85 50 fd ff ff 	mov    -0x2b0(%rbp),%rax
  80e279:	8b 18                	mov    (%rax),%ebx
  80e27b:	8d 7b 07             	lea    0x7(%rbx),%edi
  80e27e:	c1 ef 03             	shr    $0x3,%edi
  80e281:	44 89 fa             	mov    %r15d,%edx
  80e284:	44 89 ee             	mov    %r13d,%esi
  80e287:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  80e28e:	00 00 00 
  80e291:	ff d0                	call   *%rax
  80e293:	48 89 85 98 fd ff ff 	mov    %rax,-0x268(%rbp)
    if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
  80e29a:	83 fb 04             	cmp    $0x4,%ebx
  80e29d:	0f 86 d5 00 00 00    	jbe    80e378 <lodepng_decode+0xb44>
  80e2a3:	8d 4b 03             	lea    0x3(%rbx),%ecx
  80e2a6:	89 8d 88 fd ff ff    	mov    %ecx,-0x278(%rbp)
  80e2ac:	89 cf                	mov    %ecx,%edi
  80e2ae:	c1 ef 03             	shr    $0x3,%edi
  80e2b1:	44 89 fa             	mov    %r15d,%edx
  80e2b4:	44 89 ee             	mov    %r13d,%esi
  80e2b7:	49 bc 7a 2f 80 00 00 	movabs $0x802f7a,%r12
  80e2be:	00 00 00 
  80e2c1:	41 ff d4             	call   *%r12
  80e2c4:	48 89 85 80 fd ff ff 	mov    %rax,-0x280(%rbp)
    expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
  80e2cb:	45 8d 6e 03          	lea    0x3(%r14),%r13d
  80e2cf:	44 89 ee             	mov    %r13d,%esi
  80e2d2:	c1 ee 03             	shr    $0x3,%esi
  80e2d5:	8b bd 88 fd ff ff    	mov    -0x278(%rbp),%edi
  80e2db:	c1 ef 02             	shr    $0x2,%edi
  80e2de:	44 89 fa             	mov    %r15d,%edx
  80e2e1:	41 ff d4             	call   *%r12
  80e2e4:	4c 8b a5 80 fd ff ff 	mov    -0x280(%rbp),%r12
  80e2eb:	49 01 c4             	add    %rax,%r12
  80e2ee:	4c 03 a5 98 fd ff ff 	add    -0x268(%rbp),%r12
    if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
  80e2f5:	8d 43 01             	lea    0x1(%rbx),%eax
  80e2f8:	44 89 ee             	mov    %r13d,%esi
  80e2fb:	c1 ee 02             	shr    $0x2,%esi
  80e2fe:	89 85 98 fd ff ff    	mov    %eax,-0x268(%rbp)
  80e304:	89 c7                	mov    %eax,%edi
  80e306:	c1 ef 02             	shr    $0x2,%edi
  80e309:	44 89 fa             	mov    %r15d,%edx
  80e30c:	48 b9 7a 2f 80 00 00 	movabs $0x802f7a,%rcx
  80e313:	00 00 00 
  80e316:	ff d1                	call   *%rcx
  80e318:	49 01 c4             	add    %rax,%r12
    expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
  80e31b:	45 8d 6e 01          	lea    0x1(%r14),%r13d
  80e31f:	44 89 ee             	mov    %r13d,%esi
  80e322:	c1 ee 02             	shr    $0x2,%esi
  80e325:	8b bd 98 fd ff ff    	mov    -0x268(%rbp),%edi
  80e32b:	d1 ef                	shr    %edi
  80e32d:	44 89 fa             	mov    %r15d,%edx
  80e330:	48 b9 7a 2f 80 00 00 	movabs $0x802f7a,%rcx
  80e337:	00 00 00 
  80e33a:	ff d1                	call   *%rcx
  80e33c:	49 01 c4             	add    %rax,%r12
    if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
  80e33f:	44 89 ee             	mov    %r13d,%esi
  80e342:	d1 ee                	shr    %esi
  80e344:	89 df                	mov    %ebx,%edi
  80e346:	d1 ef                	shr    %edi
  80e348:	44 89 fa             	mov    %r15d,%edx
  80e34b:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  80e352:	00 00 00 
  80e355:	ff d0                	call   *%rax
  80e357:	49 01 c4             	add    %rax,%r12
    expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
  80e35a:	44 89 f6             	mov    %r14d,%esi
  80e35d:	d1 ee                	shr    %esi
  80e35f:	44 89 fa             	mov    %r15d,%edx
  80e362:	89 df                	mov    %ebx,%edi
  80e364:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  80e36b:	00 00 00 
  80e36e:	ff d0                	call   *%rax
  80e370:	49 01 c4             	add    %rax,%r12
  80e373:	e9 84 f8 ff ff       	jmp    80dbfc <lodepng_decode+0x3c8>
    expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
  80e378:	45 8d 6e 03          	lea    0x3(%r14),%r13d
  80e37c:	44 89 ee             	mov    %r13d,%esi
  80e37f:	c1 ee 03             	shr    $0x3,%esi
  80e382:	8d 7b 03             	lea    0x3(%rbx),%edi
  80e385:	c1 ef 02             	shr    $0x2,%edi
  80e388:	44 89 fa             	mov    %r15d,%edx
  80e38b:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  80e392:	00 00 00 
  80e395:	ff d0                	call   *%rax
  80e397:	4c 8b a5 98 fd ff ff 	mov    -0x268(%rbp),%r12
  80e39e:	49 01 c4             	add    %rax,%r12
    if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
  80e3a1:	83 fb 02             	cmp    $0x2,%ebx
  80e3a4:	0f 87 4b ff ff ff    	ja     80e2f5 <lodepng_decode+0xac1>
    expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
  80e3aa:	45 8d 6e 01          	lea    0x1(%r14),%r13d
  80e3ae:	44 89 ee             	mov    %r13d,%esi
  80e3b1:	c1 ee 02             	shr    $0x2,%esi
  80e3b4:	8d 7b 01             	lea    0x1(%rbx),%edi
  80e3b7:	d1 ef                	shr    %edi
  80e3b9:	44 89 fa             	mov    %r15d,%edx
  80e3bc:	48 b8 7a 2f 80 00 00 	movabs $0x802f7a,%rax
  80e3c3:	00 00 00 
  80e3c6:	ff d0                	call   *%rax
  80e3c8:	49 01 c4             	add    %rax,%r12
    if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
  80e3cb:	83 fb 02             	cmp    $0x2,%ebx
  80e3ce:	75 8a                	jne    80e35a <lodepng_decode+0xb26>
  80e3d0:	e9 6a ff ff ff       	jmp    80e33f <lodepng_decode+0xb0b>
  return jos_malloc(size);
  80e3d5:	44 89 e7             	mov    %r12d,%edi
  80e3d8:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80e3df:	00 00 00 
  80e3e2:	ff d0                	call   *%rax
    scanlines = (unsigned char*)lodepng_malloc(expected_size);
  80e3e4:	48 89 85 a8 fd ff ff 	mov    %rax,-0x258(%rbp)
    if(!scanlines) state->error = 83; /*alloc fail*/
  80e3eb:	48 85 c0             	test   %rax,%rax
  80e3ee:	74 74                	je     80e464 <lodepng_decode+0xc30>
    scanlines_size = 0;
  80e3f0:	48 c7 85 b0 fd ff ff 	movq   $0x0,-0x250(%rbp)
  80e3f7:	00 00 00 00 
  if(!state->error) {
  80e3fb:	48 8b 9d 78 fd ff ff 	mov    -0x288(%rbp),%rbx
  80e402:	83 bb f0 01 00 00 00 	cmpl   $0x0,0x1f0(%rbx)
  80e409:	0f 85 01 f8 ff ff    	jne    80dc10 <lodepng_decode+0x3dc>
    state->error = zlib_decompress(&scanlines, &scanlines_size, idat.data,
  80e40f:	49 89 d8             	mov    %rbx,%r8
  80e412:	48 8b 8d d0 fd ff ff 	mov    -0x230(%rbp),%rcx
  80e419:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  80e420:	48 8d b5 b0 fd ff ff 	lea    -0x250(%rbp),%rsi
  80e427:	48 8d bd a8 fd ff ff 	lea    -0x258(%rbp),%rdi
  80e42e:	48 b8 75 85 80 00 00 	movabs $0x808575,%rax
  80e435:	00 00 00 
  80e438:	ff d0                	call   *%rax
  80e43a:	89 83 f0 01 00 00    	mov    %eax,0x1f0(%rbx)
    if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
  80e440:	85 c0                	test   %eax,%eax
  80e442:	0f 85 c8 f7 ff ff    	jne    80dc10 <lodepng_decode+0x3dc>
  80e448:	4c 3b a5 b0 fd ff ff 	cmp    -0x250(%rbp),%r12
  80e44f:	0f 84 bb f7 ff ff    	je     80dc10 <lodepng_decode+0x3dc>
  80e455:	c7 83 f0 01 00 00 5b 	movl   $0x5b,0x1f0(%rbx)
  80e45c:	00 00 00 
  80e45f:	e9 ac f7 ff ff       	jmp    80dc10 <lodepng_decode+0x3dc>
    if(!scanlines) state->error = 83; /*alloc fail*/
  80e464:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80e46b:	c7 80 f0 01 00 00 53 	movl   $0x53,0x1f0(%rax)
  80e472:	00 00 00 
  80e475:	e9 76 ff ff ff       	jmp    80e3f0 <lodepng_decode+0xbbc>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
  80e47a:	48 8b 95 90 fd ff ff 	mov    -0x270(%rbp),%rdx
  80e481:	48 8b 85 48 fd ff ff 	mov    -0x2b8(%rbp),%rax
  80e488:	8b 30                	mov    (%rax),%esi
  80e48a:	48 8b 85 50 fd ff ff 	mov    -0x2b0(%rbp),%rax
  80e491:	8b 38                	mov    (%rax),%edi
  80e493:	48 b8 dc a4 80 00 00 	movabs $0x80a4dc,%rax
  80e49a:	00 00 00 
  80e49d:	ff d0                	call   *%rax
  80e49f:	48 89 c3             	mov    %rax,%rbx
  return jos_malloc(size);
  80e4a2:	89 c7                	mov    %eax,%edi
  80e4a4:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80e4ab:	00 00 00 
  80e4ae:	ff d0                	call   *%rax
  80e4b0:	48 89 c7             	mov    %rax,%rdi
    *out = (unsigned char*)lodepng_malloc(outsize);
  80e4b3:	48 8b 85 40 fd ff ff 	mov    -0x2c0(%rbp),%rax
  80e4ba:	48 89 38             	mov    %rdi,(%rax)
    if(!*out) state->error = 83; /*alloc fail*/
  80e4bd:	48 85 ff             	test   %rdi,%rdi
  80e4c0:	0f 84 e1 00 00 00    	je     80e5a7 <lodepng_decode+0xd73>
  if(!state->error) {
  80e4c6:	4c 8b a5 78 fd ff ff 	mov    -0x288(%rbp),%r12
  80e4cd:	41 83 bc 24 f0 01 00 	cmpl   $0x0,0x1f0(%r12)
  80e4d4:	00 00 
  80e4d6:	0f 85 5b f7 ff ff    	jne    80dc37 <lodepng_decode+0x403>
  memset(dst, value, num);
  80e4dc:	48 89 da             	mov    %rbx,%rdx
  80e4df:	be 00 00 00 00       	mov    $0x0,%esi
  80e4e4:	48 b8 f9 0e 80 00 00 	movabs $0x800ef9,%rax
  80e4eb:	00 00 00 
  80e4ee:	ff d0                	call   *%rax
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  80e4f0:	48 8b bd 90 fd ff ff 	mov    -0x270(%rbp),%rdi
  80e4f7:	48 b8 10 93 80 00 00 	movabs $0x809310,%rax
  80e4fe:	00 00 00 
  80e501:	ff d0                	call   *%rax
  80e503:	89 85 98 fd ff ff    	mov    %eax,-0x268(%rbp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
  80e509:	c7 85 74 fd ff ff 1f 	movl   $0x1f,-0x28c(%rbp)
  80e510:	00 00 00 
  80e513:	85 c0                	test   %eax,%eax
  80e515:	74 78                	je     80e58f <lodepng_decode+0xd5b>
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  80e517:	48 8b 8d 48 fd ff ff 	mov    -0x2b8(%rbp),%rcx
  80e51e:	44 8b 29             	mov    (%rcx),%r13d
  80e521:	48 8b 8d 50 fd ff ff 	mov    -0x2b0(%rbp),%rcx
  80e528:	8b 11                	mov    (%rcx),%edx
  80e52a:	89 95 80 fd ff ff    	mov    %edx,-0x280(%rbp)
  80e530:	4c 8b bd a8 fd ff ff 	mov    -0x258(%rbp),%r15
  80e537:	48 8b 8d 40 fd ff ff 	mov    -0x2c0(%rbp),%rcx
  80e53e:	4c 8b 31             	mov    (%rcx),%r14
  if(info_png->interlace_method == 0) {
  80e541:	41 83 bc 24 c0 00 00 	cmpl   $0x0,0xc0(%r12)
  80e548:	00 00 
  80e54a:	0f 85 ab 00 00 00    	jne    80e5fb <lodepng_decode+0xdc7>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
  80e550:	83 f8 07             	cmp    $0x7,%eax
  80e553:	77 12                	ja     80e567 <lodepng_decode+0xd33>
  80e555:	89 d3                	mov    %edx,%ebx
  80e557:	0f af d8             	imul   %eax,%ebx
  80e55a:	44 8d 63 07          	lea    0x7(%rbx),%r12d
  80e55e:	41 83 e4 f8          	and    $0xfffffff8,%r12d
  80e562:	44 39 e3             	cmp    %r12d,%ebx
  80e565:	75 56                	jne    80e5bd <lodepng_decode+0xd89>
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
  80e567:	44 8b 85 98 fd ff ff 	mov    -0x268(%rbp),%r8d
  80e56e:	44 89 e9             	mov    %r13d,%ecx
  80e571:	8b 95 80 fd ff ff    	mov    -0x280(%rbp),%edx
  80e577:	4c 89 fe             	mov    %r15,%rsi
  80e57a:	4c 89 f7             	mov    %r14,%rdi
  80e57d:	48 b8 4a 37 80 00 00 	movabs $0x80374a,%rax
  80e584:	00 00 00 
  80e587:	ff d0                	call   *%rax
  80e589:	89 85 74 fd ff ff    	mov    %eax,-0x28c(%rbp)
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  80e58f:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80e596:	8b 8d 74 fd ff ff    	mov    -0x28c(%rbp),%ecx
  80e59c:	89 88 f0 01 00 00    	mov    %ecx,0x1f0(%rax)
  80e5a2:	e9 90 f6 ff ff       	jmp    80dc37 <lodepng_decode+0x403>
    if(!*out) state->error = 83; /*alloc fail*/
  80e5a7:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80e5ae:	c7 80 f0 01 00 00 53 	movl   $0x53,0x1f0(%rax)
  80e5b5:	00 00 00 
  80e5b8:	e9 7a f6 ff ff       	jmp    80dc37 <lodepng_decode+0x403>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
  80e5bd:	41 89 c0             	mov    %eax,%r8d
  80e5c0:	44 89 e9             	mov    %r13d,%ecx
  80e5c3:	4c 89 fe             	mov    %r15,%rsi
  80e5c6:	4c 89 ff             	mov    %r15,%rdi
  80e5c9:	48 b8 4a 37 80 00 00 	movabs $0x80374a,%rax
  80e5d0:	00 00 00 
  80e5d3:	ff d0                	call   *%rax
  80e5d5:	89 85 74 fd ff ff    	mov    %eax,-0x28c(%rbp)
  80e5db:	85 c0                	test   %eax,%eax
  80e5dd:	75 b0                	jne    80e58f <lodepng_decode+0xd5b>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
  80e5df:	44 89 e1             	mov    %r12d,%ecx
  80e5e2:	89 da                	mov    %ebx,%edx
  80e5e4:	45 89 e8             	mov    %r13d,%r8d
  80e5e7:	4c 89 fe             	mov    %r15,%rsi
  80e5ea:	4c 89 f7             	mov    %r14,%rdi
  80e5ed:	48 b8 9e 3d 80 00 00 	movabs $0x803d9e,%rax
  80e5f4:	00 00 00 
  80e5f7:	ff d0                	call   *%rax
  80e5f9:	eb 94                	jmp    80e58f <lodepng_decode+0xd5b>
    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
  80e5fb:	8b 85 98 fd ff ff    	mov    -0x268(%rbp),%eax
  80e601:	50                   	push   %rax
  80e602:	41 55                	push   %r13
  80e604:	44 8b 8d 80 fd ff ff 	mov    -0x280(%rbp),%r9d
  80e60b:	4c 8d 85 d0 fe ff ff 	lea    -0x130(%rbp),%r8
  80e612:	48 8d 8d 90 fe ff ff 	lea    -0x170(%rbp),%rcx
  80e619:	48 8d 95 50 fe ff ff 	lea    -0x1b0(%rbp),%rdx
  80e620:	48 8d b5 fc fd ff ff 	lea    -0x204(%rbp),%rsi
  80e627:	48 8d bd e0 fd ff ff 	lea    -0x220(%rbp),%rdi
  80e62e:	48 b8 d5 35 80 00 00 	movabs $0x8035d5,%rax
  80e635:	00 00 00 
  80e638:	ff d0                	call   *%rax
  80e63a:	48 83 c4 10          	add    $0x10,%rsp
  80e63e:	bb 00 00 00 00       	mov    $0x0,%ebx
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
  80e643:	49 bc 4a 37 80 00 00 	movabs $0x80374a,%r12
  80e64a:	00 00 00 
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
  80e64d:	44 89 ad 90 fd ff ff 	mov    %r13d,-0x270(%rbp)
  80e654:	44 8b ad 98 fd ff ff 	mov    -0x268(%rbp),%r13d
  80e65b:	eb 47                	jmp    80e6a4 <lodepng_decode+0xe70>
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
  80e65d:	44 89 e8             	mov    %r13d,%eax
  80e660:	0f af 84 1d e0 fd ff 	imul   -0x220(%rbp,%rbx,1),%eax
  80e667:	ff 
  80e668:	8d 48 07             	lea    0x7(%rax),%ecx
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
  80e66b:	83 e1 f8             	and    $0xfffffff8,%ecx
  80e66e:	89 c2                	mov    %eax,%edx
  80e670:	4c 89 fe             	mov    %r15,%rsi
  80e673:	48 03 b4 5d 90 fe ff 	add    -0x170(%rbp,%rbx,2),%rsi
  80e67a:	ff 
  80e67b:	4c 89 ff             	mov    %r15,%rdi
  80e67e:	48 03 bc 5d d0 fe ff 	add    -0x130(%rbp,%rbx,2),%rdi
  80e685:	ff 
  80e686:	44 8b 84 1d fc fd ff 	mov    -0x204(%rbp,%rbx,1),%r8d
  80e68d:	ff 
  80e68e:	48 b8 9e 3d 80 00 00 	movabs $0x803d9e,%rax
  80e695:	00 00 00 
  80e698:	ff d0                	call   *%rax
    for(i = 0; i != 7; ++i) {
  80e69a:	48 83 c3 04          	add    $0x4,%rbx
  80e69e:	48 83 fb 1c          	cmp    $0x1c,%rbx
  80e6a2:	74 43                	je     80e6e7 <lodepng_decode+0xeb3>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
  80e6a4:	8b 8c 1d fc fd ff ff 	mov    -0x204(%rbp,%rbx,1),%ecx
  80e6ab:	8b 94 1d e0 fd ff ff 	mov    -0x220(%rbp,%rbx,1),%edx
  80e6b2:	4c 89 fe             	mov    %r15,%rsi
  80e6b5:	48 03 b4 5d 50 fe ff 	add    -0x1b0(%rbp,%rbx,2),%rsi
  80e6bc:	ff 
  80e6bd:	4c 89 ff             	mov    %r15,%rdi
  80e6c0:	48 03 bc 5d 90 fe ff 	add    -0x170(%rbp,%rbx,2),%rdi
  80e6c7:	ff 
  80e6c8:	45 89 e8             	mov    %r13d,%r8d
  80e6cb:	41 ff d4             	call   *%r12
  80e6ce:	89 85 74 fd ff ff    	mov    %eax,-0x28c(%rbp)
  80e6d4:	85 c0                	test   %eax,%eax
  80e6d6:	0f 85 b3 fe ff ff    	jne    80e58f <lodepng_decode+0xd5b>
      if(bpp < 8) {
  80e6dc:	41 83 fd 07          	cmp    $0x7,%r13d
  80e6e0:	77 b8                	ja     80e69a <lodepng_decode+0xe66>
  80e6e2:	e9 76 ff ff ff       	jmp    80e65d <lodepng_decode+0xe29>
  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
  80e6e7:	44 8b ad 90 fd ff ff 	mov    -0x270(%rbp),%r13d
  80e6ee:	8b 9d 98 fd ff ff    	mov    -0x268(%rbp),%ebx
  80e6f4:	53                   	push   %rbx
  80e6f5:	41 55                	push   %r13
  80e6f7:	44 8b 8d 80 fd ff ff 	mov    -0x280(%rbp),%r9d
  80e6fe:	4c 8d 45 90          	lea    -0x70(%rbp),%r8
  80e702:	48 8d 8d 50 ff ff ff 	lea    -0xb0(%rbp),%rcx
  80e709:	48 8d 95 10 ff ff ff 	lea    -0xf0(%rbp),%rdx
  80e710:	48 8d b5 34 fe ff ff 	lea    -0x1cc(%rbp),%rsi
  80e717:	48 8d bd 18 fe ff ff 	lea    -0x1e8(%rbp),%rdi
  80e71e:	48 b8 d5 35 80 00 00 	movabs $0x8035d5,%rax
  80e725:	00 00 00 
  80e728:	ff d0                	call   *%rax
  if(bpp >= 8) {
  80e72a:	48 83 c4 10          	add    $0x10,%rsp
  80e72e:	83 fb 07             	cmp    $0x7,%ebx
  80e731:	0f 86 23 01 00 00    	jbe    80e85a <lodepng_decode+0x1026>
      size_t bytewidth = bpp / 8u;
  80e737:	c1 eb 03             	shr    $0x3,%ebx
  80e73a:	89 de                	mov    %ebx,%esi
  80e73c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80e741:	e9 b3 00 00 00       	jmp    80e7f9 <lodepng_decode+0xfc5>
      for(y = 0; y < passh[i]; ++y)
  80e746:	41 83 c1 01          	add    $0x1,%r9d
  80e74a:	44 3b 8c 2b 34 fe ff 	cmp    -0x1cc(%rbx,%rbp,1),%r9d
  80e751:	ff 
  80e752:	0f 83 93 00 00 00    	jae    80e7eb <lodepng_decode+0xfb7>
      for(x = 0; x < passw[i]; ++x) {
  80e758:	8b 84 1d 18 fe ff ff 	mov    -0x1e8(%rbp,%rbx,1),%eax
  80e75f:	85 c0                	test   %eax,%eax
  80e761:	74 e3                	je     80e746 <lodepng_decode+0xf12>
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
  80e763:	45 8b 55 00          	mov    0x0(%r13),%r10d
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
  80e767:	41 8b 14 24          	mov    (%r12),%edx
  80e76b:	44 89 c9             	mov    %r9d,%ecx
  80e76e:	48 0f af d1          	imul   %rcx,%rdx
  80e772:	41 8b 0b             	mov    (%r11),%ecx
  80e775:	4c 8d 04 0a          	lea    (%rdx,%rcx,1),%r8
  80e779:	4c 0f af 85 90 fd ff 	imul   -0x270(%rbp),%r8
  80e780:	ff 
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
  80e781:	48 8b 8d 88 fd ff ff 	mov    -0x278(%rbp),%rcx
  80e788:	8b 11                	mov    (%rcx),%edx
  80e78a:	49 01 d0             	add    %rdx,%r8
      for(x = 0; x < passw[i]; ++x) {
  80e78d:	8b bd 74 fd ff ff    	mov    -0x28c(%rbp),%edi
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
  80e793:	41 0f af c1          	imul   %r9d,%eax
  80e797:	8d 0c 38             	lea    (%rax,%rdi,1),%ecx
  80e79a:	48 0f af ce          	imul   %rsi,%rcx
  80e79e:	48 03 4c 5d 90       	add    -0x70(%rbp,%rbx,2),%rcx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
  80e7a3:	89 fa                	mov    %edi,%edx
  80e7a5:	49 0f af d2          	imul   %r10,%rdx
  80e7a9:	4c 01 c2             	add    %r8,%rdx
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
  80e7ac:	48 0f af d6          	imul   %rsi,%rdx
  80e7b0:	b8 00 00 00 00       	mov    $0x0,%eax
          out[pixeloutstart + b] = in[pixelinstart + b];
  80e7b5:	4c 01 f9             	add    %r15,%rcx
  80e7b8:	4c 01 f2             	add    %r14,%rdx
  80e7bb:	89 bd 98 fd ff ff    	mov    %edi,-0x268(%rbp)
  80e7c1:	0f b6 3c 01          	movzbl (%rcx,%rax,1),%edi
  80e7c5:	40 88 3c 02          	mov    %dil,(%rdx,%rax,1)
        for(b = 0; b < bytewidth; ++b) {
  80e7c9:	48 83 c0 01          	add    $0x1,%rax
  80e7cd:	48 39 c6             	cmp    %rax,%rsi
  80e7d0:	75 ef                	jne    80e7c1 <lodepng_decode+0xf8d>
      for(x = 0; x < passw[i]; ++x) {
  80e7d2:	8b bd 98 fd ff ff    	mov    -0x268(%rbp),%edi
  80e7d8:	83 c7 01             	add    $0x1,%edi
  80e7db:	8b 84 1d 18 fe ff ff 	mov    -0x1e8(%rbp,%rbx,1),%eax
  80e7e2:	39 f8                	cmp    %edi,%eax
  80e7e4:	77 ad                	ja     80e793 <lodepng_decode+0xf5f>
  80e7e6:	e9 5b ff ff ff       	jmp    80e746 <lodepng_decode+0xf12>
    for(i = 0; i != 7; ++i) {
  80e7eb:	48 83 c3 04          	add    $0x4,%rbx
  80e7ef:	48 83 fb 1c          	cmp    $0x1c,%rbx
  80e7f3:	0f 84 96 fd ff ff    	je     80e58f <lodepng_decode+0xd5b>
      for(y = 0; y < passh[i]; ++y)
  80e7f9:	44 8b 8d 74 fd ff ff 	mov    -0x28c(%rbp),%r9d
  80e800:	83 bc 2b 34 fe ff ff 	cmpl   $0x0,-0x1cc(%rbx,%rbp,1)
  80e807:	00 
  80e808:	74 e1                	je     80e7eb <lodepng_decode+0xfb7>
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
  80e80a:	48 b8 70 1f 81 00 00 	movabs $0x811f70,%rax
  80e811:	00 00 00 
  80e814:	4c 8d 2c 03          	lea    (%rbx,%rax,1),%r13
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
  80e818:	48 b8 50 1f 81 00 00 	movabs $0x811f50,%rax
  80e81f:	00 00 00 
  80e822:	4c 8d 24 03          	lea    (%rbx,%rax,1),%r12
  80e826:	48 b8 90 1f 81 00 00 	movabs $0x811f90,%rax
  80e82d:	00 00 00 
  80e830:	4c 8d 1c 03          	lea    (%rbx,%rax,1),%r11
  80e834:	8b 85 80 fd ff ff    	mov    -0x280(%rbp),%eax
  80e83a:	48 89 85 90 fd ff ff 	mov    %rax,-0x270(%rbp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
  80e841:	48 b8 b0 1f 81 00 00 	movabs $0x811fb0,%rax
  80e848:	00 00 00 
  80e84b:	48 01 d8             	add    %rbx,%rax
  80e84e:	48 89 85 88 fd ff ff 	mov    %rax,-0x278(%rbp)
  80e855:	e9 fe fe ff ff       	jmp    80e758 <lodepng_decode+0xf24>
      unsigned olinebits = bpp * w;
  80e85a:	8b 85 80 fd ff ff    	mov    -0x280(%rbp),%eax
  80e860:	8b 8d 98 fd ff ff    	mov    -0x268(%rbp),%ecx
  80e866:	0f af c1             	imul   %ecx,%eax
  80e869:	89 85 34 fd ff ff    	mov    %eax,-0x2cc(%rbp)
  80e86f:	48 c7 85 88 fd ff ff 	movq   $0x0,-0x278(%rbp)
  80e876:	00 00 00 00 
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
  80e87a:	4c 89 bd 98 fd ff ff 	mov    %r15,-0x268(%rbp)
  80e881:	4d 89 f7             	mov    %r14,%r15
  80e884:	41 89 ce             	mov    %ecx,%r14d
  80e887:	e9 86 01 00 00       	jmp    80ea12 <lodepng_decode+0x11de>
      for(x = 0; x < passw[i]; ++x) {
  80e88c:	83 85 90 fd ff ff 01 	addl   $0x1,-0x270(%rbp)
  80e893:	8b 85 90 fd ff ff    	mov    -0x270(%rbp),%eax
  80e899:	01 9d 80 fd ff ff    	add    %ebx,-0x280(%rbp)
  80e89f:	48 8b 8d 88 fd ff ff 	mov    -0x278(%rbp),%rcx
  80e8a6:	3b 84 0d 18 fe ff ff 	cmp    -0x1e8(%rbp,%rcx,1),%eax
  80e8ad:	0f 83 85 00 00 00    	jae    80e938 <lodepng_decode+0x1104>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
  80e8b3:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
  80e8ba:	48 8b 54 45 90       	mov    -0x70(%rbp,%rax,2),%rdx
  80e8bf:	8b 85 80 fd ff ff    	mov    -0x280(%rbp),%eax
  80e8c5:	48 8d 04 d0          	lea    (%rax,%rdx,8),%rax
  80e8c9:	48 89 85 c0 fd ff ff 	mov    %rax,-0x240(%rbp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
  80e8d0:	8b 85 90 fd ff ff    	mov    -0x270(%rbp),%eax
  80e8d6:	48 0f af 85 60 fd ff 	imul   -0x2a0(%rbp),%rax
  80e8dd:	ff 
  80e8de:	48 03 85 58 fd ff ff 	add    -0x2a8(%rbp),%rax
  80e8e5:	44 89 f2             	mov    %r14d,%edx
  80e8e8:	48 0f af c2          	imul   %rdx,%rax
  80e8ec:	48 03 85 68 fd ff ff 	add    -0x298(%rbp),%rax
  80e8f3:	48 89 85 b8 fd ff ff 	mov    %rax,-0x248(%rbp)
        for(b = 0; b < bpp; ++b) {
  80e8fa:	8b 9d 74 fd ff ff    	mov    -0x28c(%rbp),%ebx
          setBitOfReversedStream(&obp, out, bit);
  80e900:	49 bc 00 2e 80 00 00 	movabs $0x802e00,%r12
  80e907:	00 00 00 
          unsigned char bit = readBitFromReversedStream(&ibp, in);
  80e90a:	48 8b b5 98 fd ff ff 	mov    -0x268(%rbp),%rsi
  80e911:	48 8d bd c0 fd ff ff 	lea    -0x240(%rbp),%rdi
  80e918:	41 ff d5             	call   *%r13
          setBitOfReversedStream(&obp, out, bit);
  80e91b:	0f b6 d0             	movzbl %al,%edx
  80e91e:	4c 89 fe             	mov    %r15,%rsi
  80e921:	48 8d bd b8 fd ff ff 	lea    -0x248(%rbp),%rdi
  80e928:	41 ff d4             	call   *%r12
        for(b = 0; b < bpp; ++b) {
  80e92b:	83 c3 01             	add    $0x1,%ebx
  80e92e:	41 39 de             	cmp    %ebx,%r14d
  80e931:	75 d7                	jne    80e90a <lodepng_decode+0x10d6>
  80e933:	e9 54 ff ff ff       	jmp    80e88c <lodepng_decode+0x1058>
      for(y = 0; y < passh[i]; ++y)
  80e938:	83 85 70 fd ff ff 01 	addl   $0x1,-0x290(%rbp)
  80e93f:	8b 85 70 fd ff ff    	mov    -0x290(%rbp),%eax
  80e945:	8b 9d 38 fd ff ff    	mov    -0x2c8(%rbp),%ebx
  80e94b:	01 9d 3c fd ff ff    	add    %ebx,-0x2c4(%rbp)
  80e951:	48 8b 8d 88 fd ff ff 	mov    -0x278(%rbp),%rcx
  80e958:	3b 84 0d 34 fe ff ff 	cmp    -0x1cc(%rbp,%rcx,1),%eax
  80e95f:	0f 83 94 00 00 00    	jae    80e9f9 <lodepng_decode+0x11c5>
      for(x = 0; x < passw[i]; ++x) {
  80e965:	8b 85 3c fd ff ff    	mov    -0x2c4(%rbp),%eax
  80e96b:	89 85 80 fd ff ff    	mov    %eax,-0x280(%rbp)
  80e971:	8b 85 74 fd ff ff    	mov    -0x28c(%rbp),%eax
  80e977:	89 85 90 fd ff ff    	mov    %eax,-0x270(%rbp)
  80e97d:	48 8b 8d 88 fd ff ff 	mov    -0x278(%rbp),%rcx
  80e984:	83 bc 0d 18 fe ff ff 	cmpl   $0x0,-0x1e8(%rbp,%rcx,1)
  80e98b:	00 
  80e98c:	74 aa                	je     80e938 <lodepng_decode+0x1104>
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
  80e98e:	48 b8 50 1f 81 00 00 	movabs $0x811f50,%rax
  80e995:	00 00 00 
  80e998:	8b 04 08             	mov    (%rax,%rcx,1),%eax
  80e99b:	8b 95 70 fd ff ff    	mov    -0x290(%rbp),%edx
  80e9a1:	48 0f af c2          	imul   %rdx,%rax
  80e9a5:	48 8b 9d 28 fd ff ff 	mov    -0x2d8(%rbp),%rbx
  80e9ac:	8b 13                	mov    (%rbx),%edx
  80e9ae:	48 01 d0             	add    %rdx,%rax
  80e9b1:	8b 95 34 fd ff ff    	mov    -0x2cc(%rbp),%edx
  80e9b7:	48 0f af c2          	imul   %rdx,%rax
  80e9bb:	48 89 85 68 fd ff ff 	mov    %rax,-0x298(%rbp)
  80e9c2:	48 b8 70 1f 81 00 00 	movabs $0x811f70,%rax
  80e9c9:	00 00 00 
  80e9cc:	8b 04 08             	mov    (%rax,%rcx,1),%eax
  80e9cf:	48 89 85 60 fd ff ff 	mov    %rax,-0x2a0(%rbp)
  80e9d6:	48 b8 b0 1f 81 00 00 	movabs $0x811fb0,%rax
  80e9dd:	00 00 00 
  80e9e0:	8b 04 08             	mov    (%rax,%rcx,1),%eax
  80e9e3:	48 89 85 58 fd ff ff 	mov    %rax,-0x2a8(%rbp)
          unsigned char bit = readBitFromReversedStream(&ibp, in);
  80e9ea:	49 bd 78 2d 80 00 00 	movabs $0x802d78,%r13
  80e9f1:	00 00 00 
  80e9f4:	e9 ba fe ff ff       	jmp    80e8b3 <lodepng_decode+0x107f>
    for(i = 0; i != 7; ++i) {
  80e9f9:	48 83 85 88 fd ff ff 	addq   $0x4,-0x278(%rbp)
  80ea00:	04 
  80ea01:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
  80ea08:	48 83 f8 1c          	cmp    $0x1c,%rax
  80ea0c:	0f 84 7d fb ff ff    	je     80e58f <lodepng_decode+0xd5b>
      unsigned ilinebits = bpp * passw[i];
  80ea12:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
  80ea19:	44 89 f1             	mov    %r14d,%ecx
  80ea1c:	0f af 8c 05 18 fe ff 	imul   -0x1e8(%rbp,%rax,1),%ecx
  80ea23:	ff 
  80ea24:	89 8d 38 fd ff ff    	mov    %ecx,-0x2c8(%rbp)
      for(y = 0; y < passh[i]; ++y)
  80ea2a:	8b 8d 74 fd ff ff    	mov    -0x28c(%rbp),%ecx
  80ea30:	89 8d 3c fd ff ff    	mov    %ecx,-0x2c4(%rbp)
  80ea36:	89 8d 70 fd ff ff    	mov    %ecx,-0x290(%rbp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
  80ea3c:	48 b9 90 1f 81 00 00 	movabs $0x811f90,%rcx
  80ea43:	00 00 00 
  80ea46:	48 01 c1             	add    %rax,%rcx
  80ea49:	48 89 8d 28 fd ff ff 	mov    %rcx,-0x2d8(%rbp)
      for(y = 0; y < passh[i]; ++y)
  80ea50:	83 bc 05 34 fe ff ff 	cmpl   $0x0,-0x1cc(%rbp,%rax,1)
  80ea57:	00 
  80ea58:	0f 85 07 ff ff ff    	jne    80e965 <lodepng_decode+0x1131>
  80ea5e:	eb 99                	jmp    80e9f9 <lodepng_decode+0x11c5>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
  80ea60:	48 8b 9d 78 fd ff ff 	mov    -0x288(%rbp),%rbx
  80ea67:	48 8d b3 c8 00 00 00 	lea    0xc8(%rbx),%rsi
  80ea6e:	48 8d bb 90 00 00 00 	lea    0x90(%rbx),%rdi
  80ea75:	48 b8 e7 91 80 00 00 	movabs $0x8091e7,%rax
  80ea7c:	00 00 00 
  80ea7f:	ff d0                	call   *%rax
  80ea81:	89 83 f0 01 00 00    	mov    %eax,0x1f0(%rbx)
      if(state->error) return state->error;
  80ea87:	85 c0                	test   %eax,%eax
  80ea89:	0f 84 38 ef ff ff    	je     80d9c7 <lodepng_decode+0x193>
  80ea8f:	e9 40 ef ff ff       	jmp    80d9d4 <lodepng_decode+0x1a0>
      state->error = 83; /*alloc fail*/
  80ea94:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80ea9b:	c7 80 f0 01 00 00 53 	movl   $0x53,0x1f0(%rax)
  80eaa2:	00 00 00 
  80eaa5:	e9 0e ef ff ff       	jmp    80d9b8 <lodepng_decode+0x184>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
  80eaaa:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80eab1:	c7 80 f0 01 00 00 49 	movl   $0x49,0x1f0(%rax)
  80eab8:	00 00 00 
      if(state->error) break;
  80eabb:	e9 de f0 ff ff       	jmp    80db9e <lodepng_decode+0x36a>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
  80eac0:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80eac7:	c7 80 f0 01 00 00 60 	movl   $0x60,0x1f0(%rax)
  80eace:	00 00 00 
      if(state->error) break;
  80ead1:	e9 c8 f0 ff ff       	jmp    80db9e <lodepng_decode+0x36a>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
  80ead6:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
  80eadd:	c7 80 f0 01 00 00 62 	movl   $0x62,0x1f0(%rax)
  80eae4:	00 00 00 
      if(state->error) break;
  80eae7:	e9 b2 f0 ff ff       	jmp    80db9e <lodepng_decode+0x36a>
  return (a != 0 && *result / a != b);
  80eaec:	48 85 f6             	test   %rsi,%rsi
  80eaef:	74 1a                	je     80eb0b <lodepng_decode+0x12d7>
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
  80eaf1:	48 8d 04 f5 00 00 00 	lea    0x0(,%rsi,8),%rax
  80eaf8:	00 
  return (a != 0 && *result / a != b);
  80eaf9:	ba 00 00 00 00       	mov    $0x0,%edx
  80eafe:	48 f7 f6             	div    %rsi
  80eb01:	48 83 f8 08          	cmp    $0x8,%rax
  80eb05:	0f 85 4e ef ff ff    	jne    80da59 <lodepng_decode+0x225>
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
  80eb0b:	44 89 ee             	mov    %r13d,%esi
  80eb0e:	c1 ee 03             	shr    $0x3,%esi
  80eb11:	89 f6                	mov    %esi,%esi
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
  80eb13:	48 89 f1             	mov    %rsi,%rcx
  80eb16:	48 0f af cb          	imul   %rbx,%rcx
  return (a != 0 && *result / a != b);
  80eb1a:	48 85 f6             	test   %rsi,%rsi
  80eb1d:	0f 85 4c ef ff ff    	jne    80da6f <lodepng_decode+0x23b>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
  80eb23:	44 89 e8             	mov    %r13d,%eax
  80eb26:	83 e0 07             	and    $0x7,%eax
  80eb29:	48 0f af c3          	imul   %rbx,%rax
  80eb2d:	48 83 c0 07          	add    $0x7,%rax
  80eb31:	48 c1 e8 03          	shr    $0x3,%rax
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
  80eb35:	48 01 c1             	add    %rax,%rcx
  80eb38:	48 83 c1 05          	add    $0x5,%rcx
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
  80eb3c:	4c 89 e0             	mov    %r12,%rax
  80eb3f:	48 0f af c1          	imul   %rcx,%rax
  return (a != 0 && *result / a != b);
  80eb43:	ba 00 00 00 00       	mov    $0x0,%edx
  80eb48:	48 f7 f1             	div    %rcx
  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
  80eb4b:	49 39 c4             	cmp    %rax,%r12
  80eb4e:	0f 85 05 ef ff ff    	jne    80da59 <lodepng_decode+0x225>
  p->data = NULL;
  80eb54:	48 c7 85 c8 fd ff ff 	movq   $0x0,-0x238(%rbp)
  80eb5b:	00 00 00 00 
  p->size = p->allocsize = 0;
  80eb5f:	48 c7 85 d8 fd ff ff 	movq   $0x0,-0x228(%rbp)
  80eb66:	00 00 00 00 
  80eb6a:	48 c7 85 d0 fd ff ff 	movq   $0x0,-0x230(%rbp)
  80eb71:	00 00 00 00 
  chunk = &in[33]; /*first byte of the first chunk after the header*/
  80eb75:	49 8d 5f 21          	lea    0x21(%r15),%rbx
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
  80eb79:	c7 85 88 fd ff ff 01 	movl   $0x1,-0x278(%rbp)
  80eb80:	00 00 00 
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
  80eb83:	4c 8b ad 78 fd ff ff 	mov    -0x288(%rbp),%r13
  80eb8a:	e9 4b f5 ff ff       	jmp    80e0da <lodepng_decode+0x8a6>

000000000080eb8f <lodepng_decoder_settings_init>:
void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
  80eb8f:	55                   	push   %rbp
  80eb90:	48 89 e5             	mov    %rsp,%rbp
  settings->color_convert = 1;
  80eb93:	c7 47 2c 01 00 00 00 	movl   $0x1,0x2c(%rdi)
  settings->read_text_chunks = 1;
  80eb9a:	c7 47 30 01 00 00 00 	movl   $0x1,0x30(%rdi)
  settings->remember_unknown_chunks = 0;
  80eba1:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%rdi)
  settings->ignore_crc = 0;
  80eba8:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%rdi)
  settings->ignore_critical = 0;
  80ebaf:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%rdi)
  settings->ignore_end = 0;
  80ebb6:	c7 47 28 00 00 00 00 	movl   $0x0,0x28(%rdi)
  lodepng_decompress_settings_init(&settings->zlibsettings);
  80ebbd:	48 b8 8b 87 80 00 00 	movabs $0x80878b,%rax
  80ebc4:	00 00 00 
  80ebc7:	ff d0                	call   *%rax
}
  80ebc9:	5d                   	pop    %rbp
  80ebca:	c3                   	ret    

000000000080ebcb <lodepng_state_cleanup>:
void lodepng_state_cleanup(LodePNGState* state) {
  80ebcb:	55                   	push   %rbp
  80ebcc:	48 89 e5             	mov    %rsp,%rbp
  80ebcf:	53                   	push   %rbx
  80ebd0:	48 83 ec 08          	sub    $0x8,%rsp
  80ebd4:	48 89 fb             	mov    %rdi,%rbx
  lodepng_color_mode_cleanup(&state->info_raw);
  80ebd7:	48 8d bf 90 00 00 00 	lea    0x90(%rdi),%rdi
  lodepng_palette_clear(info);
  80ebde:	48 b8 9e 91 80 00 00 	movabs $0x80919e,%rax
  80ebe5:	00 00 00 
  80ebe8:	ff d0                	call   *%rax
  lodepng_info_cleanup(&state->info_png);
  80ebea:	48 8d bb b8 00 00 00 	lea    0xb8(%rbx),%rdi
  80ebf1:	48 b8 93 b1 80 00 00 	movabs $0x80b193,%rax
  80ebf8:	00 00 00 
  80ebfb:	ff d0                	call   *%rax
}
  80ebfd:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80ec01:	c9                   	leave  
  80ec02:	c3                   	ret    

000000000080ec03 <lodepng_state_copy>:
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  80ec03:	55                   	push   %rbp
  80ec04:	48 89 e5             	mov    %rsp,%rbp
  80ec07:	41 56                	push   %r14
  80ec09:	41 55                	push   %r13
  80ec0b:	41 54                	push   %r12
  80ec0d:	53                   	push   %rbx
  80ec0e:	48 89 fb             	mov    %rdi,%rbx
  80ec11:	49 89 f4             	mov    %rsi,%r12
  lodepng_state_cleanup(dest);
  80ec14:	48 b8 cb eb 80 00 00 	movabs $0x80ebcb,%rax
  80ec1b:	00 00 00 
  80ec1e:	ff d0                	call   *%rax
  memcpy(dst, src, size);
  80ec20:	ba f8 01 00 00       	mov    $0x1f8,%edx
  80ec25:	4c 89 e6             	mov    %r12,%rsi
  80ec28:	48 89 df             	mov    %rbx,%rdi
  80ec2b:	48 b8 08 10 80 00 00 	movabs $0x801008,%rax
  80ec32:	00 00 00 
  80ec35:	ff d0                	call   *%rax
  lodepng_color_mode_init(&dest->info_raw);
  80ec37:	4c 8d b3 90 00 00 00 	lea    0x90(%rbx),%r14
  80ec3e:	4c 89 f7             	mov    %r14,%rdi
  80ec41:	48 b8 01 91 80 00 00 	movabs $0x809101,%rax
  80ec48:	00 00 00 
  80ec4b:	ff d0                	call   *%rax
  lodepng_info_init(&dest->info_png);
  80ec4d:	4c 8d ab b8 00 00 00 	lea    0xb8(%rbx),%r13
  80ec54:	4c 89 ef             	mov    %r13,%rdi
  80ec57:	48 b8 9d b0 80 00 00 	movabs $0x80b09d,%rax
  80ec5e:	00 00 00 
  80ec61:	ff d0                	call   *%rax
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
  80ec63:	49 8d b4 24 90 00 00 	lea    0x90(%r12),%rsi
  80ec6a:	00 
  80ec6b:	4c 89 f7             	mov    %r14,%rdi
  80ec6e:	48 b8 e7 91 80 00 00 	movabs $0x8091e7,%rax
  80ec75:	00 00 00 
  80ec78:	ff d0                	call   *%rax
  80ec7a:	89 83 f0 01 00 00    	mov    %eax,0x1f0(%rbx)
  80ec80:	85 c0                	test   %eax,%eax
  80ec82:	74 09                	je     80ec8d <lodepng_state_copy+0x8a>
}
  80ec84:	5b                   	pop    %rbx
  80ec85:	41 5c                	pop    %r12
  80ec87:	41 5d                	pop    %r13
  80ec89:	41 5e                	pop    %r14
  80ec8b:	5d                   	pop    %rbp
  80ec8c:	c3                   	ret    
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
  80ec8d:	49 8d b4 24 b8 00 00 	lea    0xb8(%r12),%rsi
  80ec94:	00 
  80ec95:	4c 89 ef             	mov    %r13,%rdi
  80ec98:	48 b8 07 b2 80 00 00 	movabs $0x80b207,%rax
  80ec9f:	00 00 00 
  80eca2:	ff d0                	call   *%rax
  80eca4:	89 83 f0 01 00 00    	mov    %eax,0x1f0(%rbx)
  80ecaa:	eb d8                	jmp    80ec84 <lodepng_state_copy+0x81>

000000000080ecac <lodepng_encode>:
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
  80ecac:	55                   	push   %rbp
  80ecad:	48 89 e5             	mov    %rsp,%rbp
  80ecb0:	41 57                	push   %r15
  80ecb2:	41 56                	push   %r14
  80ecb4:	41 55                	push   %r13
  80ecb6:	41 54                	push   %r12
  80ecb8:	53                   	push   %rbx
  80ecb9:	48 81 ec 48 06 00 00 	sub    $0x648,%rsp
  80ecc0:	49 89 ff             	mov    %rdi,%r15
  80ecc3:	49 89 f6             	mov    %rsi,%r14
  80ecc6:	48 89 95 c0 f9 ff ff 	mov    %rdx,-0x640(%rbp)
  80eccd:	41 89 cc             	mov    %ecx,%r12d
  80ecd0:	44 89 85 c8 f9 ff ff 	mov    %r8d,-0x638(%rbp)
  80ecd7:	4d 89 cd             	mov    %r9,%r13
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
  80ecda:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80ece1:	00 
  size_t datasize = 0;
  80ece2:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80ece9:	00 
  p->data = NULL;
  80ecea:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80ecf1:	00 
  p->size = p->allocsize = 0;
  80ecf2:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80ecf9:	00 
  80ecfa:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  80ed01:	00 
  ucvector outv;
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;

  ucvector_init(&outv);
  lodepng_info_init(&info);
  80ed02:	48 8d bd 70 fe ff ff 	lea    -0x190(%rbp),%rdi
  80ed09:	48 b8 9d b0 80 00 00 	movabs $0x80b09d,%rax
  80ed10:	00 00 00 
  80ed13:	ff d0                	call   *%rax

  /*provide some proper output values if error will happen*/
  *out = 0;
  80ed15:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
  *outsize = 0;
  80ed1c:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
  state->error = 0;

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
  80ed23:	41 8b bd c8 00 00 00 	mov    0xc8(%r13),%edi
  80ed2a:	83 ff 03             	cmp    $0x3,%edi
  80ed2d:	74 0a                	je     80ed39 <lodepng_encode+0x8d>
  80ed2f:	41 83 bd 80 00 00 00 	cmpl   $0x0,0x80(%r13)
  80ed36:	00 
  80ed37:	74 17                	je     80ed50 <lodepng_encode+0xa4>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
  80ed39:	49 8b 85 d8 00 00 00 	mov    0xd8(%r13),%rax
  80ed40:	48 83 e8 01          	sub    $0x1,%rax
  80ed44:	48 3d ff 00 00 00    	cmp    $0xff,%rax
  80ed4a:	0f 87 f4 00 00 00    	ja     80ee44 <lodepng_encode+0x198>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
    goto cleanup;
  }
  if(state->encoder.zlibsettings.btype > 2) {
  80ed50:	41 83 7d 38 02       	cmpl   $0x2,0x38(%r13)
  80ed55:	0f 87 f6 00 00 00    	ja     80ee51 <lodepng_encode+0x1a5>
    state->error = 61; /*error: nonexistent btype*/
    goto cleanup;
  }
  if(info_png->interlace_method > 1) {
  80ed5b:	41 83 bd c0 00 00 00 	cmpl   $0x1,0xc0(%r13)
  80ed62:	01 
  80ed63:	0f 87 3a 01 00 00    	ja     80eea3 <lodepng_encode+0x1f7>
    state->error = 71; /*error: nonexistent interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  80ed69:	41 8b b5 cc 00 00 00 	mov    0xcc(%r13),%esi
  80ed70:	48 b8 3f 2e 80 00 00 	movabs $0x802e3f,%rax
  80ed77:	00 00 00 
  80ed7a:	ff d0                	call   *%rax
  80ed7c:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
  if(state->error) goto cleanup; /*error: nonexistent color type given*/
  80ed83:	85 c0                	test   %eax,%eax
  80ed85:	0f 85 d1 00 00 00    	jne    80ee5c <lodepng_encode+0x1b0>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  80ed8b:	41 8b b5 94 00 00 00 	mov    0x94(%r13),%esi
  80ed92:	41 8b bd 90 00 00 00 	mov    0x90(%r13),%edi
  80ed99:	48 b8 3f 2e 80 00 00 	movabs $0x802e3f,%rax
  80eda0:	00 00 00 
  80eda3:	ff d0                	call   *%rax
  80eda5:	89 85 b8 f9 ff ff    	mov    %eax,-0x648(%rbp)
  80edab:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
  if(state->error) goto cleanup; /*error: nonexistent color type given*/
  80edb2:	85 c0                	test   %eax,%eax
  80edb4:	0f 85 a2 00 00 00    	jne    80ee5c <lodepng_encode+0x1b0>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
  80edba:	49 8d b5 b8 00 00 00 	lea    0xb8(%r13),%rsi
  80edc1:	48 8d bd 70 fe ff ff 	lea    -0x190(%rbp),%rdi
  80edc8:	48 b8 07 b2 80 00 00 	movabs $0x80b207,%rax
  80edcf:	00 00 00 
  80edd2:	ff d0                	call   *%rax
  if(state->encoder.auto_convert) {
  80edd4:	41 83 7d 68 00       	cmpl   $0x0,0x68(%r13)
  80edd9:	0f 85 d1 00 00 00    	jne    80eeb0 <lodepng_encode+0x204>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
  80eddf:	41 83 bd a0 01 00 00 	cmpl   $0x0,0x1a0(%r13)
  80ede6:	00 
  80ede7:	0f 84 9a 06 00 00    	je     80f487 <lodepng_encode+0x7db>
  if(size < 20) return 0;
  80eded:	41 83 bd b8 01 00 00 	cmpl   $0x13,0x1b8(%r13)
  80edf4:	13 
  80edf5:	0f 86 7c 06 00 00    	jbe    80f477 <lodepng_encode+0x7cb>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
  80edfb:	49 8b 95 b0 01 00 00 	mov    0x1b0(%r13),%rdx
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
  80ee02:	0f b6 42 10          	movzbl 0x10(%rdx),%eax
  80ee06:	3c 47                	cmp    $0x47,%al
  80ee08:	0f 84 09 06 00 00    	je     80f417 <lodepng_encode+0x76b>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
  80ee0e:	3c 52                	cmp    $0x52,%al
  80ee10:	0f 85 54 06 00 00    	jne    80f46a <lodepng_encode+0x7be>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
  80ee16:	8b 85 b8 f9 ff ff    	mov    -0x648(%rbp),%eax
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
  80ee1c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee21:	80 7a 11 47          	cmpb   $0x47,0x11(%rdx)
  80ee25:	0f 85 fc 05 00 00    	jne    80f427 <lodepng_encode+0x77b>
  80ee2b:	80 7a 12 42          	cmpb   $0x42,0x12(%rdx)
  80ee2f:	0f 85 f2 05 00 00    	jne    80f427 <lodepng_encode+0x77b>
  80ee35:	80 7a 13 20          	cmpb   $0x20,0x13(%rdx)
  80ee39:	0f 94 c1             	sete   %cl
  80ee3c:	0f b6 c9             	movzbl %cl,%ecx
  80ee3f:	e9 e3 05 00 00       	jmp    80f427 <lodepng_encode+0x77b>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
  80ee44:	41 c7 85 f0 01 00 00 	movl   $0x44,0x1f0(%r13)
  80ee4b:	44 00 00 00 
    goto cleanup;
  80ee4f:	eb 0b                	jmp    80ee5c <lodepng_encode+0x1b0>
    state->error = 61; /*error: nonexistent btype*/
  80ee51:	41 c7 85 f0 01 00 00 	movl   $0x3d,0x1f0(%r13)
  80ee58:	3d 00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    addChunk_IEND(&outv);
  }

cleanup:
  lodepng_info_cleanup(&info);
  80ee5c:	48 8d bd 70 fe ff ff 	lea    -0x190(%rbp),%rdi
  80ee63:	48 b8 93 b1 80 00 00 	movabs $0x80b193,%rax
  80ee6a:	00 00 00 
  80ee6d:	ff d0                	call   *%rax
    jos_free(ptr);
  80ee6f:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  80ee73:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  80ee7a:	00 00 00 
  80ee7d:	ff d0                	call   *%rax
  lodepng_free(data);

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
  80ee7f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80ee83:	49 89 07             	mov    %rax,(%r15)
  *outsize = outv.size;
  80ee86:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80ee8a:	49 89 06             	mov    %rax,(%r14)

  return state->error;
  80ee8d:	41 8b 85 f0 01 00 00 	mov    0x1f0(%r13),%eax
}
  80ee94:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  80ee98:	5b                   	pop    %rbx
  80ee99:	41 5c                	pop    %r12
  80ee9b:	41 5d                	pop    %r13
  80ee9d:	41 5e                	pop    %r14
  80ee9f:	41 5f                	pop    %r15
  80eea1:	5d                   	pop    %rbp
  80eea2:	c3                   	ret    
    state->error = 71; /*error: nonexistent interlace mode*/
  80eea3:	41 c7 85 f0 01 00 00 	movl   $0x47,0x1f0(%r13)
  80eeaa:	47 00 00 00 
    goto cleanup;
  80eeae:	eb ac                	jmp    80ee5c <lodepng_encode+0x1b0>
    lodepng_color_stats_init(&stats);
  80eeb0:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80eeb7:	48 b8 8b c6 80 00 00 	movabs $0x80c68b,%rax
  80eebe:	00 00 00 
  80eec1:	ff d0                	call   *%rax
    if(info_png->iccp_defined &&
  80eec3:	41 83 bd a0 01 00 00 	cmpl   $0x0,0x1a0(%r13)
  80eeca:	00 
  80eecb:	74 5c                	je     80ef29 <lodepng_encode+0x27d>
  if(size < 20) return 0;
  80eecd:	41 83 bd b8 01 00 00 	cmpl   $0x13,0x1b8(%r13)
  80eed4:	13 
  80eed5:	76 52                	jbe    80ef29 <lodepng_encode+0x27d>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
  80eed7:	49 8b 85 b0 01 00 00 	mov    0x1b0(%r13),%rax
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
  80eede:	80 78 10 47          	cmpb   $0x47,0x10(%rax)
  80eee2:	75 1c                	jne    80ef00 <lodepng_encode+0x254>
  80eee4:	80 78 11 52          	cmpb   $0x52,0x11(%rax)
  80eee8:	75 16                	jne    80ef00 <lodepng_encode+0x254>
  80eeea:	80 78 12 41          	cmpb   $0x41,0x12(%rax)
  80eeee:	75 10                	jne    80ef00 <lodepng_encode+0x254>
  80eef0:	80 78 13 59          	cmpb   $0x59,0x13(%rax)
  80eef4:	75 0a                	jne    80ef00 <lodepng_encode+0x254>
      stats.allow_palette = 0;
  80eef6:	c7 85 68 fe ff ff 00 	movl   $0x0,-0x198(%rbp)
  80eefd:	00 00 00 
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
  80ef00:	49 8b 85 b0 01 00 00 	mov    0x1b0(%r13),%rax
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
  80ef07:	80 78 10 52          	cmpb   $0x52,0x10(%rax)
  80ef0b:	75 1c                	jne    80ef29 <lodepng_encode+0x27d>
  80ef0d:	80 78 11 47          	cmpb   $0x47,0x11(%rax)
  80ef11:	75 16                	jne    80ef29 <lodepng_encode+0x27d>
  80ef13:	80 78 12 42          	cmpb   $0x42,0x12(%rax)
  80ef17:	75 10                	jne    80ef29 <lodepng_encode+0x27d>
  80ef19:	80 78 13 20          	cmpb   $0x20,0x13(%rax)
  80ef1d:	75 0a                	jne    80ef29 <lodepng_encode+0x27d>
      stats.allow_greyscale = 0;
  80ef1f:	c7 85 6c fe ff ff 00 	movl   $0x0,-0x194(%rbp)
  80ef26:	00 00 00 
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
  80ef29:	49 8d 85 90 00 00 00 	lea    0x90(%r13),%rax
  80ef30:	48 89 85 a0 f9 ff ff 	mov    %rax,-0x660(%rbp)
  80ef37:	49 89 c0             	mov    %rax,%r8
  80ef3a:	8b 8d c8 f9 ff ff    	mov    -0x638(%rbp),%ecx
  80ef40:	44 89 e2             	mov    %r12d,%edx
  80ef43:	48 8b b5 c0 f9 ff ff 	mov    -0x640(%rbp),%rsi
  80ef4a:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80ef51:	48 b8 e2 c6 80 00 00 	movabs $0x80c6e2,%rax
  80ef58:	00 00 00 
  80ef5b:	ff d0                	call   *%rax
  80ef5d:	89 85 b0 f9 ff ff    	mov    %eax,-0x650(%rbp)
  80ef63:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
    if(state->error) goto cleanup;
  80ef6a:	85 c0                	test   %eax,%eax
  80ef6c:	0f 85 ea fe ff ff    	jne    80ee5c <lodepng_encode+0x1b0>
    if(info_png->background_defined) {
  80ef72:	41 83 bd f0 00 00 00 	cmpl   $0x0,0xf0(%r13)
  80ef79:	00 
  80ef7a:	0f 84 5c 01 00 00    	je     80f0dc <lodepng_encode+0x430>
      unsigned r = 0, g = 0, b = 0;
  80ef80:	c7 85 dc f9 ff ff 00 	movl   $0x0,-0x624(%rbp)
  80ef87:	00 00 00 
  80ef8a:	c7 85 e0 f9 ff ff 00 	movl   $0x0,-0x620(%rbp)
  80ef91:	00 00 00 
  80ef94:	c7 85 e4 f9 ff ff 00 	movl   $0x0,-0x61c(%rbp)
  80ef9b:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
  80ef9e:	48 8d 9d f0 f9 ff ff 	lea    -0x610(%rbp),%rbx
  80efa5:	ba 10 00 00 00       	mov    $0x10,%edx
  80efaa:	be 02 00 00 00       	mov    $0x2,%esi
  80efaf:	48 89 df             	mov    %rbx,%rdi
  80efb2:	48 b8 3b 91 80 00 00 	movabs $0x80913b,%rax
  80efb9:	00 00 00 
  80efbc:	ff d0                	call   *%rax
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
  80efbe:	41 8b 8d f4 00 00 00 	mov    0xf4(%r13),%ecx
  80efc5:	49 8d 85 c8 00 00 00 	lea    0xc8(%r13),%rax
  80efcc:	50                   	push   %rax
  80efcd:	53                   	push   %rbx
  80efce:	45 8b 8d fc 00 00 00 	mov    0xfc(%r13),%r9d
  80efd5:	45 8b 85 f8 00 00 00 	mov    0xf8(%r13),%r8d
  80efdc:	48 8d 95 e4 f9 ff ff 	lea    -0x61c(%rbp),%rdx
  80efe3:	48 8d b5 e0 f9 ff ff 	lea    -0x620(%rbp),%rsi
  80efea:	48 8d bd dc f9 ff ff 	lea    -0x624(%rbp),%rdi
  80eff1:	48 b8 de c4 80 00 00 	movabs $0x80c4de,%rax
  80eff8:	00 00 00 
  80effb:	ff d0                	call   *%rax
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
  80effd:	8b 9d e4 f9 ff ff    	mov    -0x61c(%rbp),%ebx
  80f003:	8b 85 e0 f9 ff ff    	mov    -0x620(%rbp),%eax
  80f009:	89 85 a8 f9 ff ff    	mov    %eax,-0x658(%rbp)
  80f00f:	8b 8d dc f9 ff ff    	mov    -0x624(%rbp),%ecx
  80f015:	89 8d 98 f9 ff ff    	mov    %ecx,-0x668(%rbp)
  lodepng_color_mode_init(&mode);
  80f01b:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80f022:	48 b8 01 91 80 00 00 	movabs $0x809101,%rax
  80f029:	00 00 00 
  80f02c:	ff d0                	call   *%rax
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
  80f02e:	8b 85 98 f9 ff ff    	mov    -0x668(%rbp),%eax
  80f034:	0f b6 cc             	movzbl %ah,%ecx
  80f037:	88 8d e8 f9 ff ff    	mov    %cl,-0x618(%rbp)
  80f03d:	88 85 e9 f9 ff ff    	mov    %al,-0x617(%rbp)
  80f043:	8b 85 a8 f9 ff ff    	mov    -0x658(%rbp),%eax
  80f049:	0f b6 cc             	movzbl %ah,%ecx
  80f04c:	88 8d ea f9 ff ff    	mov    %cl,-0x616(%rbp)
  80f052:	88 85 eb f9 ff ff    	mov    %al,-0x615(%rbp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
  80f058:	0f b6 c7             	movzbl %bh,%eax
  80f05b:	88 85 ec f9 ff ff    	mov    %al,-0x614(%rbp)
  80f061:	88 9d ed f9 ff ff    	mov    %bl,-0x613(%rbp)
  80f067:	c6 85 ee f9 ff ff ff 	movb   $0xff,-0x612(%rbp)
  80f06e:	c6 85 ef f9 ff ff ff 	movb   $0xff,-0x611(%rbp)
  mode.bitdepth = 16;
  80f075:	c7 85 1c fa ff ff 10 	movl   $0x10,-0x5e4(%rbp)
  80f07c:	00 00 00 
  mode.colortype = LCT_RGBA;
  80f07f:	c7 85 18 fa ff ff 06 	movl   $0x6,-0x5e8(%rbp)
  80f086:	00 00 00 
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
  80f089:	4c 8d 85 18 fa ff ff 	lea    -0x5e8(%rbp),%r8
  80f090:	b9 01 00 00 00       	mov    $0x1,%ecx
  80f095:	ba 01 00 00 00       	mov    $0x1,%edx
  80f09a:	48 8d b5 e8 f9 ff ff 	lea    -0x618(%rbp),%rsi
  80f0a1:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80f0a8:	48 b8 e2 c6 80 00 00 	movabs $0x80c6e2,%rax
  80f0af:	00 00 00 
  80f0b2:	ff d0                	call   *%rax
  80f0b4:	89 c3                	mov    %eax,%ebx
  lodepng_palette_clear(info);
  80f0b6:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80f0bd:	48 b8 9e 91 80 00 00 	movabs $0x80919e,%rax
  80f0c4:	00 00 00 
  80f0c7:	ff d0                	call   *%rax
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
  80f0c9:	41 89 9d f0 01 00 00 	mov    %ebx,0x1f0(%r13)
      if(state->error) goto cleanup;
  80f0d0:	48 83 c4 10          	add    $0x10,%rsp
  80f0d4:	85 db                	test   %ebx,%ebx
  80f0d6:	0f 85 80 fd ff ff    	jne    80ee5c <lodepng_encode+0x1b0>
  size_t numpixels = stats->numpixels;
  80f0dc:	4c 8b 95 60 fe ff ff 	mov    -0x1a0(%rbp),%r10
  unsigned alpha = stats->alpha;
  80f0e3:	44 8b 85 50 fa ff ff 	mov    -0x5b0(%rbp),%r8d
  unsigned key = stats->key;
  80f0ea:	8b bd 44 fa ff ff    	mov    -0x5bc(%rbp),%edi
  unsigned bits = stats->bits;
  80f0f0:	8b 8d 58 fe ff ff    	mov    -0x1a8(%rbp),%ecx
  mode_out->key_defined = 0;
  80f0f6:	c7 85 98 fe ff ff 00 	movl   $0x0,-0x168(%rbp)
  80f0fd:	00 00 00 
  if(key && numpixels <= 16) {
  80f100:	85 ff                	test   %edi,%edi
  80f102:	74 3d                	je     80f141 <lodepng_encode+0x495>
  80f104:	49 83 fa 10          	cmp    $0x10,%r10
  80f108:	77 37                	ja     80f141 <lodepng_encode+0x495>
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
  80f10a:	83 f9 08             	cmp    $0x8,%ecx
  80f10d:	b8 08 00 00 00       	mov    $0x8,%eax
  80f112:	0f 42 c8             	cmovb  %eax,%ecx
  gray_ok = !stats->colored;
  80f115:	8b 85 40 fa ff ff    	mov    -0x5c0(%rbp),%eax
  if(!stats->allow_greyscale) gray_ok = 0;
  80f11b:	8b b5 6c fe ff ff    	mov    -0x194(%rbp),%esi
  80f121:	85 f6                	test   %esi,%esi
  80f123:	0f 84 bc 01 00 00    	je     80f2e5 <lodepng_encode+0x639>
  gray_ok = !stats->colored;
  80f129:	85 c0                	test   %eax,%eax
  80f12b:	40 0f 94 c6          	sete   %sil
  80f12f:	40 0f b6 f6          	movzbl %sil,%esi
    key = 0;
  80f133:	8b bd b0 f9 ff ff    	mov    -0x650(%rbp),%edi
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
  80f139:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80f13f:	eb 29                	jmp    80f16a <lodepng_encode+0x4be>
  gray_ok = !stats->colored;
  80f141:	8b 85 40 fa ff ff    	mov    -0x5c0(%rbp),%eax
  if(!stats->allow_greyscale) gray_ok = 0;
  80f147:	8b b5 6c fe ff ff    	mov    -0x194(%rbp),%esi
  80f14d:	85 f6                	test   %esi,%esi
  80f14f:	74 0a                	je     80f15b <lodepng_encode+0x4af>
  gray_ok = !stats->colored;
  80f151:	85 c0                	test   %eax,%eax
  80f153:	40 0f 94 c6          	sete   %sil
  80f157:	40 0f b6 f6          	movzbl %sil,%esi
  if(!gray_ok && bits < 8) bits = 8;
  80f15b:	85 f6                	test   %esi,%esi
  80f15d:	75 0b                	jne    80f16a <lodepng_encode+0x4be>
  80f15f:	83 f9 07             	cmp    $0x7,%ecx
  80f162:	b8 08 00 00 00       	mov    $0x8,%eax
  80f167:	0f 46 c8             	cmovbe %eax,%ecx
  n = stats->numcolors;
  80f16a:	8b 95 54 fa ff ff    	mov    -0x5ac(%rbp),%edx
  80f170:	89 d0                	mov    %edx,%eax
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
  80f172:	c7 85 a8 f9 ff ff 01 	movl   $0x1,-0x658(%rbp)
  80f179:	00 00 00 
  80f17c:	83 fa 02             	cmp    $0x2,%edx
  80f17f:	76 22                	jbe    80f1a3 <lodepng_encode+0x4f7>
  80f181:	c7 85 a8 f9 ff ff 02 	movl   $0x2,-0x658(%rbp)
  80f188:	00 00 00 
  80f18b:	48 83 f8 04          	cmp    $0x4,%rax
  80f18f:	76 12                	jbe    80f1a3 <lodepng_encode+0x4f7>
  80f191:	48 83 f8 11          	cmp    $0x11,%rax
  80f195:	19 db                	sbb    %ebx,%ebx
  80f197:	83 e3 fc             	and    $0xfffffffc,%ebx
  80f19a:	83 c3 08             	add    $0x8,%ebx
  80f19d:	89 9d a8 f9 ff ff    	mov    %ebx,-0x658(%rbp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
  80f1a3:	48 01 c0             	add    %rax,%rax
  80f1a6:	44 8b 8d b0 f9 ff ff 	mov    -0x650(%rbp),%r9d
  80f1ad:	49 39 c2             	cmp    %rax,%r10
  80f1b0:	72 1a                	jb     80f1cc <lodepng_encode+0x520>
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
  80f1b2:	83 ea 01             	sub    $0x1,%edx
  80f1b5:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  80f1bb:	0f 96 c0             	setbe  %al
  80f1be:	83 f9 08             	cmp    $0x8,%ecx
  80f1c1:	41 0f 96 c1          	setbe  %r9b
  80f1c5:	45 0f b6 c9          	movzbl %r9b,%r9d
  80f1c9:	41 21 c1             	and    %eax,%r9d
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
  80f1cc:	85 f6                	test   %esi,%esi
  80f1ce:	0f 95 c2             	setne  %dl
  80f1d1:	45 85 c0             	test   %r8d,%r8d
  80f1d4:	0f 94 c0             	sete   %al
  80f1d7:	84 c2                	test   %al,%dl
  80f1d9:	74 0c                	je     80f1e7 <lodepng_encode+0x53b>
  80f1db:	3b 8d a8 f9 ff ff    	cmp    -0x658(%rbp),%ecx
  80f1e1:	0f 86 92 13 00 00    	jbe    810579 <lodepng_encode+0x18cd>
  if(palette_ok) {
  80f1e7:	83 bd 68 fe ff ff 00 	cmpl   $0x0,-0x198(%rbp)
  80f1ee:	74 09                	je     80f1f9 <lodepng_encode+0x54d>
  80f1f0:	45 85 c9             	test   %r9d,%r9d
  80f1f3:	0f 85 f9 00 00 00    	jne    80f2f2 <lodepng_encode+0x646>
    mode_out->bitdepth = bits;
  80f1f9:	89 8d 84 fe ff ff    	mov    %ecx,-0x17c(%rbp)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
  80f1ff:	45 85 c0             	test   %r8d,%r8d
  80f202:	0f 84 f9 01 00 00    	je     80f401 <lodepng_encode+0x755>
  80f208:	83 fe 01             	cmp    $0x1,%esi
  80f20b:	19 c0                	sbb    %eax,%eax
  80f20d:	83 e0 02             	and    $0x2,%eax
  80f210:	83 c0 04             	add    $0x4,%eax
  80f213:	89 85 b0 f9 ff ff    	mov    %eax,-0x650(%rbp)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
  80f219:	8b 85 b0 f9 ff ff    	mov    -0x650(%rbp),%eax
  80f21f:	89 85 80 fe ff ff    	mov    %eax,-0x180(%rbp)
    if(key) {
  80f225:	85 ff                	test   %edi,%edi
  80f227:	74 41                	je     80f26a <lodepng_encode+0x5be>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
  80f229:	b8 01 00 00 00       	mov    $0x1,%eax
  80f22e:	d3 e0                	shl    %cl,%eax
  80f230:	83 e8 01             	sub    $0x1,%eax
      mode_out->key_r = stats->key_r & mask;
  80f233:	0f b7 95 48 fa ff ff 	movzwl -0x5b8(%rbp),%edx
  80f23a:	21 c2                	and    %eax,%edx
  80f23c:	89 95 9c fe ff ff    	mov    %edx,-0x164(%rbp)
      mode_out->key_g = stats->key_g & mask;
  80f242:	0f b7 95 4a fa ff ff 	movzwl -0x5b6(%rbp),%edx
  80f249:	21 c2                	and    %eax,%edx
  80f24b:	89 95 a0 fe ff ff    	mov    %edx,-0x160(%rbp)
      mode_out->key_b = stats->key_b & mask;
  80f251:	0f b7 95 4c fa ff ff 	movzwl -0x5b4(%rbp),%edx
  80f258:	21 d0                	and    %edx,%eax
  80f25a:	89 85 a4 fe ff ff    	mov    %eax,-0x15c(%rbp)
      mode_out->key_defined = 1;
  80f260:	c7 85 98 fe ff ff 01 	movl   $0x1,-0x168(%rbp)
  80f267:	00 00 00 
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
  80f26a:	41 c7 85 f0 01 00 00 	movl   $0x0,0x1f0(%r13)
  80f271:	00 00 00 00 
    if(info_png->background_defined) {
  80f275:	41 83 bd f0 00 00 00 	cmpl   $0x0,0xf0(%r13)
  80f27c:	00 
  80f27d:	0f 84 5c fb ff ff    	je     80eddf <lodepng_encode+0x133>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
  80f283:	41 8b 8d f4 00 00 00 	mov    0xf4(%r13),%ecx
  80f28a:	49 8d 85 c8 00 00 00 	lea    0xc8(%r13),%rax
  80f291:	50                   	push   %rax
  80f292:	48 8d 85 80 fe ff ff 	lea    -0x180(%rbp),%rax
  80f299:	50                   	push   %rax
  80f29a:	45 8b 8d fc 00 00 00 	mov    0xfc(%r13),%r9d
  80f2a1:	45 8b 85 f8 00 00 00 	mov    0xf8(%r13),%r8d
  80f2a8:	48 8d 95 b4 fe ff ff 	lea    -0x14c(%rbp),%rdx
  80f2af:	48 8d b5 b0 fe ff ff 	lea    -0x150(%rbp),%rsi
  80f2b6:	48 8d bd ac fe ff ff 	lea    -0x154(%rbp),%rdi
  80f2bd:	48 b8 de c4 80 00 00 	movabs $0x80c4de,%rax
  80f2c4:	00 00 00 
  80f2c7:	ff d0                	call   *%rax
  80f2c9:	48 83 c4 10          	add    $0x10,%rsp
  80f2cd:	85 c0                	test   %eax,%eax
  80f2cf:	0f 84 0a fb ff ff    	je     80eddf <lodepng_encode+0x133>
        state->error = 104;
  80f2d5:	41 c7 85 f0 01 00 00 	movl   $0x68,0x1f0(%r13)
  80f2dc:	68 00 00 00 
        goto cleanup;
  80f2e0:	e9 77 fb ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
    key = 0;
  80f2e5:	89 f7                	mov    %esi,%edi
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
  80f2e7:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80f2ed:	e9 78 fe ff ff       	jmp    80f16a <lodepng_encode+0x4be>
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
  80f2f2:	48 8d bd 80 fe ff ff 	lea    -0x180(%rbp),%rdi
  80f2f9:	48 b8 9e 91 80 00 00 	movabs $0x80919e,%rax
  80f300:	00 00 00 
  80f303:	ff d0                	call   *%rax
    for(i = 0; i != stats->numcolors; ++i) {
  80f305:	83 bd 54 fa ff ff 00 	cmpl   $0x0,-0x5ac(%rbp)
  80f30c:	74 5b                	je     80f369 <lodepng_encode+0x6bd>
  80f30e:	48 8d 9d 58 fa ff ff 	lea    -0x5a8(%rbp),%rbx
  80f315:	b8 00 00 00 00       	mov    $0x0,%eax
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
  80f31a:	4c 89 bd 98 f9 ff ff 	mov    %r15,-0x668(%rbp)
  80f321:	49 89 c7             	mov    %rax,%r15
  80f324:	0f b6 4b 02          	movzbl 0x2(%rbx),%ecx
  80f328:	0f b6 53 01          	movzbl 0x1(%rbx),%edx
  80f32c:	0f b6 33             	movzbl (%rbx),%esi
  80f32f:	44 0f b6 43 03       	movzbl 0x3(%rbx),%r8d
  80f334:	48 8d bd 80 fe ff ff 	lea    -0x180(%rbp),%rdi
  80f33b:	48 b8 75 92 80 00 00 	movabs $0x809275,%rax
  80f342:	00 00 00 
  80f345:	ff d0                	call   *%rax
      if(error) break;
  80f347:	85 c0                	test   %eax,%eax
  80f349:	0f 85 96 0e 00 00    	jne    8101e5 <lodepng_encode+0x1539>
    for(i = 0; i != stats->numcolors; ++i) {
  80f34f:	49 83 c7 01          	add    $0x1,%r15
  80f353:	48 83 c3 04          	add    $0x4,%rbx
  80f357:	8b 85 54 fa ff ff    	mov    -0x5ac(%rbp),%eax
  80f35d:	49 39 c7             	cmp    %rax,%r15
  80f360:	75 c2                	jne    80f324 <lodepng_encode+0x678>
  80f362:	4c 8b bd 98 f9 ff ff 	mov    -0x668(%rbp),%r15
    mode_out->colortype = LCT_PALETTE;
  80f369:	c7 85 80 fe ff ff 03 	movl   $0x3,-0x180(%rbp)
  80f370:	00 00 00 
    mode_out->bitdepth = palettebits;
  80f373:	8b 85 a8 f9 ff ff    	mov    -0x658(%rbp),%eax
  80f379:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%rbp)
    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
  80f37f:	41 83 bd 90 00 00 00 	cmpl   $0x3,0x90(%r13)
  80f386:	03 
  80f387:	0f 85 8f 0e 00 00    	jne    81021c <lodepng_encode+0x1570>
  80f38d:	48 8b 85 90 fe ff ff 	mov    -0x170(%rbp),%rax
  80f394:	49 39 85 a0 00 00 00 	cmp    %rax,0xa0(%r13)
  80f39b:	0f 82 e3 11 00 00    	jb     810584 <lodepng_encode+0x18d8>
        && mode_in->bitdepth == mode_out->bitdepth) {
  80f3a1:	8b 85 a8 f9 ff ff    	mov    -0x658(%rbp),%eax
  80f3a7:	41 3b 85 94 00 00 00 	cmp    0x94(%r13),%eax
  80f3ae:	74 22                	je     80f3d2 <lodepng_encode+0x726>
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
  80f3b0:	8b 85 b0 f9 ff ff    	mov    -0x650(%rbp),%eax
  80f3b6:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
    if(state->error) goto cleanup;
  80f3bd:	85 c0                	test   %eax,%eax
  80f3bf:	0f 85 97 fa ff ff    	jne    80ee5c <lodepng_encode+0x1b0>
  80f3c5:	e9 ab fe ff ff       	jmp    80f275 <lodepng_encode+0x5c9>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
  80f3ca:	89 85 b0 f9 ff ff    	mov    %eax,-0x650(%rbp)
  80f3d0:	eb cf                	jmp    80f3a1 <lodepng_encode+0x6f5>
  lodepng_palette_clear(info);
  80f3d2:	48 8d bd 80 fe ff ff 	lea    -0x180(%rbp),%rdi
  80f3d9:	48 b8 9e 91 80 00 00 	movabs $0x80919e,%rax
  80f3e0:	00 00 00 
  80f3e3:	ff d0                	call   *%rax
      lodepng_color_mode_copy(mode_out, mode_in);
  80f3e5:	48 8b b5 a0 f9 ff ff 	mov    -0x660(%rbp),%rsi
  80f3ec:	48 8d bd 80 fe ff ff 	lea    -0x180(%rbp),%rdi
  80f3f3:	48 b8 e7 91 80 00 00 	movabs $0x8091e7,%rax
  80f3fa:	00 00 00 
  80f3fd:	ff d0                	call   *%rax
  80f3ff:	eb af                	jmp    80f3b0 <lodepng_encode+0x704>
                                : (gray_ok ? LCT_GREY : LCT_RGB);
  80f401:	85 f6                	test   %esi,%esi
  80f403:	b8 02 00 00 00       	mov    $0x2,%eax
  80f408:	41 0f 45 c0          	cmovne %r8d,%eax
  80f40c:	89 85 b0 f9 ff ff    	mov    %eax,-0x650(%rbp)
  80f412:	e9 02 fe ff ff       	jmp    80f219 <lodepng_encode+0x56d>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
  80f417:	b8 00 00 00 00       	mov    $0x0,%eax
  80f41c:	80 7a 11 52          	cmpb   $0x52,0x11(%rdx)
  80f420:	74 36                	je     80f458 <lodepng_encode+0x7ac>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
  80f422:	b9 00 00 00 00       	mov    $0x0,%ecx
    if(!gray_icc && !rgb_icc) {
  80f427:	09 c1                	or     %eax,%ecx
  80f429:	74 4c                	je     80f477 <lodepng_encode+0x7cb>
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
  80f42b:	f7 85 80 fe ff ff fb 	testl  $0xfffffffb,-0x180(%rbp)
  80f432:	ff ff ff 
  80f435:	0f 94 c2             	sete   %dl
  80f438:	0f b6 d2             	movzbl %dl,%edx
    if(gray_icc != gray_png) {
  80f43b:	39 c2                	cmp    %eax,%edx
  80f43d:	74 48                	je     80f487 <lodepng_encode+0x7db>
      state->error = state->encoder.auto_convert ? 102 : 101;
  80f43f:	41 83 7d 68 01       	cmpl   $0x1,0x68(%r13)
  80f444:	b8 65 00 00 00       	mov    $0x65,%eax
  80f449:	83 d8 ff             	sbb    $0xffffffff,%eax
  80f44c:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      goto cleanup;
  80f453:	e9 04 fa ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
  80f458:	80 7a 12 41          	cmpb   $0x41,0x12(%rdx)
  80f45c:	75 c4                	jne    80f422 <lodepng_encode+0x776>
  80f45e:	80 7a 13 59          	cmpb   $0x59,0x13(%rdx)
  80f462:	0f 94 c0             	sete   %al
  80f465:	0f b6 c0             	movzbl %al,%eax
  80f468:	eb b8                	jmp    80f422 <lodepng_encode+0x776>
  80f46a:	8b 85 b8 f9 ff ff    	mov    -0x648(%rbp),%eax
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
  80f470:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f475:	eb b0                	jmp    80f427 <lodepng_encode+0x77b>
      state->error = 100; /* Disallowed profile color type for PNG */
  80f477:	41 c7 85 f0 01 00 00 	movl   $0x64,0x1f0(%r13)
  80f47e:	64 00 00 00 
      goto cleanup;
  80f482:	e9 d5 f9 ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
  80f487:	49 8d 85 90 00 00 00 	lea    0x90(%r13),%rax
  80f48e:	48 89 85 b0 f9 ff ff 	mov    %rax,-0x650(%rbp)
  80f495:	48 8d b5 80 fe ff ff 	lea    -0x180(%rbp),%rsi
  80f49c:	48 89 c7             	mov    %rax,%rdi
  80f49f:	48 b8 fc 2e 80 00 00 	movabs $0x802efc,%rax
  80f4a6:	00 00 00 
  80f4a9:	ff d0                	call   *%rax
  80f4ab:	85 c0                	test   %eax,%eax
  80f4ad:	0f 85 04 01 00 00    	jne    80f5b7 <lodepng_encode+0x90b>
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
  80f4b3:	44 89 e3             	mov    %r12d,%ebx
  80f4b6:	8b 85 c8 f9 ff ff    	mov    -0x638(%rbp),%eax
  80f4bc:	48 0f af d8          	imul   %rax,%rbx
  80f4c0:	48 8d bd 80 fe ff ff 	lea    -0x180(%rbp),%rdi
  80f4c7:	48 b8 10 93 80 00 00 	movabs $0x809310,%rax
  80f4ce:	00 00 00 
  80f4d1:	ff d0                	call   *%rax
  80f4d3:	89 c0                	mov    %eax,%eax
  80f4d5:	48 0f af d8          	imul   %rax,%rbx
  80f4d9:	48 83 c3 07          	add    $0x7,%rbx
  80f4dd:	48 89 df             	mov    %rbx,%rdi
  80f4e0:	48 c1 ef 03          	shr    $0x3,%rdi
  return jos_malloc(size);
  80f4e4:	48 b8 f8 0d 81 00 00 	movabs $0x810df8,%rax
  80f4eb:	00 00 00 
  80f4ee:	ff d0                	call   *%rax
  80f4f0:	48 89 85 a8 f9 ff ff 	mov    %rax,-0x658(%rbp)
    if(!converted && size) state->error = 83; /*alloc fail*/
  80f4f7:	48 85 c0             	test   %rax,%rax
  80f4fa:	75 37                	jne    80f533 <lodepng_encode+0x887>
  80f4fc:	48 83 fb 07          	cmp    $0x7,%rbx
  80f500:	76 31                	jbe    80f533 <lodepng_encode+0x887>
  80f502:	41 c7 85 f0 01 00 00 	movl   $0x53,0x1f0(%r13)
  80f509:	53 00 00 00 
    jos_free(ptr);
  80f50d:	48 8b bd a8 f9 ff ff 	mov    -0x658(%rbp),%rdi
  80f514:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  80f51b:	00 00 00 
  80f51e:	ff d0                	call   *%rax
    if(state->error) goto cleanup;
  80f520:	41 83 bd f0 01 00 00 	cmpl   $0x0,0x1f0(%r13)
  80f527:	00 
  80f528:	0f 84 c2 00 00 00    	je     80f5f0 <lodepng_encode+0x944>
  80f52e:	e9 29 f9 ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
    if(!state->error) {
  80f533:	41 83 bd f0 01 00 00 	cmpl   $0x0,0x1f0(%r13)
  80f53a:	00 
  80f53b:	75 d0                	jne    80f50d <lodepng_encode+0x861>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
  80f53d:	44 8b 8d c8 f9 ff ff 	mov    -0x638(%rbp),%r9d
  80f544:	45 89 e0             	mov    %r12d,%r8d
  80f547:	48 8b 8d b0 f9 ff ff 	mov    -0x650(%rbp),%rcx
  80f54e:	48 8d 95 80 fe ff ff 	lea    -0x180(%rbp),%rdx
  80f555:	48 8b b5 c0 f9 ff ff 	mov    -0x640(%rbp),%rsi
  80f55c:	48 8b 9d a8 f9 ff ff 	mov    -0x658(%rbp),%rbx
  80f563:	48 89 df             	mov    %rbx,%rdi
  80f566:	48 b8 6b b4 80 00 00 	movabs $0x80b46b,%rax
  80f56d:	00 00 00 
  80f570:	ff d0                	call   *%rax
  80f572:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
    if(!state->error) preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
  80f579:	85 c0                	test   %eax,%eax
  80f57b:	75 90                	jne    80f50d <lodepng_encode+0x861>
  80f57d:	48 83 ec 08          	sub    $0x8,%rsp
  80f581:	49 8d 45 38          	lea    0x38(%r13),%rax
  80f585:	50                   	push   %rax
  80f586:	4c 8d 8d 70 fe ff ff 	lea    -0x190(%rbp),%r9
  80f58d:	44 8b 85 c8 f9 ff ff 	mov    -0x638(%rbp),%r8d
  80f594:	44 89 e1             	mov    %r12d,%ecx
  80f597:	48 89 da             	mov    %rbx,%rdx
  80f59a:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  80f59e:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80f5a2:	48 b8 24 9d 80 00 00 	movabs $0x809d24,%rax
  80f5a9:	00 00 00 
  80f5ac:	ff d0                	call   *%rax
  80f5ae:	48 83 c4 10          	add    $0x10,%rsp
  80f5b2:	e9 56 ff ff ff       	jmp    80f50d <lodepng_encode+0x861>
  else preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
  80f5b7:	48 83 ec 08          	sub    $0x8,%rsp
  80f5bb:	49 8d 45 38          	lea    0x38(%r13),%rax
  80f5bf:	50                   	push   %rax
  80f5c0:	4c 8d 8d 70 fe ff ff 	lea    -0x190(%rbp),%r9
  80f5c7:	44 8b 85 c8 f9 ff ff 	mov    -0x638(%rbp),%r8d
  80f5ce:	44 89 e1             	mov    %r12d,%ecx
  80f5d1:	48 8b 95 c0 f9 ff ff 	mov    -0x640(%rbp),%rdx
  80f5d8:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  80f5dc:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80f5e0:	48 b8 24 9d 80 00 00 	movabs $0x809d24,%rax
  80f5e7:	00 00 00 
  80f5ea:	ff d0                	call   *%rax
  80f5ec:	48 83 c4 10          	add    $0x10,%rsp
  ucvector_push_back(out, 137);
  80f5f0:	be 89 00 00 00       	mov    $0x89,%esi
  80f5f5:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f5f9:	48 bb 78 46 80 00 00 	movabs $0x804678,%rbx
  80f600:	00 00 00 
  80f603:	ff d3                	call   *%rbx
  ucvector_push_back(out, 80);
  80f605:	be 50 00 00 00       	mov    $0x50,%esi
  80f60a:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f60e:	ff d3                	call   *%rbx
  ucvector_push_back(out, 78);
  80f610:	be 4e 00 00 00       	mov    $0x4e,%esi
  80f615:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f619:	ff d3                	call   *%rbx
  ucvector_push_back(out, 71);
  80f61b:	be 47 00 00 00       	mov    $0x47,%esi
  80f620:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f624:	ff d3                	call   *%rbx
  ucvector_push_back(out, 13);
  80f626:	be 0d 00 00 00       	mov    $0xd,%esi
  80f62b:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f62f:	ff d3                	call   *%rbx
  ucvector_push_back(out, 10);
  80f631:	be 0a 00 00 00       	mov    $0xa,%esi
  80f636:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f63a:	ff d3                	call   *%rbx
  ucvector_push_back(out, 26);
  80f63c:	be 1a 00 00 00       	mov    $0x1a,%esi
  80f641:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f645:	ff d3                	call   *%rbx
  ucvector_push_back(out, 10);
  80f647:	be 0a 00 00 00       	mov    $0xa,%esi
  80f64c:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f650:	ff d3                	call   *%rbx
    addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
  80f652:	8b 85 78 fe ff ff    	mov    -0x188(%rbp),%eax
  80f658:	89 85 c0 f9 ff ff    	mov    %eax,-0x640(%rbp)
  80f65e:	8b 8d 84 fe ff ff    	mov    -0x17c(%rbp),%ecx
  80f664:	89 8d b0 f9 ff ff    	mov    %ecx,-0x650(%rbp)
  80f66a:	8b 95 80 fe ff ff    	mov    -0x180(%rbp),%edx
  80f670:	89 95 a8 f9 ff ff    	mov    %edx,-0x658(%rbp)
  lodepng_set32bitInt(data + 0, w); /*width*/
  80f676:	44 89 e6             	mov    %r12d,%esi
  80f679:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80f680:	48 bb 0c 29 80 00 00 	movabs $0x80290c,%rbx
  80f687:	00 00 00 
  80f68a:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 4, h); /*height*/
  80f68c:	8b b5 c8 f9 ff ff    	mov    -0x638(%rbp),%esi
  80f692:	48 8d bd 44 fa ff ff 	lea    -0x5bc(%rbp),%rdi
  80f699:	ff d3                	call   *%rbx
  data[8] = (unsigned char)bitdepth; /*bit depth*/
  80f69b:	0f b6 8d b0 f9 ff ff 	movzbl -0x650(%rbp),%ecx
  80f6a2:	88 8d 48 fa ff ff    	mov    %cl,-0x5b8(%rbp)
  data[9] = (unsigned char)colortype; /*color type*/
  80f6a8:	0f b6 8d a8 f9 ff ff 	movzbl -0x658(%rbp),%ecx
  80f6af:	88 8d 49 fa ff ff    	mov    %cl,-0x5b7(%rbp)
  data[10] = 0; /*compression method*/
  80f6b5:	c6 85 4a fa ff ff 00 	movb   $0x0,-0x5b6(%rbp)
  data[11] = 0; /*filter method*/
  80f6bc:	c6 85 4b fa ff ff 00 	movb   $0x0,-0x5b5(%rbp)
  data[12] = interlace_method; /*interlace method*/
  80f6c3:	0f b6 85 c0 f9 ff ff 	movzbl -0x640(%rbp),%eax
  80f6ca:	88 85 4c fa ff ff    	mov    %al,-0x5b4(%rbp)
  return addChunk(out, "IHDR", data, sizeof(data));
  80f6d0:	b9 0d 00 00 00       	mov    $0xd,%ecx
  80f6d5:	48 8d 95 40 fa ff ff 	lea    -0x5c0(%rbp),%rdx
  80f6dc:	48 be a9 26 81 00 00 	movabs $0x8126a9,%rsi
  80f6e3:	00 00 00 
  80f6e6:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f6ea:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80f6f1:	00 00 00 
  80f6f4:	ff d0                	call   *%rax
    if(info.unknown_chunks_data[0]) {
  80f6f6:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  80f6fd:	48 85 f6             	test   %rsi,%rsi
  80f700:	74 23                	je     80f725 <lodepng_encode+0xa79>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
  80f702:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80f706:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f70a:	48 b8 10 8c 80 00 00 	movabs $0x808c10,%rax
  80f711:	00 00 00 
  80f714:	ff d0                	call   *%rax
  80f716:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) goto cleanup;
  80f71d:	85 c0                	test   %eax,%eax
  80f71f:	0f 85 37 f7 ff ff    	jne    80ee5c <lodepng_encode+0x1b0>
    if(info.iccp_defined) addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
  80f725:	83 bd 58 ff ff ff 00 	cmpl   $0x0,-0xa8(%rbp)
  80f72c:	0f 85 1b 01 00 00    	jne    80f84d <lodepng_encode+0xba1>
    if(info.srgb_defined) addChunk_sRGB(&outv, &info);
  80f732:	83 bd 50 ff ff ff 00 	cmpl   $0x0,-0xb0(%rbp)
  80f739:	0f 85 77 02 00 00    	jne    80f9b6 <lodepng_encode+0xd0a>
    if(info.gama_defined) addChunk_gAMA(&outv, &info);
  80f73f:	83 bd 24 ff ff ff 00 	cmpl   $0x0,-0xdc(%rbp)
  80f746:	0f 85 a1 02 00 00    	jne    80f9ed <lodepng_encode+0xd41>
    if(info.chrm_defined) addChunk_cHRM(&outv, &info);
  80f74c:	83 bd 2c ff ff ff 00 	cmpl   $0x0,-0xd4(%rbp)
  80f753:	0f 85 d8 02 00 00    	jne    80fa31 <lodepng_encode+0xd85>
    if(info.color.colortype == LCT_PALETTE) {
  80f759:	83 bd 80 fe ff ff 03 	cmpl   $0x3,-0x180(%rbp)
  80f760:	0f 84 78 03 00 00    	je     80fade <lodepng_encode+0xe32>
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
  80f766:	41 83 bd 80 00 00 00 	cmpl   $0x0,0x80(%r13)
  80f76d:	00 
  80f76e:	0f 85 99 0d 00 00    	jne    81050d <lodepng_encode+0x1861>
    if((info.color.colortype == LCT_GREY || info.color.colortype == LCT_RGB) && info.color.key_defined) {
  80f774:	f7 85 80 fe ff ff fd 	testl  $0xfffffffd,-0x180(%rbp)
  80f77b:	ff ff ff 
  80f77e:	75 0d                	jne    80f78d <lodepng_encode+0xae1>
  80f780:	83 bd 98 fe ff ff 00 	cmpl   $0x0,-0x168(%rbp)
  80f787:	0f 85 6a 04 00 00    	jne    80fbf7 <lodepng_encode+0xf4b>
    if(info.background_defined) {
  80f78d:	83 bd a8 fe ff ff 00 	cmpl   $0x0,-0x158(%rbp)
  80f794:	0f 85 79 04 00 00    	jne    80fc13 <lodepng_encode+0xf67>
    if(info.phys_defined) addChunk_pHYs(&outv, &info);
  80f79a:	83 bd 14 ff ff ff 00 	cmpl   $0x0,-0xec(%rbp)
  80f7a1:	0f 85 e9 04 00 00    	jne    80fc90 <lodepng_encode+0xfe4>
    if(info.unknown_chunks_data[1]) {
  80f7a7:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  80f7ab:	48 85 f6             	test   %rsi,%rsi
  80f7ae:	74 23                	je     80f7d3 <lodepng_encode+0xb27>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
  80f7b0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80f7b4:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f7b8:	48 b8 10 8c 80 00 00 	movabs $0x808c10,%rax
  80f7bf:	00 00 00 
  80f7c2:	ff d0                	call   *%rax
  80f7c4:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) goto cleanup;
  80f7cb:	85 c0                	test   %eax,%eax
  80f7cd:	0f 85 89 f6 ff ff    	jne    80ee5c <lodepng_encode+0x1b0>
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
  80f7d3:	49 8d 45 38          	lea    0x38(%r13),%rax
  80f7d7:	48 89 85 c0 f9 ff ff 	mov    %rax,-0x640(%rbp)
  p->data = NULL;
  80f7de:	48 c7 85 40 fa ff ff 	movq   $0x0,-0x5c0(%rbp)
  80f7e5:	00 00 00 00 
  p->size = p->allocsize = 0;
  80f7e9:	48 c7 85 50 fa ff ff 	movq   $0x0,-0x5b0(%rbp)
  80f7f0:	00 00 00 00 
  80f7f4:	48 c7 85 48 fa ff ff 	movq   $0x0,-0x5b8(%rbp)
  80f7fb:	00 00 00 00 
  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);
  80f7ff:	49 89 c0             	mov    %rax,%r8
  80f802:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80f806:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80f80a:	48 8d b5 48 fa ff ff 	lea    -0x5b8(%rbp),%rsi
  80f811:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80f818:	48 b8 2a 87 80 00 00 	movabs $0x80872a,%rax
  80f81f:	00 00 00 
  80f822:	ff d0                	call   *%rax
  80f824:	89 c3                	mov    %eax,%ebx
  if(!error) error = addChunk(out, "IDAT", zlibdata.data, zlibdata.size);
  80f826:	85 c0                	test   %eax,%eax
  80f828:	0f 84 c1 04 00 00    	je     80fcef <lodepng_encode+0x1043>
  ucvector_cleanup(&zlibdata);
  80f82e:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80f835:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  80f83c:	00 00 00 
  80f83f:	ff d0                	call   *%rax
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
  80f841:	41 89 9d f0 01 00 00 	mov    %ebx,0x1f0(%r13)
    if(state->error) goto cleanup;
  80f848:	e9 0f f6 ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
  p->data = NULL;
  80f84d:	48 c7 85 18 fa ff ff 	movq   $0x0,-0x5e8(%rbp)
  80f854:	00 00 00 00 
  p->size = p->allocsize = 0;
  80f858:	48 c7 85 28 fa ff ff 	movq   $0x0,-0x5d8(%rbp)
  80f85f:	00 00 00 00 
  80f863:	48 c7 85 20 fa ff ff 	movq   $0x0,-0x5e0(%rbp)
  80f86a:	00 00 00 00 
  p->data = NULL;
  80f86e:	48 c7 85 40 fa ff ff 	movq   $0x0,-0x5c0(%rbp)
  80f875:	00 00 00 00 
  p->size = p->allocsize = 0;
  80f879:	48 c7 85 50 fa ff ff 	movq   $0x0,-0x5b0(%rbp)
  80f880:	00 00 00 00 
  80f884:	48 c7 85 48 fa ff ff 	movq   $0x0,-0x5b8(%rbp)
  80f88b:	00 00 00 00 
  for(i = 0; info->iccp_name[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)info->iccp_name[i]);
  80f88f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80f896:	0f b6 00             	movzbl (%rax),%eax
  80f899:	84 c0                	test   %al,%al
  80f89b:	0f 84 91 fe ff ff    	je     80f732 <lodepng_encode+0xa86>
  80f8a1:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f8a6:	49 bc 78 46 80 00 00 	movabs $0x804678,%r12
  80f8ad:	00 00 00 
  80f8b0:	0f b6 f0             	movzbl %al,%esi
  80f8b3:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80f8ba:	41 ff d4             	call   *%r12
  80f8bd:	48 89 da             	mov    %rbx,%rdx
  80f8c0:	48 83 c3 01          	add    $0x1,%rbx
  80f8c4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80f8cb:	0f b6 04 18          	movzbl (%rax,%rbx,1),%eax
  80f8cf:	84 c0                	test   %al,%al
  80f8d1:	75 dd                	jne    80f8b0 <lodepng_encode+0xc04>
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  80f8d3:	48 83 fa 4e          	cmp    $0x4e,%rdx
  80f8d7:	0f 87 55 fe ff ff    	ja     80f732 <lodepng_encode+0xa86>
  ucvector_push_back(&data, 0); /*0 termination char*/
  80f8dd:	be 00 00 00 00       	mov    $0x0,%esi
  80f8e2:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80f8e9:	48 bb 78 46 80 00 00 	movabs $0x804678,%rbx
  80f8f0:	00 00 00 
  80f8f3:	ff d3                	call   *%rbx
  ucvector_push_back(&data, 0); /*compression method: 0*/
  80f8f5:	be 00 00 00 00       	mov    $0x0,%esi
  80f8fa:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80f901:	ff d3                	call   *%rbx
  error = zlib_compress(&compressed.data, &compressed.size,
  80f903:	8b 8d 70 ff ff ff    	mov    -0x90(%rbp),%ecx
  80f909:	4d 8d 45 38          	lea    0x38(%r13),%r8
  80f90d:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  80f914:	48 8d b5 48 fa ff ff 	lea    -0x5b8(%rbp),%rsi
  80f91b:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80f922:	48 b8 2a 87 80 00 00 	movabs $0x80872a,%rax
  80f929:	00 00 00 
  80f92c:	ff d0                	call   *%rax
  if(!error) {
  80f92e:	85 c0                	test   %eax,%eax
  80f930:	75 63                	jne    80f995 <lodepng_encode+0xce9>
    for(i = 0; i != compressed.size; ++i) ucvector_push_back(&data, compressed.data[i]);
  80f932:	48 83 bd 48 fa ff ff 	cmpq   $0x0,-0x5b8(%rbp)
  80f939:	00 
  80f93a:	74 31                	je     80f96d <lodepng_encode+0xcc1>
  80f93c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f941:	49 bc 78 46 80 00 00 	movabs $0x804678,%r12
  80f948:	00 00 00 
  80f94b:	48 8b 85 40 fa ff ff 	mov    -0x5c0(%rbp),%rax
  80f952:	0f b6 34 18          	movzbl (%rax,%rbx,1),%esi
  80f956:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80f95d:	41 ff d4             	call   *%r12
  80f960:	48 83 c3 01          	add    $0x1,%rbx
  80f964:	48 3b 9d 48 fa ff ff 	cmp    -0x5b8(%rbp),%rbx
  80f96b:	75 de                	jne    80f94b <lodepng_encode+0xc9f>
    error = addChunk(out, "iCCP", data.data, data.size);
  80f96d:	48 8b 8d 20 fa ff ff 	mov    -0x5e0(%rbp),%rcx
  80f974:	48 8b 95 18 fa ff ff 	mov    -0x5e8(%rbp),%rdx
  80f97b:	48 be d6 26 81 00 00 	movabs $0x8126d6,%rsi
  80f982:	00 00 00 
  80f985:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f989:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80f990:	00 00 00 
  80f993:	ff d0                	call   *%rax
  ucvector_cleanup(&compressed);
  80f995:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80f99c:	48 bb 3d 50 80 00 00 	movabs $0x80503d,%rbx
  80f9a3:	00 00 00 
  80f9a6:	ff d3                	call   *%rbx
  ucvector_cleanup(&data);
  80f9a8:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80f9af:	ff d3                	call   *%rbx
  return error;
  80f9b1:	e9 7c fd ff ff       	jmp    80f732 <lodepng_encode+0xa86>
  unsigned char data = info->srgb_intent;
  80f9b6:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
  80f9bc:	88 85 40 fa ff ff    	mov    %al,-0x5c0(%rbp)
  return addChunk(out, "sRGB", &data, 1);
  80f9c2:	b9 01 00 00 00       	mov    $0x1,%ecx
  80f9c7:	48 8d 95 40 fa ff ff 	lea    -0x5c0(%rbp),%rdx
  80f9ce:	48 be d1 26 81 00 00 	movabs $0x8126d1,%rsi
  80f9d5:	00 00 00 
  80f9d8:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80f9dc:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80f9e3:	00 00 00 
  80f9e6:	ff d0                	call   *%rax
  80f9e8:	e9 52 fd ff ff       	jmp    80f73f <lodepng_encode+0xa93>
  lodepng_set32bitInt(data, info->gama_gamma);
  80f9ed:	8b b5 28 ff ff ff    	mov    -0xd8(%rbp),%esi
  80f9f3:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80f9fa:	48 b8 0c 29 80 00 00 	movabs $0x80290c,%rax
  80fa01:	00 00 00 
  80fa04:	ff d0                	call   *%rax
  return addChunk(out, "gAMA", data, sizeof(data));
  80fa06:	b9 04 00 00 00       	mov    $0x4,%ecx
  80fa0b:	48 8d 95 40 fa ff ff 	lea    -0x5c0(%rbp),%rdx
  80fa12:	48 be c7 26 81 00 00 	movabs $0x8126c7,%rsi
  80fa19:	00 00 00 
  80fa1c:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fa20:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80fa27:	00 00 00 
  80fa2a:	ff d0                	call   *%rax
  80fa2c:	e9 1b fd ff ff       	jmp    80f74c <lodepng_encode+0xaa0>
  lodepng_set32bitInt(data + 0, info->chrm_white_x);
  80fa31:	8b b5 30 ff ff ff    	mov    -0xd0(%rbp),%esi
  80fa37:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80fa3e:	48 bb 0c 29 80 00 00 	movabs $0x80290c,%rbx
  80fa45:	00 00 00 
  80fa48:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 4, info->chrm_white_y);
  80fa4a:	8b b5 34 ff ff ff    	mov    -0xcc(%rbp),%esi
  80fa50:	48 8d bd 44 fa ff ff 	lea    -0x5bc(%rbp),%rdi
  80fa57:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 8, info->chrm_red_x);
  80fa59:	8b b5 38 ff ff ff    	mov    -0xc8(%rbp),%esi
  80fa5f:	48 8d bd 48 fa ff ff 	lea    -0x5b8(%rbp),%rdi
  80fa66:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 12, info->chrm_red_y);
  80fa68:	8b b5 3c ff ff ff    	mov    -0xc4(%rbp),%esi
  80fa6e:	48 8d bd 4c fa ff ff 	lea    -0x5b4(%rbp),%rdi
  80fa75:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 16, info->chrm_green_x);
  80fa77:	8b b5 40 ff ff ff    	mov    -0xc0(%rbp),%esi
  80fa7d:	48 8d bd 50 fa ff ff 	lea    -0x5b0(%rbp),%rdi
  80fa84:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 20, info->chrm_green_y);
  80fa86:	8b b5 44 ff ff ff    	mov    -0xbc(%rbp),%esi
  80fa8c:	48 8d bd 54 fa ff ff 	lea    -0x5ac(%rbp),%rdi
  80fa93:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 24, info->chrm_blue_x);
  80fa95:	8b b5 48 ff ff ff    	mov    -0xb8(%rbp),%esi
  80fa9b:	48 8d bd 58 fa ff ff 	lea    -0x5a8(%rbp),%rdi
  80faa2:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 28, info->chrm_blue_y);
  80faa4:	8b b5 4c ff ff ff    	mov    -0xb4(%rbp),%esi
  80faaa:	48 8d bd 5c fa ff ff 	lea    -0x5a4(%rbp),%rdi
  80fab1:	ff d3                	call   *%rbx
  return addChunk(out, "cHRM", data, sizeof(data));
  80fab3:	b9 20 00 00 00       	mov    $0x20,%ecx
  80fab8:	48 8d 95 40 fa ff ff 	lea    -0x5c0(%rbp),%rdx
  80fabf:	48 be cc 26 81 00 00 	movabs $0x8126cc,%rsi
  80fac6:	00 00 00 
  80fac9:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80facd:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80fad4:	00 00 00 
  80fad7:	ff d0                	call   *%rax
  80fad9:	e9 7b fc ff ff       	jmp    80f759 <lodepng_encode+0xaad>
      addChunk_PLTE(&outv, &info.color);
  80fade:	48 8d b5 80 fe ff ff 	lea    -0x180(%rbp),%rsi
  80fae5:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fae9:	48 b8 e7 8d 80 00 00 	movabs $0x808de7,%rax
  80faf0:	00 00 00 
  80faf3:	ff d0                	call   *%rax
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
  80faf5:	41 83 bd 80 00 00 00 	cmpl   $0x0,0x80(%r13)
  80fafc:	00 
  80fafd:	0f 84 33 0a 00 00    	je     810536 <lodepng_encode+0x188a>
  80fb03:	8b 85 80 fe ff ff    	mov    -0x180(%rbp),%eax
  80fb09:	83 e0 fb             	and    $0xfffffffb,%eax
  80fb0c:	83 f8 02             	cmp    $0x2,%eax
  80fb0f:	0f 85 21 0a 00 00    	jne    810536 <lodepng_encode+0x188a>
  80fb15:	e9 05 0a 00 00       	jmp    81051f <lodepng_encode+0x1873>
    else if(palette[4 * i + 3] != 255) return 2;
  80fb1a:	48 8d 34 85 00 00 00 	lea    0x0(,%rax,4),%rsi
  80fb21:	00 
  80fb22:	80 7c 82 03 ff       	cmpb   $0xff,0x3(%rdx,%rax,4)
  80fb27:	0f 85 ae 00 00 00    	jne    80fbdb <lodepng_encode+0xf2f>
    else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;
  80fb2d:	85 c9                	test   %ecx,%ecx
  80fb2f:	0f 85 a4 09 00 00    	jne    8104d9 <lodepng_encode+0x182d>
  for(i = 0; i != palettesize; ++i) {
  80fb35:	48 83 c0 01          	add    $0x1,%rax
  80fb39:	48 39 c7             	cmp    %rax,%rdi
  80fb3c:	74 32                	je     80fb70 <lodepng_encode+0xec4>
    if(!key && palette[4 * i + 3] == 0) {
  80fb3e:	85 c9                	test   %ecx,%ecx
  80fb40:	0f 85 80 09 00 00    	jne    8104c6 <lodepng_encode+0x181a>
  80fb46:	48 8d 34 85 00 00 00 	lea    0x0(,%rax,4),%rsi
  80fb4d:	00 
  80fb4e:	80 7c 82 03 00       	cmpb   $0x0,0x3(%rdx,%rax,4)
  80fb53:	75 c5                	jne    80fb1a <lodepng_encode+0xe6e>
      r = palette[4 * i + 0]; g = palette[4 * i + 1]; b = palette[4 * i + 2];
  80fb55:	44 0f b6 0c 82       	movzbl (%rdx,%rax,4),%r9d
  80fb5a:	44 0f b6 54 32 01    	movzbl 0x1(%rdx,%rsi,1),%r10d
  80fb60:	44 0f b6 5c 32 02    	movzbl 0x2(%rdx,%rsi,1),%r11d
      key = 1;
  80fb66:	44 89 c1             	mov    %r8d,%ecx
  for(i = 0; i != palettesize; ++i) {
  80fb69:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb6e:	eb ce                	jmp    80fb3e <lodepng_encode+0xe92>
    if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0) {
  80fb70:	85 c9                	test   %ecx,%ecx
  80fb72:	75 67                	jne    80fbdb <lodepng_encode+0xf2f>
    if(info.background_defined) {
  80fb74:	83 bd a8 fe ff ff 00 	cmpl   $0x0,-0x158(%rbp)
  80fb7b:	0f 84 19 fc ff ff    	je     80f79a <lodepng_encode+0xaee>
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
  80fb81:	8b 85 80 fe ff ff    	mov    -0x180(%rbp),%eax
  80fb87:	89 c2                	mov    %eax,%edx
  80fb89:	83 e2 fb             	and    $0xfffffffb,%edx
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
  80fb8c:	83 fa 02             	cmp    $0x2,%edx
  80fb8f:	0f 85 de 00 00 00    	jne    80fc73 <lodepng_encode+0xfc7>
    data[0] = (unsigned char)(info->background_r >> 8);
  80fb95:	8b 85 ac fe ff ff    	mov    -0x154(%rbp),%eax
  80fb9b:	0f b6 cc             	movzbl %ah,%ecx
  80fb9e:	88 8d 40 fa ff ff    	mov    %cl,-0x5c0(%rbp)
    data[1] = (unsigned char)(info->background_r & 255);
  80fba4:	88 85 41 fa ff ff    	mov    %al,-0x5bf(%rbp)
    data[2] = (unsigned char)(info->background_g >> 8);
  80fbaa:	8b 85 b0 fe ff ff    	mov    -0x150(%rbp),%eax
  80fbb0:	0f b6 cc             	movzbl %ah,%ecx
  80fbb3:	88 8d 42 fa ff ff    	mov    %cl,-0x5be(%rbp)
    data[3] = (unsigned char)(info->background_g & 255);
  80fbb9:	88 85 43 fa ff ff    	mov    %al,-0x5bd(%rbp)
    data[4] = (unsigned char)(info->background_b >> 8);
  80fbbf:	8b 85 b4 fe ff ff    	mov    -0x14c(%rbp),%eax
  80fbc5:	0f b6 cc             	movzbl %ah,%ecx
  80fbc8:	88 8d 44 fa ff ff    	mov    %cl,-0x5bc(%rbp)
    data[5] = (unsigned char)(info->background_b & 255);
  80fbce:	88 85 45 fa ff ff    	mov    %al,-0x5bb(%rbp)
    size = 6;
  80fbd4:	b9 06 00 00 00       	mov    $0x6,%ecx
  80fbd9:	eb 63                	jmp    80fc3e <lodepng_encode+0xf92>
      addChunk_tRNS(&outv, &info.color);
  80fbdb:	48 8d b5 80 fe ff ff 	lea    -0x180(%rbp),%rsi
  80fbe2:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fbe6:	48 b8 a1 8e 80 00 00 	movabs $0x808ea1,%rax
  80fbed:	00 00 00 
  80fbf0:	ff d0                	call   *%rax
  80fbf2:	e9 7d fb ff ff       	jmp    80f774 <lodepng_encode+0xac8>
      addChunk_tRNS(&outv, &info.color);
  80fbf7:	48 8d b5 80 fe ff ff 	lea    -0x180(%rbp),%rsi
  80fbfe:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fc02:	48 b8 a1 8e 80 00 00 	movabs $0x808ea1,%rax
  80fc09:	00 00 00 
  80fc0c:	ff d0                	call   *%rax
  80fc0e:	e9 7a fb ff ff       	jmp    80f78d <lodepng_encode+0xae1>
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
  80fc13:	8b 85 80 fe ff ff    	mov    -0x180(%rbp),%eax
  80fc19:	89 c2                	mov    %eax,%edx
  80fc1b:	83 e2 fb             	and    $0xfffffffb,%edx
  80fc1e:	0f 85 68 ff ff ff    	jne    80fb8c <lodepng_encode+0xee0>
    data[0] = (unsigned char)(info->background_r >> 8);
  80fc24:	8b 85 ac fe ff ff    	mov    -0x154(%rbp),%eax
  80fc2a:	0f b6 cc             	movzbl %ah,%ecx
  80fc2d:	88 8d 40 fa ff ff    	mov    %cl,-0x5c0(%rbp)
    data[1] = (unsigned char)(info->background_r & 255);
  80fc33:	88 85 41 fa ff ff    	mov    %al,-0x5bf(%rbp)
    size = 2;
  80fc39:	b9 02 00 00 00       	mov    $0x2,%ecx
  return addChunk(out, "bKGD", data, size);
  80fc3e:	48 8d 95 40 fa ff ff 	lea    -0x5c0(%rbp),%rdx
  80fc45:	48 be ae 26 81 00 00 	movabs $0x8126ae,%rsi
  80fc4c:	00 00 00 
  80fc4f:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fc53:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80fc5a:	00 00 00 
  80fc5d:	ff d0                	call   *%rax
      state->error = addChunk_bKGD(&outv, &info);
  80fc5f:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) goto cleanup;
  80fc66:	85 c0                	test   %eax,%eax
  80fc68:	0f 84 2c fb ff ff    	je     80f79a <lodepng_encode+0xaee>
  80fc6e:	e9 e9 f1 ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
  size_t size = 0;
  80fc73:	b9 00 00 00 00       	mov    $0x0,%ecx
  } else if(info->color.colortype == LCT_PALETTE) {
  80fc78:	83 f8 03             	cmp    $0x3,%eax
  80fc7b:	75 c1                	jne    80fc3e <lodepng_encode+0xf92>
    data[0] =(unsigned char)(info->background_r & 255); /*palette index*/
  80fc7d:	8b 85 ac fe ff ff    	mov    -0x154(%rbp),%eax
  80fc83:	88 85 40 fa ff ff    	mov    %al,-0x5c0(%rbp)
    size = 1;
  80fc89:	b9 01 00 00 00       	mov    $0x1,%ecx
  80fc8e:	eb ae                	jmp    80fc3e <lodepng_encode+0xf92>
  lodepng_set32bitInt(data + 0, info->phys_x);
  80fc90:	8b b5 18 ff ff ff    	mov    -0xe8(%rbp),%esi
  80fc96:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80fc9d:	48 bb 0c 29 80 00 00 	movabs $0x80290c,%rbx
  80fca4:	00 00 00 
  80fca7:	ff d3                	call   *%rbx
  lodepng_set32bitInt(data + 4, info->phys_y);  data[8] = info->phys_unit;
  80fca9:	8b b5 1c ff ff ff    	mov    -0xe4(%rbp),%esi
  80fcaf:	48 8d bd 44 fa ff ff 	lea    -0x5bc(%rbp),%rdi
  80fcb6:	ff d3                	call   *%rbx
  80fcb8:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  80fcbe:	88 85 48 fa ff ff    	mov    %al,-0x5b8(%rbp)
  return addChunk(out, "pHYs", data, sizeof(data));
  80fcc4:	b9 09 00 00 00       	mov    $0x9,%ecx
  80fcc9:	48 8d 95 40 fa ff ff 	lea    -0x5c0(%rbp),%rdx
  80fcd0:	48 be c2 26 81 00 00 	movabs $0x8126c2,%rsi
  80fcd7:	00 00 00 
  80fcda:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fcde:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80fce5:	00 00 00 
  80fce8:	ff d0                	call   *%rax
  80fcea:	e9 b8 fa ff ff       	jmp    80f7a7 <lodepng_encode+0xafb>
  if(!error) error = addChunk(out, "IDAT", zlibdata.data, zlibdata.size);
  80fcef:	48 8b 8d 48 fa ff ff 	mov    -0x5b8(%rbp),%rcx
  80fcf6:	48 8b 95 40 fa ff ff 	mov    -0x5c0(%rbp),%rdx
  80fcfd:	48 be db 26 81 00 00 	movabs $0x8126db,%rsi
  80fd04:	00 00 00 
  80fd07:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fd0b:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80fd12:	00 00 00 
  80fd15:	ff d0                	call   *%rax
  80fd17:	89 c3                	mov    %eax,%ebx
  ucvector_cleanup(&zlibdata);
  80fd19:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80fd20:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  80fd27:	00 00 00 
  80fd2a:	ff d0                	call   *%rax
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
  80fd2c:	41 89 9d f0 01 00 00 	mov    %ebx,0x1f0(%r13)
    if(state->error) goto cleanup;
  80fd33:	85 db                	test   %ebx,%ebx
  80fd35:	0f 85 21 f1 ff ff    	jne    80ee5c <lodepng_encode+0x1b0>
    if(info.time_defined) addChunk_tIME(&outv, &info.time);
  80fd3b:	83 bd f8 fe ff ff 00 	cmpl   $0x0,-0x108(%rbp)
  80fd42:	75 29                	jne    80fd6d <lodepng_encode+0x10c1>
    for(i = 0; i != info.text_num; ++i) {
  80fd44:	ba 00 00 00 00       	mov    $0x0,%edx
  80fd49:	48 83 bd b8 fe ff ff 	cmpq   $0x0,-0x148(%rbp)
  80fd50:	00 
  80fd51:	0f 84 04 07 00 00    	je     81045b <lodepng_encode+0x17af>
  80fd57:	4c 89 bd b8 f9 ff ff 	mov    %r15,-0x648(%rbp)
  80fd5e:	4c 89 b5 b0 f9 ff ff 	mov    %r14,-0x650(%rbp)
  80fd65:	49 89 d6             	mov    %rdx,%r14
  80fd68:	e9 ea 00 00 00       	jmp    80fe57 <lodepng_encode+0x11ab>
  data[0] = (unsigned char)(time->year >> 8);
  80fd6d:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
  80fd73:	0f b6 cc             	movzbl %ah,%ecx
  80fd76:	88 8d 40 fa ff ff    	mov    %cl,-0x5c0(%rbp)
  data[1] = (unsigned char)(time->year & 255);
  80fd7c:	88 85 41 fa ff ff    	mov    %al,-0x5bf(%rbp)
  data[2] = (unsigned char)time->month;
  80fd82:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
  80fd88:	88 85 42 fa ff ff    	mov    %al,-0x5be(%rbp)
  data[3] = (unsigned char)time->day;
  80fd8e:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  80fd94:	88 85 43 fa ff ff    	mov    %al,-0x5bd(%rbp)
  data[4] = (unsigned char)time->hour;
  80fd9a:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
  80fda0:	88 85 44 fa ff ff    	mov    %al,-0x5bc(%rbp)
  data[5] = (unsigned char)time->minute;
  80fda6:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  80fdac:	88 85 45 fa ff ff    	mov    %al,-0x5bb(%rbp)
  data[6] = (unsigned char)time->second;
  80fdb2:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  80fdb8:	88 85 46 fa ff ff    	mov    %al,-0x5ba(%rbp)
  return addChunk(out, "tIME", data, sizeof(data));
  80fdbe:	b9 07 00 00 00       	mov    $0x7,%ecx
  80fdc3:	48 8d 95 40 fa ff ff 	lea    -0x5c0(%rbp),%rdx
  80fdca:	48 be bd 26 81 00 00 	movabs $0x8126bd,%rsi
  80fdd1:	00 00 00 
  80fdd4:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fdd8:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80fddf:	00 00 00 
  80fde2:	ff d0                	call   *%rax
  80fde4:	e9 5b ff ff ff       	jmp    80fd44 <lodepng_encode+0x1098>
        state->error = 66; /*text chunk too large*/
  80fde9:	4c 8b bd b8 f9 ff ff 	mov    -0x648(%rbp),%r15
  80fdf0:	4c 8b b5 b0 f9 ff ff 	mov    -0x650(%rbp),%r14
  80fdf7:	41 c7 85 f0 01 00 00 	movl   $0x42,0x1f0(%r13)
  80fdfe:	42 00 00 00 
        goto cleanup;
  80fe02:	e9 55 f0 ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
        state->error = 67; /*text chunk too small*/
  80fe07:	4c 8b bd b8 f9 ff ff 	mov    -0x648(%rbp),%r15
  80fe0e:	4c 8b b5 b0 f9 ff ff 	mov    -0x650(%rbp),%r14
  80fe15:	41 c7 85 f0 01 00 00 	movl   $0x43,0x1f0(%r13)
  80fe1c:	43 00 00 00 
        goto cleanup;
  80fe20:	e9 37 f0 ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
        addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
  80fe25:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
  80fe2c:	48 8b 14 18          	mov    (%rax,%rbx,1),%rdx
  80fe30:	4c 89 e6             	mov    %r12,%rsi
  80fe33:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80fe37:	48 b8 fb 8f 80 00 00 	movabs $0x808ffb,%rax
  80fe3e:	00 00 00 
  80fe41:	ff d0                	call   *%rax
    for(i = 0; i != info.text_num; ++i) {
  80fe43:	49 8d 46 01          	lea    0x1(%r14),%rax
  80fe47:	48 39 85 b8 fe ff ff 	cmp    %rax,-0x148(%rbp)
  80fe4e:	0f 84 bf 01 00 00    	je     810013 <lodepng_encode+0x1367>
  80fe54:	49 89 c6             	mov    %rax,%r14
      if(lodepng_strlen(info.text_keys[i]) > 79) {
  80fe57:	4a 8d 1c f5 00 00 00 	lea    0x0(,%r14,8),%rbx
  80fe5e:	00 
  80fe5f:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  80fe66:	4e 8b 24 f0          	mov    (%rax,%r14,8),%r12
  80fe6a:	4c 89 e7             	mov    %r12,%rdi
  80fe6d:	48 b8 d3 28 80 00 00 	movabs $0x8028d3,%rax
  80fe74:	00 00 00 
  80fe77:	ff d0                	call   *%rax
  80fe79:	48 83 f8 4f          	cmp    $0x4f,%rax
  80fe7d:	0f 87 66 ff ff ff    	ja     80fde9 <lodepng_encode+0x113d>
      if(lodepng_strlen(info.text_keys[i]) < 1) {
  80fe83:	48 85 c0             	test   %rax,%rax
  80fe86:	0f 84 7b ff ff ff    	je     80fe07 <lodepng_encode+0x115b>
      if(state->encoder.text_compression) {
  80fe8c:	41 83 bd 88 00 00 00 	cmpl   $0x0,0x88(%r13)
  80fe93:	00 
  80fe94:	74 8f                	je     80fe25 <lodepng_encode+0x1179>
        addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
  80fe96:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
  80fe9d:	4c 8b 3c 18          	mov    (%rax,%rbx,1),%r15
  size_t i, textsize = lodepng_strlen(textstring);
  80fea1:	4c 89 ff             	mov    %r15,%rdi
  80fea4:	48 b8 d3 28 80 00 00 	movabs $0x8028d3,%rax
  80feab:	00 00 00 
  80feae:	ff d0                	call   *%rax
  80feb0:	48 89 85 c8 f9 ff ff 	mov    %rax,-0x638(%rbp)
  p->data = NULL;
  80feb7:	48 c7 85 18 fa ff ff 	movq   $0x0,-0x5e8(%rbp)
  80febe:	00 00 00 00 
  p->size = p->allocsize = 0;
  80fec2:	48 c7 85 28 fa ff ff 	movq   $0x0,-0x5d8(%rbp)
  80fec9:	00 00 00 00 
  80fecd:	48 c7 85 20 fa ff ff 	movq   $0x0,-0x5e0(%rbp)
  80fed4:	00 00 00 00 
  p->data = NULL;
  80fed8:	48 c7 85 40 fa ff ff 	movq   $0x0,-0x5c0(%rbp)
  80fedf:	00 00 00 00 
  p->size = p->allocsize = 0;
  80fee3:	48 c7 85 50 fa ff ff 	movq   $0x0,-0x5b0(%rbp)
  80feea:	00 00 00 00 
  80feee:	48 c7 85 48 fa ff ff 	movq   $0x0,-0x5b8(%rbp)
  80fef5:	00 00 00 00 
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  80fef9:	41 0f b6 04 24       	movzbl (%r12),%eax
  80fefe:	84 c0                	test   %al,%al
  80ff00:	0f 84 3d ff ff ff    	je     80fe43 <lodepng_encode+0x1197>
  80ff06:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ff0b:	0f b6 f0             	movzbl %al,%esi
  80ff0e:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80ff15:	48 b8 78 46 80 00 00 	movabs $0x804678,%rax
  80ff1c:	00 00 00 
  80ff1f:	ff d0                	call   *%rax
  80ff21:	48 89 da             	mov    %rbx,%rdx
  80ff24:	48 83 c3 01          	add    $0x1,%rbx
  80ff28:	41 0f b6 04 1c       	movzbl (%r12,%rbx,1),%eax
  80ff2d:	84 c0                	test   %al,%al
  80ff2f:	75 da                	jne    80ff0b <lodepng_encode+0x125f>
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  80ff31:	48 83 fa 4e          	cmp    $0x4e,%rdx
  80ff35:	0f 87 08 ff ff ff    	ja     80fe43 <lodepng_encode+0x1197>
  ucvector_push_back(&data, 0); /*0 termination char*/
  80ff3b:	be 00 00 00 00       	mov    $0x0,%esi
  80ff40:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80ff47:	48 bb 78 46 80 00 00 	movabs $0x804678,%rbx
  80ff4e:	00 00 00 
  80ff51:	ff d3                	call   *%rbx
  ucvector_push_back(&data, 0); /*compression method: 0*/
  80ff53:	be 00 00 00 00       	mov    $0x0,%esi
  80ff58:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80ff5f:	ff d3                	call   *%rbx
  error = zlib_compress(&compressed.data, &compressed.size,
  80ff61:	4c 8b 85 c0 f9 ff ff 	mov    -0x640(%rbp),%r8
  80ff68:	48 8b 8d c8 f9 ff ff 	mov    -0x638(%rbp),%rcx
  80ff6f:	4c 89 fa             	mov    %r15,%rdx
  80ff72:	48 8d b5 48 fa ff ff 	lea    -0x5b8(%rbp),%rsi
  80ff79:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80ff80:	48 b8 2a 87 80 00 00 	movabs $0x80872a,%rax
  80ff87:	00 00 00 
  80ff8a:	ff d0                	call   *%rax
  if(!error) {
  80ff8c:	85 c0                	test   %eax,%eax
  80ff8e:	75 62                	jne    80fff2 <lodepng_encode+0x1346>
    for(i = 0; i != compressed.size; ++i) ucvector_push_back(&data, compressed.data[i]);
  80ff90:	48 83 bd 48 fa ff ff 	cmpq   $0x0,-0x5b8(%rbp)
  80ff97:	00 
  80ff98:	74 30                	je     80ffca <lodepng_encode+0x131e>
  80ff9a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ff9f:	48 8b 85 40 fa ff ff 	mov    -0x5c0(%rbp),%rax
  80ffa6:	0f b6 34 18          	movzbl (%rax,%rbx,1),%esi
  80ffaa:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  80ffb1:	48 b8 78 46 80 00 00 	movabs $0x804678,%rax
  80ffb8:	00 00 00 
  80ffbb:	ff d0                	call   *%rax
  80ffbd:	48 83 c3 01          	add    $0x1,%rbx
  80ffc1:	48 3b 9d 48 fa ff ff 	cmp    -0x5b8(%rbp),%rbx
  80ffc8:	75 d5                	jne    80ff9f <lodepng_encode+0x12f3>
    error = addChunk(out, "zTXt", data.data, data.size);
  80ffca:	48 8b 8d 20 fa ff ff 	mov    -0x5e0(%rbp),%rcx
  80ffd1:	48 8b 95 18 fa ff ff 	mov    -0x5e8(%rbp),%rdx
  80ffd8:	48 be b3 26 81 00 00 	movabs $0x8126b3,%rsi
  80ffdf:	00 00 00 
  80ffe2:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  80ffe6:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  80ffed:	00 00 00 
  80fff0:	ff d0                	call   *%rax
  ucvector_cleanup(&compressed);
  80fff2:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  80fff9:	48 bb 3d 50 80 00 00 	movabs $0x80503d,%rbx
  810000:	00 00 00 
  810003:	ff d3                	call   *%rbx
  ucvector_cleanup(&data);
  810005:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  81000c:	ff d3                	call   *%rbx
  return error;
  81000e:	e9 30 fe ff ff       	jmp    80fe43 <lodepng_encode+0x1197>
    if(state->encoder.add_id) {
  810013:	4c 89 f2             	mov    %r14,%rdx
  810016:	4c 8b bd b8 f9 ff ff 	mov    -0x648(%rbp),%r15
  81001d:	4c 8b b5 b0 f9 ff ff 	mov    -0x650(%rbp),%r14
  810024:	41 83 bd 84 00 00 00 	cmpl   $0x0,0x84(%r13)
  81002b:	00 
  81002c:	0f 84 5a 04 00 00    	je     81048c <lodepng_encode+0x17e0>
      for(i = 0; i != info.text_num; ++i) {
  810032:	48 85 c0             	test   %rax,%rax
  810035:	0f 84 2a 04 00 00    	je     810465 <lodepng_encode+0x17b9>
        const char* k = info.text_keys[i];
  81003b:	48 8b 8d c0 fe ff ff 	mov    -0x140(%rbp),%rcx
      for(i = 0; i != info.text_num; ++i) {
  810042:	b8 00 00 00 00       	mov    $0x0,%eax
  810047:	48 89 d6             	mov    %rdx,%rsi
  81004a:	eb 10                	jmp    81005c <lodepng_encode+0x13b0>
  81004c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  810050:	48 39 c6             	cmp    %rax,%rsi
  810053:	0f 84 0c 04 00 00    	je     810465 <lodepng_encode+0x17b9>
  810059:	48 89 d0             	mov    %rdx,%rax
        const char* k = info.text_keys[i];
  81005c:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
  810060:	80 3a 4c             	cmpb   $0x4c,(%rdx)
  810063:	75 e7                	jne    81004c <lodepng_encode+0x13a0>
  810065:	80 7a 01 6f          	cmpb   $0x6f,0x1(%rdx)
  810069:	75 e1                	jne    81004c <lodepng_encode+0x13a0>
  81006b:	80 7a 02 64          	cmpb   $0x64,0x2(%rdx)
  81006f:	75 db                	jne    81004c <lodepng_encode+0x13a0>
  810071:	80 7a 03 65          	cmpb   $0x65,0x3(%rdx)
  810075:	75 d5                	jne    81004c <lodepng_encode+0x13a0>
  810077:	80 7a 04 50          	cmpb   $0x50,0x4(%rdx)
  81007b:	75 cf                	jne    81004c <lodepng_encode+0x13a0>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
  81007d:	80 7a 05 4e          	cmpb   $0x4e,0x5(%rdx)
  810081:	75 c9                	jne    81004c <lodepng_encode+0x13a0>
  810083:	80 7a 06 47          	cmpb   $0x47,0x6(%rdx)
  810087:	75 c3                	jne    81004c <lodepng_encode+0x13a0>
  810089:	80 7a 07 00          	cmpb   $0x0,0x7(%rdx)
  81008d:	75 bd                	jne    81004c <lodepng_encode+0x13a0>
  81008f:	e9 f8 03 00 00       	jmp    81048c <lodepng_encode+0x17e0>
        state->error = 66; /*text chunk too large*/
  810094:	4c 8b bd 98 f9 ff ff 	mov    -0x668(%rbp),%r15
  81009b:	4c 8b b5 90 f9 ff ff 	mov    -0x670(%rbp),%r14
  8100a2:	4c 8b ad a0 f9 ff ff 	mov    -0x660(%rbp),%r13
  8100a9:	41 c7 85 f0 01 00 00 	movl   $0x42,0x1f0(%r13)
  8100b0:	42 00 00 00 
        goto cleanup;
  8100b4:	e9 a3 ed ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
        state->error = 67; /*text chunk too small*/
  8100b9:	4c 8b bd 98 f9 ff ff 	mov    -0x668(%rbp),%r15
  8100c0:	4c 8b b5 90 f9 ff ff 	mov    -0x670(%rbp),%r14
  8100c7:	4c 8b ad a0 f9 ff ff 	mov    -0x660(%rbp),%r13
  8100ce:	41 c7 85 f0 01 00 00 	movl   $0x43,0x1f0(%r13)
  8100d5:	43 00 00 00 
        goto cleanup;
  8100d9:	e9 7e ed ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
  p->data = NULL;
  8100de:	48 c7 85 40 fa ff ff 	movq   $0x0,-0x5c0(%rbp)
  8100e5:	00 00 00 00 
  p->size = p->allocsize = 0;
  8100e9:	48 c7 85 50 fa ff ff 	movq   $0x0,-0x5b0(%rbp)
  8100f0:	00 00 00 00 
  8100f4:	48 c7 85 48 fa ff ff 	movq   $0x0,-0x5b8(%rbp)
  8100fb:	00 00 00 00 
    error = zlib_compress(&compressed_data.data, &compressed_data.size,
  8100ff:	4c 8b 85 c0 f9 ff ff 	mov    -0x640(%rbp),%r8
  810106:	48 8b 8d a8 f9 ff ff 	mov    -0x658(%rbp),%rcx
  81010d:	4c 89 ea             	mov    %r13,%rdx
  810110:	48 8d b5 48 fa ff ff 	lea    -0x5b8(%rbp),%rsi
  810117:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  81011e:	48 b8 2a 87 80 00 00 	movabs $0x80872a,%rax
  810125:	00 00 00 
  810128:	ff d0                	call   *%rax
    if(!error) {
  81012a:	85 c0                	test   %eax,%eax
  81012c:	0f 85 fa 00 00 00    	jne    81022c <lodepng_encode+0x1580>
      for(i = 0; i != compressed_data.size; ++i) ucvector_push_back(&data, compressed_data.data[i]);
  810132:	48 83 bd 48 fa ff ff 	cmpq   $0x0,-0x5b8(%rbp)
  810139:	00 
  81013a:	74 27                	je     810163 <lodepng_encode+0x14b7>
  81013c:	bb 00 00 00 00       	mov    $0x0,%ebx
  810141:	48 8b 85 40 fa ff ff 	mov    -0x5c0(%rbp),%rax
  810148:	0f b6 34 18          	movzbl (%rax,%rbx,1),%esi
  81014c:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  810153:	41 ff d4             	call   *%r12
  810156:	48 83 c3 01          	add    $0x1,%rbx
  81015a:	48 3b 9d 48 fa ff ff 	cmp    -0x5b8(%rbp),%rbx
  810161:	75 de                	jne    810141 <lodepng_encode+0x1495>
    ucvector_cleanup(&compressed_data);
  810163:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  81016a:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  810171:	00 00 00 
  810174:	ff d0                	call   *%rax
  if(!error) error = addChunk(out, "iTXt", data.data, data.size);
  810176:	e9 b3 02 00 00       	jmp    81042e <lodepng_encode+0x1782>
  81017b:	4c 8b bd 98 f9 ff ff 	mov    -0x668(%rbp),%r15
  810182:	4c 8b b5 90 f9 ff ff 	mov    -0x670(%rbp),%r14
  810189:	4c 8b ad a0 f9 ff ff 	mov    -0x660(%rbp),%r13
    if(info.unknown_chunks_data[2]) {
  810190:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
  810194:	48 85 f6             	test   %rsi,%rsi
  810197:	74 23                	je     8101bc <lodepng_encode+0x1510>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
  810199:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  81019d:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  8101a1:	48 b8 10 8c 80 00 00 	movabs $0x808c10,%rax
  8101a8:	00 00 00 
  8101ab:	ff d0                	call   *%rax
  8101ad:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
      if(state->error) goto cleanup;
  8101b4:	85 c0                	test   %eax,%eax
  8101b6:	0f 85 a0 ec ff ff    	jne    80ee5c <lodepng_encode+0x1b0>
  error = addChunk(out, "IEND", 0, 0);
  8101bc:	b9 00 00 00 00       	mov    $0x0,%ecx
  8101c1:	ba 00 00 00 00       	mov    $0x0,%edx
  8101c6:	48 be e0 26 81 00 00 	movabs $0x8126e0,%rsi
  8101cd:	00 00 00 
  8101d0:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  8101d4:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  8101db:	00 00 00 
  8101de:	ff d0                	call   *%rax
  return error;
  8101e0:	e9 77 ec ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
    mode_out->colortype = LCT_PALETTE;
  8101e5:	4c 8b bd 98 f9 ff ff 	mov    -0x668(%rbp),%r15
  8101ec:	c7 85 80 fe ff ff 03 	movl   $0x3,-0x180(%rbp)
  8101f3:	00 00 00 
    mode_out->bitdepth = palettebits;
  8101f6:	8b 8d a8 f9 ff ff    	mov    -0x658(%rbp),%ecx
  8101fc:	89 8d 84 fe ff ff    	mov    %ecx,-0x17c(%rbp)
    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
  810202:	41 83 bd 90 00 00 00 	cmpl   $0x3,0x90(%r13)
  810209:	03 
  81020a:	0f 84 84 03 00 00    	je     810594 <lodepng_encode+0x18e8>
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
  810210:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
    if(state->error) goto cleanup;
  810217:	e9 40 ec ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
  81021c:	41 c7 85 f0 01 00 00 	movl   $0x0,0x1f0(%r13)
  810223:	00 00 00 00 
    if(state->error) goto cleanup;
  810227:	e9 49 f0 ff ff       	jmp    80f275 <lodepng_encode+0x5c9>
    ucvector_cleanup(&compressed_data);
  81022c:	48 8d bd 40 fa ff ff 	lea    -0x5c0(%rbp),%rdi
  810233:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  81023a:	00 00 00 
  81023d:	ff d0                	call   *%rax
  ucvector_cleanup(&data);
  81023f:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  810246:	48 b8 3d 50 80 00 00 	movabs $0x80503d,%rax
  81024d:	00 00 00 
  810250:	ff d0                	call   *%rax
    for(i = 0; i != info.itext_num; ++i) {
  810252:	49 83 c7 01          	add    $0x1,%r15
  810256:	4c 39 bd d0 fe ff ff 	cmp    %r15,-0x130(%rbp)
  81025d:	0f 84 18 ff ff ff    	je     81017b <lodepng_encode+0x14cf>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
  810263:	4a 8d 1c fd 00 00 00 	lea    0x0(,%r15,8),%rbx
  81026a:	00 
  81026b:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
  810272:	4e 8b 34 f8          	mov    (%rax,%r15,8),%r14
  810276:	4c 89 f7             	mov    %r14,%rdi
  810279:	48 b8 d3 28 80 00 00 	movabs $0x8028d3,%rax
  810280:	00 00 00 
  810283:	ff d0                	call   *%rax
  810285:	48 83 f8 4f          	cmp    $0x4f,%rax
  810289:	0f 87 05 fe ff ff    	ja     810094 <lodepng_encode+0x13e8>
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
  81028f:	48 85 c0             	test   %rax,%rax
  810292:	0f 84 21 fe ff ff    	je     8100b9 <lodepng_encode+0x140d>
      addChunk_iTXt(&outv, state->encoder.text_compression,
  810298:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  81029f:	4c 8b 2c 18          	mov    (%rax,%rbx,1),%r13
  8102a3:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8102aa:	48 8b 04 18          	mov    (%rax,%rbx,1),%rax
  8102ae:	48 89 85 b8 f9 ff ff 	mov    %rax,-0x648(%rbp)
  8102b5:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8102bc:	48 8b 04 18          	mov    (%rax,%rbx,1),%rax
  8102c0:	48 89 85 b0 f9 ff ff 	mov    %rax,-0x650(%rbp)
  8102c7:	48 8b 85 a0 f9 ff ff 	mov    -0x660(%rbp),%rax
  8102ce:	8b 80 88 00 00 00    	mov    0x88(%rax),%eax
  8102d4:	89 85 c8 f9 ff ff    	mov    %eax,-0x638(%rbp)
  size_t i, textsize = lodepng_strlen(textstring);
  8102da:	4c 89 ef             	mov    %r13,%rdi
  8102dd:	48 b8 d3 28 80 00 00 	movabs $0x8028d3,%rax
  8102e4:	00 00 00 
  8102e7:	ff d0                	call   *%rax
  8102e9:	48 89 85 a8 f9 ff ff 	mov    %rax,-0x658(%rbp)
  p->data = NULL;
  8102f0:	48 c7 85 18 fa ff ff 	movq   $0x0,-0x5e8(%rbp)
  8102f7:	00 00 00 00 
  p->size = p->allocsize = 0;
  8102fb:	48 c7 85 28 fa ff ff 	movq   $0x0,-0x5d8(%rbp)
  810302:	00 00 00 00 
  810306:	48 c7 85 20 fa ff ff 	movq   $0x0,-0x5e0(%rbp)
  81030d:	00 00 00 00 
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  810311:	41 0f b6 06          	movzbl (%r14),%eax
  810315:	84 c0                	test   %al,%al
  810317:	0f 84 35 ff ff ff    	je     810252 <lodepng_encode+0x15a6>
  81031d:	bb 00 00 00 00       	mov    $0x0,%ebx
  810322:	0f b6 f0             	movzbl %al,%esi
  810325:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  81032c:	41 ff d4             	call   *%r12
  81032f:	48 89 da             	mov    %rbx,%rdx
  810332:	48 83 c3 01          	add    $0x1,%rbx
  810336:	41 0f b6 04 1e       	movzbl (%r14,%rbx,1),%eax
  81033b:	84 c0                	test   %al,%al
  81033d:	75 e3                	jne    810322 <lodepng_encode+0x1676>
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  81033f:	48 83 fa 4e          	cmp    $0x4e,%rdx
  810343:	0f 87 09 ff ff ff    	ja     810252 <lodepng_encode+0x15a6>
  ucvector_push_back(&data, 0); /*null termination char*/
  810349:	be 00 00 00 00       	mov    $0x0,%esi
  81034e:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  810355:	41 ff d4             	call   *%r12
  ucvector_push_back(&data, compressed ? 1 : 0); /*compression flag*/
  810358:	83 bd c8 f9 ff ff 00 	cmpl   $0x0,-0x638(%rbp)
  81035f:	40 0f 95 c6          	setne  %sil
  810363:	40 0f b6 f6          	movzbl %sil,%esi
  810367:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  81036e:	41 ff d4             	call   *%r12
  ucvector_push_back(&data, 0); /*compression method*/
  810371:	be 00 00 00 00       	mov    $0x0,%esi
  810376:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  81037d:	41 ff d4             	call   *%r12
  for(i = 0; langtag[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)langtag[i]);
  810380:	48 8b 8d b0 f9 ff ff 	mov    -0x650(%rbp),%rcx
  810387:	0f b6 01             	movzbl (%rcx),%eax
  81038a:	84 c0                	test   %al,%al
  81038c:	74 20                	je     8103ae <lodepng_encode+0x1702>
  81038e:	48 83 c1 01          	add    $0x1,%rcx
  810392:	48 89 cb             	mov    %rcx,%rbx
  810395:	0f b6 f0             	movzbl %al,%esi
  810398:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  81039f:	41 ff d4             	call   *%r12
  8103a2:	48 83 c3 01          	add    $0x1,%rbx
  8103a6:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8103aa:	84 c0                	test   %al,%al
  8103ac:	75 e7                	jne    810395 <lodepng_encode+0x16e9>
  ucvector_push_back(&data, 0); /*null termination char*/
  8103ae:	be 00 00 00 00       	mov    $0x0,%esi
  8103b3:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  8103ba:	41 ff d4             	call   *%r12
  for(i = 0; transkey[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)transkey[i]);
  8103bd:	48 8b 8d b8 f9 ff ff 	mov    -0x648(%rbp),%rcx
  8103c4:	0f b6 01             	movzbl (%rcx),%eax
  8103c7:	84 c0                	test   %al,%al
  8103c9:	74 20                	je     8103eb <lodepng_encode+0x173f>
  8103cb:	48 83 c1 01          	add    $0x1,%rcx
  8103cf:	48 89 cb             	mov    %rcx,%rbx
  8103d2:	0f b6 f0             	movzbl %al,%esi
  8103d5:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  8103dc:	41 ff d4             	call   *%r12
  8103df:	48 83 c3 01          	add    $0x1,%rbx
  8103e3:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8103e7:	84 c0                	test   %al,%al
  8103e9:	75 e7                	jne    8103d2 <lodepng_encode+0x1726>
  ucvector_push_back(&data, 0); /*null termination char*/
  8103eb:	be 00 00 00 00       	mov    $0x0,%esi
  8103f0:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  8103f7:	41 ff d4             	call   *%r12
  if(compressed) {
  8103fa:	83 bd c8 f9 ff ff 00 	cmpl   $0x0,-0x638(%rbp)
  810401:	0f 85 d7 fc ff ff    	jne    8100de <lodepng_encode+0x1432>
    for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)textstring[i]);
  810407:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
  81040c:	49 83 c5 01          	add    $0x1,%r13
  810410:	84 c0                	test   %al,%al
  810412:	74 1a                	je     81042e <lodepng_encode+0x1782>
  810414:	0f b6 f0             	movzbl %al,%esi
  810417:	48 8d bd 18 fa ff ff 	lea    -0x5e8(%rbp),%rdi
  81041e:	41 ff d4             	call   *%r12
  810421:	49 83 c5 01          	add    $0x1,%r13
  810425:	41 0f b6 45 ff       	movzbl -0x1(%r13),%eax
  81042a:	84 c0                	test   %al,%al
  81042c:	75 e6                	jne    810414 <lodepng_encode+0x1768>
  if(!error) error = addChunk(out, "iTXt", data.data, data.size);
  81042e:	48 8b 8d 20 fa ff ff 	mov    -0x5e0(%rbp),%rcx
  810435:	48 8b 95 18 fa ff ff 	mov    -0x5e8(%rbp),%rdx
  81043c:	48 be b8 26 81 00 00 	movabs $0x8126b8,%rsi
  810443:	00 00 00 
  810446:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  81044a:	48 b8 ad 8d 80 00 00 	movabs $0x808dad,%rax
  810451:	00 00 00 
  810454:	ff d0                	call   *%rax
  810456:	e9 e4 fd ff ff       	jmp    81023f <lodepng_encode+0x1593>
    if(state->encoder.add_id) {
  81045b:	41 83 bd 84 00 00 00 	cmpl   $0x0,0x84(%r13)
  810462:	00 
  810463:	74 27                	je     81048c <lodepng_encode+0x17e0>
        addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
  810465:	48 b8 98 40 81 00 00 	movabs $0x814098,%rax
  81046c:	00 00 00 
  81046f:	48 8b 10             	mov    (%rax),%rdx
  810472:	48 be e5 26 81 00 00 	movabs $0x8126e5,%rsi
  810479:	00 00 00 
  81047c:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  810480:	48 b8 fb 8f 80 00 00 	movabs $0x808ffb,%rax
  810487:	00 00 00 
  81048a:	ff d0                	call   *%rax
    for(i = 0; i != info.itext_num; ++i) {
  81048c:	b8 00 00 00 00       	mov    $0x0,%eax
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  810491:	49 bc 78 46 80 00 00 	movabs $0x804678,%r12
  810498:	00 00 00 
    for(i = 0; i != info.itext_num; ++i) {
  81049b:	48 83 bd d0 fe ff ff 	cmpq   $0x0,-0x130(%rbp)
  8104a2:	00 
  8104a3:	0f 84 e7 fc ff ff    	je     810190 <lodepng_encode+0x14e4>
  8104a9:	4c 89 bd 98 f9 ff ff 	mov    %r15,-0x668(%rbp)
  8104b0:	49 89 c7             	mov    %rax,%r15
  8104b3:	4c 89 b5 90 f9 ff ff 	mov    %r14,-0x670(%rbp)
  8104ba:	4c 89 ad a0 f9 ff ff 	mov    %r13,-0x660(%rbp)
  8104c1:	e9 9d fd ff ff       	jmp    810263 <lodepng_encode+0x15b7>
    else if(palette[4 * i + 3] != 255) return 2;
  8104c6:	48 8d 34 85 00 00 00 	lea    0x0(,%rax,4),%rsi
  8104cd:	00 
  8104ce:	80 7c 82 03 ff       	cmpb   $0xff,0x3(%rdx,%rax,4)
  8104d3:	0f 85 02 f7 ff ff    	jne    80fbdb <lodepng_encode+0xf2f>
    else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;
  8104d9:	0f b6 1c 32          	movzbl (%rdx,%rsi,1),%ebx
  8104dd:	44 89 c1             	mov    %r8d,%ecx
  8104e0:	44 39 cb             	cmp    %r9d,%ebx
  8104e3:	0f 85 4c f6 ff ff    	jne    80fb35 <lodepng_encode+0xe89>
  8104e9:	0f b6 5c 32 01       	movzbl 0x1(%rdx,%rsi,1),%ebx
  8104ee:	44 39 d3             	cmp    %r10d,%ebx
  8104f1:	0f 85 3e f6 ff ff    	jne    80fb35 <lodepng_encode+0xe89>
  8104f7:	0f b6 4c 32 02       	movzbl 0x2(%rdx,%rsi,1),%ecx
  8104fc:	44 39 d9             	cmp    %r11d,%ecx
  8104ff:	0f 84 d6 f6 ff ff    	je     80fbdb <lodepng_encode+0xf2f>
  810505:	44 89 c1             	mov    %r8d,%ecx
  810508:	e9 28 f6 ff ff       	jmp    80fb35 <lodepng_encode+0xe89>
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
  81050d:	8b 85 80 fe ff ff    	mov    -0x180(%rbp),%eax
  810513:	83 e0 fb             	and    $0xfffffffb,%eax
  810516:	83 f8 02             	cmp    $0x2,%eax
  810519:	0f 85 55 f2 ff ff    	jne    80f774 <lodepng_encode+0xac8>
      addChunk_PLTE(&outv, &info.color);
  81051f:	48 8d b5 80 fe ff ff 	lea    -0x180(%rbp),%rsi
  810526:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
  81052a:	48 b8 e7 8d 80 00 00 	movabs $0x808de7,%rax
  810531:	00 00 00 
  810534:	ff d0                	call   *%rax
    if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0) {
  810536:	83 bd 80 fe ff ff 03 	cmpl   $0x3,-0x180(%rbp)
  81053d:	0f 85 31 f2 ff ff    	jne    80f774 <lodepng_encode+0xac8>
  810543:	48 8b bd 90 fe ff ff 	mov    -0x170(%rbp),%rdi
  81054a:	48 8b 95 88 fe ff ff 	mov    -0x178(%rbp),%rdx
  for(i = 0; i != palettesize; ++i) {
  810551:	48 85 ff             	test   %rdi,%rdi
  810554:	0f 84 1a f6 ff ff    	je     80fb74 <lodepng_encode+0xec8>
  unsigned r = 0, g = 0, b = 0; /*the value of the color with alpha 0, so long as color keying is possible*/
  81055a:	8b 8d b8 f9 ff ff    	mov    -0x648(%rbp),%ecx
  810560:	41 89 cb             	mov    %ecx,%r11d
  810563:	41 89 ca             	mov    %ecx,%r10d
  810566:	41 89 c9             	mov    %ecx,%r9d
  for(i = 0; i != palettesize; ++i) {
  810569:	b8 00 00 00 00       	mov    $0x0,%eax
  81056e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  810574:	e9 c5 f5 ff ff       	jmp    80fb3e <lodepng_encode+0xe92>
    mode_out->bitdepth = bits;
  810579:	89 8d 84 fe ff ff    	mov    %ecx,-0x17c(%rbp)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
  81057f:	e9 95 ec ff ff       	jmp    80f219 <lodepng_encode+0x56d>
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
  810584:	41 c7 85 f0 01 00 00 	movl   $0x0,0x1f0(%r13)
  81058b:	00 00 00 00 
    if(state->error) goto cleanup;
  81058f:	e9 e1 ec ff ff       	jmp    80f275 <lodepng_encode+0x5c9>
    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
  810594:	49 8b 8d a0 00 00 00 	mov    0xa0(%r13),%rcx
  81059b:	48 39 8d 90 fe ff ff 	cmp    %rcx,-0x170(%rbp)
  8105a2:	0f 86 22 ee ff ff    	jbe    80f3ca <lodepng_encode+0x71e>
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
  8105a8:	41 89 85 f0 01 00 00 	mov    %eax,0x1f0(%r13)
    if(state->error) goto cleanup;
  8105af:	e9 a8 e8 ff ff       	jmp    80ee5c <lodepng_encode+0x1b0>

00000000008105b4 <lodepng_encoder_settings_init>:
unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
  8105b4:	55                   	push   %rbp
  8105b5:	48 89 e5             	mov    %rsp,%rbp
  8105b8:	53                   	push   %rbx
  8105b9:	48 83 ec 08          	sub    $0x8,%rsp
  8105bd:	48 89 fb             	mov    %rdi,%rbx
  lodepng_compress_settings_init(&settings->zlibsettings);
  8105c0:	48 b8 49 87 80 00 00 	movabs $0x808749,%rax
  8105c7:	00 00 00 
  8105ca:	ff d0                	call   *%rax
  settings->filter_palette_zero = 1;
  8105cc:	c7 43 34 01 00 00 00 	movl   $0x1,0x34(%rbx)
  settings->filter_strategy = LFS_MINSUM;
  8105d3:	c7 43 38 05 00 00 00 	movl   $0x5,0x38(%rbx)
  settings->auto_convert = 1;
  8105da:	c7 43 30 01 00 00 00 	movl   $0x1,0x30(%rbx)
  settings->force_palette = 0;
  8105e1:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%rbx)
  settings->predefined_filters = 0;
  8105e8:	48 c7 43 40 00 00 00 	movq   $0x0,0x40(%rbx)
  8105ef:	00 
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
  8105f0:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%rbx)
  settings->text_compression = 1;
  8105f7:	c7 43 50 01 00 00 00 	movl   $0x1,0x50(%rbx)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
  8105fe:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  810602:	c9                   	leave  
  810603:	c3                   	ret    

0000000000810604 <lodepng_state_init>:
void lodepng_state_init(LodePNGState* state) {
  810604:	55                   	push   %rbp
  810605:	48 89 e5             	mov    %rsp,%rbp
  810608:	53                   	push   %rbx
  810609:	48 83 ec 08          	sub    $0x8,%rsp
  81060d:	48 89 fb             	mov    %rdi,%rbx
  lodepng_decoder_settings_init(&state->decoder);
  810610:	48 b8 8f eb 80 00 00 	movabs $0x80eb8f,%rax
  810617:	00 00 00 
  81061a:	ff d0                	call   *%rax
  lodepng_encoder_settings_init(&state->encoder);
  81061c:	48 8d 7b 38          	lea    0x38(%rbx),%rdi
  810620:	48 b8 b4 05 81 00 00 	movabs $0x8105b4,%rax
  810627:	00 00 00 
  81062a:	ff d0                	call   *%rax
  lodepng_color_mode_init(&state->info_raw);
  81062c:	48 8d bb 90 00 00 00 	lea    0x90(%rbx),%rdi
  810633:	48 b8 01 91 80 00 00 	movabs $0x809101,%rax
  81063a:	00 00 00 
  81063d:	ff d0                	call   *%rax
  lodepng_info_init(&state->info_png);
  81063f:	48 8d bb b8 00 00 00 	lea    0xb8(%rbx),%rdi
  810646:	48 b8 9d b0 80 00 00 	movabs $0x80b09d,%rax
  81064d:	00 00 00 
  810650:	ff d0                	call   *%rax
  state->error = 1;
  810652:	c7 83 f0 01 00 00 01 	movl   $0x1,0x1f0(%rbx)
  810659:	00 00 00 
}
  81065c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  810660:	c9                   	leave  
  810661:	c3                   	ret    

0000000000810662 <lodepng_decode_memory>:
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
  810662:	55                   	push   %rbp
  810663:	48 89 e5             	mov    %rsp,%rbp
  810666:	41 57                	push   %r15
  810668:	41 56                	push   %r14
  81066a:	41 55                	push   %r13
  81066c:	41 54                	push   %r12
  81066e:	53                   	push   %rbx
  81066f:	48 81 ec 18 02 00 00 	sub    $0x218,%rsp
  810676:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
  81067d:	48 89 f3             	mov    %rsi,%rbx
  810680:	49 89 d4             	mov    %rdx,%r12
  810683:	49 89 cd             	mov    %rcx,%r13
  810686:	4d 89 c6             	mov    %r8,%r14
  810689:	45 89 cf             	mov    %r9d,%r15d
  lodepng_state_init(&state);
  81068c:	48 8d 85 d8 fd ff ff 	lea    -0x228(%rbp),%rax
  810693:	48 89 c7             	mov    %rax,%rdi
  810696:	48 b8 04 06 81 00 00 	movabs $0x810604,%rax
  81069d:	00 00 00 
  8106a0:	ff d0                	call   *%rax
  state.info_raw.colortype = colortype;
  8106a2:	44 89 bd 68 fe ff ff 	mov    %r15d,-0x198(%rbp)
  state.info_raw.bitdepth = bitdepth;
  8106a9:	8b 45 10             	mov    0x10(%rbp),%eax
  8106ac:	89 85 6c fe ff ff    	mov    %eax,-0x194(%rbp)
  error = lodepng_decode(out, w, h, &state, in, insize);
  8106b2:	4d 89 f1             	mov    %r14,%r9
  8106b5:	4d 89 e8             	mov    %r13,%r8
  8106b8:	48 8d 8d d8 fd ff ff 	lea    -0x228(%rbp),%rcx
  8106bf:	4c 89 e2             	mov    %r12,%rdx
  8106c2:	48 89 de             	mov    %rbx,%rsi
  8106c5:	48 8b bd c8 fd ff ff 	mov    -0x238(%rbp),%rdi
  8106cc:	48 b8 34 d8 80 00 00 	movabs $0x80d834,%rax
  8106d3:	00 00 00 
  8106d6:	ff d0                	call   *%rax
  8106d8:	89 c3                	mov    %eax,%ebx
  lodepng_state_cleanup(&state);
  8106da:	48 8d bd d8 fd ff ff 	lea    -0x228(%rbp),%rdi
  8106e1:	48 b8 cb eb 80 00 00 	movabs $0x80ebcb,%rax
  8106e8:	00 00 00 
  8106eb:	ff d0                	call   *%rax
}
  8106ed:	89 d8                	mov    %ebx,%eax
  8106ef:	48 81 c4 18 02 00 00 	add    $0x218,%rsp
  8106f6:	5b                   	pop    %rbx
  8106f7:	41 5c                	pop    %r12
  8106f9:	41 5d                	pop    %r13
  8106fb:	41 5e                	pop    %r14
  8106fd:	41 5f                	pop    %r15
  8106ff:	5d                   	pop    %rbp
  810700:	c3                   	ret    

0000000000810701 <lodepng_decode32>:
unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
  810701:	55                   	push   %rbp
  810702:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
  810705:	48 83 ec 08          	sub    $0x8,%rsp
  810709:	6a 08                	push   $0x8
  81070b:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  810711:	48 b8 62 06 81 00 00 	movabs $0x810662,%rax
  810718:	00 00 00 
  81071b:	ff d0                	call   *%rax
}
  81071d:	c9                   	leave  
  81071e:	c3                   	ret    

000000000081071f <lodepng_decode24>:
unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
  81071f:	55                   	push   %rbp
  810720:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
  810723:	48 83 ec 08          	sub    $0x8,%rsp
  810727:	6a 08                	push   $0x8
  810729:	41 b9 02 00 00 00    	mov    $0x2,%r9d
  81072f:	48 b8 62 06 81 00 00 	movabs $0x810662,%rax
  810736:	00 00 00 
  810739:	ff d0                	call   *%rax
}
  81073b:	c9                   	leave  
  81073c:	c3                   	ret    

000000000081073d <lodepng_decode_file>:
                             LodePNGColorType colortype, unsigned bitdepth) {
  81073d:	55                   	push   %rbp
  81073e:	48 89 e5             	mov    %rsp,%rbp
  810741:	41 57                	push   %r15
  810743:	41 56                	push   %r14
  810745:	41 55                	push   %r13
  810747:	41 54                	push   %r12
  810749:	53                   	push   %rbx
  81074a:	48 83 ec 28          	sub    $0x28,%rsp
  81074e:	49 89 fc             	mov    %rdi,%r12
  810751:	49 89 f5             	mov    %rsi,%r13
  810754:	49 89 d6             	mov    %rdx,%r14
  810757:	48 89 ca             	mov    %rcx,%rdx
  81075a:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
  81075e:	45 89 cf             	mov    %r9d,%r15d
  unsigned char* buffer = 0;
  810761:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  810768:	00 
  *out = 0;
  810769:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
  *w = *h = 0;
  810770:	41 c7 06 00 00 00 00 	movl   $0x0,(%r14)
  810777:	c7 06 00 00 00 00    	movl   $0x0,(%rsi)
  error = lodepng_load_file(&buffer, &buffersize, filename);
  81077d:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  810781:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  810785:	48 b8 1e 5c 80 00 00 	movabs $0x805c1e,%rax
  81078c:	00 00 00 
  81078f:	ff d0                	call   *%rax
  810791:	89 c3                	mov    %eax,%ebx
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
  810793:	85 c0                	test   %eax,%eax
  810795:	74 21                	je     8107b8 <lodepng_decode_file+0x7b>
    jos_free(ptr);
  810797:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  81079b:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  8107a2:	00 00 00 
  8107a5:	ff d0                	call   *%rax
}
  8107a7:	89 d8                	mov    %ebx,%eax
  8107a9:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  8107ad:	5b                   	pop    %rbx
  8107ae:	41 5c                	pop    %r12
  8107b0:	41 5d                	pop    %r13
  8107b2:	41 5e                	pop    %r14
  8107b4:	41 5f                	pop    %r15
  8107b6:	5d                   	pop    %rbp
  8107b7:	c3                   	ret    
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
  8107b8:	48 83 ec 08          	sub    $0x8,%rsp
  8107bc:	41 57                	push   %r15
  8107be:	44 8b 4d bc          	mov    -0x44(%rbp),%r9d
  8107c2:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  8107c6:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8107ca:	4c 89 f2             	mov    %r14,%rdx
  8107cd:	4c 89 ee             	mov    %r13,%rsi
  8107d0:	4c 89 e7             	mov    %r12,%rdi
  8107d3:	48 b8 62 06 81 00 00 	movabs $0x810662,%rax
  8107da:	00 00 00 
  8107dd:	ff d0                	call   *%rax
  8107df:	89 c3                	mov    %eax,%ebx
  8107e1:	48 83 c4 10          	add    $0x10,%rsp
  8107e5:	eb b0                	jmp    810797 <lodepng_decode_file+0x5a>

00000000008107e7 <lodepng_decode32_file>:
unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
  8107e7:	55                   	push   %rbp
  8107e8:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
  8107eb:	41 b9 08 00 00 00    	mov    $0x8,%r9d
  8107f1:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  8107f7:	48 b8 3d 07 81 00 00 	movabs $0x81073d,%rax
  8107fe:	00 00 00 
  810801:	ff d0                	call   *%rax
}
  810803:	5d                   	pop    %rbp
  810804:	c3                   	ret    

0000000000810805 <lodepng_decode24_file>:
unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
  810805:	55                   	push   %rbp
  810806:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
  810809:	41 b9 08 00 00 00    	mov    $0x8,%r9d
  81080f:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  810815:	48 b8 3d 07 81 00 00 	movabs $0x81073d,%rax
  81081c:	00 00 00 
  81081f:	ff d0                	call   *%rax
}
  810821:	5d                   	pop    %rbp
  810822:	c3                   	ret    

0000000000810823 <lodepng_encode_memory>:
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
  810823:	55                   	push   %rbp
  810824:	48 89 e5             	mov    %rsp,%rbp
  810827:	41 57                	push   %r15
  810829:	41 56                	push   %r14
  81082b:	41 55                	push   %r13
  81082d:	41 54                	push   %r12
  81082f:	53                   	push   %rbx
  810830:	48 81 ec 18 02 00 00 	sub    $0x218,%rsp
  810837:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
  81083e:	48 89 b5 c0 fd ff ff 	mov    %rsi,-0x240(%rbp)
  810845:	49 89 d4             	mov    %rdx,%r12
  810848:	41 89 cd             	mov    %ecx,%r13d
  81084b:	45 89 c6             	mov    %r8d,%r14d
  81084e:	44 89 cb             	mov    %r9d,%ebx
  810851:	44 8b 7d 10          	mov    0x10(%rbp),%r15d
  lodepng_state_init(&state);
  810855:	48 8d 85 d8 fd ff ff 	lea    -0x228(%rbp),%rax
  81085c:	48 89 c7             	mov    %rax,%rdi
  81085f:	48 b8 04 06 81 00 00 	movabs $0x810604,%rax
  810866:	00 00 00 
  810869:	ff d0                	call   *%rax
  state.info_raw.colortype = colortype;
  81086b:	89 9d 68 fe ff ff    	mov    %ebx,-0x198(%rbp)
  state.info_raw.bitdepth = bitdepth;
  810871:	44 89 bd 6c fe ff ff 	mov    %r15d,-0x194(%rbp)
  state.info_png.color.colortype = colortype;
  810878:	89 9d a0 fe ff ff    	mov    %ebx,-0x160(%rbp)
  state.info_png.color.bitdepth = bitdepth;
  81087e:	44 89 bd a4 fe ff ff 	mov    %r15d,-0x15c(%rbp)
  lodepng_encode(out, outsize, image, w, h, &state);
  810885:	4c 8d 8d d8 fd ff ff 	lea    -0x228(%rbp),%r9
  81088c:	45 89 f0             	mov    %r14d,%r8d
  81088f:	44 89 e9             	mov    %r13d,%ecx
  810892:	4c 89 e2             	mov    %r12,%rdx
  810895:	48 8b b5 c0 fd ff ff 	mov    -0x240(%rbp),%rsi
  81089c:	48 8b bd c8 fd ff ff 	mov    -0x238(%rbp),%rdi
  8108a3:	48 b8 ac ec 80 00 00 	movabs $0x80ecac,%rax
  8108aa:	00 00 00 
  8108ad:	ff d0                	call   *%rax
  error = state.error;
  8108af:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  lodepng_state_cleanup(&state);
  8108b2:	48 8d bd d8 fd ff ff 	lea    -0x228(%rbp),%rdi
  8108b9:	48 b8 cb eb 80 00 00 	movabs $0x80ebcb,%rax
  8108c0:	00 00 00 
  8108c3:	ff d0                	call   *%rax
}
  8108c5:	89 d8                	mov    %ebx,%eax
  8108c7:	48 81 c4 18 02 00 00 	add    $0x218,%rsp
  8108ce:	5b                   	pop    %rbx
  8108cf:	41 5c                	pop    %r12
  8108d1:	41 5d                	pop    %r13
  8108d3:	41 5e                	pop    %r14
  8108d5:	41 5f                	pop    %r15
  8108d7:	5d                   	pop    %rbp
  8108d8:	c3                   	ret    

00000000008108d9 <lodepng_encode32>:
unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
  8108d9:	55                   	push   %rbp
  8108da:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
  8108dd:	48 83 ec 08          	sub    $0x8,%rsp
  8108e1:	6a 08                	push   $0x8
  8108e3:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8108e9:	48 b8 23 08 81 00 00 	movabs $0x810823,%rax
  8108f0:	00 00 00 
  8108f3:	ff d0                	call   *%rax
}
  8108f5:	c9                   	leave  
  8108f6:	c3                   	ret    

00000000008108f7 <lodepng_encode24>:
unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
  8108f7:	55                   	push   %rbp
  8108f8:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
  8108fb:	48 83 ec 08          	sub    $0x8,%rsp
  8108ff:	6a 08                	push   $0x8
  810901:	41 b9 02 00 00 00    	mov    $0x2,%r9d
  810907:	48 b8 23 08 81 00 00 	movabs $0x810823,%rax
  81090e:	00 00 00 
  810911:	ff d0                	call   *%rax
}
  810913:	c9                   	leave  
  810914:	c3                   	ret    

0000000000810915 <lodepng_encode_file>:
                             LodePNGColorType colortype, unsigned bitdepth) {
  810915:	55                   	push   %rbp
  810916:	48 89 e5             	mov    %rsp,%rbp
  810919:	41 54                	push   %r12
  81091b:	53                   	push   %rbx
  81091c:	48 83 ec 18          	sub    $0x18,%rsp
  810920:	49 89 fc             	mov    %rdi,%r12
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
  810923:	41 51                	push   %r9
  810925:	45 89 c1             	mov    %r8d,%r9d
  810928:	41 89 c8             	mov    %ecx,%r8d
  81092b:	89 d1                	mov    %edx,%ecx
  81092d:	48 89 f2             	mov    %rsi,%rdx
  810930:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  810934:	48 8d 7d e8          	lea    -0x18(%rbp),%rdi
  810938:	48 b8 23 08 81 00 00 	movabs $0x810823,%rax
  81093f:	00 00 00 
  810942:	ff d0                	call   *%rax
  810944:	89 c3                	mov    %eax,%ebx
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
  810946:	48 83 c4 10          	add    $0x10,%rsp
  81094a:	85 c0                	test   %eax,%eax
  81094c:	74 1b                	je     810969 <lodepng_encode_file+0x54>
    jos_free(ptr);
  81094e:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  810952:	48 b8 be 0e 81 00 00 	movabs $0x810ebe,%rax
  810959:	00 00 00 
  81095c:	ff d0                	call   *%rax
}
  81095e:	89 d8                	mov    %ebx,%eax
  810960:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  810964:	5b                   	pop    %rbx
  810965:	41 5c                	pop    %r12
  810967:	5d                   	pop    %rbp
  810968:	c3                   	ret    
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
  810969:	4c 89 e2             	mov    %r12,%rdx
  81096c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  810970:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  810974:	48 b8 37 5d 80 00 00 	movabs $0x805d37,%rax
  81097b:	00 00 00 
  81097e:	ff d0                	call   *%rax
  810980:	89 c3                	mov    %eax,%ebx
  810982:	eb ca                	jmp    81094e <lodepng_encode_file+0x39>

0000000000810984 <lodepng_encode32_file>:
unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
  810984:	55                   	push   %rbp
  810985:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
  810988:	41 b9 08 00 00 00    	mov    $0x8,%r9d
  81098e:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  810994:	48 b8 15 09 81 00 00 	movabs $0x810915,%rax
  81099b:	00 00 00 
  81099e:	ff d0                	call   *%rax
}
  8109a0:	5d                   	pop    %rbp
  8109a1:	c3                   	ret    

00000000008109a2 <lodepng_encode24_file>:
unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
  8109a2:	55                   	push   %rbp
  8109a3:	48 89 e5             	mov    %rsp,%rbp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
  8109a6:	41 b9 08 00 00 00    	mov    $0x8,%r9d
  8109ac:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  8109b2:	48 b8 15 09 81 00 00 	movabs $0x810915,%rax
  8109b9:	00 00 00 
  8109bc:	ff d0                	call   *%rax
}
  8109be:	5d                   	pop    %rbp
  8109bf:	c3                   	ret    

00000000008109c0 <lodepng_error_text>:
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
  switch(code) {
  8109c0:	83 ff 6c             	cmp    $0x6c,%edi
  8109c3:	0f 87 19 04 00 00    	ja     810de2 <lodepng_error_text+0x422>
  8109c9:	89 ff                	mov    %edi,%edi
  8109cb:	48 b8 e0 1b 81 00 00 	movabs $0x811be0,%rax
  8109d2:	00 00 00 
  8109d5:	ff 24 f8             	jmp    *(%rax,%rdi,8)
  8109d8:	48 b8 77 28 81 00 00 	movabs $0x812877,%rax
  8109df:	00 00 00 
  8109e2:	c3                   	ret    
    case 0: return "no error, everything went ok";
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
  8109e3:	48 b8 98 28 81 00 00 	movabs $0x812898,%rax
  8109ea:	00 00 00 
  8109ed:	c3                   	ret    
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
  8109ee:	48 b8 d0 28 81 00 00 	movabs $0x8128d0,%rax
  8109f5:	00 00 00 
  8109f8:	c3                   	ret    
    case 13: return "problem while processing dynamic deflate block";
  8109f9:	48 b8 08 29 81 00 00 	movabs $0x812908,%rax
  810a00:	00 00 00 
  810a03:	c3                   	ret    
    case 14: return "problem while processing dynamic deflate block";
  810a04:	48 b8 08 29 81 00 00 	movabs $0x812908,%rax
  810a0b:	00 00 00 
  810a0e:	c3                   	ret    
    case 15: return "problem while processing dynamic deflate block";
  810a0f:	48 b8 08 29 81 00 00 	movabs $0x812908,%rax
  810a16:	00 00 00 
  810a19:	c3                   	ret    
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "nonexistent code while processing dynamic deflate block";
  810a1a:	48 b8 38 29 81 00 00 	movabs $0x812938,%rax
  810a21:	00 00 00 
  810a24:	c3                   	ret    
    case 17: return "end of out buffer memory reached while inflating";
  810a25:	48 b8 70 29 81 00 00 	movabs $0x812970,%rax
  810a2c:	00 00 00 
  810a2f:	c3                   	ret    
    case 18: return "invalid distance code while inflating";
  810a30:	48 b8 a8 29 81 00 00 	movabs $0x8129a8,%rax
  810a37:	00 00 00 
  810a3a:	c3                   	ret    
    case 19: return "end of out buffer memory reached while inflating";
  810a3b:	48 b8 70 29 81 00 00 	movabs $0x812970,%rax
  810a42:	00 00 00 
  810a45:	c3                   	ret    
    case 20: return "invalid deflate block BTYPE encountered while decoding";
  810a46:	48 b8 d0 29 81 00 00 	movabs $0x8129d0,%rax
  810a4d:	00 00 00 
  810a50:	c3                   	ret    
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
  810a51:	48 b8 08 2a 81 00 00 	movabs $0x812a08,%rax
  810a58:	00 00 00 
  810a5b:	c3                   	ret    

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
  810a5c:	48 b8 70 29 81 00 00 	movabs $0x812970,%rax
  810a63:	00 00 00 
  810a66:	c3                   	ret    
    case 23: return "end of in buffer memory reached while inflating";
  810a67:	48 b8 40 2a 81 00 00 	movabs $0x812a40,%rax
  810a6e:	00 00 00 
  810a71:	c3                   	ret    
    case 24: return "invalid FCHECK in zlib header";
  810a72:	48 b8 1d 27 81 00 00 	movabs $0x81271d,%rax
  810a79:	00 00 00 
  810a7c:	c3                   	ret    
    case 25: return "invalid compression method in zlib header";
  810a7d:	48 b8 70 2a 81 00 00 	movabs $0x812a70,%rax
  810a84:	00 00 00 
  810a87:	c3                   	ret    
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
  810a88:	48 b8 a0 2a 81 00 00 	movabs $0x812aa0,%rax
  810a8f:	00 00 00 
  810a92:	c3                   	ret    
    case 27: return "PNG file is smaller than a PNG header";
  810a93:	48 b8 e0 2a 81 00 00 	movabs $0x812ae0,%rax
  810a9a:	00 00 00 
  810a9d:	c3                   	ret    
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
  810a9e:	48 b8 08 2b 81 00 00 	movabs $0x812b08,%rax
  810aa5:	00 00 00 
  810aa8:	c3                   	ret    
    case 29: return "first chunk is not the header chunk";
  810aa9:	48 b8 40 2b 81 00 00 	movabs $0x812b40,%rax
  810ab0:	00 00 00 
  810ab3:	c3                   	ret    
    case 30: return "chunk length too large, chunk broken off at end of file";
  810ab4:	48 b8 68 2b 81 00 00 	movabs $0x812b68,%rax
  810abb:	00 00 00 
  810abe:	c3                   	ret    
    case 31: return "illegal PNG color type or bpp";
  810abf:	48 b8 3b 27 81 00 00 	movabs $0x81273b,%rax
  810ac6:	00 00 00 
  810ac9:	c3                   	ret    
    case 32: return "illegal PNG compression method";
  810aca:	48 b8 a0 2b 81 00 00 	movabs $0x812ba0,%rax
  810ad1:	00 00 00 
  810ad4:	c3                   	ret    
    case 33: return "illegal PNG filter method";
  810ad5:	48 b8 59 27 81 00 00 	movabs $0x812759,%rax
  810adc:	00 00 00 
  810adf:	c3                   	ret    
    case 34: return "illegal PNG interlace method";
  810ae0:	48 b8 73 27 81 00 00 	movabs $0x812773,%rax
  810ae7:	00 00 00 
  810aea:	c3                   	ret    
    case 35: return "chunk length of a chunk is too large or the chunk too small";
  810aeb:	48 b8 c0 2b 81 00 00 	movabs $0x812bc0,%rax
  810af2:	00 00 00 
  810af5:	c3                   	ret    
    case 36: return "illegal PNG filter type encountered";
  810af6:	48 b8 00 2c 81 00 00 	movabs $0x812c00,%rax
  810afd:	00 00 00 
  810b00:	c3                   	ret    
    case 37: return "illegal bit depth for this color type given";
  810b01:	48 b8 28 2c 81 00 00 	movabs $0x812c28,%rax
  810b08:	00 00 00 
  810b0b:	c3                   	ret    
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
  810b0c:	48 b8 58 2c 81 00 00 	movabs $0x812c58,%rax
  810b13:	00 00 00 
  810b16:	c3                   	ret    
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
  810b17:	48 b8 80 2c 81 00 00 	movabs $0x812c80,%rax
  810b1e:	00 00 00 
  810b21:	c3                   	ret    
    case 40: return "tRNS chunk has wrong size for grayscale image";
  810b22:	48 b8 c0 2c 81 00 00 	movabs $0x812cc0,%rax
  810b29:	00 00 00 
  810b2c:	c3                   	ret    
    case 41: return "tRNS chunk has wrong size for RGB image";
  810b2d:	48 b8 f0 2c 81 00 00 	movabs $0x812cf0,%rax
  810b34:	00 00 00 
  810b37:	c3                   	ret    
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
  810b38:	48 b8 18 2d 81 00 00 	movabs $0x812d18,%rax
  810b3f:	00 00 00 
  810b42:	c3                   	ret    
    case 43: return "bKGD chunk has wrong size for palette image";
  810b43:	48 b8 60 2d 81 00 00 	movabs $0x812d60,%rax
  810b4a:	00 00 00 
  810b4d:	c3                   	ret    
    case 44: return "bKGD chunk has wrong size for grayscale image";
  810b4e:	48 b8 90 2d 81 00 00 	movabs $0x812d90,%rax
  810b55:	00 00 00 
  810b58:	c3                   	ret    
    case 45: return "bKGD chunk has wrong size for RGB image";
  810b59:	48 b8 c0 2d 81 00 00 	movabs $0x812dc0,%rax
  810b60:	00 00 00 
  810b63:	c3                   	ret    
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
  810b64:	48 b8 e8 2d 81 00 00 	movabs $0x812de8,%rax
  810b6b:	00 00 00 
  810b6e:	c3                   	ret    
    case 49: return "jumped past memory while generating dynamic huffman tree";
  810b6f:	48 b8 30 2e 81 00 00 	movabs $0x812e30,%rax
  810b76:	00 00 00 
  810b79:	c3                   	ret    
    case 50: return "jumped past memory while generating dynamic huffman tree";
  810b7a:	48 b8 30 2e 81 00 00 	movabs $0x812e30,%rax
  810b81:	00 00 00 
  810b84:	c3                   	ret    
    case 51: return "jumped past memory while inflating huffman block";
  810b85:	48 b8 70 2e 81 00 00 	movabs $0x812e70,%rax
  810b8c:	00 00 00 
  810b8f:	c3                   	ret    
    case 52: return "jumped past memory while inflating";
  810b90:	48 b8 a8 2e 81 00 00 	movabs $0x812ea8,%rax
  810b97:	00 00 00 
  810b9a:	c3                   	ret    
    case 53: return "size of zlib data too small";
  810b9b:	48 b8 90 27 81 00 00 	movabs $0x812790,%rax
  810ba2:	00 00 00 
  810ba5:	c3                   	ret    
    case 54: return "repeat symbol in tree while there was no value symbol yet";
  810ba6:	48 b8 d0 2e 81 00 00 	movabs $0x812ed0,%rax
  810bad:	00 00 00 
  810bb0:	c3                   	ret    
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
  810bb1:	48 b8 10 2f 81 00 00 	movabs $0x812f10,%rax
  810bb8:	00 00 00 
  810bbb:	c3                   	ret    
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
  810bbc:	48 b8 40 2f 81 00 00 	movabs $0x812f40,%rax
  810bc3:	00 00 00 
  810bc6:	c3                   	ret    
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
  810bc7:	48 b8 90 2f 81 00 00 	movabs $0x812f90,%rax
  810bce:	00 00 00 
  810bd1:	c3                   	ret    
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
  810bd2:	48 b8 c8 2f 81 00 00 	movabs $0x812fc8,%rax
  810bd9:	00 00 00 
  810bdc:	c3                   	ret    
    case 59: return "requested color conversion not supported";
  810bdd:	48 b8 08 30 81 00 00 	movabs $0x813008,%rax
  810be4:	00 00 00 
  810be7:	c3                   	ret    
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
  810be8:	48 b8 38 30 81 00 00 	movabs $0x813038,%rax
  810bef:	00 00 00 
  810bf2:	c3                   	ret    
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
  810bf3:	48 b8 88 30 81 00 00 	movabs $0x813088,%rax
  810bfa:	00 00 00 
  810bfd:	c3                   	ret    
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
  810bfe:	48 b8 e0 30 81 00 00 	movabs $0x8130e0,%rax
  810c05:	00 00 00 
  810c08:	c3                   	ret    
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
  810c09:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  810c10:	00 00 00 
  810c13:	c3                   	ret    
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
  810c14:	48 b8 68 31 81 00 00 	movabs $0x813168,%rax
  810c1b:	00 00 00 
  810c1e:	c3                   	ret    
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
  810c1f:	48 b8 a8 31 81 00 00 	movabs $0x8131a8,%rax
  810c26:	00 00 00 
  810c29:	c3                   	ret    
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
  810c2a:	48 b8 08 32 81 00 00 	movabs $0x813208,%rax
  810c31:	00 00 00 
  810c34:	c3                   	ret    
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
  810c35:	48 b8 68 32 81 00 00 	movabs $0x813268,%rax
  810c3c:	00 00 00 
  810c3f:	c3                   	ret    
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
  810c40:	48 b8 c8 32 81 00 00 	movabs $0x8132c8,%rax
  810c47:	00 00 00 
  810c4a:	c3                   	ret    
    case 71: return "nonexistent interlace mode given to encoder (must be 0 or 1)";
  810c4b:	48 b8 10 33 81 00 00 	movabs $0x813310,%rax
  810c52:	00 00 00 
  810c55:	c3                   	ret    
    case 72: return "while decoding, nonexistent compression method encountering in zTXt or iTXt chunk (it must be 0)";
  810c56:	48 b8 50 33 81 00 00 	movabs $0x813350,%rax
  810c5d:	00 00 00 
  810c60:	c3                   	ret    
    case 73: return "invalid tIME chunk size";
  810c61:	48 b8 ac 27 81 00 00 	movabs $0x8127ac,%rax
  810c68:	00 00 00 
  810c6b:	c3                   	ret    
    case 74: return "invalid pHYs chunk size";
  810c6c:	48 b8 c4 27 81 00 00 	movabs $0x8127c4,%rax
  810c73:	00 00 00 
  810c76:	c3                   	ret    
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
  810c77:	48 b8 b8 33 81 00 00 	movabs $0x8133b8,%rax
  810c7e:	00 00 00 
  810c81:	c3                   	ret    
    case 76: return "iTXt chunk too short to contain required bytes";
  810c82:	48 b8 f8 33 81 00 00 	movabs $0x8133f8,%rax
  810c89:	00 00 00 
  810c8c:	c3                   	ret    
    case 77: return "integer overflow in buffer size";
  810c8d:	48 b8 28 34 81 00 00 	movabs $0x813428,%rax
  810c94:	00 00 00 
  810c97:	c3                   	ret    
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
  810c98:	48 b8 48 34 81 00 00 	movabs $0x813448,%rax
  810c9f:	00 00 00 
  810ca2:	c3                   	ret    
    case 79: return "failed to open file for writing";
  810ca3:	48 b8 68 34 81 00 00 	movabs $0x813468,%rax
  810caa:	00 00 00 
  810cad:	c3                   	ret    
    case 80: return "tried creating a tree of 0 symbols";
  810cae:	48 b8 88 34 81 00 00 	movabs $0x813488,%rax
  810cb5:	00 00 00 
  810cb8:	c3                   	ret    
    case 81: return "lazy matching at pos 0 is impossible";
  810cb9:	48 b8 b0 34 81 00 00 	movabs $0x8134b0,%rax
  810cc0:	00 00 00 
  810cc3:	c3                   	ret    
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
  810cc4:	48 b8 d8 34 81 00 00 	movabs $0x8134d8,%rax
  810ccb:	00 00 00 
  810cce:	c3                   	ret    
    case 83: return "memory allocation failed";
  810ccf:	48 b8 dc 27 81 00 00 	movabs $0x8127dc,%rax
  810cd6:	00 00 00 
  810cd9:	c3                   	ret    
    case 84: return "given image too small to contain all pixels to be encoded";
  810cda:	48 b8 38 35 81 00 00 	movabs $0x813538,%rax
  810ce1:	00 00 00 
  810ce4:	c3                   	ret    
    case 86: return "impossible offset in lz77 encoding (internal bug)";
  810ce5:	48 b8 78 35 81 00 00 	movabs $0x813578,%rax
  810cec:	00 00 00 
  810cef:	c3                   	ret    
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
  810cf0:	48 b8 b0 35 81 00 00 	movabs $0x8135b0,%rax
  810cf7:	00 00 00 
  810cfa:	c3                   	ret    
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
  810cfb:	48 b8 08 36 81 00 00 	movabs $0x813608,%rax
  810d02:	00 00 00 
  810d05:	c3                   	ret    
    case 89: return "text chunk keyword too short or long: must have size 1-79";
  810d06:	48 b8 58 36 81 00 00 	movabs $0x813658,%rax
  810d0d:	00 00 00 
  810d10:	c3                   	ret    
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
  810d11:	48 b8 98 36 81 00 00 	movabs $0x813698,%rax
  810d18:	00 00 00 
  810d1b:	c3                   	ret    
    case 91: return "invalid decompressed idat size";
  810d1c:	48 b8 c0 36 81 00 00 	movabs $0x8136c0,%rax
  810d23:	00 00 00 
  810d26:	c3                   	ret    
    case 92: return "integer overflow due to too many pixels";
  810d27:	48 b8 e0 36 81 00 00 	movabs $0x8136e0,%rax
  810d2e:	00 00 00 
  810d31:	c3                   	ret    
    case 93: return "zero width or height is invalid";
  810d32:	48 b8 08 37 81 00 00 	movabs $0x813708,%rax
  810d39:	00 00 00 
  810d3c:	c3                   	ret    
    case 94: return "header chunk must have a size of 13 bytes";
  810d3d:	48 b8 28 37 81 00 00 	movabs $0x813728,%rax
  810d44:	00 00 00 
  810d47:	c3                   	ret    
    case 95: return "integer overflow with combined idat chunk size";
  810d48:	48 b8 58 37 81 00 00 	movabs $0x813758,%rax
  810d4f:	00 00 00 
  810d52:	c3                   	ret    
    case 96: return "invalid gAMA chunk size";
  810d53:	48 b8 f5 27 81 00 00 	movabs $0x8127f5,%rax
  810d5a:	00 00 00 
  810d5d:	c3                   	ret    
    case 97: return "invalid cHRM chunk size";
  810d5e:	48 b8 0d 28 81 00 00 	movabs $0x81280d,%rax
  810d65:	00 00 00 
  810d68:	c3                   	ret    
    case 98: return "invalid sRGB chunk size";
  810d69:	48 b8 25 28 81 00 00 	movabs $0x812825,%rax
  810d70:	00 00 00 
  810d73:	c3                   	ret    
    case 99: return "invalid sRGB rendering intent";
  810d74:	48 b8 3d 28 81 00 00 	movabs $0x81283d,%rax
  810d7b:	00 00 00 
  810d7e:	c3                   	ret    
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
  810d7f:	48 b8 88 37 81 00 00 	movabs $0x813788,%rax
  810d86:	00 00 00 
  810d89:	c3                   	ret    
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
  810d8a:	48 b8 d8 37 81 00 00 	movabs $0x8137d8,%rax
  810d91:	00 00 00 
  810d94:	c3                   	ret    
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
  810d95:	48 b8 30 38 81 00 00 	movabs $0x813830,%rax
  810d9c:	00 00 00 
  810d9f:	c3                   	ret    
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
  810da0:	48 b8 88 38 81 00 00 	movabs $0x813888,%rax
  810da7:	00 00 00 
  810daa:	c3                   	ret    
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
  810dab:	48 b8 d0 38 81 00 00 	movabs $0x8138d0,%rax
  810db2:	00 00 00 
  810db5:	c3                   	ret    
    case 105: return "integer overflow of bitsize";
  810db6:	48 b8 5b 28 81 00 00 	movabs $0x81285b,%rax
  810dbd:	00 00 00 
  810dc0:	c3                   	ret    
    case 106: return "PNG file must have PLTE chunk if color type is palette";
  810dc1:	48 b8 18 39 81 00 00 	movabs $0x813918,%rax
  810dc8:	00 00 00 
  810dcb:	c3                   	ret    
    case 107: return "color convert from palette mode requested without setting the palette data in it";
  810dcc:	48 b8 50 39 81 00 00 	movabs $0x813950,%rax
  810dd3:	00 00 00 
  810dd6:	c3                   	ret    
    case 108: return "tried to add more than 256 values to a palette";
  810dd7:	48 b8 a8 39 81 00 00 	movabs $0x8139a8,%rax
  810dde:	00 00 00 
  810de1:	c3                   	ret    
  }
  return "unknown error code";
  810de2:	48 b8 ed 26 81 00 00 	movabs $0x8126ed,%rax
  810de9:	00 00 00 
  810dec:	c3                   	ret    
    case 0: return "no error, everything went ok";
  810ded:	48 b8 00 27 81 00 00 	movabs $0x812700,%rax
  810df4:	00 00 00 
}
  810df7:	c3                   	ret    

0000000000810df8 <jos_malloc>:
jos_malloc(uint32_t nbytes) {

    /* Make allocator thread-safe with the help of spin_lock/spin_unlock. */
    // LAB 5: Your code here

    size_t nunits = (nbytes + sizeof(Header) - 1) / sizeof(Header) + 1;
  810df8:	89 fe                	mov    %edi,%esi
  810dfa:	48 83 c6 1f          	add    $0x1f,%rsi
  810dfe:	48 c1 ee 05          	shr    $0x5,%rsi
  810e02:	48 83 c6 01          	add    $0x1,%rsi
    /* no free list yet */
    if (!freep) {
  810e06:	48 b8 20 70 81 00 00 	movabs $0x817020,%rax
  810e0d:	00 00 00 
  810e10:	48 83 38 00          	cmpq   $0x0,(%rax)
  810e14:	74 36                	je     810e4c <jos_malloc+0x54>

        freep = &base;
    }


    for (Header *p = freep->next;; p = p->next) {
  810e16:	48 a1 20 70 81 00 00 	movabs 0x817020,%rax
  810e1d:	00 00 00 
  810e20:	48 8b 10             	mov    (%rax),%rdx
        /* big enough */
        if (p->size >= nunits) {
  810e23:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  810e27:	48 39 ce             	cmp    %rcx,%rsi
  810e2a:	76 4f                	jbe    810e7b <jos_malloc+0x83>
            }
            return (void *)(p + 1);
        }

        /* wrapped around free list */
        if (p == freep) {
  810e2c:	48 39 d0             	cmp    %rdx,%rax
  810e2f:	0f 84 83 00 00 00    	je     810eb8 <jos_malloc+0xc0>
    for (Header *p = freep->next;; p = p->next) {
  810e35:	48 8b 12             	mov    (%rdx),%rdx
        if (p->size >= nunits) {
  810e38:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  810e3c:	48 39 f1             	cmp    %rsi,%rcx
  810e3f:	73 3a                	jae    810e7b <jos_malloc+0x83>
        if (p == freep) {
  810e41:	48 39 d0             	cmp    %rdx,%rax
  810e44:	75 ef                	jne    810e35 <jos_malloc+0x3d>
            return NULL;
  810e46:	b8 00 00 00 00       	mov    $0x0,%eax
        }
    }
}
  810e4b:	c3                   	ret    
        hd->next = (Header *)&base;
  810e4c:	48 ba 40 70 81 00 00 	movabs $0x817040,%rdx
  810e53:	00 00 00 
  810e56:	48 b8 a0 40 81 00 00 	movabs $0x8140a0,%rax
  810e5d:	00 00 00 
  810e60:	48 89 02             	mov    %rax,(%rdx)
        hd->prev = (Header *)&base;
  810e63:	48 89 42 08          	mov    %rax,0x8(%rdx)
        hd->size = (SPACE_SIZE - sizeof(Header)) / sizeof(Header);
  810e67:	48 c7 42 10 ff ff 01 	movq   $0x1ffff,0x10(%rdx)
  810e6e:	00 
        freep = &base;
  810e6f:	48 a3 20 70 81 00 00 	movabs %rax,0x817020
  810e76:	00 00 00 
  810e79:	eb 9b                	jmp    810e16 <jos_malloc+0x1e>
            freep = p->prev;
  810e7b:	48 8b 42 08          	mov    0x8(%rdx),%rax
  810e7f:	48 a3 20 70 81 00 00 	movabs %rax,0x817020
  810e86:	00 00 00 
            if (p->size == nunits) {
  810e89:	48 39 ce             	cmp    %rcx,%rsi
  810e8c:	74 17                	je     810ea5 <jos_malloc+0xad>
                p->size -= nunits;
  810e8e:	48 29 f1             	sub    %rsi,%rcx
  810e91:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                p += p->size;
  810e95:	48 c1 e1 05          	shl    $0x5,%rcx
  810e99:	48 01 ca             	add    %rcx,%rdx
                p->size = nunits;
  810e9c:	48 89 72 10          	mov    %rsi,0x10(%rdx)
            return (void *)(p + 1);
  810ea0:	48 8d 42 20          	lea    0x20(%rdx),%rax
  810ea4:	c3                   	ret    
                p->prev->next = p->next;
  810ea5:	48 8b 0a             	mov    (%rdx),%rcx
  810ea8:	48 89 08             	mov    %rcx,(%rax)
                p->next->prev = p->prev;
  810eab:	48 8b 02             	mov    (%rdx),%rax
  810eae:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  810eb2:	48 89 48 08          	mov    %rcx,0x8(%rax)
  810eb6:	eb e8                	jmp    810ea0 <jos_malloc+0xa8>
            return NULL;
  810eb8:	b8 00 00 00 00       	mov    $0x0,%eax
  810ebd:	c3                   	ret    

0000000000810ebe <jos_free>:

/* free: put block ap in free list */
void
jos_free(void *ap) {
   
    if (ap == NULL)
  810ebe:	48 85 ff             	test   %rdi,%rdi
  810ec1:	0f 84 dd 00 00 00    	je     810fa4 <jos_free+0xe6>
        return ;
    /* point to block header */
    Header *bp = (Header *)ap - 1;
  810ec7:	48 8d 4f e0          	lea    -0x20(%rdi),%rcx
    /* Make allocator thread-safe with the help of spin_lock/spin_unlock. */
    // LAB 5: Your code here

    /* freed block at start or end of arena */
    Header *p = freep;
  810ecb:	48 a1 20 70 81 00 00 	movabs 0x817020,%rax
  810ed2:	00 00 00 
    for (; !(bp > p && bp < p->next); p = p->next)
  810ed5:	eb 10                	jmp    810ee7 <jos_free+0x29>
        if (p >= p->next && (bp > p || bp < p->next)) break;
  810ed7:	48 8b 10             	mov    (%rax),%rdx
  810eda:	48 39 c2             	cmp    %rax,%rdx
  810edd:	77 05                	ja     810ee4 <jos_free+0x26>
  810edf:	48 39 ca             	cmp    %rcx,%rdx
  810ee2:	77 15                	ja     810ef9 <jos_free+0x3b>
jos_free(void *ap) {
  810ee4:	48 89 d0             	mov    %rdx,%rax
    for (; !(bp > p && bp < p->next); p = p->next)
  810ee7:	48 39 c8             	cmp    %rcx,%rax
  810eea:	73 eb                	jae    810ed7 <jos_free+0x19>
  810eec:	48 8b 10             	mov    (%rax),%rdx
  810eef:	48 39 ca             	cmp    %rcx,%rdx
  810ef2:	77 05                	ja     810ef9 <jos_free+0x3b>
        if (p >= p->next && (bp > p || bp < p->next)) break;
  810ef4:	48 39 c2             	cmp    %rax,%rdx
  810ef7:	77 eb                	ja     810ee4 <jos_free+0x26>

    if (bp + bp->size == p->next && p + p->size == bp) /* join to both */ {
  810ef9:	48 8b 77 f0          	mov    -0x10(%rdi),%rsi
  810efd:	4c 8b 00             	mov    (%rax),%r8
  810f00:	48 89 f2             	mov    %rsi,%rdx
  810f03:	48 c1 e2 05          	shl    $0x5,%rdx
  810f07:	48 01 ca             	add    %rcx,%rdx
  810f0a:	49 39 d0             	cmp    %rdx,%r8
  810f0d:	74 30                	je     810f3f <jos_free+0x81>
        bp->size += p->next->size;
        bp->next = p->next->next;
        bp->prev = p->next->prev;
        p->next->next->prev = bp;
        p->next = bp;
    } else if (p + p->size == bp) /* join to lower nbr */ {
  810f0f:	4c 8b 48 10          	mov    0x10(%rax),%r9
  810f13:	4c 89 ca             	mov    %r9,%rdx
  810f16:	48 c1 e2 05          	shl    $0x5,%rdx
  810f1a:	48 01 c2             	add    %rax,%rdx
  810f1d:	48 39 d1             	cmp    %rdx,%rcx
  810f20:	74 79                	je     810f9b <jos_free+0xdd>
        p->size += bp->size;
    } else {
        bp->next = p->next;
  810f22:	4c 89 47 e0          	mov    %r8,-0x20(%rdi)
        bp->prev = p;
  810f26:	48 89 47 e8          	mov    %rax,-0x18(%rdi)
        p->next->prev = bp;
  810f2a:	48 8b 10             	mov    (%rax),%rdx
  810f2d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
        p->next = bp;
  810f31:	48 89 08             	mov    %rcx,(%rax)
    }
    freep = p;
  810f34:	48 a3 20 70 81 00 00 	movabs %rax,0x817020
  810f3b:	00 00 00 
  810f3e:	c3                   	ret    
    if (bp + bp->size == p->next && p + p->size == bp) /* join to both */ {
  810f3f:	4c 8b 48 10          	mov    0x10(%rax),%r9
  810f43:	4c 89 ca             	mov    %r9,%rdx
  810f46:	48 c1 e2 05          	shl    $0x5,%rdx
  810f4a:	48 01 c2             	add    %rax,%rdx
  810f4d:	48 39 d1             	cmp    %rdx,%rcx
  810f50:	74 2c                	je     810f7e <jos_free+0xc0>
        bp->size += p->next->size;
  810f52:	49 03 70 10          	add    0x10(%r8),%rsi
  810f56:	48 89 77 f0          	mov    %rsi,-0x10(%rdi)
        bp->next = p->next->next;
  810f5a:	48 8b 10             	mov    (%rax),%rdx
  810f5d:	48 8b 12             	mov    (%rdx),%rdx
  810f60:	48 89 57 e0          	mov    %rdx,-0x20(%rdi)
        bp->prev = p->next->prev;
  810f64:	48 8b 10             	mov    (%rax),%rdx
  810f67:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  810f6b:	48 89 57 e8          	mov    %rdx,-0x18(%rdi)
        p->next->next->prev = bp;
  810f6f:	48 8b 10             	mov    (%rax),%rdx
  810f72:	48 8b 12             	mov    (%rdx),%rdx
  810f75:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
        p->next = bp;
  810f79:	48 89 08             	mov    %rcx,(%rax)
  810f7c:	eb b6                	jmp    810f34 <jos_free+0x76>
        p->size += bp->size + p->next->size;
  810f7e:	4c 01 ce             	add    %r9,%rsi
  810f81:	49 03 70 10          	add    0x10(%r8),%rsi
  810f85:	48 89 70 10          	mov    %rsi,0x10(%rax)
        p->next->next->prev = p;
  810f89:	49 8b 10             	mov    (%r8),%rdx
  810f8c:	48 89 42 08          	mov    %rax,0x8(%rdx)
        p->next = p->next->next;
  810f90:	48 8b 10             	mov    (%rax),%rdx
  810f93:	48 8b 12             	mov    (%rdx),%rdx
  810f96:	48 89 10             	mov    %rdx,(%rax)
  810f99:	eb 99                	jmp    810f34 <jos_free+0x76>
        p->size += bp->size;
  810f9b:	4c 01 ce             	add    %r9,%rsi
  810f9e:	48 89 70 10          	mov    %rsi,0x10(%rax)
  810fa2:	eb 90                	jmp    810f34 <jos_free+0x76>

}
  810fa4:	c3                   	ret    

0000000000810fa5 <devcons_close>:
static int
devcons_close(struct Fd *fd) {
    USED(fd);

    return 0;
}
  810fa5:	b8 00 00 00 00       	mov    $0x0,%eax
  810faa:	c3                   	ret    

0000000000810fab <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat) {
  810fab:	55                   	push   %rbp
  810fac:	48 89 e5             	mov    %rsp,%rbp
  810faf:	48 89 f7             	mov    %rsi,%rdi
    strcpy(stat->st_name, "<cons>");
  810fb2:	48 be d7 39 81 00 00 	movabs $0x8139d7,%rsi
  810fb9:	00 00 00 
  810fbc:	48 b8 a8 0d 80 00 00 	movabs $0x800da8,%rax
  810fc3:	00 00 00 
  810fc6:	ff d0                	call   *%rax
    return 0;
}
  810fc8:	b8 00 00 00 00       	mov    $0x0,%eax
  810fcd:	5d                   	pop    %rbp
  810fce:	c3                   	ret    

0000000000810fcf <devcons_write>:
devcons_write(struct Fd *fd, const void *vbuf, size_t n) {
  810fcf:	55                   	push   %rbp
  810fd0:	48 89 e5             	mov    %rsp,%rbp
  810fd3:	41 57                	push   %r15
  810fd5:	41 56                	push   %r14
  810fd7:	41 55                	push   %r13
  810fd9:	41 54                	push   %r12
  810fdb:	53                   	push   %rbx
  810fdc:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  810fe3:	48 89 b5 48 ff ff ff 	mov    %rsi,-0xb8(%rbp)
    for (res = 0; res < n; res += inc) {
  810fea:	48 85 d2             	test   %rdx,%rdx
  810fed:	74 78                	je     811067 <devcons_write+0x98>
  810fef:	49 89 d6             	mov    %rdx,%r14
  810ff2:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  810ff8:	be 00 00 00 00       	mov    $0x0,%esi
        memmove(buf, (char *)vbuf + res, inc);
  810ffd:	49 bf a3 0f 80 00 00 	movabs $0x800fa3,%r15
  811004:	00 00 00 
        inc = MIN(n - res, WRITEBUFSZ - 1);
  811007:	4c 89 f3             	mov    %r14,%rbx
  81100a:	48 29 f3             	sub    %rsi,%rbx
  81100d:	48 83 fb 7f          	cmp    $0x7f,%rbx
  811011:	b8 7f 00 00 00       	mov    $0x7f,%eax
  811016:	48 0f 47 d8          	cmova  %rax,%rbx
        memmove(buf, (char *)vbuf + res, inc);
  81101a:	4c 63 eb             	movslq %ebx,%r13
  81101d:	48 03 b5 48 ff ff ff 	add    -0xb8(%rbp),%rsi
  811024:	4c 89 ea             	mov    %r13,%rdx
  811027:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
  81102e:	41 ff d7             	call   *%r15
        sys_cputs(buf, inc);
  811031:	4c 89 ee             	mov    %r13,%rsi
  811034:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
  81103b:	48 b8 d9 11 80 00 00 	movabs $0x8011d9,%rax
  811042:	00 00 00 
  811045:	ff d0                	call   *%rax
    for (res = 0; res < n; res += inc) {
  811047:	41 01 dc             	add    %ebx,%r12d
  81104a:	49 63 f4             	movslq %r12d,%rsi
  81104d:	4c 39 f6             	cmp    %r14,%rsi
  811050:	72 b5                	jb     811007 <devcons_write+0x38>
    return res;
  811052:	49 63 c4             	movslq %r12d,%rax
}
  811055:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  81105c:	5b                   	pop    %rbx
  81105d:	41 5c                	pop    %r12
  81105f:	41 5d                	pop    %r13
  811061:	41 5e                	pop    %r14
  811063:	41 5f                	pop    %r15
  811065:	5d                   	pop    %rbp
  811066:	c3                   	ret    
    for (res = 0; res < n; res += inc) {
  811067:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  81106d:	eb e3                	jmp    811052 <devcons_write+0x83>

000000000081106f <devcons_read>:
devcons_read(struct Fd *fd, void *vbuf, size_t n) {
  81106f:	48 89 d0             	mov    %rdx,%rax
    if (!n) return 0;
  811072:	ba 00 00 00 00       	mov    $0x0,%edx
  811077:	48 85 c0             	test   %rax,%rax
  81107a:	74 55                	je     8110d1 <devcons_read+0x62>
devcons_read(struct Fd *fd, void *vbuf, size_t n) {
  81107c:	55                   	push   %rbp
  81107d:	48 89 e5             	mov    %rsp,%rbp
  811080:	41 55                	push   %r13
  811082:	41 54                	push   %r12
  811084:	53                   	push   %rbx
  811085:	48 83 ec 08          	sub    $0x8,%rsp
  811089:	49 89 f5             	mov    %rsi,%r13
    while (!(c = sys_cgetc())) sys_yield();
  81108c:	48 bb 06 12 80 00 00 	movabs $0x801206,%rbx
  811093:	00 00 00 
  811096:	49 bc d3 12 80 00 00 	movabs $0x8012d3,%r12
  81109d:	00 00 00 
  8110a0:	eb 03                	jmp    8110a5 <devcons_read+0x36>
  8110a2:	41 ff d4             	call   *%r12
  8110a5:	ff d3                	call   *%rbx
  8110a7:	85 c0                	test   %eax,%eax
  8110a9:	74 f7                	je     8110a2 <devcons_read+0x33>
    if (c < 0) return c;
  8110ab:	48 63 d0             	movslq %eax,%rdx
  8110ae:	78 13                	js     8110c3 <devcons_read+0x54>
    if (c == 0x04) return 0;
  8110b0:	ba 00 00 00 00       	mov    $0x0,%edx
  8110b5:	83 f8 04             	cmp    $0x4,%eax
  8110b8:	74 09                	je     8110c3 <devcons_read+0x54>
    *(char *)vbuf = (char)c;
  8110ba:	41 88 45 00          	mov    %al,0x0(%r13)
    return 1;
  8110be:	ba 01 00 00 00       	mov    $0x1,%edx
}
  8110c3:	48 89 d0             	mov    %rdx,%rax
  8110c6:	48 83 c4 08          	add    $0x8,%rsp
  8110ca:	5b                   	pop    %rbx
  8110cb:	41 5c                	pop    %r12
  8110cd:	41 5d                	pop    %r13
  8110cf:	5d                   	pop    %rbp
  8110d0:	c3                   	ret    
  8110d1:	48 89 d0             	mov    %rdx,%rax
  8110d4:	c3                   	ret    

00000000008110d5 <cputchar>:
cputchar(int ch) {
  8110d5:	55                   	push   %rbp
  8110d6:	48 89 e5             	mov    %rsp,%rbp
  8110d9:	48 83 ec 10          	sub    $0x10,%rsp
    char c = (char)ch;
  8110dd:	40 88 7d ff          	mov    %dil,-0x1(%rbp)
    sys_cputs(&c, 1);
  8110e1:	be 01 00 00 00       	mov    $0x1,%esi
  8110e6:	48 8d 7d ff          	lea    -0x1(%rbp),%rdi
  8110ea:	48 b8 d9 11 80 00 00 	movabs $0x8011d9,%rax
  8110f1:	00 00 00 
  8110f4:	ff d0                	call   *%rax
}
  8110f6:	c9                   	leave  
  8110f7:	c3                   	ret    

00000000008110f8 <getchar>:
getchar(void) {
  8110f8:	55                   	push   %rbp
  8110f9:	48 89 e5             	mov    %rsp,%rbp
  8110fc:	48 83 ec 10          	sub    $0x10,%rsp
    int res = read(0, &c, 1);
  811100:	ba 01 00 00 00       	mov    $0x1,%edx
  811105:	48 8d 75 ff          	lea    -0x1(%rbp),%rsi
  811109:	bf 00 00 00 00       	mov    $0x0,%edi
  81110e:	48 b8 38 1a 80 00 00 	movabs $0x801a38,%rax
  811115:	00 00 00 
  811118:	ff d0                	call   *%rax
  81111a:	89 c2                	mov    %eax,%edx
    return res < 0 ? res : res ? c :
  81111c:	85 c0                	test   %eax,%eax
  81111e:	78 06                	js     811126 <getchar+0x2e>
  811120:	74 08                	je     81112a <getchar+0x32>
  811122:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
}
  811126:	89 d0                	mov    %edx,%eax
  811128:	c9                   	leave  
  811129:	c3                   	ret    
    return res < 0 ? res : res ? c :
  81112a:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  81112f:	eb f5                	jmp    811126 <getchar+0x2e>

0000000000811131 <iscons>:
iscons(int fdnum) {
  811131:	55                   	push   %rbp
  811132:	48 89 e5             	mov    %rsp,%rbp
  811135:	48 83 ec 10          	sub    $0x10,%rsp
    int res = fd_lookup(fdnum, &fd);
  811139:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
  81113d:	48 b8 55 17 80 00 00 	movabs $0x801755,%rax
  811144:	00 00 00 
  811147:	ff d0                	call   *%rax
    if (res < 0) return res;
  811149:	85 c0                	test   %eax,%eax
  81114b:	78 18                	js     811165 <iscons+0x34>
    return fd->fd_dev_id == devcons.dev_id;
  81114d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  811151:	48 b8 c0 40 81 00 00 	movabs $0x8140c0,%rax
  811158:	00 00 00 
  81115b:	8b 00                	mov    (%rax),%eax
  81115d:	39 02                	cmp    %eax,(%rdx)
  81115f:	0f 94 c0             	sete   %al
  811162:	0f b6 c0             	movzbl %al,%eax
}
  811165:	c9                   	leave  
  811166:	c3                   	ret    

0000000000811167 <opencons>:
opencons(void) {
  811167:	55                   	push   %rbp
  811168:	48 89 e5             	mov    %rsp,%rbp
  81116b:	48 83 ec 10          	sub    $0x10,%rsp
    if ((res = fd_alloc(&fd)) < 0) return res;
  81116f:	48 8d 7d f8          	lea    -0x8(%rbp),%rdi
  811173:	48 b8 f5 16 80 00 00 	movabs $0x8016f5,%rax
  81117a:	00 00 00 
  81117d:	ff d0                	call   *%rax
  81117f:	85 c0                	test   %eax,%eax
  811181:	78 49                	js     8111cc <opencons+0x65>
    if ((res = sys_alloc_region(0, fd, PAGE_SIZE, PROT_RW | PROT_SHARE)) < 0) return res;
  811183:	b9 46 00 00 00       	mov    $0x46,%ecx
  811188:	ba 00 10 00 00       	mov    $0x1000,%edx
  81118d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  811191:	bf 00 00 00 00       	mov    $0x0,%edi
  811196:	48 b8 62 13 80 00 00 	movabs $0x801362,%rax
  81119d:	00 00 00 
  8111a0:	ff d0                	call   *%rax
  8111a2:	85 c0                	test   %eax,%eax
  8111a4:	78 26                	js     8111cc <opencons+0x65>
    fd->fd_dev_id = devcons.dev_id;
  8111a6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8111aa:	a1 c0 40 81 00 00 00 	movabs 0x8140c0,%eax
  8111b1:	00 00 
  8111b3:	89 02                	mov    %eax,(%rdx)
    fd->fd_omode = O_RDWR;
  8111b5:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8111b9:	c7 47 08 02 00 00 00 	movl   $0x2,0x8(%rdi)
    return fd2num(fd);
  8111c0:	48 b8 c7 16 80 00 00 	movabs $0x8016c7,%rax
  8111c7:	00 00 00 
  8111ca:	ff d0                	call   *%rax
}
  8111cc:	c9                   	leave  
  8111cd:	c3                   	ret    

00000000008111ce <_panic>:

/* Panic is called on unresolvable fatal errors.
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor. */
void
_panic(const char *file, int line, const char *fmt, ...) {
  8111ce:	55                   	push   %rbp
  8111cf:	48 89 e5             	mov    %rsp,%rbp
  8111d2:	41 56                	push   %r14
  8111d4:	41 55                	push   %r13
  8111d6:	41 54                	push   %r12
  8111d8:	53                   	push   %rbx
  8111d9:	48 83 ec 50          	sub    $0x50,%rsp
  8111dd:	49 89 fc             	mov    %rdi,%r12
  8111e0:	41 89 f5             	mov    %esi,%r13d
  8111e3:	48 89 d3             	mov    %rdx,%rbx
  8111e6:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8111ea:	4c 89 45 d0          	mov    %r8,-0x30(%rbp)
  8111ee:	4c 89 4d d8          	mov    %r9,-0x28(%rbp)
    va_list ap;

    va_start(ap, fmt);
  8111f2:	c7 45 98 18 00 00 00 	movl   $0x18,-0x68(%rbp)
  8111f9:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8111fd:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  811201:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  811205:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

    /* Print the panic message */
    cprintf("[%08x] user panic in %s at %s:%d: ",
  811209:	48 b8 00 40 81 00 00 	movabs $0x814000,%rax
  811210:	00 00 00 
  811213:	4c 8b 30             	mov    (%rax),%r14
  811216:	48 b8 a2 12 80 00 00 	movabs $0x8012a2,%rax
  81121d:	00 00 00 
  811220:	ff d0                	call   *%rax
  811222:	89 c6                	mov    %eax,%esi
  811224:	45 89 e8             	mov    %r13d,%r8d
  811227:	4c 89 e1             	mov    %r12,%rcx
  81122a:	4c 89 f2             	mov    %r14,%rdx
  81122d:	48 bf e8 39 81 00 00 	movabs $0x8139e8,%rdi
  811234:	00 00 00 
  811237:	b8 00 00 00 00       	mov    $0x0,%eax
  81123c:	49 bc 67 04 80 00 00 	movabs $0x800467,%r12
  811243:	00 00 00 
  811246:	41 ff d4             	call   *%r12
            sys_getenvid(), binaryname, file, line);
    vcprintf(fmt, ap);
  811249:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
  81124d:	48 89 df             	mov    %rbx,%rdi
  811250:	48 b8 03 04 80 00 00 	movabs $0x800403,%rax
  811257:	00 00 00 
  81125a:	ff d0                	call   *%rax
    cprintf("\n");
  81125c:	48 bf 6b 1a 81 00 00 	movabs $0x811a6b,%rdi
  811263:	00 00 00 
  811266:	b8 00 00 00 00       	mov    $0x0,%eax
  81126b:	41 ff d4             	call   *%r12

    /* Cause a breakpoint exception */
    for (;;) asm volatile("int3");
  81126e:	cc                   	int3   
  81126f:	eb fd                	jmp    81126e <_panic+0xa0>

0000000000811271 <ipc_recv>:
 *   Use 'thisenv' to discover the value and who sent it.
 *   If 'pg' is null, pass sys_ipc_recv a value that it will understand
 *   as meaning "no page".  (Zero is not the right value, since that's
 *   a perfectly valid place to map a page.) */
int32_t
ipc_recv(envid_t *from_env_store, void *pg, size_t *size, int *perm_store) {
  811271:	55                   	push   %rbp
  811272:	48 89 e5             	mov    %rsp,%rbp
  811275:	41 54                	push   %r12
  811277:	53                   	push   %rbx
  811278:	48 89 fb             	mov    %rdi,%rbx
  81127b:	48 89 f7             	mov    %rsi,%rdi
  81127e:	49 89 cc             	mov    %rcx,%r12
    // LAB 9: Your code here:
    if (pg == NULL)
        pg = (void*)MAX_USER_ADDRESS;
  811281:	48 85 f6             	test   %rsi,%rsi
  811284:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  81128b:	00 00 00 
  81128e:	48 0f 44 f8          	cmove  %rax,%rdi
    
    int sz = PAGE_SIZE;
  811292:	be 00 10 00 00       	mov    $0x1000,%esi
    if (size) sz = *size;
  811297:	48 85 d2             	test   %rdx,%rdx
  81129a:	74 02                	je     81129e <ipc_recv+0x2d>
  81129c:	8b 32                	mov    (%rdx),%esi
    
    int res = 0;

    res = sys_ipc_recv(pg, sz);
  81129e:	48 63 f6             	movslq %esi,%rsi
  8112a1:	48 b8 fc 15 80 00 00 	movabs $0x8015fc,%rax
  8112a8:	00 00 00 
  8112ab:	ff d0                	call   *%rax

    if (res < 0) {
  8112ad:	85 c0                	test   %eax,%eax
  8112af:	78 45                	js     8112f6 <ipc_recv+0x85>
        if (perm_store)
            *perm_store = 0;
        return res;
    } 

    if (from_env_store) 
  8112b1:	48 85 db             	test   %rbx,%rbx
  8112b4:	74 12                	je     8112c8 <ipc_recv+0x57>
       *from_env_store = thisenv->env_ipc_from;
  8112b6:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  8112bd:	00 00 00 
  8112c0:	8b 80 24 01 00 00    	mov    0x124(%rax),%eax
  8112c6:	89 03                	mov    %eax,(%rbx)
                            
    if (perm_store) 
  8112c8:	4d 85 e4             	test   %r12,%r12
  8112cb:	74 14                	je     8112e1 <ipc_recv+0x70>
       *perm_store = thisenv->env_ipc_perm;
  8112cd:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  8112d4:	00 00 00 
  8112d7:	8b 80 28 01 00 00    	mov    0x128(%rax),%eax
  8112dd:	41 89 04 24          	mov    %eax,(%r12)
                                   
 
    return thisenv->env_ipc_value;
  8112e1:	48 a1 08 50 81 00 00 	movabs 0x815008,%rax
  8112e8:	00 00 00 
  8112eb:	8b 80 20 01 00 00    	mov    0x120(%rax),%eax
}
  8112f1:	5b                   	pop    %rbx
  8112f2:	41 5c                	pop    %r12
  8112f4:	5d                   	pop    %rbp
  8112f5:	c3                   	ret    
        if (from_env_store)
  8112f6:	48 85 db             	test   %rbx,%rbx
  8112f9:	74 06                	je     811301 <ipc_recv+0x90>
            *from_env_store = 0;
  8112fb:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
        if (perm_store)
  811301:	4d 85 e4             	test   %r12,%r12
  811304:	74 eb                	je     8112f1 <ipc_recv+0x80>
            *perm_store = 0;
  811306:	41 c7 04 24 00 00 00 	movl   $0x0,(%r12)
  81130d:	00 
  81130e:	eb e1                	jmp    8112f1 <ipc_recv+0x80>

0000000000811310 <ipc_send>:
 * Hint:
 *   Use sys_yield() to be CPU-friendly.
 *   If 'pg' is null, pass sys_ipc_recv a value that it will understand
 *   as meaning "no page".  (Zero is not the right value.) */
void
ipc_send(envid_t to_env, uint32_t val, void *pg, size_t size, int perm) {
  811310:	55                   	push   %rbp
  811311:	48 89 e5             	mov    %rsp,%rbp
  811314:	41 57                	push   %r15
  811316:	41 56                	push   %r14
  811318:	41 55                	push   %r13
  81131a:	41 54                	push   %r12
  81131c:	53                   	push   %rbx
  81131d:	48 83 ec 18          	sub    $0x18,%rsp
  811321:	41 89 fd             	mov    %edi,%r13d
  811324:	89 75 cc             	mov    %esi,-0x34(%rbp)
  811327:	48 89 d3             	mov    %rdx,%rbx
  81132a:	49 89 cc             	mov    %rcx,%r12
  81132d:	44 89 45 c8          	mov    %r8d,-0x38(%rbp)
    // LAB 9: Your code here:
    int res = 0;
    if (pg == NULL) 
        pg = (void *)MAX_USER_ADDRESS;
  811331:	48 85 d2             	test   %rdx,%rdx
  811334:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  81133b:	00 00 00 
  81133e:	48 0f 44 d8          	cmove  %rax,%rbx
               
      while ((res = sys_ipc_try_send(to_env, val, pg, size, perm)) < 0) {
  811342:	49 be d0 15 80 00 00 	movabs $0x8015d0,%r14
  811349:	00 00 00 
          if (res < 0 && res != -E_IPC_NOT_RECV) {
              panic("ipc_send error: %i", res);
          }
          sys_yield();
  81134c:	49 bf d3 12 80 00 00 	movabs $0x8012d3,%r15
  811353:	00 00 00 
      while ((res = sys_ipc_try_send(to_env, val, pg, size, perm)) < 0) {
  811356:	8b 75 cc             	mov    -0x34(%rbp),%esi
  811359:	44 8b 45 c8          	mov    -0x38(%rbp),%r8d
  81135d:	4c 89 e1             	mov    %r12,%rcx
  811360:	48 89 da             	mov    %rbx,%rdx
  811363:	44 89 ef             	mov    %r13d,%edi
  811366:	41 ff d6             	call   *%r14
  811369:	85 c0                	test   %eax,%eax
  81136b:	79 37                	jns    8113a4 <ipc_send+0x94>
          if (res < 0 && res != -E_IPC_NOT_RECV) {
  81136d:	83 f8 f5             	cmp    $0xfffffff5,%eax
  811370:	75 05                	jne    811377 <ipc_send+0x67>
          sys_yield();
  811372:	41 ff d7             	call   *%r15
  811375:	eb df                	jmp    811356 <ipc_send+0x46>
              panic("ipc_send error: %i", res);
  811377:	89 c1                	mov    %eax,%ecx
  811379:	48 ba 0b 3a 81 00 00 	movabs $0x813a0b,%rdx
  811380:	00 00 00 
  811383:	be 46 00 00 00       	mov    $0x46,%esi
  811388:	48 bf 1e 3a 81 00 00 	movabs $0x813a1e,%rdi
  81138f:	00 00 00 
  811392:	b8 00 00 00 00       	mov    $0x0,%eax
  811397:	49 b8 ce 11 81 00 00 	movabs $0x8111ce,%r8
  81139e:	00 00 00 
  8113a1:	41 ff d0             	call   *%r8
      }
}
  8113a4:	48 83 c4 18          	add    $0x18,%rsp
  8113a8:	5b                   	pop    %rbx
  8113a9:	41 5c                	pop    %r12
  8113ab:	41 5d                	pop    %r13
  8113ad:	41 5e                	pop    %r14
  8113af:	41 5f                	pop    %r15
  8113b1:	5d                   	pop    %rbp
  8113b2:	c3                   	ret    

00000000008113b3 <ipc_find_env>:
/* Find the first environment of the given type.  We'll use this to
 * find special environments.
 * Returns 0 if no such environment exists. */
envid_t
ipc_find_env(enum EnvType type) {
    for (size_t i = 0; i < NENV; i++)
  8113b3:	b8 00 00 00 00       	mov    $0x0,%eax
        if (envs[i].env_type == type)
  8113b8:	48 b9 00 00 c0 1f 80 	movabs $0x801fc00000,%rcx
  8113bf:	00 00 00 
  8113c2:	48 8d 14 c0          	lea    (%rax,%rax,8),%rdx
  8113c6:	48 8d 14 50          	lea    (%rax,%rdx,2),%rdx
  8113ca:	48 c1 e2 04          	shl    $0x4,%rdx
  8113ce:	48 01 ca             	add    %rcx,%rdx
  8113d1:	8b 92 d0 00 00 00    	mov    0xd0(%rdx),%edx
  8113d7:	39 fa                	cmp    %edi,%edx
  8113d9:	74 12                	je     8113ed <ipc_find_env+0x3a>
    for (size_t i = 0; i < NENV; i++)
  8113db:	48 83 c0 01          	add    $0x1,%rax
  8113df:	48 3d 00 04 00 00    	cmp    $0x400,%rax
  8113e5:	75 db                	jne    8113c2 <ipc_find_env+0xf>
            return envs[i].env_id;
    return 0;
  8113e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8113ec:	c3                   	ret    
            return envs[i].env_id;
  8113ed:	48 8d 14 c0          	lea    (%rax,%rax,8),%rdx
  8113f1:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
  8113f5:	48 c1 e0 04          	shl    $0x4,%rax
  8113f9:	48 89 c2             	mov    %rax,%rdx
  8113fc:	48 b8 00 00 c0 1f 80 	movabs $0x801fc00000,%rax
  811403:	00 00 00 
  811406:	48 01 d0             	add    %rdx,%rax
  811409:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  81140f:	c3                   	ret    

0000000000811410 <__rodata_start>:
  811410:	67 72 61             	addr32 jb 811474 <__rodata_start+0x64>
  811413:	70 68                	jo     81147d <__rodata_start+0x6d>
  811415:	69 63 73 00 65 72 72 	imul   $0x72726500,0x73(%rbx),%esp
  81141c:	6f                   	outsl  %ds:(%rsi),(%dx)
  81141d:	72 20                	jb     81143f <__rodata_start+0x2f>
  81141f:	25 69 0a 00 66       	and    $0x66000a69,%eax
  811424:	72 6f                	jb     811495 <__rodata_start+0x85>
  811426:	6e                   	outsb  %ds:(%rsi),(%dx)
  811427:	74 3a                	je     811463 <__rodata_start+0x53>
  811429:	20 25 70 2c 20 62    	and    %ah,0x62202c70(%rip)        # 62a1409f <__bss_end+0x61dfc09f>
  81142f:	61                   	(bad)  
  811430:	63 6b 3a             	movsxd 0x3a(%rbx),%ebp
  811433:	20 25 70 0a 00 73    	and    %ah,0x73000a70(%rip)        # 73811ea9 <__bss_end+0x72bf9ea9>
  811439:	70 61                	jo     81149c <__rodata_start+0x8c>
  81143b:	63 65 73             	movsxd 0x73(%rbp),%esp
  81143e:	68 69 70 2e 70       	push   $0x702e7069
  811443:	6e                   	outsb  %ds:(%rsi),(%dx)
  811444:	67 00 64 65 63       	add    %ah,0x63(%ebp,%eiz,2)
  811449:	6f                   	outsl  %ds:(%rsi),(%dx)
  81144a:	64 65 72 20          	fs gs jb 81146e <__rodata_start+0x5e>
  81144e:	65 72 72             	gs jb  8114c3 <__rodata_start+0xb3>
  811451:	6f                   	outsl  %ds:(%rsi),(%dx)
  811452:	72 20                	jb     811474 <__rodata_start+0x64>
  811454:	25 75 3a 20 25       	and    $0x25203a75,%eax
  811459:	73 0a                	jae    811465 <__rodata_start+0x55>
  81145b:	00 77 69             	add    %dh,0x69(%rdi)
  81145e:	64 74 68             	fs je  8114c9 <__rodata_start+0xb9>
  811461:	3a 20                	cmp    (%rax),%ah
  811463:	25 75 2c 20 68       	and    $0x68202c75,%eax
  811468:	65 69 67 68 74 3a 20 	imul   $0x25203a74,%gs:0x68(%rdi),%esp
  81146f:	25 
  811470:	75 0a                	jne    81147c <__rodata_start+0x6c>
  811472:	00 0f                	add    %cl,(%rdi)
  811474:	1f                   	(bad)  
  811475:	44 00 00             	add    %r8b,(%rax)
  811478:	77 69                	ja     8114e3 <__rodata_start+0xd3>
  81147a:	64 74 68             	fs je  8114e5 <__rodata_start+0xd5>
  81147d:	3a 20                	cmp    (%rax),%ah
  81147f:	25 64 2c 20 68       	and    $0x68202c64,%eax
  811484:	65 69 67 68 74 3a 20 	imul   $0x25203a74,%gs:0x68(%rdi),%esp
  81148b:	25 
  81148c:	64 2c 20             	fs sub $0x20,%al
  81148f:	62                   	(bad)  
  811490:	70 70                	jo     811502 <__rodata_start+0xf2>
  811492:	3a 20                	cmp    (%rax),%ah
  811494:	25 64 20 66 72       	and    $0x72662064,%eax
  811499:	61                   	(bad)  
  81149a:	6d                   	insl   (%dx),%es:(%rdi)
  81149b:	65 62                	gs (bad) 
  81149d:	75 66                	jne    811505 <__rodata_start+0xf5>
  81149f:	66 65 72 5f          	data16 gs jb 811502 <__rodata_start+0xf2>
  8114a3:	73 69                	jae    81150e <__rodata_start+0xfe>
  8114a5:	7a 65                	jp     81150c <__rodata_start+0xfc>
  8114a7:	3a 20                	cmp    (%rax),%ah
  8114a9:	25 64 0a 00 3c       	and    $0x3c000a64,%eax
  8114ae:	75 6e                	jne    81151e <__rodata_start+0x10e>
  8114b0:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
  8114b4:	6e                   	outsb  %ds:(%rsi),(%dx)
  8114b5:	3e 00 30             	ds add %dh,(%rax)
  8114b8:	31 32                	xor    %esi,(%rdx)
  8114ba:	33 34 35 36 37 38 39 	xor    0x39383736(,%rsi,1),%esi
  8114c1:	41                   	rex.B
  8114c2:	42                   	rex.X
  8114c3:	43                   	rex.XB
  8114c4:	44                   	rex.R
  8114c5:	45                   	rex.RB
  8114c6:	46 00 30             	rex.RX add %r14b,(%rax)
  8114c9:	31 32                	xor    %esi,(%rdx)
  8114cb:	33 34 35 36 37 38 39 	xor    0x39383736(,%rsi,1),%esi
  8114d2:	61                   	(bad)  
  8114d3:	62 63 64 65 66       	(bad)
  8114d8:	00 28                	add    %ch,(%rax)
  8114da:	6e                   	outsb  %ds:(%rsi),(%dx)
  8114db:	75 6c                	jne    811549 <__rodata_start+0x139>
  8114dd:	6c                   	insb   (%dx),%es:(%rdi)
  8114de:	29 00                	sub    %eax,(%rax)
  8114e0:	65 72 72             	gs jb  811555 <__rodata_start+0x145>
  8114e3:	6f                   	outsl  %ds:(%rsi),(%dx)
  8114e4:	72 20                	jb     811506 <__rodata_start+0xf6>
  8114e6:	25 64 00 75 6e       	and    $0x6e750064,%eax
  8114eb:	73 70                	jae    81155d <__rodata_start+0x14d>
  8114ed:	65 63 69 66          	movsxd %gs:0x66(%rcx),%ebp
  8114f1:	69 65 64 20 65 72 72 	imul   $0x72726520,0x64(%rbp),%esp
  8114f8:	6f                   	outsl  %ds:(%rsi),(%dx)
  8114f9:	72 00                	jb     8114fb <__rodata_start+0xeb>
  8114fb:	62 61 64 20 65       	(bad)
  811500:	6e                   	outsb  %ds:(%rsi),(%dx)
  811501:	76 69                	jbe    81156c <__rodata_start+0x15c>
  811503:	72 6f                	jb     811574 <__rodata_start+0x164>
  811505:	6e                   	outsb  %ds:(%rsi),(%dx)
  811506:	6d                   	insl   (%dx),%es:(%rdi)
  811507:	65 6e                	outsb  %gs:(%rsi),(%dx)
  811509:	74 00                	je     81150b <__rodata_start+0xfb>
  81150b:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
  811512:	20 70 61             	and    %dh,0x61(%rax)
  811515:	72 61                	jb     811578 <__rodata_start+0x168>
  811517:	6d                   	insl   (%dx),%es:(%rdi)
  811518:	65 74 65             	gs je  811580 <__rodata_start+0x170>
  81151b:	72 00                	jb     81151d <__rodata_start+0x10d>
  81151d:	6f                   	outsl  %ds:(%rsi),(%dx)
  81151e:	75 74                	jne    811594 <__rodata_start+0x184>
  811520:	20 6f 66             	and    %ch,0x66(%rdi)
  811523:	20 6d 65             	and    %ch,0x65(%rbp)
  811526:	6d                   	insl   (%dx),%es:(%rdi)
  811527:	6f                   	outsl  %ds:(%rsi),(%dx)
  811528:	72 79                	jb     8115a3 <__rodata_start+0x193>
  81152a:	00 6f 75             	add    %ch,0x75(%rdi)
  81152d:	74 20                	je     81154f <__rodata_start+0x13f>
  81152f:	6f                   	outsl  %ds:(%rsi),(%dx)
  811530:	66 20 65 6e          	data16 and %ah,0x6e(%rbp)
  811534:	76 69                	jbe    81159f <__rodata_start+0x18f>
  811536:	72 6f                	jb     8115a7 <__rodata_start+0x197>
  811538:	6e                   	outsb  %ds:(%rsi),(%dx)
  811539:	6d                   	insl   (%dx),%es:(%rdi)
  81153a:	65 6e                	outsb  %gs:(%rsi),(%dx)
  81153c:	74 73                	je     8115b1 <__rodata_start+0x1a1>
  81153e:	00 63 6f             	add    %ah,0x6f(%rbx)
  811541:	72 72                	jb     8115b5 <__rodata_start+0x1a5>
  811543:	75 70                	jne    8115b5 <__rodata_start+0x1a5>
  811545:	74 65                	je     8115ac <__rodata_start+0x19c>
  811547:	64 20 64 65 62       	and    %ah,%fs:0x62(%rbp,%riz,2)
  81154c:	75 67                	jne    8115b5 <__rodata_start+0x1a5>
  81154e:	20 69 6e             	and    %ch,0x6e(%rcx)
  811551:	66 6f                	outsw  %ds:(%rsi),(%dx)
  811553:	00 73 65             	add    %dh,0x65(%rbx)
  811556:	67 6d                	insl   (%dx),%es:(%edi)
  811558:	65 6e                	outsb  %gs:(%rsi),(%dx)
  81155a:	74 61                	je     8115bd <__rodata_start+0x1ad>
  81155c:	74 69                	je     8115c7 <__rodata_start+0x1b7>
  81155e:	6f                   	outsl  %ds:(%rsi),(%dx)
  81155f:	6e                   	outsb  %ds:(%rsi),(%dx)
  811560:	20 66 61             	and    %ah,0x61(%rsi)
  811563:	75 6c                	jne    8115d1 <__rodata_start+0x1c1>
  811565:	74 00                	je     811567 <__rodata_start+0x157>
  811567:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
  81156e:	20 45 4c             	and    %al,0x4c(%rbp)
  811571:	46 20 69 6d          	rex.RX and %r13b,0x6d(%rcx)
  811575:	61                   	(bad)  
  811576:	67 65 00 6e 6f       	add    %ch,%gs:0x6f(%esi)
  81157b:	20 73 75             	and    %dh,0x75(%rbx)
  81157e:	63 68 20             	movsxd 0x20(%rax),%ebp
  811581:	73 79                	jae    8115fc <__rodata_start+0x1ec>
  811583:	73 74                	jae    8115f9 <__rodata_start+0x1e9>
  811585:	65 6d                	gs insl (%dx),%es:(%rdi)
  811587:	20 63 61             	and    %ah,0x61(%rbx)
  81158a:	6c                   	insb   (%dx),%es:(%rdi)
  81158b:	6c                   	insb   (%dx),%es:(%rdi)
  81158c:	00 65 6e             	add    %ah,0x6e(%rbp)
  81158f:	74 72                	je     811603 <__rodata_start+0x1f3>
  811591:	79 20                	jns    8115b3 <__rodata_start+0x1a3>
  811593:	6e                   	outsb  %ds:(%rsi),(%dx)
  811594:	6f                   	outsl  %ds:(%rsi),(%dx)
  811595:	74 20                	je     8115b7 <__rodata_start+0x1a7>
  811597:	66 6f                	outsw  %ds:(%rsi),(%dx)
  811599:	75 6e                	jne    811609 <__rodata_start+0x1f9>
  81159b:	64 00 65 6e          	add    %ah,%fs:0x6e(%rbp)
  81159f:	76 20                	jbe    8115c1 <__rodata_start+0x1b1>
  8115a1:	69 73 20 6e 6f 74 20 	imul   $0x20746f6e,0x20(%rbx),%esi
  8115a8:	72 65                	jb     81160f <__rodata_start+0x1ff>
  8115aa:	63 76 69             	movsxd 0x69(%rsi),%esi
  8115ad:	6e                   	outsb  %ds:(%rsi),(%dx)
  8115ae:	67 00 75 6e          	add    %dh,0x6e(%ebp)
  8115b2:	65 78 70             	gs js  811625 <__rodata_start+0x215>
  8115b5:	65 63 74 65 64       	movsxd %gs:0x64(%rbp,%riz,2),%esi
  8115ba:	20 65 6e             	and    %ah,0x6e(%rbp)
  8115bd:	64 20 6f 66          	and    %ch,%fs:0x66(%rdi)
  8115c1:	20 66 69             	and    %ah,0x69(%rsi)
  8115c4:	6c                   	insb   (%dx),%es:(%rdi)
  8115c5:	65 00 6e 6f          	add    %ch,%gs:0x6f(%rsi)
  8115c9:	20 66 72             	and    %ah,0x72(%rsi)
  8115cc:	65 65 20 73 70       	gs and %dh,%gs:0x70(%rbx)
  8115d1:	61                   	(bad)  
  8115d2:	63 65 20             	movsxd 0x20(%rbp),%esp
  8115d5:	6f                   	outsl  %ds:(%rsi),(%dx)
  8115d6:	6e                   	outsb  %ds:(%rsi),(%dx)
  8115d7:	20 64 69 73          	and    %ah,0x73(%rcx,%rbp,2)
  8115db:	6b 00 74             	imul   $0x74,(%rax),%eax
  8115de:	6f                   	outsl  %ds:(%rsi),(%dx)
  8115df:	6f                   	outsl  %ds:(%rsi),(%dx)
  8115e0:	20 6d 61             	and    %ch,0x61(%rbp)
  8115e3:	6e                   	outsb  %ds:(%rsi),(%dx)
  8115e4:	79 20                	jns    811606 <__rodata_start+0x1f6>
  8115e6:	66 69 6c 65 73 20 61 	imul   $0x6120,0x73(%rbp,%riz,2),%bp
  8115ed:	72 65                	jb     811654 <__rodata_start+0x244>
  8115ef:	20 6f 70             	and    %ch,0x70(%rdi)
  8115f2:	65 6e                	outsb  %gs:(%rsi),(%dx)
  8115f4:	00 66 69             	add    %ah,0x69(%rsi)
  8115f7:	6c                   	insb   (%dx),%es:(%rdi)
  8115f8:	65 20 6f 72          	and    %ch,%gs:0x72(%rdi)
  8115fc:	20 62 6c             	and    %ah,0x6c(%rdx)
  8115ff:	6f                   	outsl  %ds:(%rsi),(%dx)
  811600:	63 6b 20             	movsxd 0x20(%rbx),%ebp
  811603:	6e                   	outsb  %ds:(%rsi),(%dx)
  811604:	6f                   	outsl  %ds:(%rsi),(%dx)
  811605:	74 20                	je     811627 <__rodata_start+0x217>
  811607:	66 6f                	outsw  %ds:(%rsi),(%dx)
  811609:	75 6e                	jne    811679 <__rodata_start+0x269>
  81160b:	64 00 69 6e          	add    %ch,%fs:0x6e(%rcx)
  81160f:	76 61                	jbe    811672 <__rodata_start+0x262>
  811611:	6c                   	insb   (%dx),%es:(%rdi)
  811612:	69 64 20 70 61 74 68 	imul   $0x687461,0x70(%rax,%riz,1),%esp
  811619:	00 
  81161a:	66 69 6c 65 20 61 6c 	imul   $0x6c61,0x20(%rbp,%riz,2),%bp
  811621:	72 65                	jb     811688 <__rodata_start+0x278>
  811623:	61                   	(bad)  
  811624:	64 79 20             	fs jns 811647 <__rodata_start+0x237>
  811627:	65 78 69             	gs js  811693 <__rodata_start+0x283>
  81162a:	73 74                	jae    8116a0 <__rodata_start+0x290>
  81162c:	73 00                	jae    81162e <__rodata_start+0x21e>
  81162e:	6f                   	outsl  %ds:(%rsi),(%dx)
  81162f:	70 65                	jo     811696 <__rodata_start+0x286>
  811631:	72 61                	jb     811694 <__rodata_start+0x284>
  811633:	74 69                	je     81169e <__rodata_start+0x28e>
  811635:	6f                   	outsl  %ds:(%rsi),(%dx)
  811636:	6e                   	outsb  %ds:(%rsi),(%dx)
  811637:	20 6e 6f             	and    %ch,0x6f(%rsi)
  81163a:	74 20                	je     81165c <__rodata_start+0x24c>
  81163c:	73 75                	jae    8116b3 <__rodata_start+0x2a3>
  81163e:	70 70                	jo     8116b0 <__rodata_start+0x2a0>
  811640:	6f                   	outsl  %ds:(%rsi),(%dx)
  811641:	72 74                	jb     8116b7 <__rodata_start+0x2a7>
  811643:	65 64 00 66 2e       	gs add %ah,%fs:0x2e(%rsi)
  811648:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  81164f:	00 
  811650:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
  811657:	00 00 00 
  81165a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  811660:	61                   	(bad)  
  811661:	06                   	(bad)  
  811662:	80 00 00             	addb   $0x0,(%rax)
  811665:	00 00                	add    %al,(%rax)
  811667:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81166d:	00 00                	add    %al,(%rax)
  81166f:	00 a5 0c 80 00 00    	add    %ah,0x800c(%rbp)
  811675:	00 00                	add    %al,(%rax)
  811677:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81167d:	00 00                	add    %al,(%rax)
  81167f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811685:	00 00                	add    %al,(%rax)
  811687:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81168d:	00 00                	add    %al,(%rax)
  81168f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811695:	00 00                	add    %al,(%rax)
  811697:	00 7b 06             	add    %bh,0x6(%rbx)
  81169a:	80 00 00             	addb   $0x0,(%rax)
  81169d:	00 00                	add    %al,(%rax)
  81169f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8116a5:	00 00                	add    %al,(%rax)
  8116a7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8116ad:	00 00                	add    %al,(%rax)
  8116af:	00 72 06             	add    %dh,0x6(%rdx)
  8116b2:	80 00 00             	addb   $0x0,(%rax)
  8116b5:	00 00                	add    %al,(%rax)
  8116b7:	00 e8                	add    %ch,%al
  8116b9:	06                   	(bad)  
  8116ba:	80 00 00             	addb   $0x0,(%rax)
  8116bd:	00 00                	add    %al,(%rax)
  8116bf:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8116c5:	00 00                	add    %al,(%rax)
  8116c7:	00 72 06             	add    %dh,0x6(%rdx)
  8116ca:	80 00 00             	addb   $0x0,(%rax)
  8116cd:	00 00                	add    %al,(%rax)
  8116cf:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  8116d5:	00 00                	add    %al,(%rax)
  8116d7:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  8116dd:	00 00                	add    %al,(%rax)
  8116df:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  8116e5:	00 00                	add    %al,(%rax)
  8116e7:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  8116ed:	00 00                	add    %al,(%rax)
  8116ef:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  8116f5:	00 00                	add    %al,(%rax)
  8116f7:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  8116fd:	00 00                	add    %al,(%rax)
  8116ff:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  811705:	00 00                	add    %al,(%rax)
  811707:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  81170d:	00 00                	add    %al,(%rax)
  81170f:	00 b5 06 80 00 00    	add    %dh,0x8006(%rbp)
  811715:	00 00                	add    %al,(%rax)
  811717:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81171d:	00 00                	add    %al,(%rax)
  81171f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811725:	00 00                	add    %al,(%rax)
  811727:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81172d:	00 00                	add    %al,(%rax)
  81172f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811735:	00 00                	add    %al,(%rax)
  811737:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81173d:	00 00                	add    %al,(%rax)
  81173f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811745:	00 00                	add    %al,(%rax)
  811747:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81174d:	00 00                	add    %al,(%rax)
  81174f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811755:	00 00                	add    %al,(%rax)
  811757:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81175d:	00 00                	add    %al,(%rax)
  81175f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811765:	00 00                	add    %al,(%rax)
  811767:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81176d:	00 00                	add    %al,(%rax)
  81176f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811775:	00 00                	add    %al,(%rax)
  811777:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81177d:	00 00                	add    %al,(%rax)
  81177f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811785:	00 00                	add    %al,(%rax)
  811787:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81178d:	00 00                	add    %al,(%rax)
  81178f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811795:	00 00                	add    %al,(%rax)
  811797:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81179d:	00 00                	add    %al,(%rax)
  81179f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117a5:	00 00                	add    %al,(%rax)
  8117a7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117ad:	00 00                	add    %al,(%rax)
  8117af:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117b5:	00 00                	add    %al,(%rax)
  8117b7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117bd:	00 00                	add    %al,(%rax)
  8117bf:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117c5:	00 00                	add    %al,(%rax)
  8117c7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117cd:	00 00                	add    %al,(%rax)
  8117cf:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117d5:	00 00                	add    %al,(%rax)
  8117d7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117dd:	00 00                	add    %al,(%rax)
  8117df:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117e5:	00 00                	add    %al,(%rax)
  8117e7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117ed:	00 00                	add    %al,(%rax)
  8117ef:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117f5:	00 00                	add    %al,(%rax)
  8117f7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8117fd:	00 00                	add    %al,(%rax)
  8117ff:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811805:	00 00                	add    %al,(%rax)
  811807:	00 da                	add    %bl,%dl
  811809:	0b 80 00 00 00 00    	or     0x0(%rax),%eax
  81180f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811815:	00 00                	add    %al,(%rax)
  811817:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81181d:	00 00                	add    %al,(%rax)
  81181f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811825:	00 00                	add    %al,(%rax)
  811827:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81182d:	00 00                	add    %al,(%rax)
  81182f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811835:	00 00                	add    %al,(%rax)
  811837:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81183d:	00 00                	add    %al,(%rax)
  81183f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811845:	00 00                	add    %al,(%rax)
  811847:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81184d:	00 00                	add    %al,(%rax)
  81184f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811855:	00 00                	add    %al,(%rax)
  811857:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81185d:	00 00                	add    %al,(%rax)
  81185f:	00 06                	add    %al,(%rsi)
  811861:	07                   	(bad)  
  811862:	80 00 00             	addb   $0x0,(%rax)
  811865:	00 00                	add    %al,(%rax)
  811867:	00 fc                	add    %bh,%ah
  811869:	08 80 00 00 00 00    	or     %al,0x0(%rax)
  81186f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811875:	00 00                	add    %al,(%rax)
  811877:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81187d:	00 00                	add    %al,(%rax)
  81187f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811885:	00 00                	add    %al,(%rax)
  811887:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81188d:	00 00                	add    %al,(%rax)
  81188f:	00 34 07             	add    %dh,(%rdi,%rax,1)
  811892:	80 00 00             	addb   $0x0,(%rax)
  811895:	00 00                	add    %al,(%rax)
  811897:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  81189d:	00 00                	add    %al,(%rax)
  81189f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8118a5:	00 00                	add    %al,(%rax)
  8118a7:	00 fb                	add    %bh,%bl
  8118a9:	06                   	(bad)  
  8118aa:	80 00 00             	addb   $0x0,(%rax)
  8118ad:	00 00                	add    %al,(%rax)
  8118af:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8118b5:	00 00                	add    %al,(%rax)
  8118b7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8118bd:	00 00                	add    %al,(%rax)
  8118bf:	00 9c 0a 80 00 00 00 	add    %bl,0x80(%rdx,%rcx,1)
  8118c6:	00 00                	add    %al,(%rax)
  8118c8:	64 0b 80 00 00 00 00 	or     %fs:0x0(%rax),%eax
  8118cf:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8118d5:	00 00                	add    %al,(%rax)
  8118d7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8118dd:	00 00                	add    %al,(%rax)
  8118df:	00 cc                	add    %cl,%ah
  8118e1:	07                   	(bad)  
  8118e2:	80 00 00             	addb   $0x0,(%rax)
  8118e5:	00 00                	add    %al,(%rax)
  8118e7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8118ed:	00 00                	add    %al,(%rax)
  8118ef:	00 ce                	add    %cl,%dh
  8118f1:	09 80 00 00 00 00    	or     %eax,0x0(%rax)
  8118f7:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  8118fd:	00 00                	add    %al,(%rax)
  8118ff:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811905:	00 00                	add    %al,(%rax)
  811907:	00 da                	add    %bl,%dl
  811909:	0b 80 00 00 00 00    	or     0x0(%rax),%eax
  81190f:	00 b5 0c 80 00 00    	add    %dh,0x800c(%rbp)
  811915:	00 00                	add    %al,(%rax)
  811917:	00 6a 06             	add    %ch,0x6(%rdx)
  81191a:	80 00 00             	addb   $0x0,(%rax)
  81191d:	00 00                	add    %al,(%rax)
	...

0000000000811920 <error_string>:
	...
  811928:	e9 14 81 00 00 00 00 00 fb 14 81 00 00 00 00 00     ................
  811938:	0b 15 81 00 00 00 00 00 1d 15 81 00 00 00 00 00     ................
  811948:	2b 15 81 00 00 00 00 00 3f 15 81 00 00 00 00 00     +.......?.......
  811958:	54 15 81 00 00 00 00 00 67 15 81 00 00 00 00 00     T.......g.......
  811968:	79 15 81 00 00 00 00 00 8d 15 81 00 00 00 00 00     y...............
  811978:	9d 15 81 00 00 00 00 00 b0 15 81 00 00 00 00 00     ................
  811988:	c7 15 81 00 00 00 00 00 dd 15 81 00 00 00 00 00     ................
  811998:	f5 15 81 00 00 00 00 00 0d 16 81 00 00 00 00 00     ................
  8119a8:	1a 16 81 00 00 00 00 00 c0 19 81 00 00 00 00 00     ................
  8119b8:	2e 16 81 00 00 00 00 00 66 69 6c 65 20 69 73 20     ........file is 
  8119c8:	6e 6f 74 20 61 20 76 61 6c 69 64 20 65 78 65 63     not a valid exec
  8119d8:	75 74 61 62 6c 65 00 90 73 79 73 63 61 6c 6c 20     utable..syscall 
  8119e8:	25 7a 64 20 72 65 74 75 72 6e 65 64 20 25 7a 64     %zd returned %zd
  8119f8:	20 28 3e 20 30 29 00 6c 69 62 2f 73 79 73 63 61      (> 0).lib/sysca
  811a08:	6c 6c 2e 63 00 0f 1f 00 5b 25 30 38 78 5d 20 75     ll.c....[%08x] u
  811a18:	6e 6b 6e 6f 77 6e 20 64 65 76 69 63 65 20 74 79     nknown device ty
  811a28:	70 65 20 25 64 0a 00 00 5b 25 30 38 78 5d 20 66     pe %d...[%08x] f
  811a38:	74 72 75 6e 63 61 74 65 20 25 64 20 2d 2d 20 62     truncate %d -- b
  811a48:	61 64 20 6d 6f 64 65 0a 00 5b 25 30 38 78 5d 20     ad mode..[%08x] 
  811a58:	72 65 61 64 20 25 64 20 2d 2d 20 62 61 64 20 6d     read %d -- bad m
  811a68:	6f 64 65 0a 00 5b 25 30 38 78 5d 20 77 72 69 74     ode..[%08x] writ
  811a78:	65 20 25 64 20 2d 2d 20 62 61 64 20 6d 6f 64 65     e %d -- bad mode
  811a88:	0a 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  811a98:	84 00 00 00 00 00 66 90                             ......f.

0000000000811aa0 <devtab>:
  811aa0:	20 40 81 00 00 00 00 00 60 40 81 00 00 00 00 00      @......`@......
  811ab0:	c0 40 81 00 00 00 00 00 00 00 00 00 00 00 00 00     .@..............
  811ac0:	3c 70 69 70 65 3e 00 61 73 73 65 72 74 69 6f 6e     <pipe>.assertion
  811ad0:	20 66 61 69 6c 65 64 3a 20 25 73 00 6c 69 62 2f      failed: %s.lib/
  811ae0:	70 69 70 65 2e 63 00 70 69 70 65 00 0f 1f 40 00     pipe.c.pipe...@.
  811af0:	73 79 73 5f 72 65 67 69 6f 6e 5f 72 65 66 73 28     sys_region_refs(
  811b00:	76 61 2c 20 50 41 47 45 5f 53 49 5a 45 29 20 3d     va, PAGE_SIZE) =
  811b10:	3d 20 32 00 66 2e 0f 1f 84 00 00 00 00 00 66 90     = 2.f.........f.
  811b20:	55 2e 80 00 00 00 00 00 bd 2e 80 00 00 00 00 00     U...............
  811b30:	72 2e 80 00 00 00 00 00 81 2e 80 00 00 00 00 00     r...............
  811b40:	9f 2e 80 00 00 00 00 00 bd 2e 80 00 00 00 00 00     ................
  811b50:	ae 2e 80 00 00 00 00 00 f6 2e 80 00 00 00 00 00     ................
  811b60:	f0 2e 80 00 00 00 00 00 de 2e 80 00 00 00 00 00     ................
  811b70:	f6 2e 80 00 00 00 00 00 e4 2e 80 00 00 00 00 00     ................
  811b80:	f0 2e 80 00 00 00 00 00 ea 2e 80 00 00 00 00 00     ................
  811b90:	14 38 80 00 00 00 00 00 cc 37 80 00 00 00 00 00     .8.......7......
  811ba0:	7a 38 80 00 00 00 00 00 c4 38 80 00 00 00 00 00     z8.......8......
  811bb0:	79 39 80 00 00 00 00 00 03 42 80 00 00 00 00 00     y9.......B......
  811bc0:	c2 41 80 00 00 00 00 00 2e 42 80 00 00 00 00 00     .A.......B......
  811bd0:	73 42 80 00 00 00 00 00 22 43 80 00 00 00 00 00     sB......"C......
  811be0:	ed 0d 81 00 00 00 00 00 d8 09 81 00 00 00 00 00     ................
  811bf0:	e2 0d 81 00 00 00 00 00 e2 0d 81 00 00 00 00 00     ................
  811c00:	e2 0d 81 00 00 00 00 00 e2 0d 81 00 00 00 00 00     ................
  811c10:	e2 0d 81 00 00 00 00 00 e2 0d 81 00 00 00 00 00     ................
  811c20:	e2 0d 81 00 00 00 00 00 e2 0d 81 00 00 00 00 00     ................
  811c30:	e3 09 81 00 00 00 00 00 ee 09 81 00 00 00 00 00     ................
  811c40:	e2 0d 81 00 00 00 00 00 f9 09 81 00 00 00 00 00     ................
  811c50:	04 0a 81 00 00 00 00 00 0f 0a 81 00 00 00 00 00     ................
  811c60:	1a 0a 81 00 00 00 00 00 25 0a 81 00 00 00 00 00     ........%.......
  811c70:	30 0a 81 00 00 00 00 00 3b 0a 81 00 00 00 00 00     0.......;.......
  811c80:	46 0a 81 00 00 00 00 00 51 0a 81 00 00 00 00 00     F.......Q.......
  811c90:	5c 0a 81 00 00 00 00 00 67 0a 81 00 00 00 00 00     \.......g.......
  811ca0:	72 0a 81 00 00 00 00 00 7d 0a 81 00 00 00 00 00     r.......}.......
  811cb0:	88 0a 81 00 00 00 00 00 93 0a 81 00 00 00 00 00     ................
  811cc0:	9e 0a 81 00 00 00 00 00 a9 0a 81 00 00 00 00 00     ................
  811cd0:	b4 0a 81 00 00 00 00 00 bf 0a 81 00 00 00 00 00     ................
  811ce0:	ca 0a 81 00 00 00 00 00 d5 0a 81 00 00 00 00 00     ................
  811cf0:	e0 0a 81 00 00 00 00 00 eb 0a 81 00 00 00 00 00     ................
  811d00:	f6 0a 81 00 00 00 00 00 01 0b 81 00 00 00 00 00     ................
  811d10:	0c 0b 81 00 00 00 00 00 17 0b 81 00 00 00 00 00     ................
  811d20:	22 0b 81 00 00 00 00 00 2d 0b 81 00 00 00 00 00     ".......-.......
  811d30:	38 0b 81 00 00 00 00 00 43 0b 81 00 00 00 00 00     8.......C.......
  811d40:	4e 0b 81 00 00 00 00 00 59 0b 81 00 00 00 00 00     N.......Y.......
  811d50:	e2 0d 81 00 00 00 00 00 e2 0d 81 00 00 00 00 00     ................
  811d60:	64 0b 81 00 00 00 00 00 6f 0b 81 00 00 00 00 00     d.......o.......
  811d70:	7a 0b 81 00 00 00 00 00 85 0b 81 00 00 00 00 00     z...............
  811d80:	90 0b 81 00 00 00 00 00 9b 0b 81 00 00 00 00 00     ................
  811d90:	a6 0b 81 00 00 00 00 00 b1 0b 81 00 00 00 00 00     ................
  811da0:	bc 0b 81 00 00 00 00 00 c7 0b 81 00 00 00 00 00     ................
  811db0:	d2 0b 81 00 00 00 00 00 dd 0b 81 00 00 00 00 00     ................
  811dc0:	e8 0b 81 00 00 00 00 00 f3 0b 81 00 00 00 00 00     ................
  811dd0:	fe 0b 81 00 00 00 00 00 09 0c 81 00 00 00 00 00     ................
  811de0:	14 0c 81 00 00 00 00 00 e2 0d 81 00 00 00 00 00     ................
  811df0:	1f 0c 81 00 00 00 00 00 2a 0c 81 00 00 00 00 00     ........*.......
  811e00:	35 0c 81 00 00 00 00 00 40 0c 81 00 00 00 00 00     5.......@.......
  811e10:	e2 0d 81 00 00 00 00 00 4b 0c 81 00 00 00 00 00     ........K.......
  811e20:	56 0c 81 00 00 00 00 00 61 0c 81 00 00 00 00 00     V.......a.......
  811e30:	6c 0c 81 00 00 00 00 00 77 0c 81 00 00 00 00 00     l.......w.......
  811e40:	82 0c 81 00 00 00 00 00 8d 0c 81 00 00 00 00 00     ................
  811e50:	98 0c 81 00 00 00 00 00 a3 0c 81 00 00 00 00 00     ................
  811e60:	ae 0c 81 00 00 00 00 00 b9 0c 81 00 00 00 00 00     ................
  811e70:	c4 0c 81 00 00 00 00 00 cf 0c 81 00 00 00 00 00     ................
  811e80:	da 0c 81 00 00 00 00 00 e2 0d 81 00 00 00 00 00     ................
  811e90:	e5 0c 81 00 00 00 00 00 f0 0c 81 00 00 00 00 00     ................
  811ea0:	fb 0c 81 00 00 00 00 00 06 0d 81 00 00 00 00 00     ................
  811eb0:	11 0d 81 00 00 00 00 00 1c 0d 81 00 00 00 00 00     ................
  811ec0:	27 0d 81 00 00 00 00 00 32 0d 81 00 00 00 00 00     '.......2.......
  811ed0:	3d 0d 81 00 00 00 00 00 48 0d 81 00 00 00 00 00     =.......H.......
  811ee0:	53 0d 81 00 00 00 00 00 5e 0d 81 00 00 00 00 00     S.......^.......
  811ef0:	69 0d 81 00 00 00 00 00 74 0d 81 00 00 00 00 00     i.......t.......
  811f00:	7f 0d 81 00 00 00 00 00 8a 0d 81 00 00 00 00 00     ................
  811f10:	95 0d 81 00 00 00 00 00 a0 0d 81 00 00 00 00 00     ................
  811f20:	ab 0d 81 00 00 00 00 00 b6 0d 81 00 00 00 00 00     ................
  811f30:	c1 0d 81 00 00 00 00 00 cc 0d 81 00 00 00 00 00     ................
  811f40:	d7 0d 81 00 00 00 00 00 00 00 00 00 00 00 00 00     ................

0000000000811f50 <ADAM7_DY>:
  811f50:	08 00 00 00 08 00 00 00 08 00 00 00 04 00 00 00     ................
  811f60:	04 00 00 00 02 00 00 00 02 00 00 00 00 00 00 00     ................

0000000000811f70 <ADAM7_DX>:
  811f70:	08 00 00 00 08 00 00 00 04 00 00 00 04 00 00 00     ................
  811f80:	02 00 00 00 02 00 00 00 01 00 00 00 00 00 00 00     ................

0000000000811f90 <ADAM7_IY>:
	...
  811f98:	04 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00     ................
  811fa8:	01 00 00 00 00 00 00 00                             ........

0000000000811fb0 <ADAM7_IX>:
  811fb0:	00 00 00 00 04 00 00 00 00 00 00 00 02 00 00 00     ................
  811fc0:	00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...

0000000000811fe0 <lodepng_crc32_table>:
  811fe0:	00 00 00 00 96 30 07 77 2c 61 0e ee ba 51 09 99     .....0.w,a...Q..
  811ff0:	19 c4 6d 07 8f f4 6a 70 35 a5 63 e9 a3 95 64 9e     ..m...jp5.c...d.
  812000:	32 88 db 0e a4 b8 dc 79 1e e9 d5 e0 88 d9 d2 97     2......y........
  812010:	2b 4c b6 09 bd 7c b1 7e 07 2d b8 e7 91 1d bf 90     +L...|.~.-......
  812020:	64 10 b7 1d f2 20 b0 6a 48 71 b9 f3 de 41 be 84     d.... .jHq...A..
  812030:	7d d4 da 1a eb e4 dd 6d 51 b5 d4 f4 c7 85 d3 83     }......mQ.......
  812040:	56 98 6c 13 c0 a8 6b 64 7a f9 62 fd ec c9 65 8a     V.l...kdz.b...e.
  812050:	4f 5c 01 14 d9 6c 06 63 63 3d 0f fa f5 0d 08 8d     O\...l.cc=......
  812060:	c8 20 6e 3b 5e 10 69 4c e4 41 60 d5 72 71 67 a2     . n;^.iL.A`.rqg.
  812070:	d1 e4 03 3c 47 d4 04 4b fd 85 0d d2 6b b5 0a a5     ...<G..K....k...
  812080:	fa a8 b5 35 6c 98 b2 42 d6 c9 bb db 40 f9 bc ac     ...5l..B....@...
  812090:	e3 6c d8 32 75 5c df 45 cf 0d d6 dc 59 3d d1 ab     .l.2u\.E....Y=..
  8120a0:	ac 30 d9 26 3a 00 de 51 80 51 d7 c8 16 61 d0 bf     .0.&:..Q.Q...a..
  8120b0:	b5 f4 b4 21 23 c4 b3 56 99 95 ba cf 0f a5 bd b8     ...!#..V........
  8120c0:	9e b8 02 28 08 88 05 5f b2 d9 0c c6 24 e9 0b b1     ...(..._....$...
  8120d0:	87 7c 6f 2f 11 4c 68 58 ab 1d 61 c1 3d 2d 66 b6     .|o/.LhX..a.=-f.
  8120e0:	90 41 dc 76 06 71 db 01 bc 20 d2 98 2a 10 d5 ef     .A.v.q... ..*...
  8120f0:	89 85 b1 71 1f b5 b6 06 a5 e4 bf 9f 33 d4 b8 e8     ...q........3...
  812100:	a2 c9 07 78 34 f9 00 0f 8e a8 09 96 18 98 0e e1     ...x4...........
  812110:	bb 0d 6a 7f 2d 3d 6d 08 97 6c 64 91 01 5c 63 e6     ..j.-=m..ld..\c.
  812120:	f4 51 6b 6b 62 61 6c 1c d8 30 65 85 4e 00 62 f2     .Qkkbal..0e.N.b.
  812130:	ed 95 06 6c 7b a5 01 1b c1 f4 08 82 57 c4 0f f5     ...l{.......W...
  812140:	c6 d9 b0 65 50 e9 b7 12 ea b8 be 8b 7c 88 b9 fc     ...eP.......|...
  812150:	df 1d dd 62 49 2d da 15 f3 7c d3 8c 65 4c d4 fb     ...bI-...|..eL..
  812160:	58 61 b2 4d ce 51 b5 3a 74 00 bc a3 e2 30 bb d4     Xa.M.Q.:t....0..
  812170:	41 a5 df 4a d7 95 d8 3d 6d c4 d1 a4 fb f4 d6 d3     A..J...=m.......
  812180:	6a e9 69 43 fc d9 6e 34 46 88 67 ad d0 b8 60 da     j.iC..n4F.g...`.
  812190:	73 2d 04 44 e5 1d 03 33 5f 4c 0a aa c9 7c 0d dd     s-.D...3_L...|..
  8121a0:	3c 71 05 50 aa 41 02 27 10 10 0b be 86 20 0c c9     <q.P.A.'..... ..
  8121b0:	25 b5 68 57 b3 85 6f 20 09 d4 66 b9 9f e4 61 ce     %.hW..o ..f...a.
  8121c0:	0e f9 de 5e 98 c9 d9 29 22 98 d0 b0 b4 a8 d7 c7     ...^...)".......
  8121d0:	17 3d b3 59 81 0d b4 2e 3b 5c bd b7 ad 6c ba c0     .=.Y....;\...l..
  8121e0:	20 83 b8 ed b6 b3 bf 9a 0c e2 b6 03 9a d2 b1 74      ..............t
  8121f0:	39 47 d5 ea af 77 d2 9d 15 26 db 04 83 16 dc 73     9G...w...&.....s
  812200:	12 0b 63 e3 84 3b 64 94 3e 6a 6d 0d a8 5a 6a 7a     ..c..;d.>jm..Zjz
  812210:	0b cf 0e e4 9d ff 09 93 27 ae 00 0a b1 9e 07 7d     ........'......}
  812220:	44 93 0f f0 d2 a3 08 87 68 f2 01 1e fe c2 06 69     D.......h......i
  812230:	5d 57 62 f7 cb 67 65 80 71 36 6c 19 e7 06 6b 6e     ]Wb..ge.q6l...kn
  812240:	76 1b d4 fe e0 2b d3 89 5a 7a da 10 cc 4a dd 67     v....+..Zz...J.g
  812250:	6f df b9 f9 f9 ef be 8e 43 be b7 17 d5 8e b0 60     o.......C......`
  812260:	e8 a3 d6 d6 7e 93 d1 a1 c4 c2 d8 38 52 f2 df 4f     ....~......8R..O
  812270:	f1 67 bb d1 67 57 bc a6 dd 06 b5 3f 4b 36 b2 48     .g..gW.....?K6.H
  812280:	da 2b 0d d8 4c 1b 0a af f6 4a 03 36 60 7a 04 41     .+..L....J.6`z.A
  812290:	c3 ef 60 df 55 df 67 a8 ef 8e 6e 31 79 be 69 46     ..`.U.g...n1y.iF
  8122a0:	8c b3 61 cb 1a 83 66 bc a0 d2 6f 25 36 e2 68 52     ..a...f...o%6.hR
  8122b0:	95 77 0c cc 03 47 0b bb b9 16 02 22 2f 26 05 55     .w...G....."/&.U
  8122c0:	be 3b ba c5 28 0b bd b2 92 5a b4 2b 04 6a b3 5c     .;..(....Z.+.j.\
  8122d0:	a7 ff d7 c2 31 cf d0 b5 8b 9e d9 2c 1d ae de 5b     ....1......,...[
  8122e0:	b0 c2 64 9b 26 f2 63 ec 9c a3 6a 75 0a 93 6d 02     ..d.&.c...ju..m.
  8122f0:	a9 06 09 9c 3f 36 0e eb 85 67 07 72 13 57 00 05     ....?6...g.r.W..
  812300:	82 4a bf 95 14 7a b8 e2 ae 2b b1 7b 38 1b b6 0c     .J...z...+.{8...
  812310:	9b 8e d2 92 0d be d5 e5 b7 ef dc 7c 21 df db 0b     ...........|!...
  812320:	d4 d2 d3 86 42 e2 d4 f1 f8 b3 dd 68 6e 83 da 1f     ....B......hn...
  812330:	cd 16 be 81 5b 26 b9 f6 e1 77 b0 6f 77 47 b7 18     ....[&...w.owG..
  812340:	e6 5a 08 88 70 6a 0f ff ca 3b 06 66 5c 0b 01 11     .Z..pj...;.f\...
  812350:	ff 9e 65 8f 69 ae 62 f8 d3 ff 6b 61 45 cf 6c 16     ..e.i.b...kaE.l.
  812360:	78 e2 0a a0 ee d2 0d d7 54 83 04 4e c2 b3 03 39     x.......T..N...9
  812370:	61 26 67 a7 f7 16 60 d0 4d 47 69 49 db 77 6e 3e     a&g...`.MGiI.wn>
  812380:	4a 6a d1 ae dc 5a d6 d9 66 0b df 40 f0 3b d8 37     Jj...Z..f..@.;.7
  812390:	53 ae bc a9 c5 9e bb de 7f cf b2 47 e9 ff b5 30     S..........G...0
  8123a0:	1c f2 bd bd 8a c2 ba ca 30 93 b3 53 a6 a3 b4 24     ........0..S...$
  8123b0:	05 36 d0 ba 93 06 d7 cd 29 57 de 54 bf 67 d9 23     .6......)W.T.g.#
  8123c0:	2e 7a 66 b3 b8 4a 61 c4 02 1b 68 5d 94 2b 6f 2a     .zf..Ja...h].+o*
  8123d0:	37 be 0b b4 a1 8e 0c c3 1b df 05 5a 8d ef 02 2d     7..........Z...-

00000000008123e0 <lodepng_default_decompress_settings>:
	...

0000000000812400 <lodepng_default_compress_settings>:
  812400:	02 00 00 00 01 00 00 00 00 08 00 00 03 00 00 00     ................
  812410:	80 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...

0000000000812440 <CLCL_ORDER>:
  812440:	10 00 00 00 11 00 00 00 12 00 00 00 00 00 00 00     ................
  812450:	08 00 00 00 07 00 00 00 09 00 00 00 06 00 00 00     ................
  812460:	0a 00 00 00 05 00 00 00 0b 00 00 00 04 00 00 00     ................
  812470:	0c 00 00 00 03 00 00 00 0d 00 00 00 02 00 00 00     ................
  812480:	0e 00 00 00 01 00 00 00 0f 00 00 00 00 00 00 00     ................
	...

00000000008124a0 <DISTANCEEXTRA>:
	...
  8124b0:	01 00 00 00 01 00 00 00 02 00 00 00 02 00 00 00     ................
  8124c0:	03 00 00 00 03 00 00 00 04 00 00 00 04 00 00 00     ................
  8124d0:	05 00 00 00 05 00 00 00 06 00 00 00 06 00 00 00     ................
  8124e0:	07 00 00 00 07 00 00 00 08 00 00 00 08 00 00 00     ................
  8124f0:	09 00 00 00 09 00 00 00 0a 00 00 00 0a 00 00 00     ................
  812500:	0b 00 00 00 0b 00 00 00 0c 00 00 00 0c 00 00 00     ................
  812510:	0d 00 00 00 0d 00 00 00 00 00 00 00 00 00 00 00     ................

0000000000812520 <DISTANCEBASE>:
  812520:	01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00     ................
  812530:	05 00 00 00 07 00 00 00 09 00 00 00 0d 00 00 00     ................
  812540:	11 00 00 00 19 00 00 00 21 00 00 00 31 00 00 00     ........!...1...
  812550:	41 00 00 00 61 00 00 00 81 00 00 00 c1 00 00 00     A...a...........
  812560:	01 01 00 00 81 01 00 00 01 02 00 00 01 03 00 00     ................
  812570:	01 04 00 00 01 06 00 00 01 08 00 00 01 0c 00 00     ................
  812580:	01 10 00 00 01 18 00 00 01 20 00 00 01 30 00 00     ......... ...0..
  812590:	01 40 00 00 01 60 00 00 00 00 00 00 00 00 00 00     .@...`..........

00000000008125a0 <LENGTHEXTRA>:
	...
  8125c0:	01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00     ................
  8125d0:	02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00     ................
  8125e0:	03 00 00 00 03 00 00 00 03 00 00 00 03 00 00 00     ................
  8125f0:	04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00     ................
  812600:	05 00 00 00 05 00 00 00 05 00 00 00 05 00 00 00     ................
	...

0000000000812620 <LENGTHBASE>:
  812620:	03 00 00 00 04 00 00 00 05 00 00 00 06 00 00 00     ................
  812630:	07 00 00 00 08 00 00 00 09 00 00 00 0a 00 00 00     ................
  812640:	0b 00 00 00 0d 00 00 00 0f 00 00 00 11 00 00 00     ................
  812650:	13 00 00 00 17 00 00 00 1b 00 00 00 1f 00 00 00     ................
  812660:	23 00 00 00 2b 00 00 00 33 00 00 00 3b 00 00 00     #...+...3...;...
  812670:	43 00 00 00 53 00 00 00 63 00 00 00 73 00 00 00     C...S...c...s...
  812680:	83 00 00 00 a3 00 00 00 c3 00 00 00 e3 00 00 00     ................
  812690:	02 01 00 00 50 4c 54 45 00 74 52 4e 53 00 74 45     ....PLTE.tRNS.tE
  8126a0:	58 74 00 68 65 72 65 0a 00 49 48 44 52 00 62 4b     Xt.here..IHDR.bK
  8126b0:	47 44 00 7a 54 58 74 00 69 54 58 74 00 74 49 4d     GD.zTXt.iTXt.tIM
  8126c0:	45 00 70 48 59 73 00 67 41 4d 41 00 63 48 52 4d     E.pHYs.gAMA.cHRM
  8126d0:	00 73 52 47 42 00 69 43 43 50 00 49 44 41 54 00     .sRGB.iCCP.IDAT.
  8126e0:	49 45 4e 44 00 4c 6f 64 65 50 4e 47 00 75 6e 6b     IEND.LodePNG.unk
  8126f0:	6e 6f 77 6e 20 65 72 72 6f 72 20 63 6f 64 65 00     nown error code.
  812700:	6e 6f 20 65 72 72 6f 72 2c 20 65 76 65 72 79 74     no error, everyt
  812710:	68 69 6e 67 20 77 65 6e 74 20 6f 6b 00 69 6e 76     hing went ok.inv
  812720:	61 6c 69 64 20 46 43 48 45 43 4b 20 69 6e 20 7a     alid FCHECK in z
  812730:	6c 69 62 20 68 65 61 64 65 72 00 69 6c 6c 65 67     lib header.illeg
  812740:	61 6c 20 50 4e 47 20 63 6f 6c 6f 72 20 74 79 70     al PNG color typ
  812750:	65 20 6f 72 20 62 70 70 00 69 6c 6c 65 67 61 6c     e or bpp.illegal
  812760:	20 50 4e 47 20 66 69 6c 74 65 72 20 6d 65 74 68      PNG filter meth
  812770:	6f 64 00 69 6c 6c 65 67 61 6c 20 50 4e 47 20 69     od.illegal PNG i
  812780:	6e 74 65 72 6c 61 63 65 20 6d 65 74 68 6f 64 00     nterlace method.
  812790:	73 69 7a 65 20 6f 66 20 7a 6c 69 62 20 64 61 74     size of zlib dat
  8127a0:	61 20 74 6f 6f 20 73 6d 61 6c 6c 00 69 6e 76 61     a too small.inva
  8127b0:	6c 69 64 20 74 49 4d 45 20 63 68 75 6e 6b 20 73     lid tIME chunk s
  8127c0:	69 7a 65 00 69 6e 76 61 6c 69 64 20 70 48 59 73     ize.invalid pHYs
  8127d0:	20 63 68 75 6e 6b 20 73 69 7a 65 00 6d 65 6d 6f      chunk size.memo
  8127e0:	72 79 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 66 61     ry allocation fa
  8127f0:	69 6c 65 64 00 69 6e 76 61 6c 69 64 20 67 41 4d     iled.invalid gAM
  812800:	41 20 63 68 75 6e 6b 20 73 69 7a 65 00 69 6e 76     A chunk size.inv
  812810:	61 6c 69 64 20 63 48 52 4d 20 63 68 75 6e 6b 20     alid cHRM chunk 
  812820:	73 69 7a 65 00 69 6e 76 61 6c 69 64 20 73 52 47     size.invalid sRG
  812830:	42 20 63 68 75 6e 6b 20 73 69 7a 65 00 69 6e 76     B chunk size.inv
  812840:	61 6c 69 64 20 73 52 47 42 20 72 65 6e 64 65 72     alid sRGB render
  812850:	69 6e 67 20 69 6e 74 65 6e 74 00 69 6e 74 65 67     ing intent.integ
  812860:	65 72 20 6f 76 65 72 66 6c 6f 77 20 6f 66 20 62     er overflow of b
  812870:	69 74 73 69 7a 65 00 6e 6f 74 68 69 6e 67 20 64     itsize.nothing d
  812880:	6f 6e 65 20 79 65 74 00 32 30 32 30 30 32 31 39     one yet.20200219
  812890:	00 0f 1f 80 00 00 00 00 65 6e 64 20 6f 66 20 69     ........end of i
  8128a0:	6e 70 75 74 20 6d 65 6d 6f 72 79 20 72 65 61 63     nput memory reac
  8128b0:	68 65 64 20 77 69 74 68 6f 75 74 20 68 75 66 66     hed without huff
  8128c0:	6d 61 6e 20 65 6e 64 20 63 6f 64 65 00 00 00 00     man end code....
  8128d0:	65 72 72 6f 72 20 69 6e 20 63 6f 64 65 20 74 72     error in code tr
  8128e0:	65 65 20 6d 61 64 65 20 69 74 20 6a 75 6d 70 20     ee made it jump 
  8128f0:	6f 75 74 73 69 64 65 20 6f 66 20 68 75 66 66 6d     outside of huffm
  812900:	61 6e 20 74 72 65 65 00 70 72 6f 62 6c 65 6d 20     an tree.problem 
  812910:	77 68 69 6c 65 20 70 72 6f 63 65 73 73 69 6e 67     while processing
  812920:	20 64 79 6e 61 6d 69 63 20 64 65 66 6c 61 74 65      dynamic deflate
  812930:	20 62 6c 6f 63 6b 00 00 6e 6f 6e 65 78 69 73 74      block..nonexist
  812940:	65 6e 74 20 63 6f 64 65 20 77 68 69 6c 65 20 70     ent code while p
  812950:	72 6f 63 65 73 73 69 6e 67 20 64 79 6e 61 6d 69     rocessing dynami
  812960:	63 20 64 65 66 6c 61 74 65 20 62 6c 6f 63 6b 00     c deflate block.
  812970:	65 6e 64 20 6f 66 20 6f 75 74 20 62 75 66 66 65     end of out buffe
  812980:	72 20 6d 65 6d 6f 72 79 20 72 65 61 63 68 65 64     r memory reached
  812990:	20 77 68 69 6c 65 20 69 6e 66 6c 61 74 69 6e 67      while inflating
	...
  8129a8:	69 6e 76 61 6c 69 64 20 64 69 73 74 61 6e 63 65     invalid distance
  8129b8:	20 63 6f 64 65 20 77 68 69 6c 65 20 69 6e 66 6c      code while infl
  8129c8:	61 74 69 6e 67 00 00 00 69 6e 76 61 6c 69 64 20     ating...invalid 
  8129d8:	64 65 66 6c 61 74 65 20 62 6c 6f 63 6b 20 42 54     deflate block BT
  8129e8:	59 50 45 20 65 6e 63 6f 75 6e 74 65 72 65 64 20     YPE encountered 
  8129f8:	77 68 69 6c 65 20 64 65 63 6f 64 69 6e 67 00 00     while decoding..
  812a08:	4e 4c 45 4e 20 69 73 20 6e 6f 74 20 6f 6e 65 73     NLEN is not ones
  812a18:	20 63 6f 6d 70 6c 65 6d 65 6e 74 20 6f 66 20 4c      complement of L
  812a28:	45 4e 20 69 6e 20 61 20 64 65 66 6c 61 74 65 20     EN in a deflate 
  812a38:	62 6c 6f 63 6b 00 00 00 65 6e 64 20 6f 66 20 69     block...end of i
  812a48:	6e 20 62 75 66 66 65 72 20 6d 65 6d 6f 72 79 20     n buffer memory 
  812a58:	72 65 61 63 68 65 64 20 77 68 69 6c 65 20 69 6e     reached while in
  812a68:	66 6c 61 74 69 6e 67 00 69 6e 76 61 6c 69 64 20     flating.invalid 
  812a78:	63 6f 6d 70 72 65 73 73 69 6f 6e 20 6d 65 74 68     compression meth
  812a88:	6f 64 20 69 6e 20 7a 6c 69 62 20 68 65 61 64 65     od in zlib heade
  812a98:	72 00 00 00 00 00 00 00 46 44 49 43 54 20 65 6e     r.......FDICT en
  812aa8:	63 6f 75 6e 74 65 72 65 64 20 69 6e 20 7a 6c 69     countered in zli
  812ab8:	62 20 68 65 61 64 65 72 20 77 68 69 6c 65 20 69     b header while i
  812ac8:	74 27 73 20 6e 6f 74 20 75 73 65 64 20 66 6f 72     t's not used for
  812ad8:	20 50 4e 47 00 00 00 00 50 4e 47 20 66 69 6c 65      PNG....PNG file
  812ae8:	20 69 73 20 73 6d 61 6c 6c 65 72 20 74 68 61 6e      is smaller than
  812af8:	20 61 20 50 4e 47 20 68 65 61 64 65 72 00 00 00      a PNG header...
  812b08:	69 6e 63 6f 72 72 65 63 74 20 50 4e 47 20 73 69     incorrect PNG si
  812b18:	67 6e 61 74 75 72 65 2c 20 69 74 27 73 20 6e 6f     gnature, it's no
  812b28:	20 50 4e 47 20 6f 72 20 63 6f 72 72 75 70 74 65      PNG or corrupte
  812b38:	64 00 00 00 00 00 00 00 66 69 72 73 74 20 63 68     d.......first ch
  812b48:	75 6e 6b 20 69 73 20 6e 6f 74 20 74 68 65 20 68     unk is not the h
  812b58:	65 61 64 65 72 20 63 68 75 6e 6b 00 00 00 00 00     eader chunk.....
  812b68:	63 68 75 6e 6b 20 6c 65 6e 67 74 68 20 74 6f 6f     chunk length too
  812b78:	20 6c 61 72 67 65 2c 20 63 68 75 6e 6b 20 62 72      large, chunk br
  812b88:	6f 6b 65 6e 20 6f 66 66 20 61 74 20 65 6e 64 20     oken off at end 
  812b98:	6f 66 20 66 69 6c 65 00 69 6c 6c 65 67 61 6c 20     of file.illegal 
  812ba8:	50 4e 47 20 63 6f 6d 70 72 65 73 73 69 6f 6e 20     PNG compression 
  812bb8:	6d 65 74 68 6f 64 00 00 63 68 75 6e 6b 20 6c 65     method..chunk le
  812bc8:	6e 67 74 68 20 6f 66 20 61 20 63 68 75 6e 6b 20     ngth of a chunk 
  812bd8:	69 73 20 74 6f 6f 20 6c 61 72 67 65 20 6f 72 20     is too large or 
  812be8:	74 68 65 20 63 68 75 6e 6b 20 74 6f 6f 20 73 6d     the chunk too sm
  812bf8:	61 6c 6c 00 00 00 00 00 69 6c 6c 65 67 61 6c 20     all.....illegal 
  812c08:	50 4e 47 20 66 69 6c 74 65 72 20 74 79 70 65 20     PNG filter type 
  812c18:	65 6e 63 6f 75 6e 74 65 72 65 64 00 00 00 00 00     encountered.....
  812c28:	69 6c 6c 65 67 61 6c 20 62 69 74 20 64 65 70 74     illegal bit dept
  812c38:	68 20 66 6f 72 20 74 68 69 73 20 63 6f 6c 6f 72     h for this color
  812c48:	20 74 79 70 65 20 67 69 76 65 6e 00 00 00 00 00      type given.....
  812c58:	74 68 65 20 70 61 6c 65 74 74 65 20 69 73 20 74     the palette is t
  812c68:	6f 6f 20 73 6d 61 6c 6c 20 6f 72 20 74 6f 6f 20     oo small or too 
  812c78:	62 69 67 00 00 00 00 00 74 52 4e 53 20 63 68 75     big.....tRNS chu
  812c88:	6e 6b 20 62 65 66 6f 72 65 20 50 4c 54 45 20 6f     nk before PLTE o
  812c98:	72 20 68 61 73 20 6d 6f 72 65 20 65 6e 74 72 69     r has more entri
  812ca8:	65 73 20 74 68 61 6e 20 70 61 6c 65 74 74 65 20     es than palette 
  812cb8:	73 69 7a 65 00 00 00 00 74 52 4e 53 20 63 68 75     size....tRNS chu
  812cc8:	6e 6b 20 68 61 73 20 77 72 6f 6e 67 20 73 69 7a     nk has wrong siz
  812cd8:	65 20 66 6f 72 20 67 72 61 79 73 63 61 6c 65 20     e for grayscale 
  812ce8:	69 6d 61 67 65 00 00 00 74 52 4e 53 20 63 68 75     image...tRNS chu
  812cf8:	6e 6b 20 68 61 73 20 77 72 6f 6e 67 20 73 69 7a     nk has wrong siz
  812d08:	65 20 66 6f 72 20 52 47 42 20 69 6d 61 67 65 00     e for RGB image.
  812d18:	74 52 4e 53 20 63 68 75 6e 6b 20 61 70 70 65 61     tRNS chunk appea
  812d28:	72 65 64 20 77 68 69 6c 65 20 69 74 20 77 61 73     red while it was
  812d38:	20 6e 6f 74 20 61 6c 6c 6f 77 65 64 20 66 6f 72      not allowed for
  812d48:	20 74 68 69 73 20 63 6f 6c 6f 72 20 74 79 70 65      this color type
	...
  812d60:	62 4b 47 44 20 63 68 75 6e 6b 20 68 61 73 20 77     bKGD chunk has w
  812d70:	72 6f 6e 67 20 73 69 7a 65 20 66 6f 72 20 70 61     rong size for pa
  812d80:	6c 65 74 74 65 20 69 6d 61 67 65 00 00 00 00 00     lette image.....
  812d90:	62 4b 47 44 20 63 68 75 6e 6b 20 68 61 73 20 77     bKGD chunk has w
  812da0:	72 6f 6e 67 20 73 69 7a 65 20 66 6f 72 20 67 72     rong size for gr
  812db0:	61 79 73 63 61 6c 65 20 69 6d 61 67 65 00 00 00     ayscale image...
  812dc0:	62 4b 47 44 20 63 68 75 6e 6b 20 68 61 73 20 77     bKGD chunk has w
  812dd0:	72 6f 6e 67 20 73 69 7a 65 20 66 6f 72 20 52 47     rong size for RG
  812de0:	42 20 69 6d 61 67 65 00 65 6d 70 74 79 20 69 6e     B image.empty in
  812df0:	70 75 74 20 62 75 66 66 65 72 20 67 69 76 65 6e     put buffer given
  812e00:	20 74 6f 20 64 65 63 6f 64 65 72 2e 20 4d 61 79      to decoder. May
  812e10:	62 65 20 63 61 75 73 65 64 20 62 79 20 6e 6f 6e     be caused by non
  812e20:	2d 65 78 69 73 74 69 6e 67 20 66 69 6c 65 3f 00     -existing file?.
  812e30:	6a 75 6d 70 65 64 20 70 61 73 74 20 6d 65 6d 6f     jumped past memo
  812e40:	72 79 20 77 68 69 6c 65 20 67 65 6e 65 72 61 74     ry while generat
  812e50:	69 6e 67 20 64 79 6e 61 6d 69 63 20 68 75 66 66     ing dynamic huff
  812e60:	6d 61 6e 20 74 72 65 65 00 00 00 00 00 00 00 00     man tree........
  812e70:	6a 75 6d 70 65 64 20 70 61 73 74 20 6d 65 6d 6f     jumped past memo
  812e80:	72 79 20 77 68 69 6c 65 20 69 6e 66 6c 61 74 69     ry while inflati
  812e90:	6e 67 20 68 75 66 66 6d 61 6e 20 62 6c 6f 63 6b     ng huffman block
	...
  812ea8:	6a 75 6d 70 65 64 20 70 61 73 74 20 6d 65 6d 6f     jumped past memo
  812eb8:	72 79 20 77 68 69 6c 65 20 69 6e 66 6c 61 74 69     ry while inflati
  812ec8:	6e 67 00 00 00 00 00 00 72 65 70 65 61 74 20 73     ng......repeat s
  812ed8:	79 6d 62 6f 6c 20 69 6e 20 74 72 65 65 20 77 68     ymbol in tree wh
  812ee8:	69 6c 65 20 74 68 65 72 65 20 77 61 73 20 6e 6f     ile there was no
  812ef8:	20 76 61 6c 75 65 20 73 79 6d 62 6f 6c 20 79 65      value symbol ye
  812f08:	74 00 00 00 00 00 00 00 6a 75 6d 70 65 64 20 70     t.......jumped p
  812f18:	61 73 74 20 74 72 65 65 20 77 68 69 6c 65 20 67     ast tree while g
  812f28:	65 6e 65 72 61 74 69 6e 67 20 68 75 66 66 6d 61     enerating huffma
  812f38:	6e 20 74 72 65 65 00 00 67 69 76 65 6e 20 6f 75     n tree..given ou
  812f48:	74 70 75 74 20 69 6d 61 67 65 20 63 6f 6c 6f 72     tput image color
  812f58:	74 79 70 65 20 6f 72 20 62 69 74 64 65 70 74 68     type or bitdepth
  812f68:	20 6e 6f 74 20 73 75 70 70 6f 72 74 65 64 20 66      not supported f
  812f78:	6f 72 20 63 6f 6c 6f 72 20 63 6f 6e 76 65 72 73     or color convers
  812f88:	69 6f 6e 00 00 00 00 00 69 6e 76 61 6c 69 64 20     ion.....invalid 
  812f98:	43 52 43 20 65 6e 63 6f 75 6e 74 65 72 65 64 20     CRC encountered 
  812fa8:	28 63 68 65 63 6b 69 6e 67 20 43 52 43 20 63 61     (checking CRC ca
  812fb8:	6e 20 62 65 20 64 69 73 61 62 6c 65 64 29 00 00     n be disabled)..
  812fc8:	69 6e 76 61 6c 69 64 20 41 44 4c 45 52 33 32 20     invalid ADLER32 
  812fd8:	65 6e 63 6f 75 6e 74 65 72 65 64 20 28 63 68 65     encountered (che
  812fe8:	63 6b 69 6e 67 20 41 44 4c 45 52 33 32 20 63 61     cking ADLER32 ca
  812ff8:	6e 20 62 65 20 64 69 73 61 62 6c 65 64 29 00 00     n be disabled)..
  813008:	72 65 71 75 65 73 74 65 64 20 63 6f 6c 6f 72 20     requested color 
  813018:	63 6f 6e 76 65 72 73 69 6f 6e 20 6e 6f 74 20 73     conversion not s
  813028:	75 70 70 6f 72 74 65 64 00 00 00 00 00 00 00 00     upported........
  813038:	69 6e 76 61 6c 69 64 20 77 69 6e 64 6f 77 20 73     invalid window s
  813048:	69 7a 65 20 67 69 76 65 6e 20 69 6e 20 74 68 65     ize given in the
  813058:	20 73 65 74 74 69 6e 67 73 20 6f 66 20 74 68 65      settings of the
  813068:	20 65 6e 63 6f 64 65 72 20 28 6d 75 73 74 20 62      encoder (must b
  813078:	65 20 30 2d 33 32 37 36 38 29 00 00 00 00 00 00     e 0-32768)......
  813088:	69 6e 76 61 6c 69 64 20 42 54 59 50 45 20 67 69     invalid BTYPE gi
  813098:	76 65 6e 20 69 6e 20 74 68 65 20 73 65 74 74 69     ven in the setti
  8130a8:	6e 67 73 20 6f 66 20 74 68 65 20 65 6e 63 6f 64     ngs of the encod
  8130b8:	65 72 20 28 6f 6e 6c 79 20 30 2c 20 31 20 61 6e     er (only 0, 1 an
  8130c8:	64 20 32 20 61 72 65 20 61 6c 6c 6f 77 65 64 29     d 2 are allowed)
	...
  8130e0:	63 6f 6e 76 65 72 73 69 6f 6e 20 66 72 6f 6d 20     conversion from 
  8130f0:	63 6f 6c 6f 72 20 74 6f 20 67 72 61 79 73 63 61     color to graysca
  813100:	6c 65 20 6e 6f 74 20 73 75 70 70 6f 72 74 65 64     le not supported
	...
  813118:	6c 65 6e 67 74 68 20 6f 66 20 61 20 63 68 75 6e     length of a chun
  813128:	6b 20 74 6f 6f 20 6c 6f 6e 67 2c 20 6d 61 78 20     k too long, max 
  813138:	61 6c 6c 6f 77 65 64 20 66 6f 72 20 50 4e 47 20     allowed for PNG 
  813148:	69 73 20 32 31 34 37 34 38 33 36 34 37 20 62 79     is 2147483647 by
  813158:	74 65 73 20 70 65 72 20 63 68 75 6e 6b 00 00 00     tes per chunk...
  813168:	74 68 65 20 6c 65 6e 67 74 68 20 6f 66 20 74 68     the length of th
  813178:	65 20 45 4e 44 20 73 79 6d 62 6f 6c 20 32 35 36     e END symbol 256
  813188:	20 69 6e 20 74 68 65 20 48 75 66 66 6d 61 6e 20      in the Huffman 
  813198:	74 72 65 65 20 69 73 20 30 00 00 00 00 00 00 00     tree is 0.......
  8131a8:	74 68 65 20 6c 65 6e 67 74 68 20 6f 66 20 61 20     the length of a 
  8131b8:	74 65 78 74 20 63 68 75 6e 6b 20 6b 65 79 77 6f     text chunk keywo
  8131c8:	72 64 20 67 69 76 65 6e 20 74 6f 20 74 68 65 20     rd given to the 
  8131d8:	65 6e 63 6f 64 65 72 20 69 73 20 6c 6f 6e 67 65     encoder is longe
  8131e8:	72 20 74 68 61 6e 20 74 68 65 20 6d 61 78 69 6d     r than the maxim
  8131f8:	75 6d 20 6f 66 20 37 39 20 62 79 74 65 73 00 00     um of 79 bytes..
  813208:	74 68 65 20 6c 65 6e 67 74 68 20 6f 66 20 61 20     the length of a 
  813218:	74 65 78 74 20 63 68 75 6e 6b 20 6b 65 79 77 6f     text chunk keywo
  813228:	72 64 20 67 69 76 65 6e 20 74 6f 20 74 68 65 20     rd given to the 
  813238:	65 6e 63 6f 64 65 72 20 69 73 20 73 6d 61 6c 6c     encoder is small
  813248:	65 72 20 74 68 61 6e 20 74 68 65 20 6d 69 6e 69     er than the mini
  813258:	6d 75 6d 20 6f 66 20 31 20 62 79 74 65 00 00 00     mum of 1 byte...
  813268:	74 72 69 65 64 20 74 6f 20 65 6e 63 6f 64 65 20     tried to encode 
  813278:	61 20 50 4c 54 45 20 63 68 75 6e 6b 20 77 69 74     a PLTE chunk wit
  813288:	68 20 61 20 70 61 6c 65 74 74 65 20 74 68 61 74     h a palette that
  813298:	20 68 61 73 20 6c 65 73 73 20 74 68 61 6e 20 31      has less than 1
  8132a8:	20 6f 72 20 6d 6f 72 65 20 74 68 61 6e 20 32 35      or more than 25
  8132b8:	36 20 63 6f 6c 6f 72 73 00 00 00 00 00 00 00 00     6 colors........
  8132c8:	75 6e 6b 6e 6f 77 6e 20 63 68 75 6e 6b 20 74 79     unknown chunk ty
  8132d8:	70 65 20 77 69 74 68 20 27 63 72 69 74 69 63 61     pe with 'critica
  8132e8:	6c 27 20 66 6c 61 67 20 65 6e 63 6f 75 6e 74 65     l' flag encounte
  8132f8:	72 65 64 20 62 79 20 74 68 65 20 64 65 63 6f 64     red by the decod
  813308:	65 72 00 00 00 00 00 00 6e 6f 6e 65 78 69 73 74     er......nonexist
  813318:	65 6e 74 20 69 6e 74 65 72 6c 61 63 65 20 6d 6f     ent interlace mo
  813328:	64 65 20 67 69 76 65 6e 20 74 6f 20 65 6e 63 6f     de given to enco
  813338:	64 65 72 20 28 6d 75 73 74 20 62 65 20 30 20 6f     der (must be 0 o
  813348:	72 20 31 29 00 00 00 00 77 68 69 6c 65 20 64 65     r 1)....while de
  813358:	63 6f 64 69 6e 67 2c 20 6e 6f 6e 65 78 69 73 74     coding, nonexist
  813368:	65 6e 74 20 63 6f 6d 70 72 65 73 73 69 6f 6e 20     ent compression 
  813378:	6d 65 74 68 6f 64 20 65 6e 63 6f 75 6e 74 65 72     method encounter
  813388:	69 6e 67 20 69 6e 20 7a 54 58 74 20 6f 72 20 69     ing in zTXt or i
  813398:	54 58 74 20 63 68 75 6e 6b 20 28 69 74 20 6d 75     TXt chunk (it mu
  8133a8:	73 74 20 62 65 20 30 29 00 00 00 00 00 00 00 00     st be 0)........
  8133b8:	6e 6f 20 6e 75 6c 6c 20 74 65 72 6d 69 6e 61 74     no null terminat
  8133c8:	69 6f 6e 20 63 68 61 72 20 66 6f 75 6e 64 20 77     ion char found w
  8133d8:	68 69 6c 65 20 64 65 63 6f 64 69 6e 67 20 74 65     hile decoding te
  8133e8:	78 74 20 63 68 75 6e 6b 00 00 00 00 00 00 00 00     xt chunk........
  8133f8:	69 54 58 74 20 63 68 75 6e 6b 20 74 6f 6f 20 73     iTXt chunk too s
  813408:	68 6f 72 74 20 74 6f 20 63 6f 6e 74 61 69 6e 20     hort to contain 
  813418:	72 65 71 75 69 72 65 64 20 62 79 74 65 73 00 00     required bytes..
  813428:	69 6e 74 65 67 65 72 20 6f 76 65 72 66 6c 6f 77     integer overflow
  813438:	20 69 6e 20 62 75 66 66 65 72 20 73 69 7a 65 00      in buffer size.
  813448:	66 61 69 6c 65 64 20 74 6f 20 6f 70 65 6e 20 66     failed to open f
  813458:	69 6c 65 20 66 6f 72 20 72 65 61 64 69 6e 67 00     ile for reading.
  813468:	66 61 69 6c 65 64 20 74 6f 20 6f 70 65 6e 20 66     failed to open f
  813478:	69 6c 65 20 66 6f 72 20 77 72 69 74 69 6e 67 00     ile for writing.
  813488:	74 72 69 65 64 20 63 72 65 61 74 69 6e 67 20 61     tried creating a
  813498:	20 74 72 65 65 20 6f 66 20 30 20 73 79 6d 62 6f      tree of 0 symbo
  8134a8:	6c 73 00 00 00 00 00 00 6c 61 7a 79 20 6d 61 74     ls......lazy mat
  8134b8:	63 68 69 6e 67 20 61 74 20 70 6f 73 20 30 20 69     ching at pos 0 i
  8134c8:	73 20 69 6d 70 6f 73 73 69 62 6c 65 00 00 00 00     s impossible....
  8134d8:	63 6f 6c 6f 72 20 63 6f 6e 76 65 72 73 69 6f 6e     color conversion
  8134e8:	20 74 6f 20 70 61 6c 65 74 74 65 20 72 65 71 75      to palette requ
  8134f8:	65 73 74 65 64 20 77 68 69 6c 65 20 61 20 63 6f     ested while a co
  813508:	6c 6f 72 20 69 73 6e 27 74 20 69 6e 20 70 61 6c     lor isn't in pal
  813518:	65 74 74 65 2c 20 6f 72 20 69 6e 64 65 78 20 6f     ette, or index o
  813528:	75 74 20 6f 66 20 62 6f 75 6e 64 73 00 00 00 00     ut of bounds....
  813538:	67 69 76 65 6e 20 69 6d 61 67 65 20 74 6f 6f 20     given image too 
  813548:	73 6d 61 6c 6c 20 74 6f 20 63 6f 6e 74 61 69 6e     small to contain
  813558:	20 61 6c 6c 20 70 69 78 65 6c 73 20 74 6f 20 62      all pixels to b
  813568:	65 20 65 6e 63 6f 64 65 64 00 00 00 00 00 00 00     e encoded.......
  813578:	69 6d 70 6f 73 73 69 62 6c 65 20 6f 66 66 73 65     impossible offse
  813588:	74 20 69 6e 20 6c 7a 37 37 20 65 6e 63 6f 64 69     t in lz77 encodi
  813598:	6e 67 20 28 69 6e 74 65 72 6e 61 6c 20 62 75 67     ng (internal bug
  8135a8:	29 00 00 00 00 00 00 00 6d 75 73 74 20 70 72 6f     ).......must pro
  8135b8:	76 69 64 65 20 63 75 73 74 6f 6d 20 7a 6c 69 62     vide custom zlib
  8135c8:	20 66 75 6e 63 74 69 6f 6e 20 70 6f 69 6e 74 65      function pointe
  8135d8:	72 20 69 66 20 4c 4f 44 45 50 4e 47 5f 43 4f 4d     r if LODEPNG_COM
  8135e8:	50 49 4c 45 5f 5a 4c 49 42 20 69 73 20 6e 6f 74     PILE_ZLIB is not
  8135f8:	20 64 65 66 69 6e 65 64 00 00 00 00 00 00 00 00      defined........
  813608:	69 6e 76 61 6c 69 64 20 66 69 6c 74 65 72 20 73     invalid filter s
  813618:	74 72 61 74 65 67 79 20 67 69 76 65 6e 20 66 6f     trategy given fo
  813628:	72 20 4c 6f 64 65 50 4e 47 45 6e 63 6f 64 65 72     r LodePNGEncoder
  813638:	53 65 74 74 69 6e 67 73 2e 66 69 6c 74 65 72 5f     Settings.filter_
  813648:	73 74 72 61 74 65 67 79 00 00 00 00 00 00 00 00     strategy........
  813658:	74 65 78 74 20 63 68 75 6e 6b 20 6b 65 79 77 6f     text chunk keywo
  813668:	72 64 20 74 6f 6f 20 73 68 6f 72 74 20 6f 72 20     rd too short or 
  813678:	6c 6f 6e 67 3a 20 6d 75 73 74 20 68 61 76 65 20     long: must have 
  813688:	73 69 7a 65 20 31 2d 37 39 00 00 00 00 00 00 00     size 1-79.......
  813698:	77 69 6e 64 6f 77 73 69 7a 65 20 6d 75 73 74 20     windowsize must 
  8136a8:	62 65 20 61 20 70 6f 77 65 72 20 6f 66 20 74 77     be a power of tw
  8136b8:	6f 00 00 00 00 00 00 00 69 6e 76 61 6c 69 64 20     o.......invalid 
  8136c8:	64 65 63 6f 6d 70 72 65 73 73 65 64 20 69 64 61     decompressed ida
  8136d8:	74 20 73 69 7a 65 00 00 69 6e 74 65 67 65 72 20     t size..integer 
  8136e8:	6f 76 65 72 66 6c 6f 77 20 64 75 65 20 74 6f 20     overflow due to 
  8136f8:	74 6f 6f 20 6d 61 6e 79 20 70 69 78 65 6c 73 00     too many pixels.
  813708:	7a 65 72 6f 20 77 69 64 74 68 20 6f 72 20 68 65     zero width or he
  813718:	69 67 68 74 20 69 73 20 69 6e 76 61 6c 69 64 00     ight is invalid.
  813728:	68 65 61 64 65 72 20 63 68 75 6e 6b 20 6d 75 73     header chunk mus
  813738:	74 20 68 61 76 65 20 61 20 73 69 7a 65 20 6f 66     t have a size of
  813748:	20 31 33 20 62 79 74 65 73 00 00 00 00 00 00 00      13 bytes.......
  813758:	69 6e 74 65 67 65 72 20 6f 76 65 72 66 6c 6f 77     integer overflow
  813768:	20 77 69 74 68 20 63 6f 6d 62 69 6e 65 64 20 69      with combined i
  813778:	64 61 74 20 63 68 75 6e 6b 20 73 69 7a 65 00 00     dat chunk size..
  813788:	69 6e 76 61 6c 69 64 20 49 43 43 20 70 72 6f 66     invalid ICC prof
  813798:	69 6c 65 20 63 6f 6c 6f 72 20 74 79 70 65 2c 20     ile color type, 
  8137a8:	74 68 65 20 50 4e 47 20 73 70 65 63 69 66 69 63     the PNG specific
  8137b8:	61 74 69 6f 6e 20 6f 6e 6c 79 20 61 6c 6c 6f 77     ation only allow
  8137c8:	73 20 52 47 42 20 6f 72 20 47 52 41 59 00 00 00     s RGB or GRAY...
  8137d8:	50 4e 47 20 73 70 65 63 69 66 69 63 61 74 69 6f     PNG specificatio
  8137e8:	6e 20 64 6f 65 73 20 6e 6f 74 20 61 6c 6c 6f 77     n does not allow
  8137f8:	20 52 47 42 20 49 43 43 20 70 72 6f 66 69 6c 65      RGB ICC profile
  813808:	20 6f 6e 20 67 72 61 79 20 63 6f 6c 6f 72 20 74      on gray color t
  813818:	79 70 65 73 20 61 6e 64 20 76 69 63 65 20 76 65     ypes and vice ve
  813828:	72 73 61 00 00 00 00 00 6e 6f 74 20 61 6c 6c 6f     rsa.....not allo
  813838:	77 65 64 20 74 6f 20 73 65 74 20 67 72 61 79 73     wed to set grays
  813848:	63 61 6c 65 20 49 43 43 20 70 72 6f 66 69 6c 65     cale ICC profile
  813858:	20 77 69 74 68 20 63 6f 6c 6f 72 65 64 20 70 69      with colored pi
  813868:	78 65 6c 73 20 62 79 20 50 4e 47 20 73 70 65 63     xels by PNG spec
  813878:	69 66 69 63 61 74 69 6f 6e 00 00 00 00 00 00 00     ification.......
  813888:	69 6e 76 61 6c 69 64 20 70 61 6c 65 74 74 65 20     invalid palette 
  813898:	69 6e 64 65 78 20 69 6e 20 62 4b 47 44 20 63 68     index in bKGD ch
  8138a8:	75 6e 6b 2e 20 4d 61 79 62 65 20 69 74 20 63 61     unk. Maybe it ca
  8138b8:	6d 65 20 62 65 66 6f 72 65 20 50 4c 54 45 20 63     me before PLTE c
  8138c8:	68 75 6e 6b 3f 00 00 00 69 6e 76 61 6c 69 64 20     hunk?...invalid 
  8138d8:	62 4b 47 44 20 63 6f 6c 6f 72 20 77 68 69 6c 65     bKGD color while
  8138e8:	20 65 6e 63 6f 64 69 6e 67 20 28 65 2e 67 2e 20      encoding (e.g. 
  8138f8:	70 61 6c 65 74 74 65 20 69 6e 64 65 78 20 6f 75     palette index ou
  813908:	74 20 6f 66 20 72 61 6e 67 65 29 00 00 00 00 00     t of range).....
  813918:	50 4e 47 20 66 69 6c 65 20 6d 75 73 74 20 68 61     PNG file must ha
  813928:	76 65 20 50 4c 54 45 20 63 68 75 6e 6b 20 69 66     ve PLTE chunk if
  813938:	20 63 6f 6c 6f 72 20 74 79 70 65 20 69 73 20 70      color type is p
  813948:	61 6c 65 74 74 65 00 00 63 6f 6c 6f 72 20 63 6f     alette..color co
  813958:	6e 76 65 72 74 20 66 72 6f 6d 20 70 61 6c 65 74     nvert from palet
  813968:	74 65 20 6d 6f 64 65 20 72 65 71 75 65 73 74 65     te mode requeste
  813978:	64 20 77 69 74 68 6f 75 74 20 73 65 74 74 69 6e     d without settin
  813988:	67 20 74 68 65 20 70 61 6c 65 74 74 65 20 64 61     g the palette da
  813998:	74 61 20 69 6e 20 69 74 00 00 00 00 00 00 00 00     ta in it........
  8139a8:	74 72 69 65 64 20 74 6f 20 61 64 64 20 6d 6f 72     tried to add mor
  8139b8:	65 20 74 68 61 6e 20 32 35 36 20 76 61 6c 75 65     e than 256 value
  8139c8:	73 20 74 6f 20 61 20 70 61 6c 65 74 74 65 00 3c     s to a palette.<
  8139d8:	63 6f 6e 73 3e 00 63 6f 6e 73 00 0f 1f 44 00 00     cons>.cons...D..
  8139e8:	5b 25 30 38 78 5d 20 75 73 65 72 20 70 61 6e 69     [%08x] user pani
  8139f8:	63 20 69 6e 20 25 73 20 61 74 20 25 73 3a 25 64     c in %s at %s:%d
  813a08:	3a 20 00 69 70 63 5f 73 65 6e 64 20 65 72 72 6f     : .ipc_send erro
  813a18:	72 3a 20 25 69 00 6c 69 62 2f 69 70 63 2e 63 00     r: %i.lib/ipc.c.
  813a28:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813a38:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813a48:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813a58:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813a68:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813a78:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813a88:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813a98:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813aa8:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813ab8:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813ac8:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813ad8:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813ae8:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813af8:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813b08:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813b18:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813b28:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813b38:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813b48:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813b58:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813b68:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813b78:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813b88:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813b98:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813ba8:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813bb8:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813bc8:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813bd8:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813be8:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813bf8:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813c08:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813c18:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813c28:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813c38:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813c48:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813c58:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813c68:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813c78:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813c88:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813c98:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813ca8:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813cb8:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813cc8:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813cd8:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813ce8:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813cf8:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813d08:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813d18:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813d28:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813d38:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813d48:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813d58:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813d68:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813d78:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813d88:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813d98:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813da8:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813db8:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813dc8:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813dd8:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813de8:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813df8:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813e08:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813e18:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813e28:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813e38:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813e48:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813e58:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813e68:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813e78:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813e88:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813e98:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813ea8:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813eb8:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813ec8:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813ed8:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813ee8:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813ef8:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813f08:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813f18:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813f28:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813f38:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813f48:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813f58:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813f68:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813f78:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813f88:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813f98:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813fa8:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  813fb8:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  813fc8:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  813fd8:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  813fe8:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  813ff8:	00 00 66 0f 1f 44 00 00                             ..f..D..
