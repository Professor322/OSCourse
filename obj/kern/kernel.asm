
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000001500000 <_head64>:

.text
.globl _head64
_head64:
    # Disable interrupts.
    cli
 1500000:	fa                   	cli    

    # Save Loader_block pointer from Bootloader.c in r12
    movq %rcx, %r12
 1500001:	49 89 cc             	mov    %rcx,%r12

    # Build an early boot pml4 at pml4phys (physical = virtual for it)

    # Initialize the page tables.
    movq $pml4, %rdi
 1500004:	48 c7 c7 00 10 50 01 	mov    $0x1501000,%rdi
    xorl %eax, %eax
 150000b:	31 c0                	xor    %eax,%eax
    movq $PML_SIZE, %rcx  # moving these many words to the 11 pages
 150000d:	48 c7 c1 00 16 00 00 	mov    $0x1600,%rcx
    rep stosq
 1500014:	f3 48 ab             	rep stos %rax,%es:(%rdi)

    # Creating a 4G boot page table...

    # Setting the 4-level page table with only the second entry needed (PML4)
    movq $pml4, %rdi
 1500017:	48 c7 c7 00 10 50 01 	mov    $0x1501000,%rdi
    movq $(pdpt1 + (PTE_P | PTE_W)), %rax
 150001e:	48 c7 c0 03 20 50 01 	mov    $0x1502003,%rax
    stosq
 1500025:	48 ab                	stos   %rax,%es:(%rdi)
    movq %rax, (%rdi)
 1500027:	48 89 07             	mov    %rax,(%rdi)
    movq $(pdpt2 + (PTE_P | PTE_W)), %rax
 150002a:	48 c7 c0 03 30 50 01 	mov    $0x1503003,%rax
    stosq
 1500031:	48 ab                	stos   %rax,%es:(%rdi)

    # Setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xA0000--0xD000
    movq $pdpt1, %rdi
 1500033:	48 c7 c7 00 20 50 01 	mov    $0x1502000,%rdi
    movq $(pde1 + (PTE_P | PTE_W)), %rax
 150003a:	48 c7 c0 03 40 50 01 	mov    $0x1504003,%rax
    stosq
 1500041:	48 ab                	stos   %rax,%es:(%rdi)

    movq $(pdpt2 + 8), %rdi
 1500043:	48 c7 c7 08 30 50 01 	mov    $0x1503008,%rdi
    movq $(pde2 + (PTE_P | PTE_W)), %rax
 150004a:	48 c7 c0 03 50 50 01 	mov    $0x1505003,%rax
    stosq
 1500051:	48 ab                	stos   %rax,%es:(%rdi)

    # Setting the pgdir so that the LA=PA
    # Mapping first 1024mb of mem at KERN_BASE_ADDR
    movq $-PDP_ENTRY_COUNT, %rcx
 1500053:	48 c7 c1 00 fe ff ff 	mov    $0xfffffffffffffe00,%rcx
    movq $pde1, %rdi
 150005a:	48 c7 c7 00 40 50 01 	mov    $0x1504000,%rdi
    movq $pde2, %rsi
 1500061:	48 c7 c6 00 50 50 01 	mov    $0x1505000,%rsi
    movl $(PTE_P|PTE_W|PTE_MBZ), %eax
 1500068:	b8 83 01 00 00       	mov    $0x183,%eax
1:
    movq %rax, PAGE_SIZE(%rsi,%rcx,8)
 150006d:	48 89 84 ce 00 10 00 	mov    %rax,0x1000(%rsi,%rcx,8)
 1500074:	00 
    movq %rax, PAGE_SIZE(%rdi,%rcx,8)
 1500075:	48 89 84 cf 00 10 00 	mov    %rax,0x1000(%rdi,%rcx,8)
 150007c:	00 
    addq $HUGE_PAGE_SIZE, %rax
 150007d:	48 05 00 00 20 00    	add    $0x200000,%rax
    incq %rcx
 1500083:	48 ff c1             	inc    %rcx
    jnz 1b
 1500086:	75 e5                	jne    150006d <_head64+0x6d>

    # Update CR3 register
    movq $pml4, %rax
 1500088:	48 c7 c0 00 10 50 01 	mov    $0x1501000,%rax
    movq %rax, %cr3
 150008f:	0f 22 d8             	mov    %rax,%cr3

    # Transition to high mem entry code and pass LoadParams address
    movabs $entry, %rax
 1500092:	48 b8 00 00 60 41 80 	movabs $0x8041600000,%rax
 1500099:	00 00 00 
    movq %r12, %rcx
 150009c:	4c 89 e1             	mov    %r12,%rcx
    jmpq *%rax
 150009f:	ff e0                	jmp    *%rax
 15000a1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000a8:	00 00 00 
 15000ab:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000b2:	00 00 00 
 15000b5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000bc:	00 00 00 
 15000bf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000c6:	00 00 00 
 15000c9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000d0:	00 00 00 
 15000d3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000da:	00 00 00 
 15000dd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000e4:	00 00 00 
 15000e7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000ee:	00 00 00 
 15000f1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15000f8:	00 00 00 
 15000fb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500102:	00 00 00 
 1500105:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150010c:	00 00 00 
 150010f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500116:	00 00 00 
 1500119:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500120:	00 00 00 
 1500123:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150012a:	00 00 00 
 150012d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500134:	00 00 00 
 1500137:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150013e:	00 00 00 
 1500141:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500148:	00 00 00 
 150014b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500152:	00 00 00 
 1500155:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150015c:	00 00 00 
 150015f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500166:	00 00 00 
 1500169:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500170:	00 00 00 
 1500173:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150017a:	00 00 00 
 150017d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500184:	00 00 00 
 1500187:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150018e:	00 00 00 
 1500191:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500198:	00 00 00 
 150019b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001a2:	00 00 00 
 15001a5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001ac:	00 00 00 
 15001af:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001b6:	00 00 00 
 15001b9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001c0:	00 00 00 
 15001c3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001ca:	00 00 00 
 15001cd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001d4:	00 00 00 
 15001d7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001de:	00 00 00 
 15001e1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001e8:	00 00 00 
 15001eb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001f2:	00 00 00 
 15001f5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15001fc:	00 00 00 
 15001ff:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500206:	00 00 00 
 1500209:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500210:	00 00 00 
 1500213:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150021a:	00 00 00 
 150021d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500224:	00 00 00 
 1500227:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150022e:	00 00 00 
 1500231:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500238:	00 00 00 
 150023b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500242:	00 00 00 
 1500245:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150024c:	00 00 00 
 150024f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500256:	00 00 00 
 1500259:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500260:	00 00 00 
 1500263:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150026a:	00 00 00 
 150026d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500274:	00 00 00 
 1500277:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150027e:	00 00 00 
 1500281:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500288:	00 00 00 
 150028b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500292:	00 00 00 
 1500295:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150029c:	00 00 00 
 150029f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002a6:	00 00 00 
 15002a9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002b0:	00 00 00 
 15002b3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002ba:	00 00 00 
 15002bd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002c4:	00 00 00 
 15002c7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002ce:	00 00 00 
 15002d1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002d8:	00 00 00 
 15002db:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002e2:	00 00 00 
 15002e5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002ec:	00 00 00 
 15002ef:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15002f6:	00 00 00 
 15002f9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500300:	00 00 00 
 1500303:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150030a:	00 00 00 
 150030d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500314:	00 00 00 
 1500317:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150031e:	00 00 00 
 1500321:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500328:	00 00 00 
 150032b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500332:	00 00 00 
 1500335:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150033c:	00 00 00 
 150033f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500346:	00 00 00 
 1500349:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500350:	00 00 00 
 1500353:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150035a:	00 00 00 
 150035d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500364:	00 00 00 
 1500367:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150036e:	00 00 00 
 1500371:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500378:	00 00 00 
 150037b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500382:	00 00 00 
 1500385:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150038c:	00 00 00 
 150038f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500396:	00 00 00 
 1500399:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003a0:	00 00 00 
 15003a3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003aa:	00 00 00 
 15003ad:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003b4:	00 00 00 
 15003b7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003be:	00 00 00 
 15003c1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003c8:	00 00 00 
 15003cb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003d2:	00 00 00 
 15003d5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003dc:	00 00 00 
 15003df:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003e6:	00 00 00 
 15003e9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003f0:	00 00 00 
 15003f3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15003fa:	00 00 00 
 15003fd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500404:	00 00 00 
 1500407:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150040e:	00 00 00 
 1500411:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500418:	00 00 00 
 150041b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500422:	00 00 00 
 1500425:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150042c:	00 00 00 
 150042f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500436:	00 00 00 
 1500439:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500440:	00 00 00 
 1500443:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150044a:	00 00 00 
 150044d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500454:	00 00 00 
 1500457:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150045e:	00 00 00 
 1500461:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500468:	00 00 00 
 150046b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500472:	00 00 00 
 1500475:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150047c:	00 00 00 
 150047f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500486:	00 00 00 
 1500489:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500490:	00 00 00 
 1500493:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150049a:	00 00 00 
 150049d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004a4:	00 00 00 
 15004a7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004ae:	00 00 00 
 15004b1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004b8:	00 00 00 
 15004bb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004c2:	00 00 00 
 15004c5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004cc:	00 00 00 
 15004cf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004d6:	00 00 00 
 15004d9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004e0:	00 00 00 
 15004e3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004ea:	00 00 00 
 15004ed:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004f4:	00 00 00 
 15004f7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15004fe:	00 00 00 
 1500501:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500508:	00 00 00 
 150050b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500512:	00 00 00 
 1500515:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150051c:	00 00 00 
 150051f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500526:	00 00 00 
 1500529:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500530:	00 00 00 
 1500533:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150053a:	00 00 00 
 150053d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500544:	00 00 00 
 1500547:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150054e:	00 00 00 
 1500551:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500558:	00 00 00 
 150055b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500562:	00 00 00 
 1500565:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150056c:	00 00 00 
 150056f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500576:	00 00 00 
 1500579:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500580:	00 00 00 
 1500583:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150058a:	00 00 00 
 150058d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500594:	00 00 00 
 1500597:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150059e:	00 00 00 
 15005a1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005a8:	00 00 00 
 15005ab:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005b2:	00 00 00 
 15005b5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005bc:	00 00 00 
 15005bf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005c6:	00 00 00 
 15005c9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005d0:	00 00 00 
 15005d3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005da:	00 00 00 
 15005dd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005e4:	00 00 00 
 15005e7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005ee:	00 00 00 
 15005f1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15005f8:	00 00 00 
 15005fb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500602:	00 00 00 
 1500605:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150060c:	00 00 00 
 150060f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500616:	00 00 00 
 1500619:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500620:	00 00 00 
 1500623:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150062a:	00 00 00 
 150062d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500634:	00 00 00 
 1500637:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150063e:	00 00 00 
 1500641:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500648:	00 00 00 
 150064b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500652:	00 00 00 
 1500655:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150065c:	00 00 00 
 150065f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500666:	00 00 00 
 1500669:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500670:	00 00 00 
 1500673:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150067a:	00 00 00 
 150067d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500684:	00 00 00 
 1500687:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150068e:	00 00 00 
 1500691:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500698:	00 00 00 
 150069b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006a2:	00 00 00 
 15006a5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006ac:	00 00 00 
 15006af:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006b6:	00 00 00 
 15006b9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006c0:	00 00 00 
 15006c3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006ca:	00 00 00 
 15006cd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006d4:	00 00 00 
 15006d7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006de:	00 00 00 
 15006e1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006e8:	00 00 00 
 15006eb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006f2:	00 00 00 
 15006f5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15006fc:	00 00 00 
 15006ff:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500706:	00 00 00 
 1500709:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500710:	00 00 00 
 1500713:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150071a:	00 00 00 
 150071d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500724:	00 00 00 
 1500727:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150072e:	00 00 00 
 1500731:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500738:	00 00 00 
 150073b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500742:	00 00 00 
 1500745:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150074c:	00 00 00 
 150074f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500756:	00 00 00 
 1500759:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500760:	00 00 00 
 1500763:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150076a:	00 00 00 
 150076d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500774:	00 00 00 
 1500777:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150077e:	00 00 00 
 1500781:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500788:	00 00 00 
 150078b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500792:	00 00 00 
 1500795:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150079c:	00 00 00 
 150079f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007a6:	00 00 00 
 15007a9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007b0:	00 00 00 
 15007b3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007ba:	00 00 00 
 15007bd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007c4:	00 00 00 
 15007c7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007ce:	00 00 00 
 15007d1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007d8:	00 00 00 
 15007db:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007e2:	00 00 00 
 15007e5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007ec:	00 00 00 
 15007ef:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15007f6:	00 00 00 
 15007f9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500800:	00 00 00 
 1500803:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150080a:	00 00 00 
 150080d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500814:	00 00 00 
 1500817:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150081e:	00 00 00 
 1500821:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500828:	00 00 00 
 150082b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500832:	00 00 00 
 1500835:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150083c:	00 00 00 
 150083f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500846:	00 00 00 
 1500849:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500850:	00 00 00 
 1500853:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150085a:	00 00 00 
 150085d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500864:	00 00 00 
 1500867:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150086e:	00 00 00 
 1500871:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500878:	00 00 00 
 150087b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500882:	00 00 00 
 1500885:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150088c:	00 00 00 
 150088f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500896:	00 00 00 
 1500899:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008a0:	00 00 00 
 15008a3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008aa:	00 00 00 
 15008ad:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008b4:	00 00 00 
 15008b7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008be:	00 00 00 
 15008c1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008c8:	00 00 00 
 15008cb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008d2:	00 00 00 
 15008d5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008dc:	00 00 00 
 15008df:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008e6:	00 00 00 
 15008e9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008f0:	00 00 00 
 15008f3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15008fa:	00 00 00 
 15008fd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500904:	00 00 00 
 1500907:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150090e:	00 00 00 
 1500911:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500918:	00 00 00 
 150091b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500922:	00 00 00 
 1500925:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150092c:	00 00 00 
 150092f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500936:	00 00 00 
 1500939:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500940:	00 00 00 
 1500943:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150094a:	00 00 00 
 150094d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500954:	00 00 00 
 1500957:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150095e:	00 00 00 
 1500961:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500968:	00 00 00 
 150096b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500972:	00 00 00 
 1500975:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150097c:	00 00 00 
 150097f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500986:	00 00 00 
 1500989:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500990:	00 00 00 
 1500993:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 150099a:	00 00 00 
 150099d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009a4:	00 00 00 
 15009a7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009ae:	00 00 00 
 15009b1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009b8:	00 00 00 
 15009bb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009c2:	00 00 00 
 15009c5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009cc:	00 00 00 
 15009cf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009d6:	00 00 00 
 15009d9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009e0:	00 00 00 
 15009e3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009ea:	00 00 00 
 15009ed:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009f4:	00 00 00 
 15009f7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 15009fe:	00 00 00 
 1500a01:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a08:	00 00 00 
 1500a0b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a12:	00 00 00 
 1500a15:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a1c:	00 00 00 
 1500a1f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a26:	00 00 00 
 1500a29:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a30:	00 00 00 
 1500a33:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a3a:	00 00 00 
 1500a3d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a44:	00 00 00 
 1500a47:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a4e:	00 00 00 
 1500a51:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a58:	00 00 00 
 1500a5b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a62:	00 00 00 
 1500a65:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a6c:	00 00 00 
 1500a6f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a76:	00 00 00 
 1500a79:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a80:	00 00 00 
 1500a83:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a8a:	00 00 00 
 1500a8d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a94:	00 00 00 
 1500a97:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500a9e:	00 00 00 
 1500aa1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500aa8:	00 00 00 
 1500aab:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ab2:	00 00 00 
 1500ab5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500abc:	00 00 00 
 1500abf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ac6:	00 00 00 
 1500ac9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ad0:	00 00 00 
 1500ad3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ada:	00 00 00 
 1500add:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ae4:	00 00 00 
 1500ae7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500aee:	00 00 00 
 1500af1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500af8:	00 00 00 
 1500afb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b02:	00 00 00 
 1500b05:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b0c:	00 00 00 
 1500b0f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b16:	00 00 00 
 1500b19:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b20:	00 00 00 
 1500b23:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b2a:	00 00 00 
 1500b2d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b34:	00 00 00 
 1500b37:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b3e:	00 00 00 
 1500b41:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b48:	00 00 00 
 1500b4b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b52:	00 00 00 
 1500b55:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b5c:	00 00 00 
 1500b5f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b66:	00 00 00 
 1500b69:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b70:	00 00 00 
 1500b73:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b7a:	00 00 00 
 1500b7d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b84:	00 00 00 
 1500b87:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b8e:	00 00 00 
 1500b91:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500b98:	00 00 00 
 1500b9b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ba2:	00 00 00 
 1500ba5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bac:	00 00 00 
 1500baf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bb6:	00 00 00 
 1500bb9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bc0:	00 00 00 
 1500bc3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bca:	00 00 00 
 1500bcd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bd4:	00 00 00 
 1500bd7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bde:	00 00 00 
 1500be1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500be8:	00 00 00 
 1500beb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bf2:	00 00 00 
 1500bf5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500bfc:	00 00 00 
 1500bff:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c06:	00 00 00 
 1500c09:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c10:	00 00 00 
 1500c13:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c1a:	00 00 00 
 1500c1d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c24:	00 00 00 
 1500c27:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c2e:	00 00 00 
 1500c31:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c38:	00 00 00 
 1500c3b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c42:	00 00 00 
 1500c45:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c4c:	00 00 00 
 1500c4f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c56:	00 00 00 
 1500c59:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c60:	00 00 00 
 1500c63:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c6a:	00 00 00 
 1500c6d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c74:	00 00 00 
 1500c77:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c7e:	00 00 00 
 1500c81:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c88:	00 00 00 
 1500c8b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c92:	00 00 00 
 1500c95:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500c9c:	00 00 00 
 1500c9f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ca6:	00 00 00 
 1500ca9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500cb0:	00 00 00 
 1500cb3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500cba:	00 00 00 
 1500cbd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500cc4:	00 00 00 
 1500cc7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500cce:	00 00 00 
 1500cd1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500cd8:	00 00 00 
 1500cdb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ce2:	00 00 00 
 1500ce5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500cec:	00 00 00 
 1500cef:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500cf6:	00 00 00 
 1500cf9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d00:	00 00 00 
 1500d03:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d0a:	00 00 00 
 1500d0d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d14:	00 00 00 
 1500d17:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d1e:	00 00 00 
 1500d21:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d28:	00 00 00 
 1500d2b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d32:	00 00 00 
 1500d35:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d3c:	00 00 00 
 1500d3f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d46:	00 00 00 
 1500d49:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d50:	00 00 00 
 1500d53:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d5a:	00 00 00 
 1500d5d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d64:	00 00 00 
 1500d67:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d6e:	00 00 00 
 1500d71:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d78:	00 00 00 
 1500d7b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d82:	00 00 00 
 1500d85:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d8c:	00 00 00 
 1500d8f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500d96:	00 00 00 
 1500d99:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500da0:	00 00 00 
 1500da3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500daa:	00 00 00 
 1500dad:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500db4:	00 00 00 
 1500db7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500dbe:	00 00 00 
 1500dc1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500dc8:	00 00 00 
 1500dcb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500dd2:	00 00 00 
 1500dd5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ddc:	00 00 00 
 1500ddf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500de6:	00 00 00 
 1500de9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500df0:	00 00 00 
 1500df3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500dfa:	00 00 00 
 1500dfd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e04:	00 00 00 
 1500e07:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e0e:	00 00 00 
 1500e11:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e18:	00 00 00 
 1500e1b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e22:	00 00 00 
 1500e25:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e2c:	00 00 00 
 1500e2f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e36:	00 00 00 
 1500e39:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e40:	00 00 00 
 1500e43:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e4a:	00 00 00 
 1500e4d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e54:	00 00 00 
 1500e57:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e5e:	00 00 00 
 1500e61:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e68:	00 00 00 
 1500e6b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e72:	00 00 00 
 1500e75:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e7c:	00 00 00 
 1500e7f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e86:	00 00 00 
 1500e89:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e90:	00 00 00 
 1500e93:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500e9a:	00 00 00 
 1500e9d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ea4:	00 00 00 
 1500ea7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500eae:	00 00 00 
 1500eb1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500eb8:	00 00 00 
 1500ebb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ec2:	00 00 00 
 1500ec5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ecc:	00 00 00 
 1500ecf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ed6:	00 00 00 
 1500ed9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ee0:	00 00 00 
 1500ee3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500eea:	00 00 00 
 1500eed:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ef4:	00 00 00 
 1500ef7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500efe:	00 00 00 
 1500f01:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f08:	00 00 00 
 1500f0b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f12:	00 00 00 
 1500f15:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f1c:	00 00 00 
 1500f1f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f26:	00 00 00 
 1500f29:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f30:	00 00 00 
 1500f33:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f3a:	00 00 00 
 1500f3d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f44:	00 00 00 
 1500f47:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f4e:	00 00 00 
 1500f51:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f58:	00 00 00 
 1500f5b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f62:	00 00 00 
 1500f65:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f6c:	00 00 00 
 1500f6f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f76:	00 00 00 
 1500f79:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f80:	00 00 00 
 1500f83:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f8a:	00 00 00 
 1500f8d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f94:	00 00 00 
 1500f97:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500f9e:	00 00 00 
 1500fa1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fa8:	00 00 00 
 1500fab:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fb2:	00 00 00 
 1500fb5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fbc:	00 00 00 
 1500fbf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fc6:	00 00 00 
 1500fc9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fd0:	00 00 00 
 1500fd3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fda:	00 00 00 
 1500fdd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fe4:	00 00 00 
 1500fe7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500fee:	00 00 00 
 1500ff1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 1500ff8:	00 00 00 
 1500ffb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000001501000 <pml4phys>:
	...

0000000001502000 <pdpt1>:
	...

0000000001503000 <pdpt2>:
	...

0000000001504000 <pde1>:
	...

0000000001505000 <pde2>:
	...

0000000001506000 <pdefreestart>:
	...

Disassembly of section .text:

0000008041600000 <__text_start>:
.text

.globl entry
entry:
    # Set up kernel stack
    leaq bootstacktop(%rip),%rsp
  8041600000:	48 8d 25 f9 3f 02 00 	lea    0x23ff9(%rip),%rsp        # 8041624000 <bootstacktop>
    xor %ebp, %ebp
  8041600007:	31 ed                	xor    %ebp,%ebp

    # Save LoadParams in uefi_lp.
    movq %rcx, uefi_lp(%rip)
  8041600009:	48 89 0d f0 3f 03 00 	mov    %rcx,0x33ff0(%rip)        # 8041634000 <pfstacktop>

    # Invoke C code
    call i386_init
  8041600010:	e8 5b 04 00 00       	call   8041600470 <i386_init>
    # Should never reach this place
    jmp .
  8041600015:	eb fe                	jmp    8041600015 <__text_start+0x15>

0000008041600017 <timers_init>:
#include <kern/traceopt.h>
#include <kern/pci.h>
#include <kern/vsyscall.h>

void
timers_init(void) {
  8041600017:	55                   	push   %rbp
  8041600018:	48 89 e5             	mov    %rsp,%rbp
  804160001b:	41 55                	push   %r13
  804160001d:	41 54                	push   %r12
  804160001f:	53                   	push   %rbx
  8041600020:	48 83 ec 08          	sub    $0x8,%rsp
    timertab[0] = timer_rtc;
  8041600024:	48 b8 60 55 40 42 80 	movabs $0x8042405560,%rax
  804160002b:	00 00 00 
  804160002e:	48 ba 20 47 63 41 80 	movabs $0x8041634720,%rdx
  8041600035:	00 00 00 
  8041600038:	48 8b 0a             	mov    (%rdx),%rcx
  804160003b:	48 89 08             	mov    %rcx,(%rax)
  804160003e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8041600042:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8041600046:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  804160004a:	48 89 48 10          	mov    %rcx,0x10(%rax)
  804160004e:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  8041600052:	48 89 48 18          	mov    %rcx,0x18(%rax)
  8041600056:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  804160005a:	48 89 50 20          	mov    %rdx,0x20(%rax)
    timertab[1] = timer_pit;
  804160005e:	48 ba c0 48 63 41 80 	movabs $0x80416348c0,%rdx
  8041600065:	00 00 00 
  8041600068:	48 8b 0a             	mov    (%rdx),%rcx
  804160006b:	48 89 48 28          	mov    %rcx,0x28(%rax)
  804160006f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8041600073:	48 89 48 30          	mov    %rcx,0x30(%rax)
  8041600077:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  804160007b:	48 89 48 38          	mov    %rcx,0x38(%rax)
  804160007f:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  8041600083:	48 89 48 40          	mov    %rcx,0x40(%rax)
  8041600087:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  804160008b:	48 89 50 48          	mov    %rdx,0x48(%rax)
    timertab[2] = timer_acpipm;
  804160008f:	48 ba e0 47 63 41 80 	movabs $0x80416347e0,%rdx
  8041600096:	00 00 00 
  8041600099:	48 8b 0a             	mov    (%rdx),%rcx
  804160009c:	48 89 48 50          	mov    %rcx,0x50(%rax)
  80416000a0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80416000a4:	48 89 48 58          	mov    %rcx,0x58(%rax)
  80416000a8:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  80416000ac:	48 89 48 60          	mov    %rcx,0x60(%rax)
  80416000b0:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  80416000b4:	48 89 48 68          	mov    %rcx,0x68(%rax)
  80416000b8:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80416000bc:	48 89 50 70          	mov    %rdx,0x70(%rax)
    timertab[3] = timer_hpet0;
  80416000c0:	48 ba 60 48 63 41 80 	movabs $0x8041634860,%rdx
  80416000c7:	00 00 00 
  80416000ca:	48 8b 0a             	mov    (%rdx),%rcx
  80416000cd:	48 89 48 78          	mov    %rcx,0x78(%rax)
  80416000d1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80416000d5:	48 89 88 80 00 00 00 	mov    %rcx,0x80(%rax)
  80416000dc:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  80416000e0:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
  80416000e7:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  80416000eb:	48 89 88 90 00 00 00 	mov    %rcx,0x90(%rax)
  80416000f2:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80416000f6:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
    timertab[4] = timer_hpet1;
  80416000fd:	48 ba 20 48 63 41 80 	movabs $0x8041634820,%rdx
  8041600104:	00 00 00 
  8041600107:	48 8b 0a             	mov    (%rdx),%rcx
  804160010a:	48 89 88 a0 00 00 00 	mov    %rcx,0xa0(%rax)
  8041600111:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8041600115:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
  804160011c:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  8041600120:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
  8041600127:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  804160012b:	48 89 88 b8 00 00 00 	mov    %rcx,0xb8(%rax)
  8041600132:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  8041600136:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)

    for (int i = 0; i < MAX_TIMERS; i++) {
  804160013d:	48 89 c3             	mov    %rax,%rbx
  8041600140:	4c 8d a0 c8 00 00 00 	lea    0xc8(%rax),%r12
        if (timertab[i].timer_init) {
            timertab[i].timer_init();
            if (trace_init) cprintf("Initialized timer %s\n", timertab[i].timer_name);
  8041600147:	49 bd 99 c8 60 41 80 	movabs $0x804160c899,%r13
  804160014e:	00 00 00 
  8041600151:	eb 09                	jmp    804160015c <timers_init+0x145>
    for (int i = 0; i < MAX_TIMERS; i++) {
  8041600153:	48 83 c3 28          	add    $0x28,%rbx
  8041600157:	4c 39 e3             	cmp    %r12,%rbx
  804160015a:	74 22                	je     804160017e <timers_init+0x167>
        if (timertab[i].timer_init) {
  804160015c:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8041600160:	48 85 c0             	test   %rax,%rax
  8041600163:	74 ee                	je     8041600153 <timers_init+0x13c>
            timertab[i].timer_init();
  8041600165:	ff d0                	call   *%rax
            if (trace_init) cprintf("Initialized timer %s\n", timertab[i].timer_name);
  8041600167:	48 8b 33             	mov    (%rbx),%rsi
  804160016a:	48 bf a8 10 61 41 80 	movabs $0x80416110a8,%rdi
  8041600171:	00 00 00 
  8041600174:	b8 00 00 00 00       	mov    $0x0,%eax
  8041600179:	41 ff d5             	call   *%r13
  804160017c:	eb d5                	jmp    8041600153 <timers_init+0x13c>
        }
    }
}
  804160017e:	48 83 c4 08          	add    $0x8,%rsp
  8041600182:	5b                   	pop    %rbx
  8041600183:	41 5c                	pop    %r12
  8041600185:	41 5d                	pop    %r13
  8041600187:	5d                   	pop    %rbp
  8041600188:	c3                   	ret    

0000008041600189 <alloc_pd_early_boot>:
alloc_pd_early_boot(void) {
    /* Assume pde1, pde2 is already used */
    extern uintptr_t pdefreestart, pdefreeend;
    static uintptr_t pdefree = (uintptr_t)&pdefreestart;

    if (pdefree >= (uintptr_t)&pdefreeend) return NULL;
  8041600189:	48 a1 08 40 63 41 80 	movabs 0x8041634008,%rax
  8041600190:	00 00 00 
  8041600193:	48 ba 00 c0 50 01 00 	movabs $0x150c000,%rdx
  804160019a:	00 00 00 
  804160019d:	48 39 d0             	cmp    %rdx,%rax
  80416001a0:	73 17                	jae    80416001b9 <alloc_pd_early_boot+0x30>

    pde_t *ret = (pde_t *)pdefree;
  80416001a2:	48 89 c2             	mov    %rax,%rdx
    pdefree += PAGE_SIZE;
  80416001a5:	48 05 00 10 00 00    	add    $0x1000,%rax
  80416001ab:	48 a3 08 40 63 41 80 	movabs %rax,0x8041634008
  80416001b2:	00 00 00 
    return ret;
}
  80416001b5:	48 89 d0             	mov    %rdx,%rax
  80416001b8:	c3                   	ret    
    if (pdefree >= (uintptr_t)&pdefreeend) return NULL;
  80416001b9:	ba 00 00 00 00       	mov    $0x0,%edx
  80416001be:	eb f5                	jmp    80416001b5 <alloc_pd_early_boot+0x2c>

00000080416001c0 <map_addr_early_boot>:

void
map_addr_early_boot(uintptr_t va, uintptr_t pa, size_t sz) {
  80416001c0:	55                   	push   %rbp
  80416001c1:	48 89 e5             	mov    %rsp,%rbp
  80416001c4:	41 57                	push   %r15
  80416001c6:	41 56                	push   %r14
  80416001c8:	41 55                	push   %r13
  80416001ca:	41 54                	push   %r12
  80416001cc:	53                   	push   %rbx
  80416001cd:	48 83 ec 18          	sub    $0x18,%rsp

    pml4e_t *pml4 = &pml4phys;
    pdpe_t *pdp;
    pde_t *pd;

    uintptr_t vstart = ROUNDDOWN(va, HUGE_PAGE_SIZE);
  80416001d1:	48 89 f8             	mov    %rdi,%rax
  80416001d4:	48 25 00 00 e0 ff    	and    $0xffffffffffe00000,%rax
    uintptr_t vend = ROUNDUP(va + sz, HUGE_PAGE_SIZE);
  80416001da:	4c 8d bc 17 ff ff 1f 	lea    0x1fffff(%rdi,%rdx,1),%r15
  80416001e1:	00 
  80416001e2:	49 81 e7 00 00 e0 ff 	and    $0xffffffffffe00000,%r15
    uintptr_t pstart = ROUNDDOWN(pa, HUGE_PAGE_SIZE);
  80416001e9:	48 81 e6 00 00 e0 ff 	and    $0xffffffffffe00000,%rsi

    pdp = (pdpe_t *)PTE_ADDR(pml4[PML4_INDEX(vstart)]);
  80416001f0:	48 c1 ef 24          	shr    $0x24,%rdi
  80416001f4:	81 e7 f8 0f 00 00    	and    $0xff8,%edi
  80416001fa:	48 ba 00 10 50 01 00 	movabs $0x1501000,%rdx
  8041600201:	00 00 00 
  8041600204:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  804160020b:	ff ff 7f 
  804160020e:	48 23 0c 3a          	and    (%rdx,%rdi,1),%rcx
  8041600212:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
    for (; vstart < vend; vstart += HUGE_PAGE_SIZE, pstart += HUGE_PAGE_SIZE) {
  8041600216:	49 39 c7             	cmp    %rax,%r15
  8041600219:	76 70                	jbe    804160028b <map_addr_early_boot+0xcb>
    uintptr_t vstart = ROUNDDOWN(va, HUGE_PAGE_SIZE);
  804160021b:	49 89 c4             	mov    %rax,%r12
  804160021e:	48 29 c6             	sub    %rax,%rsi
  8041600221:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
        pd = (pde_t *)PTE_ADDR(pdp[PDP_INDEX(vstart)]);
  8041600225:	49 be 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%r14
  804160022c:	ff ff 7f 
  804160022f:	eb 21                	jmp    8041600252 <map_addr_early_boot+0x92>
        if (!pd) {
            pd = alloc_pd_early_boot();
            pdp[PDP_INDEX(vstart)] = (uintptr_t)pd | PTE_P | PTE_W;
        }
        pd[PD_INDEX(vstart)] = pstart | PTE_P | PTE_W | PTE_PS;
  8041600231:	4c 89 e2             	mov    %r12,%rdx
  8041600234:	48 c1 ea 15          	shr    $0x15,%rdx
  8041600238:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  804160023e:	41 80 cd 83          	or     $0x83,%r13b
  8041600242:	4c 89 2c d0          	mov    %r13,(%rax,%rdx,8)
    for (; vstart < vend; vstart += HUGE_PAGE_SIZE, pstart += HUGE_PAGE_SIZE) {
  8041600246:	49 81 c4 00 00 20 00 	add    $0x200000,%r12
  804160024d:	4d 39 e7             	cmp    %r12,%r15
  8041600250:	76 39                	jbe    804160028b <map_addr_early_boot+0xcb>
  8041600252:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8041600256:	4e 8d 2c 20          	lea    (%rax,%r12,1),%r13
        pd = (pde_t *)PTE_ADDR(pdp[PDP_INDEX(vstart)]);
  804160025a:	4c 89 e3             	mov    %r12,%rbx
  804160025d:	48 c1 eb 1b          	shr    $0x1b,%rbx
  8041600261:	81 e3 f8 0f 00 00    	and    $0xff8,%ebx
  8041600267:	48 03 5d c8          	add    -0x38(%rbp),%rbx
        if (!pd) {
  804160026b:	4c 89 f0             	mov    %r14,%rax
  804160026e:	48 23 03             	and    (%rbx),%rax
  8041600271:	75 be                	jne    8041600231 <map_addr_early_boot+0x71>
            pd = alloc_pd_early_boot();
  8041600273:	48 b8 89 01 60 41 80 	movabs $0x8041600189,%rax
  804160027a:	00 00 00 
  804160027d:	ff d0                	call   *%rax
            pdp[PDP_INDEX(vstart)] = (uintptr_t)pd | PTE_P | PTE_W;
  804160027f:	48 89 c2             	mov    %rax,%rdx
  8041600282:	48 83 ca 03          	or     $0x3,%rdx
  8041600286:	48 89 13             	mov    %rdx,(%rbx)
  8041600289:	eb a6                	jmp    8041600231 <map_addr_early_boot+0x71>
    }
}
  804160028b:	48 83 c4 18          	add    $0x18,%rsp
  804160028f:	5b                   	pop    %rbx
  8041600290:	41 5c                	pop    %r12
  8041600292:	41 5d                	pop    %r13
  8041600294:	41 5e                	pop    %r14
  8041600296:	41 5f                	pop    %r15
  8041600298:	5d                   	pop    %rbp
  8041600299:	c3                   	ret    

000000804160029a <early_boot_pml4_init>:
extern char end[];

/* Additionally maps pml4 memory so that we dont get memory errors on accessing
 * uefi_lp, MemMap, KASAN functions. */
void
early_boot_pml4_init(void) {
  804160029a:	55                   	push   %rbp
  804160029b:	48 89 e5             	mov    %rsp,%rbp
  804160029e:	41 54                	push   %r12
  80416002a0:	53                   	push   %rbx
    map_addr_early_boot((uintptr_t)uefi_lp, (uintptr_t)uefi_lp, sizeof(LOADER_PARAMS));
  80416002a1:	49 bc 00 40 63 41 80 	movabs $0x8041634000,%r12
  80416002a8:	00 00 00 
  80416002ab:	49 8b 3c 24          	mov    (%r12),%rdi
  80416002af:	ba e8 00 00 00       	mov    $0xe8,%edx
  80416002b4:	48 89 fe             	mov    %rdi,%rsi
  80416002b7:	48 bb c0 01 60 41 80 	movabs $0x80416001c0,%rbx
  80416002be:	00 00 00 
  80416002c1:	ff d3                	call   *%rbx
    map_addr_early_boot((uintptr_t)uefi_lp->MemoryMap, (uintptr_t)uefi_lp->MemoryMap, uefi_lp->MemoryMapSize);
  80416002c3:	49 8b 04 24          	mov    (%r12),%rax
  80416002c7:	48 8b 78 28          	mov    0x28(%rax),%rdi
  80416002cb:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80416002cf:	48 89 fe             	mov    %rdi,%rsi
  80416002d2:	ff d3                	call   *%rbx
#endif

#if LAB <= 6
    map_addr_early_boot(FRAMEBUFFER, uefi_lp->FrameBufferBase, uefi_lp->FrameBufferSize);
#endif
}
  80416002d4:	5b                   	pop    %rbx
  80416002d5:	41 5c                	pop    %r12
  80416002d7:	5d                   	pop    %rbp
  80416002d8:	c3                   	ret    

00000080416002d9 <_panic>:
const char *panicstr = NULL;

/* Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor. */
_Noreturn void
_panic(const char *file, int line, const char *fmt, ...) {
  80416002d9:	55                   	push   %rbp
  80416002da:	48 89 e5             	mov    %rsp,%rbp
  80416002dd:	41 54                	push   %r12
  80416002df:	53                   	push   %rbx
  80416002e0:	48 83 ec 50          	sub    $0x50,%rsp
  80416002e4:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  80416002e8:	4c 89 45 e0          	mov    %r8,-0x20(%rbp)
  80416002ec:	4c 89 4d e8          	mov    %r9,-0x18(%rbp)
    va_list ap;

    if (panicstr) goto dead;
  80416002f0:	48 b8 00 00 e0 41 80 	movabs $0x8041e00000,%rax
  80416002f7:	00 00 00 
  80416002fa:	48 83 38 00          	cmpq   $0x0,(%rax)
  80416002fe:	74 13                	je     8041600313 <_panic+0x3a>
    cprintf("\n");
    va_end(ap);

dead:
    /* Break into the kernel monitor */
    for (;;) monitor(NULL);
  8041600300:	48 bb b1 45 60 41 80 	movabs $0x80416045b1,%rbx
  8041600307:	00 00 00 
  804160030a:	bf 00 00 00 00       	mov    $0x0,%edi
  804160030f:	ff d3                	call   *%rbx
  8041600311:	eb f7                	jmp    804160030a <_panic+0x31>
  8041600313:	48 89 d3             	mov    %rdx,%rbx
    panicstr = fmt;
  8041600316:	48 89 d0             	mov    %rdx,%rax
  8041600319:	48 a3 00 00 e0 41 80 	movabs %rax,0x8041e00000
  8041600320:	00 00 00 
    asm volatile("cli; cld");
  8041600323:	fa                   	cli    
  8041600324:	fc                   	cld    
    va_start(ap, fmt);
  8041600325:	c7 45 a8 18 00 00 00 	movl   $0x18,-0x58(%rbp)
  804160032c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8041600330:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8041600334:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8041600338:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    cprintf("kernel panic at %s:%d: ", file, line);
  804160033c:	89 f2                	mov    %esi,%edx
  804160033e:	48 89 fe             	mov    %rdi,%rsi
  8041600341:	48 bf be 10 61 41 80 	movabs $0x80416110be,%rdi
  8041600348:	00 00 00 
  804160034b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041600350:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  8041600357:	00 00 00 
  804160035a:	41 ff d4             	call   *%r12
    vcprintf(fmt, ap);
  804160035d:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8041600361:	48 89 df             	mov    %rbx,%rdi
  8041600364:	48 b8 65 c8 60 41 80 	movabs $0x804160c865,%rax
  804160036b:	00 00 00 
  804160036e:	ff d0                	call   *%rax
    cprintf("\n");
  8041600370:	48 bf 88 11 61 41 80 	movabs $0x8041611188,%rdi
  8041600377:	00 00 00 
  804160037a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160037f:	41 ff d4             	call   *%r12
    va_end(ap);
  8041600382:	e9 79 ff ff ff       	jmp    8041600300 <_panic+0x27>

0000008041600387 <timers_schedule>:
timers_schedule(const char *name) {
  8041600387:	55                   	push   %rbp
  8041600388:	48 89 e5             	mov    %rsp,%rbp
  804160038b:	41 56                	push   %r14
  804160038d:	41 55                	push   %r13
  804160038f:	41 54                	push   %r12
  8041600391:	53                   	push   %rbx
  8041600392:	49 89 fd             	mov    %rdi,%r13
    for (int i = 0; i < MAX_TIMERS; i++) {
  8041600395:	49 bc 60 55 40 42 80 	movabs $0x8042405560,%r12
  804160039c:	00 00 00 
  804160039f:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (timertab[i].timer_name && !strcmp(timertab[i].timer_name, name)) {
  80416003a4:	49 be f6 fc 60 41 80 	movabs $0x804160fcf6,%r14
  80416003ab:	00 00 00 
  80416003ae:	eb 3a                	jmp    80416003ea <timers_schedule+0x63>
                panic("Timer %s does not support interrupts\n", name);
  80416003b0:	4c 89 e9             	mov    %r13,%rcx
  80416003b3:	48 ba 58 11 61 41 80 	movabs $0x8041611158,%rdx
  80416003ba:	00 00 00 
  80416003bd:	be 2d 00 00 00       	mov    $0x2d,%esi
  80416003c2:	48 bf d6 10 61 41 80 	movabs $0x80416110d6,%rdi
  80416003c9:	00 00 00 
  80416003cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80416003d1:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416003d8:	00 00 00 
  80416003db:	41 ff d0             	call   *%r8
    for (int i = 0; i < MAX_TIMERS; i++) {
  80416003de:	83 c3 01             	add    $0x1,%ebx
  80416003e1:	49 83 c4 28          	add    $0x28,%r12
  80416003e5:	83 fb 05             	cmp    $0x5,%ebx
  80416003e8:	74 58                	je     8041600442 <timers_schedule+0xbb>
        if (timertab[i].timer_name && !strcmp(timertab[i].timer_name, name)) {
  80416003ea:	49 8b 3c 24          	mov    (%r12),%rdi
  80416003ee:	48 85 ff             	test   %rdi,%rdi
  80416003f1:	74 eb                	je     80416003de <timers_schedule+0x57>
  80416003f3:	4c 89 ee             	mov    %r13,%rsi
  80416003f6:	41 ff d6             	call   *%r14
  80416003f9:	85 c0                	test   %eax,%eax
  80416003fb:	75 e1                	jne    80416003de <timers_schedule+0x57>
            if (!timertab[i].enable_interrupts) {
  80416003fd:	48 63 c3             	movslq %ebx,%rax
  8041600400:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
  8041600404:	48 b8 60 55 40 42 80 	movabs $0x8042405560,%rax
  804160040b:	00 00 00 
  804160040e:	48 8b 54 d0 18       	mov    0x18(%rax,%rdx,8),%rdx
  8041600413:	48 85 d2             	test   %rdx,%rdx
  8041600416:	74 98                	je     80416003b0 <timers_schedule+0x29>
            timer_for_schedule = &timertab[i];
  8041600418:	48 63 db             	movslq %ebx,%rbx
  804160041b:	48 8d 0c 9b          	lea    (%rbx,%rbx,4),%rcx
  804160041f:	48 b8 60 55 40 42 80 	movabs $0x8042405560,%rax
  8041600426:	00 00 00 
  8041600429:	48 8d 04 c8          	lea    (%rax,%rcx,8),%rax
  804160042d:	48 a3 40 55 40 42 80 	movabs %rax,0x8042405540
  8041600434:	00 00 00 
            timertab[i].enable_interrupts();
  8041600437:	ff d2                	call   *%rdx
}
  8041600439:	5b                   	pop    %rbx
  804160043a:	41 5c                	pop    %r12
  804160043c:	41 5d                	pop    %r13
  804160043e:	41 5e                	pop    %r14
  8041600440:	5d                   	pop    %rbp
  8041600441:	c3                   	ret    
    panic("Timer %s does not exist\n", name);
  8041600442:	4c 89 e9             	mov    %r13,%rcx
  8041600445:	48 ba e2 10 61 41 80 	movabs $0x80416110e2,%rdx
  804160044c:	00 00 00 
  804160044f:	be 36 00 00 00       	mov    $0x36,%esi
  8041600454:	48 bf d6 10 61 41 80 	movabs $0x80416110d6,%rdi
  804160045b:	00 00 00 
  804160045e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041600463:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160046a:	00 00 00 
  804160046d:	41 ff d0             	call   *%r8

0000008041600470 <i386_init>:
i386_init(void) {
  8041600470:	55                   	push   %rbp
  8041600471:	48 89 e5             	mov    %rsp,%rbp
  8041600474:	53                   	push   %rbx
  8041600475:	48 83 ec 08          	sub    $0x8,%rsp
    early_boot_pml4_init();
  8041600479:	48 b8 9a 02 60 41 80 	movabs $0x804160029a,%rax
  8041600480:	00 00 00 
  8041600483:	ff d0                	call   *%rax
    cons_init();
  8041600485:	48 b8 b5 0b 60 41 80 	movabs $0x8041600bb5,%rax
  804160048c:	00 00 00 
  804160048f:	ff d0                	call   *%rax
    tsc_calibrate();
  8041600491:	48 b8 85 00 61 41 80 	movabs $0x8041610085,%rax
  8041600498:	00 00 00 
  804160049b:	ff d0                	call   *%rax
        cprintf("6828 decimal is %o octal!\n", 6828);
  804160049d:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80416004a2:	48 bf fb 10 61 41 80 	movabs $0x80416110fb,%rdi
  80416004a9:	00 00 00 
  80416004ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80416004b1:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  80416004b8:	00 00 00 
  80416004bb:	ff d3                	call   *%rbx
        cprintf("END: %p\n", end);
  80416004bd:	48 be 00 60 40 42 80 	movabs $0x8042406000,%rsi
  80416004c4:	00 00 00 
  80416004c7:	48 bf 16 11 61 41 80 	movabs $0x8041611116,%rdi
  80416004ce:	00 00 00 
  80416004d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80416004d6:	ff d3                	call   *%rbx
    init_memory();
  80416004d8:	48 b8 15 a8 60 41 80 	movabs $0x804160a815,%rax
  80416004df:	00 00 00 
  80416004e2:	ff d0                	call   *%rax
    pic_init();
  80416004e4:	48 b8 bc c6 60 41 80 	movabs $0x804160c6bc,%rax
  80416004eb:	00 00 00 
  80416004ee:	ff d0                	call   *%rax
    timers_init();
  80416004f0:	48 b8 17 00 60 41 80 	movabs $0x8041600017,%rax
  80416004f7:	00 00 00 
  80416004fa:	ff d0                	call   *%rax
    pci_init();
  80416004fc:	48 b8 b4 0d 61 41 80 	movabs $0x8041610db4,%rax
  8041600503:	00 00 00 
  8041600506:	ff d0                	call   *%rax
    if (trace_init) cprintf("Framebuffer initialised\n");
  8041600508:	48 bf 1f 11 61 41 80 	movabs $0x804161111f,%rdi
  804160050f:	00 00 00 
  8041600512:	b8 00 00 00 00       	mov    $0x0,%eax
  8041600517:	ff d3                	call   *%rbx
    env_init();
  8041600519:	48 b8 c1 b8 60 41 80 	movabs $0x804160b8c1,%rax
  8041600520:	00 00 00 
  8041600523:	ff d0                	call   *%rax
    vsyscall_init();
  8041600525:	48 b8 56 10 61 41 80 	movabs $0x8041611056,%rax
  804160052c:	00 00 00 
  804160052f:	ff d0                	call   *%rax
    timers_schedule("hpet0");
  8041600531:	48 bf 38 11 61 41 80 	movabs $0x8041611138,%rdi
  8041600538:	00 00 00 
  804160053b:	48 b8 87 03 60 41 80 	movabs $0x8041600387,%rax
  8041600542:	00 00 00 
  8041600545:	ff d0                	call   *%rax
    ENV_CREATE(fs_fs, ENV_TYPE_FS);
  8041600547:	48 bf 40 5d a2 41 80 	movabs $0x8041a25d40,%rdi
  804160054e:	00 00 00 
  8041600551:	48 be 90 8e a5 41 80 	movabs $0x8041a58e90,%rsi
  8041600558:	00 00 00 
  804160055b:	48 29 fe             	sub    %rdi,%rsi
  804160055e:	ba 03 00 00 00       	mov    $0x3,%edx
  8041600563:	48 bb 51 bd 60 41 80 	movabs $0x804160bd51,%rbx
  804160056a:	00 00 00 
  804160056d:	ff d3                	call   *%rbx
    ENV_CREATE(user_graphics, ENV_TYPE_USER);
  804160056f:	48 bf 30 7b c2 41 80 	movabs $0x8041c27b30,%rdi
  8041600576:	00 00 00 
  8041600579:	48 be a0 9e ca 41 80 	movabs $0x8041ca9ea0,%rsi
  8041600580:	00 00 00 
  8041600583:	48 29 fe             	sub    %rdi,%rsi
  8041600586:	ba 02 00 00 00       	mov    $0x2,%edx
  804160058b:	ff d3                	call   *%rbx
    kbd_intr();
  804160058d:	48 b8 48 0b 60 41 80 	movabs $0x8041600b48,%rax
  8041600594:	00 00 00 
  8041600597:	ff d0                	call   *%rax
    sched_yield();
  8041600599:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  80416005a0:	00 00 00 
  80416005a3:	ff d0                	call   *%rax

00000080416005a5 <_warn>:
}

/* Like panic, but don't */
void
_warn(const char *file, int line, const char *fmt, ...) {
  80416005a5:	55                   	push   %rbp
  80416005a6:	48 89 e5             	mov    %rsp,%rbp
  80416005a9:	41 54                	push   %r12
  80416005ab:	53                   	push   %rbx
  80416005ac:	48 83 ec 50          	sub    $0x50,%rsp
  80416005b0:	48 89 d3             	mov    %rdx,%rbx
  80416005b3:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  80416005b7:	4c 89 45 e0          	mov    %r8,-0x20(%rbp)
  80416005bb:	4c 89 4d e8          	mov    %r9,-0x18(%rbp)
    va_list ap;

    va_start(ap, fmt);
  80416005bf:	c7 45 a8 18 00 00 00 	movl   $0x18,-0x58(%rbp)
  80416005c6:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80416005ca:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80416005ce:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80416005d2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    cprintf("kernel warning at %s:%d: ", file, line);
  80416005d6:	89 f2                	mov    %esi,%edx
  80416005d8:	48 89 fe             	mov    %rdi,%rsi
  80416005db:	48 bf 3e 11 61 41 80 	movabs $0x804161113e,%rdi
  80416005e2:	00 00 00 
  80416005e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80416005ea:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  80416005f1:	00 00 00 
  80416005f4:	41 ff d4             	call   *%r12
    vcprintf(fmt, ap);
  80416005f7:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  80416005fb:	48 89 df             	mov    %rbx,%rdi
  80416005fe:	48 b8 65 c8 60 41 80 	movabs $0x804160c865,%rax
  8041600605:	00 00 00 
  8041600608:	ff d0                	call   *%rax
    cprintf("\n");
  804160060a:	48 bf 88 11 61 41 80 	movabs $0x8041611188,%rdi
  8041600611:	00 00 00 
  8041600614:	b8 00 00 00 00       	mov    $0x0,%eax
  8041600619:	41 ff d4             	call   *%r12
    va_end(ap);
}
  804160061c:	48 83 c4 50          	add    $0x50,%rsp
  8041600620:	5b                   	pop    %rbx
  8041600621:	41 5c                	pop    %r12
  8041600623:	5d                   	pop    %rbp
  8041600624:	c3                   	ret    

0000008041600625 <serial_proc_data>:
}

static inline uint8_t __attribute__((always_inline))
inb(int port) {
    uint8_t data;
    asm volatile("inb %w1,%0"
  8041600625:	ba fd 03 00 00       	mov    $0x3fd,%edx
  804160062a:	ec                   	in     (%dx),%al
    inb(0x84);
}

static int
serial_proc_data(void) {
    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) return -1;
  804160062b:	a8 01                	test   $0x1,%al
  804160062d:	74 0a                	je     8041600639 <serial_proc_data+0x14>
  804160062f:	ba f8 03 00 00       	mov    $0x3f8,%edx
  8041600634:	ec                   	in     (%dx),%al
    return inb(COM1 + COM_RX);
  8041600635:	0f b6 c0             	movzbl %al,%eax
  8041600638:	c3                   	ret    
    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) return -1;
  8041600639:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  804160063e:	c3                   	ret    

000000804160063f <cons_intr>:
} cons;

/* called by device interrupt routines to feed input characters
 * into the circular console input buffer */
static void
cons_intr(int (*proc)(void)) {
  804160063f:	55                   	push   %rbp
  8041600640:	48 89 e5             	mov    %rsp,%rbp
  8041600643:	41 54                	push   %r12
  8041600645:	53                   	push   %rbx
  8041600646:	49 89 fc             	mov    %rdi,%r12
    int ch;

    while ((ch = (*proc)()) != -1) {
        if (!ch) continue;
        cons.buf[cons.wpos++] = ch;
  8041600649:	48 bb 40 00 e0 41 80 	movabs $0x8041e00040,%rbx
  8041600650:	00 00 00 
    while ((ch = (*proc)()) != -1) {
  8041600653:	eb 22                	jmp    8041600677 <cons_intr+0x38>
        cons.buf[cons.wpos++] = ch;
  8041600655:	8b 8b 04 02 00 00    	mov    0x204(%rbx),%ecx
  804160065b:	8d 51 01             	lea    0x1(%rcx),%edx
  804160065e:	89 c9                	mov    %ecx,%ecx
  8041600660:	88 04 0b             	mov    %al,(%rbx,%rcx,1)
        if (cons.wpos == CONSBUFSIZE) cons.wpos = 0;
  8041600663:	81 fa 00 02 00 00    	cmp    $0x200,%edx
  8041600669:	b8 00 00 00 00       	mov    $0x0,%eax
  804160066e:	0f 44 d0             	cmove  %eax,%edx
  8041600671:	89 93 04 02 00 00    	mov    %edx,0x204(%rbx)
    while ((ch = (*proc)()) != -1) {
  8041600677:	41 ff d4             	call   *%r12
  804160067a:	83 f8 ff             	cmp    $0xffffffff,%eax
  804160067d:	74 06                	je     8041600685 <cons_intr+0x46>
        if (!ch) continue;
  804160067f:	85 c0                	test   %eax,%eax
  8041600681:	75 d2                	jne    8041600655 <cons_intr+0x16>
  8041600683:	eb f2                	jmp    8041600677 <cons_intr+0x38>
    }
}
  8041600685:	5b                   	pop    %rbx
  8041600686:	41 5c                	pop    %r12
  8041600688:	5d                   	pop    %rbp
  8041600689:	c3                   	ret    

000000804160068a <kbd_proc_data>:
kbd_proc_data(void) {
  804160068a:	55                   	push   %rbp
  804160068b:	48 89 e5             	mov    %rsp,%rbp
  804160068e:	53                   	push   %rbx
  804160068f:	48 83 ec 08          	sub    $0x8,%rsp
  8041600693:	ba 64 00 00 00       	mov    $0x64,%edx
  8041600698:	ec                   	in     (%dx),%al
    if (!(inb(KBSTATP) & KBS_DIB)) return -1;
  8041600699:	a8 01                	test   $0x1,%al
  804160069b:	0f 84 30 01 00 00    	je     80416007d1 <kbd_proc_data+0x147>
  80416006a1:	ba 60 00 00 00       	mov    $0x60,%edx
  80416006a6:	ec                   	in     (%dx),%al
  80416006a7:	89 c2                	mov    %eax,%edx
  80416006a9:	89 c1                	mov    %eax,%ecx
    if (data == 0xE0) {
  80416006ab:	3c e0                	cmp    $0xe0,%al
  80416006ad:	0f 84 83 00 00 00    	je     8041600736 <kbd_proc_data+0xac>
    } else if (data & 0x80) {
  80416006b3:	84 c0                	test   %al,%al
  80416006b5:	0f 88 95 00 00 00    	js     8041600750 <kbd_proc_data+0xc6>
    } else if (shift & E0ESC) {
  80416006bb:	a1 20 00 e0 41 80 00 	movabs 0x8041e00020,%eax
  80416006c2:	00 00 
  80416006c4:	a8 40                	test   $0x40,%al
  80416006c6:	74 0f                	je     80416006d7 <kbd_proc_data+0x4d>
        data |= 0x80;
  80416006c8:	83 c9 80             	or     $0xffffff80,%ecx
        shift &= ~E0ESC;
  80416006cb:	83 e0 bf             	and    $0xffffffbf,%eax
  80416006ce:	a3 20 00 e0 41 80 00 	movabs %eax,0x8041e00020
  80416006d5:	00 00 
    shift |= shiftcode[data];
  80416006d7:	0f b6 f1             	movzbl %cl,%esi
  80416006da:	48 b8 e0 12 61 41 80 	movabs $0x80416112e0,%rax
  80416006e1:	00 00 00 
  80416006e4:	0f b6 04 30          	movzbl (%rax,%rsi,1),%eax
  80416006e8:	48 ba 20 00 e0 41 80 	movabs $0x8041e00020,%rdx
  80416006ef:	00 00 00 
  80416006f2:	0b 02                	or     (%rdx),%eax
    shift ^= togglecode[data];
  80416006f4:	48 bf e0 11 61 41 80 	movabs $0x80416111e0,%rdi
  80416006fb:	00 00 00 
  80416006fe:	0f b6 34 37          	movzbl (%rdi,%rsi,1),%esi
  8041600702:	31 f0                	xor    %esi,%eax
  8041600704:	89 02                	mov    %eax,(%rdx)
    c = charcode[shift & (CTL | SHIFT)][data];
  8041600706:	89 c6                	mov    %eax,%esi
  8041600708:	83 e6 03             	and    $0x3,%esi
  804160070b:	0f b6 c9             	movzbl %cl,%ecx
  804160070e:	48 ba c0 11 61 41 80 	movabs $0x80416111c0,%rdx
  8041600715:	00 00 00 
  8041600718:	48 8b 14 f2          	mov    (%rdx,%rsi,8),%rdx
  804160071c:	0f b6 14 0a          	movzbl (%rdx,%rcx,1),%edx
  8041600720:	0f b6 da             	movzbl %dl,%ebx
    if (shift & CAPSLOCK) {
  8041600723:	a8 08                	test   $0x8,%al
  8041600725:	74 71                	je     8041600798 <kbd_proc_data+0x10e>
        if ('a' <= c && c <= 'z')
  8041600727:	89 da                	mov    %ebx,%edx
  8041600729:	8d 4b 9f             	lea    -0x61(%rbx),%ecx
  804160072c:	83 f9 19             	cmp    $0x19,%ecx
  804160072f:	77 5b                	ja     804160078c <kbd_proc_data+0x102>
            c += 'A' - 'a';
  8041600731:	83 eb 20             	sub    $0x20,%ebx
    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8041600734:	eb 12                	jmp    8041600748 <kbd_proc_data+0xbe>
        shift |= E0ESC;
  8041600736:	48 b8 20 00 e0 41 80 	movabs $0x8041e00020,%rax
  804160073d:	00 00 00 
  8041600740:	83 08 40             	orl    $0x40,(%rax)
        return 0;
  8041600743:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  8041600748:	89 d8                	mov    %ebx,%eax
  804160074a:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804160074e:	c9                   	leave  
  804160074f:	c3                   	ret    
        data = (shift & E0ESC ? data : data & 0x7F);
  8041600750:	a1 20 00 e0 41 80 00 	movabs 0x8041e00020,%eax
  8041600757:	00 00 
  8041600759:	83 e2 7f             	and    $0x7f,%edx
  804160075c:	a8 40                	test   $0x40,%al
  804160075e:	0f 44 ca             	cmove  %edx,%ecx
        shift &= ~(shiftcode[data] | E0ESC);
  8041600761:	0f b6 c9             	movzbl %cl,%ecx
  8041600764:	48 ba e0 12 61 41 80 	movabs $0x80416112e0,%rdx
  804160076b:	00 00 00 
  804160076e:	0f b6 14 0a          	movzbl (%rdx,%rcx,1),%edx
  8041600772:	83 ca 40             	or     $0x40,%edx
  8041600775:	0f b6 d2             	movzbl %dl,%edx
  8041600778:	f7 d2                	not    %edx
  804160077a:	21 d0                	and    %edx,%eax
  804160077c:	a3 20 00 e0 41 80 00 	movabs %eax,0x8041e00020
  8041600783:	00 00 
        return 0;
  8041600785:	bb 00 00 00 00       	mov    $0x0,%ebx
  804160078a:	eb bc                	jmp    8041600748 <kbd_proc_data+0xbe>
        else if ('A' <= c && c <= 'Z')
  804160078c:	83 ea 41             	sub    $0x41,%edx
            c += 'a' - 'A';
  804160078f:	8d 4b 20             	lea    0x20(%rbx),%ecx
  8041600792:	83 fa 1a             	cmp    $0x1a,%edx
  8041600795:	0f 42 d9             	cmovb  %ecx,%ebx
    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8041600798:	f7 d0                	not    %eax
  804160079a:	a8 06                	test   $0x6,%al
  804160079c:	75 aa                	jne    8041600748 <kbd_proc_data+0xbe>
  804160079e:	81 fb e9 00 00 00    	cmp    $0xe9,%ebx
  80416007a4:	75 a2                	jne    8041600748 <kbd_proc_data+0xbe>
        cprintf("Rebooting!\n");
  80416007a6:	48 bf 7e 11 61 41 80 	movabs $0x804161117e,%rdi
  80416007ad:	00 00 00 
  80416007b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80416007b5:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  80416007bc:	00 00 00 
  80416007bf:	ff d2                	call   *%rdx
                 : "memory", "cc");
}

static inline void __attribute__((always_inline))
outb(int port, uint8_t data) {
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  80416007c1:	b8 03 00 00 00       	mov    $0x3,%eax
  80416007c6:	ba 92 00 00 00       	mov    $0x92,%edx
  80416007cb:	ee                   	out    %al,(%dx)
}
  80416007cc:	e9 77 ff ff ff       	jmp    8041600748 <kbd_proc_data+0xbe>
    if (!(inb(KBSTATP) & KBS_DIB)) return -1;
  80416007d1:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80416007d6:	e9 6d ff ff ff       	jmp    8041600748 <kbd_proc_data+0xbe>

00000080416007db <draw_char>:
draw_char(uint32_t *buffer, uint32_t x, uint32_t y, uint32_t color, uint8_t charcode) {
  80416007db:	49 89 f9             	mov    %rdi,%r9
  80416007de:	41 89 d2             	mov    %edx,%r10d
  80416007e1:	89 cf                	mov    %ecx,%edi
    uint32_t *buf = buffer + uefi_stride * SYMBOL_SIZE * y + SYMBOL_SIZE * x;
  80416007e3:	a1 54 02 e0 41 80 00 	movabs 0x8041e00254,%eax
  80416007ea:	00 00 
    char *chr = font8x8_basic[(unsigned)charcode];
  80416007ec:	45 0f b6 c0          	movzbl %r8b,%r8d
  80416007f0:	48 ba 20 43 63 41 80 	movabs $0x8041634320,%rdx
  80416007f7:	00 00 00 
  80416007fa:	4a 8d 14 c2          	lea    (%rdx,%r8,8),%rdx
  80416007fe:	41 89 c0             	mov    %eax,%r8d
  8041600801:	49 c1 e0 02          	shl    $0x2,%r8
    uint32_t *buf = buffer + uefi_stride * SYMBOL_SIZE * y + SYMBOL_SIZE * x;
  8041600805:	41 0f af c2          	imul   %r10d,%eax
  8041600809:	c1 e0 03             	shl    $0x3,%eax
  804160080c:	89 c0                	mov    %eax,%eax
  804160080e:	8d 0c f5 00 00 00 00 	lea    0x0(,%rsi,8),%ecx
  8041600815:	89 c9                	mov    %ecx,%ecx
  8041600817:	48 01 c8             	add    %rcx,%rax
  804160081a:	49 8d 34 81          	lea    (%r9,%rax,4),%rsi
  804160081e:	4c 8d 4a 08          	lea    0x8(%rdx),%r9
        for (size_t width = 0; width < 8; width++) {
  8041600822:	b9 00 00 00 00       	mov    $0x0,%ecx
            buf[uefi_stride * heigth + width] = color * ((chr[heigth] >> width) & 1);
  8041600827:	0f be 02             	movsbl (%rdx),%eax
  804160082a:	d3 f8                	sar    %cl,%eax
  804160082c:	83 e0 01             	and    $0x1,%eax
  804160082f:	0f af c7             	imul   %edi,%eax
  8041600832:	89 04 8e             	mov    %eax,(%rsi,%rcx,4)
        for (size_t width = 0; width < 8; width++) {
  8041600835:	48 83 c1 01          	add    $0x1,%rcx
  8041600839:	48 83 f9 08          	cmp    $0x8,%rcx
  804160083d:	75 e8                	jne    8041600827 <draw_char+0x4c>
    for (size_t heigth = 0; heigth < 8; heigth++) {
  804160083f:	48 83 c2 01          	add    $0x1,%rdx
  8041600843:	4c 01 c6             	add    %r8,%rsi
  8041600846:	4c 39 ca             	cmp    %r9,%rdx
  8041600849:	75 d7                	jne    8041600822 <draw_char+0x47>
}
  804160084b:	c3                   	ret    

000000804160084c <fb_putc>:
    if (!graphics_exists) return;
  804160084c:	48 b8 5c 02 e0 41 80 	movabs $0x8041e0025c,%rax
  8041600853:	00 00 00 
  8041600856:	80 38 00             	cmpb   $0x0,(%rax)
  8041600859:	0f 84 36 02 00 00    	je     8041600a95 <fb_putc+0x249>
fb_putc(int c) {
  804160085f:	55                   	push   %rbp
  8041600860:	48 89 e5             	mov    %rsp,%rbp
  8041600863:	41 55                	push   %r13
  8041600865:	41 54                	push   %r12
  8041600867:	53                   	push   %rbx
  8041600868:	48 83 ec 08          	sub    $0x8,%rsp
    if (!(c & ~0xFF)) c |= 0x0700;
  804160086c:	89 f8                	mov    %edi,%eax
  804160086e:	80 cc 07             	or     $0x7,%ah
  8041600871:	f7 c7 00 ff ff ff    	test   $0xffffff00,%edi
  8041600877:	0f 44 f8             	cmove  %eax,%edi
    switch (c & 0xFF) {
  804160087a:	44 0f b6 c7          	movzbl %dil,%r8d
  804160087e:	40 80 ff 0a          	cmp    $0xa,%dil
  8041600882:	0f 84 01 01 00 00    	je     8041600989 <fb_putc+0x13d>
  8041600888:	41 83 f8 0a          	cmp    $0xa,%r8d
  804160088c:	7f 43                	jg     80416008d1 <fb_putc+0x85>
  804160088e:	41 83 f8 08          	cmp    $0x8,%r8d
  8041600892:	0f 84 93 00 00 00    	je     804160092b <fb_putc+0xdf>
  8041600898:	41 83 f8 09          	cmp    $0x9,%r8d
  804160089c:	0f 85 02 01 00 00    	jne    80416009a4 <fb_putc+0x158>
            fb_putc(' ');
  80416008a2:	bf 20 00 00 00       	mov    $0x20,%edi
  80416008a7:	48 bb 4c 08 60 41 80 	movabs $0x804160084c,%rbx
  80416008ae:	00 00 00 
  80416008b1:	ff d3                	call   *%rbx
  80416008b3:	bf 20 00 00 00       	mov    $0x20,%edi
  80416008b8:	ff d3                	call   *%rbx
  80416008ba:	bf 20 00 00 00       	mov    $0x20,%edi
  80416008bf:	ff d3                	call   *%rbx
  80416008c1:	bf 20 00 00 00       	mov    $0x20,%edi
  80416008c6:	ff d3                	call   *%rbx
  80416008c8:	bf 20 00 00 00       	mov    $0x20,%edi
  80416008cd:	ff d3                	call   *%rbx
        for (size_t i = 0; i < TABW; i++)
  80416008cf:	eb 30                	jmp    8041600901 <fb_putc+0xb5>
    switch (c & 0xFF) {
  80416008d1:	41 83 f8 0d          	cmp    $0xd,%r8d
  80416008d5:	0f 85 c9 00 00 00    	jne    80416009a4 <fb_putc+0x158>
        crt_pos -= (crt_pos % crt_cols);
  80416008db:	48 be 4a 02 e0 41 80 	movabs $0x8041e0024a,%rsi
  80416008e2:	00 00 00 
  80416008e5:	0f b7 0e             	movzwl (%rsi),%ecx
  80416008e8:	0f b7 c1             	movzwl %cx,%eax
  80416008eb:	48 bb 50 02 e0 41 80 	movabs $0x8041e00250,%rbx
  80416008f2:	00 00 00 
  80416008f5:	ba 00 00 00 00       	mov    $0x0,%edx
  80416008fa:	f7 33                	divl   (%rbx)
  80416008fc:	29 d1                	sub    %edx,%ecx
  80416008fe:	66 89 0e             	mov    %cx,(%rsi)
    if (crt_pos >= crt_size) {
  8041600901:	48 b8 4a 02 e0 41 80 	movabs $0x8041e0024a,%rax
  8041600908:	00 00 00 
  804160090b:	0f b7 10             	movzwl (%rax),%edx
  804160090e:	48 b8 4c 02 e0 41 80 	movabs $0x8041e0024c,%rax
  8041600915:	00 00 00 
  8041600918:	3b 10                	cmp    (%rax),%edx
  804160091a:	0f 83 d7 00 00 00    	jae    80416009f7 <fb_putc+0x1ab>
}
  8041600920:	48 83 c4 08          	add    $0x8,%rsp
  8041600924:	5b                   	pop    %rbx
  8041600925:	41 5c                	pop    %r12
  8041600927:	41 5d                	pop    %r13
  8041600929:	5d                   	pop    %rbp
  804160092a:	c3                   	ret    
        if (crt_pos > 0) {
  804160092b:	66 a1 4a 02 e0 41 80 	movabs 0x8041e0024a,%ax
  8041600932:	00 00 00 
  8041600935:	66 85 c0             	test   %ax,%ax
  8041600938:	74 c7                	je     8041600901 <fb_putc+0xb5>
            crt_pos--;
  804160093a:	83 e8 01             	sub    $0x1,%eax
  804160093d:	66 a3 4a 02 e0 41 80 	movabs %ax,0x8041e0024a
  8041600944:	00 00 00 
            draw_char(crt_buf, crt_pos % crt_cols, crt_pos / crt_cols, 0x0, 0x8);
  8041600947:	0f b7 d0             	movzwl %ax,%edx
  804160094a:	48 b8 50 02 e0 41 80 	movabs $0x8041e00250,%rax
  8041600951:	00 00 00 
  8041600954:	8b 08                	mov    (%rax),%ecx
  8041600956:	89 d0                	mov    %edx,%eax
  8041600958:	ba 00 00 00 00       	mov    $0x0,%edx
  804160095d:	f7 f1                	div    %ecx
  804160095f:	89 d6                	mov    %edx,%esi
  8041600961:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041600967:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160096c:	89 c2                	mov    %eax,%edx
  804160096e:	48 bf 00 00 e0 1f 80 	movabs $0x801fe00000,%rdi
  8041600975:	00 00 00 
  8041600978:	48 b8 db 07 60 41 80 	movabs $0x80416007db,%rax
  804160097f:	00 00 00 
  8041600982:	ff d0                	call   *%rax
  8041600984:	e9 78 ff ff ff       	jmp    8041600901 <fb_putc+0xb5>
        crt_pos += crt_cols;
  8041600989:	48 ba 4a 02 e0 41 80 	movabs $0x8041e0024a,%rdx
  8041600990:	00 00 00 
  8041600993:	a1 50 02 e0 41 80 00 	movabs 0x8041e00250,%eax
  804160099a:	00 00 
  804160099c:	66 01 02             	add    %ax,(%rdx)
  804160099f:	e9 37 ff ff ff       	jmp    80416008db <fb_putc+0x8f>
        draw_char(crt_buf, crt_pos % crt_cols, crt_pos / crt_cols, 0xFFFFFFFF, (uint8_t)c);
  80416009a4:	49 bc 4a 02 e0 41 80 	movabs $0x8041e0024a,%r12
  80416009ab:	00 00 00 
  80416009ae:	41 0f b7 1c 24       	movzwl (%r12),%ebx
  80416009b3:	0f b7 d3             	movzwl %bx,%edx
  80416009b6:	48 b8 50 02 e0 41 80 	movabs $0x8041e00250,%rax
  80416009bd:	00 00 00 
  80416009c0:	8b 08                	mov    (%rax),%ecx
  80416009c2:	89 d0                	mov    %edx,%eax
  80416009c4:	ba 00 00 00 00       	mov    $0x0,%edx
  80416009c9:	f7 f1                	div    %ecx
  80416009cb:	89 d6                	mov    %edx,%esi
  80416009cd:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80416009d2:	89 c2                	mov    %eax,%edx
  80416009d4:	48 bf 00 00 e0 1f 80 	movabs $0x801fe00000,%rdi
  80416009db:	00 00 00 
  80416009de:	48 b8 db 07 60 41 80 	movabs $0x80416007db,%rax
  80416009e5:	00 00 00 
  80416009e8:	ff d0                	call   *%rax
        crt_pos++;
  80416009ea:	83 c3 01             	add    $0x1,%ebx
  80416009ed:	66 41 89 1c 24       	mov    %bx,(%r12)
  80416009f2:	e9 0a ff ff ff       	jmp    8041600901 <fb_putc+0xb5>
                      uefi_stride * (uefi_vres - SYMBOL_SIZE) * sizeof(uint32_t));
  80416009f7:	49 bc 54 02 e0 41 80 	movabs $0x8041e00254,%r12
  80416009fe:	00 00 00 
  8041600a01:	41 8b 04 24          	mov    (%r12),%eax
  8041600a05:	49 bd 58 02 e0 41 80 	movabs $0x8041e00258,%r13
  8041600a0c:	00 00 00 
  8041600a0f:	41 8b 75 00          	mov    0x0(%r13),%esi
  8041600a13:	8d 56 f8             	lea    -0x8(%rsi),%edx
  8041600a16:	0f af d0             	imul   %eax,%edx
        nosan_memmove(crt_buf, crt_buf + uefi_stride * SYMBOL_SIZE,
  8041600a19:	48 c1 e2 02          	shl    $0x2,%rdx
  8041600a1d:	c1 e0 03             	shl    $0x3,%eax
  8041600a20:	89 c0                	mov    %eax,%eax
  8041600a22:	48 bb 00 00 e0 1f 80 	movabs $0x801fe00000,%rbx
  8041600a29:	00 00 00 
  8041600a2c:	48 8d 34 83          	lea    (%rbx,%rax,4),%rsi
  8041600a30:	48 89 df             	mov    %rbx,%rdi
  8041600a33:	48 b8 4f fe 60 41 80 	movabs $0x804160fe4f,%rax
  8041600a3a:	00 00 00 
  8041600a3d:	ff d0                	call   *%rax
        size_t i = (uefi_vres - (uefi_vres % SYMBOL_SIZE) - SYMBOL_SIZE);
  8041600a3f:	41 8b 55 00          	mov    0x0(%r13),%edx
  8041600a43:	89 d7                	mov    %edx,%edi
  8041600a45:	83 e7 f8             	and    $0xfffffff8,%edi
  8041600a48:	83 ef 08             	sub    $0x8,%edi
  8041600a4b:	89 f9                	mov    %edi,%ecx
        nosan_memset(crt_buf + i * uefi_stride, 0, uefi_stride * (uefi_vres - i) * sizeof(uint32_t));
  8041600a4d:	41 8b 04 24          	mov    (%r12),%eax
  8041600a51:	48 8d 3c 85 00 00 00 	lea    0x0(,%rax,4),%rdi
  8041600a58:	00 
  8041600a59:	89 d2                	mov    %edx,%edx
  8041600a5b:	48 29 ca             	sub    %rcx,%rdx
  8041600a5e:	48 0f af d7          	imul   %rdi,%rdx
  8041600a62:	48 0f af f9          	imul   %rcx,%rdi
  8041600a66:	48 01 df             	add    %rbx,%rdi
  8041600a69:	be 00 00 00 00       	mov    $0x0,%esi
  8041600a6e:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041600a75:	00 00 00 
  8041600a78:	ff d0                	call   *%rax
        crt_pos -= crt_cols;
  8041600a7a:	48 ba 4a 02 e0 41 80 	movabs $0x8041e0024a,%rdx
  8041600a81:	00 00 00 
  8041600a84:	a1 50 02 e0 41 80 00 	movabs 0x8041e00250,%eax
  8041600a8b:	00 00 
  8041600a8d:	66 29 02             	sub    %ax,(%rdx)
  8041600a90:	e9 8b fe ff ff       	jmp    8041600920 <fb_putc+0xd4>
  8041600a95:	c3                   	ret    

0000008041600a96 <fb_init>:
fb_init(void) {
  8041600a96:	55                   	push   %rbp
  8041600a97:	48 89 e5             	mov    %rsp,%rbp
    LOADER_PARAMS *lp = (LOADER_PARAMS *)uefi_lp;
  8041600a9a:	48 b8 00 40 63 41 80 	movabs $0x8041634000,%rax
  8041600aa1:	00 00 00 
  8041600aa4:	48 8b 30             	mov    (%rax),%rsi
    uefi_vres = lp->VerticalResolution;
  8041600aa7:	8b 56 50             	mov    0x50(%rsi),%edx
  8041600aaa:	89 d0                	mov    %edx,%eax
  8041600aac:	a3 58 02 e0 41 80 00 	movabs %eax,0x8041e00258
  8041600ab3:	00 00 
    uefi_stride = lp->PixelsPerScanLine;
  8041600ab5:	8b 46 4c             	mov    0x4c(%rsi),%eax
  8041600ab8:	a3 54 02 e0 41 80 00 	movabs %eax,0x8041e00254
  8041600abf:	00 00 
    crt_cols = uefi_hres / SYMBOL_SIZE;
  8041600ac1:	8b 4e 54             	mov    0x54(%rsi),%ecx
  8041600ac4:	c1 e9 03             	shr    $0x3,%ecx
  8041600ac7:	89 c8                	mov    %ecx,%eax
  8041600ac9:	a3 50 02 e0 41 80 00 	movabs %eax,0x8041e00250
  8041600ad0:	00 00 
    crt_rows = uefi_vres / SYMBOL_SIZE;
  8041600ad2:	89 d0                	mov    %edx,%eax
  8041600ad4:	c1 e8 03             	shr    $0x3,%eax
    crt_size = crt_rows * crt_cols;
  8041600ad7:	0f af c1             	imul   %ecx,%eax
  8041600ada:	a3 4c 02 e0 41 80 00 	movabs %eax,0x8041e0024c
  8041600ae1:	00 00 
    crt_pos = crt_cols;
  8041600ae3:	89 c8                	mov    %ecx,%eax
  8041600ae5:	66 a3 4a 02 e0 41 80 	movabs %ax,0x8041e0024a
  8041600aec:	00 00 00 
    memset(crt_buf,0, lp->FrameBufferSize);
  8041600aef:	8b 56 48             	mov    0x48(%rsi),%edx
  8041600af2:	be 00 00 00 00       	mov    $0x0,%esi
  8041600af7:	48 bf 00 00 e0 1f 80 	movabs $0x801fe00000,%rdi
  8041600afe:	00 00 00 
  8041600b01:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041600b08:	00 00 00 
  8041600b0b:	ff d0                	call   *%rax
    graphics_exists = true;
  8041600b0d:	48 b8 5c 02 e0 41 80 	movabs $0x8041e0025c,%rax
  8041600b14:	00 00 00 
  8041600b17:	c6 00 01             	movb   $0x1,(%rax)
}
  8041600b1a:	5d                   	pop    %rbp
  8041600b1b:	c3                   	ret    

0000008041600b1c <serial_intr>:
    if (serial_exists) cons_intr(serial_proc_data);
  8041600b1c:	48 b8 48 02 e0 41 80 	movabs $0x8041e00248,%rax
  8041600b23:	00 00 00 
  8041600b26:	80 38 00             	cmpb   $0x0,(%rax)
  8041600b29:	75 01                	jne    8041600b2c <serial_intr+0x10>
  8041600b2b:	c3                   	ret    
serial_intr(void) {
  8041600b2c:	55                   	push   %rbp
  8041600b2d:	48 89 e5             	mov    %rsp,%rbp
    if (serial_exists) cons_intr(serial_proc_data);
  8041600b30:	48 bf 25 06 60 41 80 	movabs $0x8041600625,%rdi
  8041600b37:	00 00 00 
  8041600b3a:	48 b8 3f 06 60 41 80 	movabs $0x804160063f,%rax
  8041600b41:	00 00 00 
  8041600b44:	ff d0                	call   *%rax
}
  8041600b46:	5d                   	pop    %rbp
  8041600b47:	c3                   	ret    

0000008041600b48 <kbd_intr>:
kbd_intr(void) {
  8041600b48:	55                   	push   %rbp
  8041600b49:	48 89 e5             	mov    %rsp,%rbp
    cons_intr(kbd_proc_data);
  8041600b4c:	48 bf 8a 06 60 41 80 	movabs $0x804160068a,%rdi
  8041600b53:	00 00 00 
  8041600b56:	48 b8 3f 06 60 41 80 	movabs $0x804160063f,%rax
  8041600b5d:	00 00 00 
  8041600b60:	ff d0                	call   *%rax
}
  8041600b62:	5d                   	pop    %rbp
  8041600b63:	c3                   	ret    

0000008041600b64 <cons_getc>:

/* Return the next input character from the console, or 0 if none waiting */
int
cons_getc(void) {
  8041600b64:	55                   	push   %rbp
  8041600b65:	48 89 e5             	mov    %rsp,%rbp

    /* Poll for any pending input characters,
     * so that this function works even when interrupts are disabled
     * (e.g., when called from the kernel monitor) */
    serial_intr();
  8041600b68:	48 b8 1c 0b 60 41 80 	movabs $0x8041600b1c,%rax
  8041600b6f:	00 00 00 
  8041600b72:	ff d0                	call   *%rax
    kbd_intr();
  8041600b74:	48 b8 48 0b 60 41 80 	movabs $0x8041600b48,%rax
  8041600b7b:	00 00 00 
  8041600b7e:	ff d0                	call   *%rax

    /* Grab the next character from the input buffer */
    if (cons.rpos != cons.wpos) {
  8041600b80:	48 ba 40 00 e0 41 80 	movabs $0x8041e00040,%rdx
  8041600b87:	00 00 00 
  8041600b8a:	8b 82 00 02 00 00    	mov    0x200(%rdx),%eax
        uint8_t ch = cons.buf[cons.rpos++];
        cons.rpos %= CONSBUFSIZE;
        return ch;
    }
    return 0;
  8041600b90:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (cons.rpos != cons.wpos) {
  8041600b95:	3b 82 04 02 00 00    	cmp    0x204(%rdx),%eax
  8041600b9b:	74 14                	je     8041600bb1 <cons_getc+0x4d>
        uint8_t ch = cons.buf[cons.rpos++];
  8041600b9d:	89 c1                	mov    %eax,%ecx
  8041600b9f:	83 c0 01             	add    $0x1,%eax
        cons.rpos %= CONSBUFSIZE;
  8041600ba2:	25 ff 01 00 00       	and    $0x1ff,%eax
  8041600ba7:	89 82 00 02 00 00    	mov    %eax,0x200(%rdx)
        return ch;
  8041600bad:	0f b6 0c 0a          	movzbl (%rdx,%rcx,1),%ecx
}
  8041600bb1:	89 c8                	mov    %ecx,%eax
  8041600bb3:	5d                   	pop    %rbp
  8041600bb4:	c3                   	ret    

0000008041600bb5 <cons_init>:
    fb_putc(c);
}

/* Initialize the console devices */
void
cons_init(void) {
  8041600bb5:	55                   	push   %rbp
  8041600bb6:	48 89 e5             	mov    %rsp,%rbp
    kbd_intr();
  8041600bb9:	48 b8 48 0b 60 41 80 	movabs $0x8041600b48,%rax
  8041600bc0:	00 00 00 
  8041600bc3:	ff d0                	call   *%rax
    pic_irq_unmask(IRQ_KBD);
  8041600bc5:	bf 01 00 00 00       	mov    $0x1,%edi
  8041600bca:	48 b8 d3 c7 60 41 80 	movabs $0x804160c7d3,%rax
  8041600bd1:	00 00 00 
  8041600bd4:	ff d0                	call   *%rax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8041600bd6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041600bdb:	bf fa 03 00 00       	mov    $0x3fa,%edi
  8041600be0:	89 c8                	mov    %ecx,%eax
  8041600be2:	89 fa                	mov    %edi,%edx
  8041600be4:	ee                   	out    %al,(%dx)
  8041600be5:	41 b9 fb 03 00 00    	mov    $0x3fb,%r9d
  8041600beb:	b8 80 ff ff ff       	mov    $0xffffff80,%eax
  8041600bf0:	44 89 ca             	mov    %r9d,%edx
  8041600bf3:	ee                   	out    %al,(%dx)
  8041600bf4:	be f8 03 00 00       	mov    $0x3f8,%esi
  8041600bf9:	b8 0c 00 00 00       	mov    $0xc,%eax
  8041600bfe:	89 f2                	mov    %esi,%edx
  8041600c00:	ee                   	out    %al,(%dx)
  8041600c01:	41 b8 f9 03 00 00    	mov    $0x3f9,%r8d
  8041600c07:	89 c8                	mov    %ecx,%eax
  8041600c09:	44 89 c2             	mov    %r8d,%edx
  8041600c0c:	ee                   	out    %al,(%dx)
  8041600c0d:	b8 03 00 00 00       	mov    $0x3,%eax
  8041600c12:	44 89 ca             	mov    %r9d,%edx
  8041600c15:	ee                   	out    %al,(%dx)
  8041600c16:	ba fc 03 00 00       	mov    $0x3fc,%edx
  8041600c1b:	89 c8                	mov    %ecx,%eax
  8041600c1d:	ee                   	out    %al,(%dx)
  8041600c1e:	b8 01 00 00 00       	mov    $0x1,%eax
  8041600c23:	44 89 c2             	mov    %r8d,%edx
  8041600c26:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  8041600c27:	ba fd 03 00 00       	mov    $0x3fd,%edx
  8041600c2c:	ec                   	in     (%dx),%al
  8041600c2d:	89 c1                	mov    %eax,%ecx
    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
  8041600c2f:	3c ff                	cmp    $0xff,%al
  8041600c31:	0f 95 c0             	setne  %al
  8041600c34:	a2 48 02 e0 41 80 00 	movabs %al,0x8041e00248
  8041600c3b:	00 00 
  8041600c3d:	89 fa                	mov    %edi,%edx
  8041600c3f:	ec                   	in     (%dx),%al
  8041600c40:	89 f2                	mov    %esi,%edx
  8041600c42:	ec                   	in     (%dx),%al
    if (serial_exists) pic_irq_unmask(IRQ_SERIAL);
  8041600c43:	80 f9 ff             	cmp    $0xff,%cl
  8041600c46:	75 1d                	jne    8041600c65 <cons_init+0xb0>
    kbd_init();
    serial_init();

    if (!serial_exists)
        cprintf("Serial port does not exist!\n");
  8041600c48:	48 bf 8a 11 61 41 80 	movabs $0x804161118a,%rdi
  8041600c4f:	00 00 00 
  8041600c52:	b8 00 00 00 00       	mov    $0x0,%eax
  8041600c57:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041600c5e:	00 00 00 
  8041600c61:	ff d2                	call   *%rdx
}
  8041600c63:	eb 20                	jmp    8041600c85 <cons_init+0xd0>
    if (serial_exists) pic_irq_unmask(IRQ_SERIAL);
  8041600c65:	bf 04 00 00 00       	mov    $0x4,%edi
  8041600c6a:	48 b8 d3 c7 60 41 80 	movabs $0x804160c7d3,%rax
  8041600c71:	00 00 00 
  8041600c74:	ff d0                	call   *%rax
    if (!serial_exists)
  8041600c76:	48 b8 48 02 e0 41 80 	movabs $0x8041e00248,%rax
  8041600c7d:	00 00 00 
  8041600c80:	80 38 00             	cmpb   $0x0,(%rax)
  8041600c83:	74 c3                	je     8041600c48 <cons_init+0x93>
}
  8041600c85:	5d                   	pop    %rbp
  8041600c86:	c3                   	ret    

0000008041600c87 <cputchar>:

/* `High'-level console I/O.  Used by readline and cprintf. */

void
cputchar(int c) {
  8041600c87:	55                   	push   %rbp
  8041600c88:	48 89 e5             	mov    %rsp,%rbp
    c &= 0x7F;
  8041600c8b:	83 e7 7f             	and    $0x7f,%edi
  8041600c8e:	41 89 f8             	mov    %edi,%r8d
  8041600c91:	ba fd 03 00 00       	mov    $0x3fd,%edx
  8041600c96:	ec                   	in     (%dx),%al
        if (inb(COM1 + COM_LSR) & COM_LSR_TXRDY) break;
  8041600c97:	a8 20                	test   $0x20,%al
  8041600c99:	75 22                	jne    8041600cbd <cputchar+0x36>
  8041600c9b:	be 00 32 00 00       	mov    $0x3200,%esi
  8041600ca0:	b9 84 00 00 00       	mov    $0x84,%ecx
  8041600ca5:	bf fd 03 00 00       	mov    $0x3fd,%edi
  8041600caa:	89 ca                	mov    %ecx,%edx
  8041600cac:	ec                   	in     (%dx),%al
  8041600cad:	ec                   	in     (%dx),%al
  8041600cae:	ec                   	in     (%dx),%al
  8041600caf:	ec                   	in     (%dx),%al
    for (size_t i = 0; i < 12800; i++) {
  8041600cb0:	48 83 ee 01          	sub    $0x1,%rsi
  8041600cb4:	74 07                	je     8041600cbd <cputchar+0x36>
  8041600cb6:	89 fa                	mov    %edi,%edx
  8041600cb8:	ec                   	in     (%dx),%al
        if (inb(COM1 + COM_LSR) & COM_LSR_TXRDY) break;
  8041600cb9:	a8 20                	test   $0x20,%al
  8041600cbb:	74 ed                	je     8041600caa <cputchar+0x23>
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8041600cbd:	ba f8 03 00 00       	mov    $0x3f8,%edx
  8041600cc2:	44 89 c0             	mov    %r8d,%eax
  8041600cc5:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  8041600cc6:	ba 79 03 00 00       	mov    $0x379,%edx
  8041600ccb:	ec                   	in     (%dx),%al
        if (inb(0x378 + 1) & 0x80) break;
  8041600ccc:	84 c0                	test   %al,%al
  8041600cce:	78 22                	js     8041600cf2 <cputchar+0x6b>
  8041600cd0:	be 00 32 00 00       	mov    $0x3200,%esi
  8041600cd5:	b9 84 00 00 00       	mov    $0x84,%ecx
  8041600cda:	bf 79 03 00 00       	mov    $0x379,%edi
  8041600cdf:	89 ca                	mov    %ecx,%edx
  8041600ce1:	ec                   	in     (%dx),%al
  8041600ce2:	ec                   	in     (%dx),%al
  8041600ce3:	ec                   	in     (%dx),%al
  8041600ce4:	ec                   	in     (%dx),%al
    for (size_t i = 0; i < 12800; i++) {
  8041600ce5:	48 83 ee 01          	sub    $0x1,%rsi
  8041600ce9:	74 07                	je     8041600cf2 <cputchar+0x6b>
  8041600ceb:	89 fa                	mov    %edi,%edx
  8041600ced:	ec                   	in     (%dx),%al
        if (inb(0x378 + 1) & 0x80) break;
  8041600cee:	84 c0                	test   %al,%al
  8041600cf0:	79 ed                	jns    8041600cdf <cputchar+0x58>
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8041600cf2:	ba 78 03 00 00       	mov    $0x378,%edx
  8041600cf7:	44 89 c0             	mov    %r8d,%eax
  8041600cfa:	ee                   	out    %al,(%dx)
  8041600cfb:	ba 7a 03 00 00       	mov    $0x37a,%edx
  8041600d00:	b8 0d 00 00 00       	mov    $0xd,%eax
  8041600d05:	ee                   	out    %al,(%dx)
  8041600d06:	b8 08 00 00 00       	mov    $0x8,%eax
  8041600d0b:	ee                   	out    %al,(%dx)
    fb_putc(c);
  8041600d0c:	44 89 c7             	mov    %r8d,%edi
  8041600d0f:	48 b8 4c 08 60 41 80 	movabs $0x804160084c,%rax
  8041600d16:	00 00 00 
  8041600d19:	ff d0                	call   *%rax
    cons_putc(c);
}
  8041600d1b:	5d                   	pop    %rbp
  8041600d1c:	c3                   	ret    

0000008041600d1d <getchar>:

int
getchar(void) {
  8041600d1d:	55                   	push   %rbp
  8041600d1e:	48 89 e5             	mov    %rsp,%rbp
  8041600d21:	53                   	push   %rbx
  8041600d22:	48 83 ec 08          	sub    $0x8,%rsp
    int ch;

    while (!(ch = cons_getc()))
  8041600d26:	48 bb 64 0b 60 41 80 	movabs $0x8041600b64,%rbx
  8041600d2d:	00 00 00 
  8041600d30:	ff d3                	call   *%rbx
  8041600d32:	85 c0                	test   %eax,%eax
  8041600d34:	74 fa                	je     8041600d30 <getchar+0x13>
        /* nothing */;

    return ch;
}
  8041600d36:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8041600d3a:	c9                   	leave  
  8041600d3b:	c3                   	ret    

0000008041600d3c <iscons>:
int
iscons(int fdnum) {
    /* Used by readline */

    return 1;
}
  8041600d3c:	b8 01 00 00 00       	mov    $0x1,%eax
  8041600d41:	c3                   	ret    

0000008041600d42 <dwarf_read_abbrev_entry>:
    return -E_BAD_DWARF;
}

/* Read value from .debug_abbrev table in buf. Returns number of bytes read */
static int
dwarf_read_abbrev_entry(const void *entry, unsigned form, void *buf, int bufsize, size_t address_size) {
  8041600d42:	55                   	push   %rbp
  8041600d43:	48 89 e5             	mov    %rsp,%rbp
  8041600d46:	41 56                	push   %r14
  8041600d48:	41 55                	push   %r13
  8041600d4a:	41 54                	push   %r12
  8041600d4c:	53                   	push   %rbx
  8041600d4d:	48 83 ec 30          	sub    $0x30,%rsp
  8041600d51:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    int bytes = 0;
    switch (form) {
  8041600d55:	83 fe 20             	cmp    $0x20,%esi
  8041600d58:	0f 87 56 0a 00 00    	ja     80416017b4 <dwarf_read_abbrev_entry+0xa72>
  8041600d5e:	49 89 d4             	mov    %rdx,%r12
  8041600d61:	41 89 cd             	mov    %ecx,%r13d
  8041600d64:	4c 89 c3             	mov    %r8,%rbx
  8041600d67:	89 f6                	mov    %esi,%esi
  8041600d69:	48 b8 60 14 61 41 80 	movabs $0x8041611460,%rax
  8041600d70:	00 00 00 
  8041600d73:	ff 24 f0             	jmp    *(%rax,%rsi,8)
    case DW_FORM_addr: {
        uintptr_t data = 0;
  8041600d76:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8041600d7d:	00 
        memcpy(&data, entry, address_size);
  8041600d7e:	4c 89 c2             	mov    %r8,%rdx
  8041600d81:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041600d85:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041600d89:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600d90:	00 00 00 
  8041600d93:	ff d0                	call   *%rax
        entry += address_size;
  8041600d95:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uintptr_t))
  8041600d99:	4d 85 e4             	test   %r12,%r12
  8041600d9c:	74 06                	je     8041600da4 <dwarf_read_abbrev_entry+0x62>
  8041600d9e:	41 83 fd 07          	cmp    $0x7,%r13d
  8041600da2:	77 07                	ja     8041600dab <dwarf_read_abbrev_entry+0x69>
            put_unaligned(data, (uintptr_t *)buf);
        bytes = address_size;
  8041600da4:	89 d8                	mov    %ebx,%eax
    } break;
  8041600da6:	e9 0e 0a 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (uintptr_t *)buf);
  8041600dab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8041600daf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8041600db3:	ba 08 00 00 00       	mov    $0x8,%edx
  8041600db8:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041600dbc:	4c 89 e7             	mov    %r12,%rdi
  8041600dbf:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600dc6:	00 00 00 
  8041600dc9:	ff d0                	call   *%rax
  8041600dcb:	eb d7                	jmp    8041600da4 <dwarf_read_abbrev_entry+0x62>
    case DW_FORM_block2: {
        /* Read block of 2-byte length followed by 0 to 65535 contiguous information bytes */
        // LAB 2: Your code here
        uint32_t length = get_unaligned(entry, Dwarf_Half);
  8041600dcd:	ba 02 00 00 00       	mov    $0x2,%edx
  8041600dd2:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041600dd6:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041600dda:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600de1:	00 00 00 
  8041600de4:	ff d0                	call   *%rax
  8041600de6:	0f b7 5d d0          	movzwl -0x30(%rbp),%ebx
        entry += sizeof(Dwarf_Half);
  8041600dea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041600dee:	48 83 c0 02          	add    $0x2,%rax
  8041600df2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        struct Slice slice = {
  8041600df6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8041600dfa:	89 5d d8             	mov    %ebx,-0x28(%rbp)
                .mem = entry,
                .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  8041600dfd:	4d 85 e4             	test   %r12,%r12
  8041600e00:	74 18                	je     8041600e1a <dwarf_read_abbrev_entry+0xd8>
  8041600e02:	ba 10 00 00 00       	mov    $0x10,%edx
  8041600e07:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041600e0b:	4c 89 e7             	mov    %r12,%rdi
  8041600e0e:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600e15:	00 00 00 
  8041600e18:	ff d0                	call   *%rax
        entry += length;
        bytes = sizeof(Dwarf_Half) + length;
  8041600e1a:	8d 43 02             	lea    0x2(%rbx),%eax
    } break;
  8041600e1d:	e9 97 09 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    case DW_FORM_block4: {
        uint32_t length = get_unaligned(entry, uint32_t);
  8041600e22:	ba 04 00 00 00       	mov    $0x4,%edx
  8041600e27:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041600e2b:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041600e2f:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600e36:	00 00 00 
  8041600e39:	ff d0                	call   *%rax
  8041600e3b:	8b 5d d0             	mov    -0x30(%rbp),%ebx
        entry += sizeof(uint32_t);
  8041600e3e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041600e42:	48 83 c0 04          	add    $0x4,%rax
  8041600e46:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        struct Slice slice = {
  8041600e4a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8041600e4e:	89 5d d8             	mov    %ebx,-0x28(%rbp)
                .mem = entry,
                .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  8041600e51:	4d 85 e4             	test   %r12,%r12
  8041600e54:	74 18                	je     8041600e6e <dwarf_read_abbrev_entry+0x12c>
  8041600e56:	ba 10 00 00 00       	mov    $0x10,%edx
  8041600e5b:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041600e5f:	4c 89 e7             	mov    %r12,%rdi
  8041600e62:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600e69:	00 00 00 
  8041600e6c:	ff d0                	call   *%rax
        entry += length;
        bytes = sizeof(uint32_t) + length;
  8041600e6e:	8d 43 04             	lea    0x4(%rbx),%eax
    } break;
  8041600e71:	e9 43 09 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    case DW_FORM_data2: {
        Dwarf_Half data = get_unaligned(entry, Dwarf_Half);
  8041600e76:	ba 02 00 00 00       	mov    $0x2,%edx
  8041600e7b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041600e7f:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041600e83:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600e8a:	00 00 00 
  8041600e8d:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  8041600e8f:	48 83 45 b8 02       	addq   $0x2,-0x48(%rbp)
        if (buf && bufsize >= sizeof(Dwarf_Half))
  8041600e94:	4d 85 e4             	test   %r12,%r12
  8041600e97:	74 06                	je     8041600e9f <dwarf_read_abbrev_entry+0x15d>
  8041600e99:	41 83 fd 01          	cmp    $0x1,%r13d
  8041600e9d:	77 0a                	ja     8041600ea9 <dwarf_read_abbrev_entry+0x167>
            put_unaligned(data, (Dwarf_Half *)buf);
        bytes = sizeof(Dwarf_Half);
  8041600e9f:	b8 02 00 00 00       	mov    $0x2,%eax
  8041600ea4:	e9 10 09 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (Dwarf_Half *)buf);
  8041600ea9:	ba 02 00 00 00       	mov    $0x2,%edx
  8041600eae:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041600eb2:	4c 89 e7             	mov    %r12,%rdi
  8041600eb5:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600ebc:	00 00 00 
  8041600ebf:	ff d0                	call   *%rax
        bytes = sizeof(Dwarf_Half);
  8041600ec1:	b8 02 00 00 00       	mov    $0x2,%eax
            put_unaligned(data, (Dwarf_Half *)buf);
  8041600ec6:	e9 ee 08 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_data4: {
        uint32_t data = get_unaligned(entry, uint32_t);
  8041600ecb:	ba 04 00 00 00       	mov    $0x4,%edx
  8041600ed0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041600ed4:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041600ed8:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600edf:	00 00 00 
  8041600ee2:	ff d0                	call   *%rax
        entry += sizeof(uint32_t);
  8041600ee4:	48 83 45 b8 04       	addq   $0x4,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint32_t))
  8041600ee9:	4d 85 e4             	test   %r12,%r12
  8041600eec:	74 06                	je     8041600ef4 <dwarf_read_abbrev_entry+0x1b2>
  8041600eee:	41 83 fd 03          	cmp    $0x3,%r13d
  8041600ef2:	77 0a                	ja     8041600efe <dwarf_read_abbrev_entry+0x1bc>
            put_unaligned(data, (uint32_t *)buf);
        bytes = sizeof(uint32_t);
  8041600ef4:	b8 04 00 00 00       	mov    $0x4,%eax
  8041600ef9:	e9 bb 08 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (uint32_t *)buf);
  8041600efe:	ba 04 00 00 00       	mov    $0x4,%edx
  8041600f03:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041600f07:	4c 89 e7             	mov    %r12,%rdi
  8041600f0a:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600f11:	00 00 00 
  8041600f14:	ff d0                	call   *%rax
        bytes = sizeof(uint32_t);
  8041600f16:	b8 04 00 00 00       	mov    $0x4,%eax
            put_unaligned(data, (uint32_t *)buf);
  8041600f1b:	e9 99 08 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_data8: {
        uint64_t data = get_unaligned(entry, uint64_t);
  8041600f20:	ba 08 00 00 00       	mov    $0x8,%edx
  8041600f25:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041600f29:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041600f2d:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600f34:	00 00 00 
  8041600f37:	ff d0                	call   *%rax
        entry += sizeof(uint64_t);
  8041600f39:	48 83 45 b8 08       	addq   $0x8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  8041600f3e:	4d 85 e4             	test   %r12,%r12
  8041600f41:	74 06                	je     8041600f49 <dwarf_read_abbrev_entry+0x207>
  8041600f43:	41 83 fd 07          	cmp    $0x7,%r13d
  8041600f47:	77 0a                	ja     8041600f53 <dwarf_read_abbrev_entry+0x211>
            put_unaligned(data, (uint64_t *)buf);
        bytes = sizeof(uint64_t);
  8041600f49:	b8 08 00 00 00       	mov    $0x8,%eax
  8041600f4e:	e9 66 08 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (uint64_t *)buf);
  8041600f53:	ba 08 00 00 00       	mov    $0x8,%edx
  8041600f58:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041600f5c:	4c 89 e7             	mov    %r12,%rdi
  8041600f5f:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600f66:	00 00 00 
  8041600f69:	ff d0                	call   *%rax
        bytes = sizeof(uint64_t);
  8041600f6b:	b8 08 00 00 00       	mov    $0x8,%eax
            put_unaligned(data, (uint64_t *)buf);
  8041600f70:	e9 44 08 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_string: {
        if (buf && bufsize >= sizeof(char *))
  8041600f75:	48 85 d2             	test   %rdx,%rdx
  8041600f78:	74 05                	je     8041600f7f <dwarf_read_abbrev_entry+0x23d>
  8041600f7a:	83 f9 07             	cmp    $0x7,%ecx
  8041600f7d:	77 18                	ja     8041600f97 <dwarf_read_abbrev_entry+0x255>
            memcpy(buf, &entry, sizeof(char *));
        bytes = strlen(entry) + 1;
  8041600f7f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8041600f83:	48 b8 1b fc 60 41 80 	movabs $0x804160fc1b,%rax
  8041600f8a:	00 00 00 
  8041600f8d:	ff d0                	call   *%rax
  8041600f8f:	83 c0 01             	add    $0x1,%eax
    } break;
  8041600f92:	e9 22 08 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            memcpy(buf, &entry, sizeof(char *));
  8041600f97:	ba 08 00 00 00       	mov    $0x8,%edx
  8041600f9c:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
  8041600fa0:	4c 89 e7             	mov    %r12,%rdi
  8041600fa3:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041600faa:	00 00 00 
  8041600fad:	ff d0                	call   *%rax
  8041600faf:	eb ce                	jmp    8041600f7f <dwarf_read_abbrev_entry+0x23d>
    case DW_FORM_block: {
        uint64_t length = 0;
        uint32_t count = dwarf_read_uleb128(entry, &length);
  8041600fb1:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8041600fb5:	4c 89 c2             	mov    %r8,%rdx
/* Decode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C
 * of the DWARF 4 spec. Return the number of bytes read */
static inline uint64_t
dwarf_read_uleb128(const uint8_t *addr, uint64_t *ret) {
    uint64_t result = 0;
    size_t shift = 0, count = 0;
  8041600fb8:	b8 00 00 00 00       	mov    $0x0,%eax
  8041600fbd:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041600fc2:	41 bd 00 00 00 00    	mov    $0x0,%r13d
    uint8_t byte;

    do {
        byte = *addr++;
  8041600fc8:	48 83 c2 01          	add    $0x1,%rdx
  8041600fcc:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041600fd0:	48 89 fe             	mov    %rdi,%rsi
  8041600fd3:	83 e6 7f             	and    $0x7f,%esi
  8041600fd6:	48 d3 e6             	shl    %cl,%rsi
  8041600fd9:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8041600fdc:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041600fe0:	48 89 c6             	mov    %rax,%rsi
  8041600fe3:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041600fe7:	40 84 ff             	test   %dil,%dil
  8041600fea:	79 06                	jns    8041600ff2 <dwarf_read_abbrev_entry+0x2b0>
  8041600fec:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041600ff0:	76 d6                	jbe    8041600fc8 <dwarf_read_abbrev_entry+0x286>

    while (byte & 0x80) {
  8041600ff2:	40 84 ff             	test   %dil,%dil
  8041600ff5:	79 12                	jns    8041601009 <dwarf_read_abbrev_entry+0x2c7>
        byte = *addr++;
  8041600ff7:	48 f7 d6             	not    %rsi
  8041600ffa:	48 01 f2             	add    %rsi,%rdx
  8041600ffd:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041601001:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041601005:	84 c9                	test   %cl,%cl
  8041601007:	78 f4                	js     8041600ffd <dwarf_read_abbrev_entry+0x2bb>
  8041601009:	89 c3                	mov    %eax,%ebx
        entry += count;
  804160100b:	89 c0                	mov    %eax,%eax
  804160100d:	4c 01 c0             	add    %r8,%rax
  8041601010:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        struct Slice slice = {
  8041601014:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8041601018:	44 89 6d d8          	mov    %r13d,-0x28(%rbp)
                .mem = entry,
                .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  804160101c:	4d 85 e4             	test   %r12,%r12
  804160101f:	74 18                	je     8041601039 <dwarf_read_abbrev_entry+0x2f7>
  8041601021:	ba 10 00 00 00       	mov    $0x10,%edx
  8041601026:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  804160102a:	4c 89 e7             	mov    %r12,%rdi
  804160102d:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601034:	00 00 00 
  8041601037:	ff d0                	call   *%rax
        entry += length;
        bytes = count + length;
  8041601039:	42 8d 04 2b          	lea    (%rbx,%r13,1),%eax
    } break;
  804160103d:	e9 77 07 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    case DW_FORM_block1: {
        uint32_t length = get_unaligned(entry, Dwarf_Small);
  8041601042:	ba 01 00 00 00       	mov    $0x1,%edx
  8041601047:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804160104b:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  804160104f:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601056:	00 00 00 
  8041601059:	ff d0                	call   *%rax
  804160105b:	0f b6 5d d0          	movzbl -0x30(%rbp),%ebx
        entry += sizeof(Dwarf_Small);
  804160105f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041601063:	48 83 c0 01          	add    $0x1,%rax
  8041601067:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        struct Slice slice = {
  804160106b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  804160106f:	89 5d d8             	mov    %ebx,-0x28(%rbp)
                .mem = entry,
                .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  8041601072:	4d 85 e4             	test   %r12,%r12
  8041601075:	74 18                	je     804160108f <dwarf_read_abbrev_entry+0x34d>
  8041601077:	ba 10 00 00 00       	mov    $0x10,%edx
  804160107c:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041601080:	4c 89 e7             	mov    %r12,%rdi
  8041601083:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160108a:	00 00 00 
  804160108d:	ff d0                	call   *%rax
        entry += length;
        bytes = length + sizeof(Dwarf_Small);
  804160108f:	8d 43 01             	lea    0x1(%rbx),%eax
    } break;
  8041601092:	e9 22 07 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    case DW_FORM_data1: {
        Dwarf_Small data = get_unaligned(entry, Dwarf_Small);
  8041601097:	ba 01 00 00 00       	mov    $0x1,%edx
  804160109c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80416010a0:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80416010a4:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416010ab:	00 00 00 
  80416010ae:	ff d0                	call   *%rax
  80416010b0:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
        entry += sizeof(Dwarf_Small);
        if (buf && bufsize >= sizeof(Dwarf_Small)) {
  80416010b4:	4d 85 e4             	test   %r12,%r12
  80416010b7:	0f 84 09 07 00 00    	je     80416017c6 <dwarf_read_abbrev_entry+0xa84>
  80416010bd:	45 85 ed             	test   %r13d,%r13d
  80416010c0:	0f 84 00 07 00 00    	je     80416017c6 <dwarf_read_abbrev_entry+0xa84>
            put_unaligned(data, (Dwarf_Small *)buf);
  80416010c6:	41 88 04 24          	mov    %al,(%r12)
        }
        bytes = sizeof(Dwarf_Small);
  80416010ca:	b8 01 00 00 00       	mov    $0x1,%eax
            put_unaligned(data, (Dwarf_Small *)buf);
  80416010cf:	e9 e5 06 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_flag: {
        bool data = get_unaligned(entry, Dwarf_Small);
  80416010d4:	ba 01 00 00 00       	mov    $0x1,%edx
  80416010d9:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80416010dd:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80416010e1:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416010e8:	00 00 00 
  80416010eb:	ff d0                	call   *%rax
  80416010ed:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
        entry += sizeof(Dwarf_Small);
        if (buf && bufsize >= sizeof(bool)) {
  80416010f1:	4d 85 e4             	test   %r12,%r12
  80416010f4:	0f 84 d3 06 00 00    	je     80416017cd <dwarf_read_abbrev_entry+0xa8b>
  80416010fa:	45 85 ed             	test   %r13d,%r13d
  80416010fd:	0f 84 ca 06 00 00    	je     80416017cd <dwarf_read_abbrev_entry+0xa8b>
        bool data = get_unaligned(entry, Dwarf_Small);
  8041601103:	84 c0                	test   %al,%al
            put_unaligned(data, (bool *)buf);
  8041601105:	41 0f 95 04 24       	setne  (%r12)
        }
        bytes = sizeof(Dwarf_Small);
  804160110a:	b8 01 00 00 00       	mov    $0x1,%eax
            put_unaligned(data, (bool *)buf);
  804160110f:	e9 a5 06 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_sdata: {
        int64_t data = 0;
        uint32_t count = dwarf_read_leb128(entry, &data);
  8041601114:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8041601118:	4c 89 c0             	mov    %r8,%rax
/* Decode signed LEB128 data. The Algorithm is taken from Appendix C
 * of the DWARF 4 spec. Return the number of bytes read */
static inline uint64_t
dwarf_read_leb128(const char *addr, int64_t *ret) {
    size_t shift = 0, count = 0;
    uint64_t result = 0;
  804160111b:	bf 00 00 00 00       	mov    $0x0,%edi
    size_t shift = 0, count = 0;
  8041601120:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041601125:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint8_t byte;

    do {
        byte = *addr++;
  804160112a:	48 83 c0 01          	add    $0x1,%rax
  804160112e:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
        result |= (byte & 0x7FULL) << shift;
  8041601132:	48 89 f2             	mov    %rsi,%rdx
  8041601135:	83 e2 7f             	and    $0x7f,%edx
  8041601138:	48 d3 e2             	shl    %cl,%rdx
  804160113b:	48 09 d7             	or     %rdx,%rdi
        shift += 7;
  804160113e:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601142:	48 89 da             	mov    %rbx,%rdx
  8041601145:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041601149:	40 84 f6             	test   %sil,%sil
  804160114c:	79 06                	jns    8041601154 <dwarf_read_abbrev_entry+0x412>
  804160114e:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601152:	76 d6                	jbe    804160112a <dwarf_read_abbrev_entry+0x3e8>

    while (byte & 0x80) {
  8041601154:	40 84 f6             	test   %sil,%sil
  8041601157:	79 2d                	jns    8041601186 <dwarf_read_abbrev_entry+0x444>
        byte = *addr++;
  8041601159:	48 f7 d2             	not    %rdx
  804160115c:	48 01 d0             	add    %rdx,%rax
  804160115f:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  8041601163:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8041601167:	84 d2                	test   %dl,%dl
  8041601169:	78 f4                	js     804160115f <dwarf_read_abbrev_entry+0x41d>
        entry += count;
  804160116b:	89 d8                	mov    %ebx,%eax
  804160116d:	49 01 c0             	add    %rax,%r8
  8041601170:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(int32_t))
  8041601174:	4d 85 e4             	test   %r12,%r12
  8041601177:	74 06                	je     804160117f <dwarf_read_abbrev_entry+0x43d>
  8041601179:	41 83 fd 03          	cmp    $0x3,%r13d
  804160117d:	77 1f                	ja     804160119e <dwarf_read_abbrev_entry+0x45c>
            put_unaligned(data, (int32_t *)buf);
        bytes = count;
  804160117f:	89 d8                	mov    %ebx,%eax
    } break;
  8041601181:	e9 33 06 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    }

    /* The number of bits in a signed integer. */
    if (shift < 8 * sizeof(result) && byte & 0x40)
  8041601186:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160118a:	77 df                	ja     804160116b <dwarf_read_abbrev_entry+0x429>
  804160118c:	40 f6 c6 40          	test   $0x40,%sil
  8041601190:	74 d9                	je     804160116b <dwarf_read_abbrev_entry+0x429>
        result |= (-1U << shift);
  8041601192:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8041601197:	d3 e0                	shl    %cl,%eax
  8041601199:	48 09 c7             	or     %rax,%rdi
  804160119c:	eb cd                	jmp    804160116b <dwarf_read_abbrev_entry+0x429>
            put_unaligned(data, (int32_t *)buf);
  804160119e:	89 7d d0             	mov    %edi,-0x30(%rbp)
  80416011a1:	ba 04 00 00 00       	mov    $0x4,%edx
  80416011a6:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80416011aa:	4c 89 e7             	mov    %r12,%rdi
  80416011ad:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416011b4:	00 00 00 
  80416011b7:	ff d0                	call   *%rax
  80416011b9:	eb c4                	jmp    804160117f <dwarf_read_abbrev_entry+0x43d>
    case DW_FORM_strp: {
        uint64_t length = 0;
        uint32_t count = dwarf_entry_len(entry, &length);
  80416011bb:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80416011bf:	ba 04 00 00 00       	mov    $0x4,%edx
  80416011c4:	4c 89 f6             	mov    %r14,%rsi
  80416011c7:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80416011cb:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416011d2:	00 00 00 
  80416011d5:	ff d0                	call   *%rax
  80416011d7:	8b 55 d0             	mov    -0x30(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80416011da:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  80416011e1:	ff ff ff 
  80416011e4:	48 01 d0             	add    %rdx,%rax
    uint64_t count = sizeof(uint32_t);
  80416011e7:	bb 04 00 00 00       	mov    $0x4,%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80416011ec:	48 83 f8 0f          	cmp    $0xf,%rax
  80416011f0:	77 2f                	ja     8041601221 <dwarf_read_abbrev_entry+0x4df>
        if (initial_len == DW_EXT_DWARF64) {
  80416011f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80416011f7:	48 39 c2             	cmp    %rax,%rdx
  80416011fa:	74 3b                	je     8041601237 <dwarf_read_abbrev_entry+0x4f5>
            cprintf("Unknown DWARF extension\n");
  80416011fc:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041601203:	00 00 00 
  8041601206:	b8 00 00 00 00       	mov    $0x0,%eax
  804160120b:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041601212:	00 00 00 
  8041601215:	ff d2                	call   *%rdx
        uint64_t length = 0;
  8041601217:	ba 00 00 00 00       	mov    $0x0,%edx
            count = 0;
  804160121c:	bb 00 00 00 00       	mov    $0x0,%ebx
        entry += count;
  8041601221:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  8041601225:	4d 85 e4             	test   %r12,%r12
  8041601228:	74 06                	je     8041601230 <dwarf_read_abbrev_entry+0x4ee>
  804160122a:	41 83 fd 07          	cmp    $0x7,%r13d
  804160122e:	77 2b                	ja     804160125b <dwarf_read_abbrev_entry+0x519>
            put_unaligned(length, (uint64_t *)buf);
        bytes = count;
  8041601230:	89 d8                	mov    %ebx,%eax
    } break;
  8041601232:	e9 82 05 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041601237:	49 8d 76 20          	lea    0x20(%r14),%rsi
  804160123b:	ba 08 00 00 00       	mov    $0x8,%edx
  8041601240:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041601244:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160124b:	00 00 00 
  804160124e:	ff d0                	call   *%rax
  8041601250:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
            count += sizeof(uint64_t);
  8041601254:	bb 0c 00 00 00       	mov    $0xc,%ebx
  8041601259:	eb c6                	jmp    8041601221 <dwarf_read_abbrev_entry+0x4df>
            put_unaligned(length, (uint64_t *)buf);
  804160125b:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  804160125f:	ba 08 00 00 00       	mov    $0x8,%edx
  8041601264:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041601268:	4c 89 e7             	mov    %r12,%rdi
  804160126b:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601272:	00 00 00 
  8041601275:	ff d0                	call   *%rax
  8041601277:	eb b7                	jmp    8041601230 <dwarf_read_abbrev_entry+0x4ee>
    case DW_FORM_udata: {
        uint64_t data = 0;
        uint32_t count = dwarf_read_uleb128(entry, &data);
  8041601279:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  804160127d:	4c 89 c0             	mov    %r8,%rax
    size_t shift = 0, count = 0;
  8041601280:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041601285:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804160128a:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  804160128f:	48 83 c0 01          	add    $0x1,%rax
  8041601293:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
        result |= (byte & 0x7FULL) << shift;
  8041601297:	48 89 f2             	mov    %rsi,%rdx
  804160129a:	83 e2 7f             	and    $0x7f,%edx
  804160129d:	48 d3 e2             	shl    %cl,%rdx
  80416012a0:	48 09 d7             	or     %rdx,%rdi
        shift += 7;
  80416012a3:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416012a7:	48 89 da             	mov    %rbx,%rdx
  80416012aa:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  80416012ae:	40 84 f6             	test   %sil,%sil
  80416012b1:	79 06                	jns    80416012b9 <dwarf_read_abbrev_entry+0x577>
  80416012b3:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416012b7:	76 d6                	jbe    804160128f <dwarf_read_abbrev_entry+0x54d>
    while (byte & 0x80) {
  80416012b9:	40 84 f6             	test   %sil,%sil
  80416012bc:	79 12                	jns    80416012d0 <dwarf_read_abbrev_entry+0x58e>
        byte = *addr++;
  80416012be:	48 f7 d2             	not    %rdx
  80416012c1:	48 01 d0             	add    %rdx,%rax
  80416012c4:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  80416012c8:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  80416012cc:	84 d2                	test   %dl,%dl
  80416012ce:	78 f4                	js     80416012c4 <dwarf_read_abbrev_entry+0x582>
        entry += count;
  80416012d0:	89 d8                	mov    %ebx,%eax
  80416012d2:	49 01 c0             	add    %rax,%r8
  80416012d5:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint32_t))
  80416012d9:	4d 85 e4             	test   %r12,%r12
  80416012dc:	74 06                	je     80416012e4 <dwarf_read_abbrev_entry+0x5a2>
  80416012de:	41 83 fd 03          	cmp    $0x3,%r13d
  80416012e2:	77 07                	ja     80416012eb <dwarf_read_abbrev_entry+0x5a9>
            put_unaligned(data, (uint32_t *)buf);
        bytes = count;
  80416012e4:	89 d8                	mov    %ebx,%eax
    } break;
  80416012e6:	e9 ce 04 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (uint32_t *)buf);
  80416012eb:	89 7d d0             	mov    %edi,-0x30(%rbp)
  80416012ee:	ba 04 00 00 00       	mov    $0x4,%edx
  80416012f3:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80416012f7:	4c 89 e7             	mov    %r12,%rdi
  80416012fa:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601301:	00 00 00 
  8041601304:	ff d0                	call   *%rax
  8041601306:	eb dc                	jmp    80416012e4 <dwarf_read_abbrev_entry+0x5a2>
    case DW_FORM_ref_addr: {
        uint64_t length = 0;
        uint32_t count = dwarf_entry_len(entry, &length);
  8041601308:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  804160130c:	ba 04 00 00 00       	mov    $0x4,%edx
  8041601311:	4c 89 f6             	mov    %r14,%rsi
  8041601314:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041601318:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160131f:	00 00 00 
  8041601322:	ff d0                	call   *%rax
  8041601324:	8b 55 d0             	mov    -0x30(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041601327:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  804160132e:	ff ff ff 
  8041601331:	48 01 d0             	add    %rdx,%rax
    uint64_t count = sizeof(uint32_t);
  8041601334:	bb 04 00 00 00       	mov    $0x4,%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041601339:	48 83 f8 0f          	cmp    $0xf,%rax
  804160133d:	77 2f                	ja     804160136e <dwarf_read_abbrev_entry+0x62c>
        if (initial_len == DW_EXT_DWARF64) {
  804160133f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8041601344:	48 39 c2             	cmp    %rax,%rdx
  8041601347:	74 3b                	je     8041601384 <dwarf_read_abbrev_entry+0x642>
            cprintf("Unknown DWARF extension\n");
  8041601349:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041601350:	00 00 00 
  8041601353:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601358:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160135f:	00 00 00 
  8041601362:	ff d2                	call   *%rdx
        uint64_t length = 0;
  8041601364:	ba 00 00 00 00       	mov    $0x0,%edx
            count = 0;
  8041601369:	bb 00 00 00 00       	mov    $0x0,%ebx
        entry += count;
  804160136e:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  8041601372:	4d 85 e4             	test   %r12,%r12
  8041601375:	74 06                	je     804160137d <dwarf_read_abbrev_entry+0x63b>
  8041601377:	41 83 fd 07          	cmp    $0x7,%r13d
  804160137b:	77 2b                	ja     80416013a8 <dwarf_read_abbrev_entry+0x666>
            put_unaligned(length, (uint64_t *)buf);
        bytes = count;
  804160137d:	89 d8                	mov    %ebx,%eax
    } break;
  804160137f:	e9 35 04 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041601384:	49 8d 76 20          	lea    0x20(%r14),%rsi
  8041601388:	ba 08 00 00 00       	mov    $0x8,%edx
  804160138d:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041601391:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601398:	00 00 00 
  804160139b:	ff d0                	call   *%rax
  804160139d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
            count += sizeof(uint64_t);
  80416013a1:	bb 0c 00 00 00       	mov    $0xc,%ebx
  80416013a6:	eb c6                	jmp    804160136e <dwarf_read_abbrev_entry+0x62c>
            put_unaligned(length, (uint64_t *)buf);
  80416013a8:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80416013ac:	ba 08 00 00 00       	mov    $0x8,%edx
  80416013b1:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80416013b5:	4c 89 e7             	mov    %r12,%rdi
  80416013b8:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416013bf:	00 00 00 
  80416013c2:	ff d0                	call   *%rax
  80416013c4:	eb b7                	jmp    804160137d <dwarf_read_abbrev_entry+0x63b>
    case DW_FORM_ref1: {
        Dwarf_Small data = get_unaligned(entry, Dwarf_Small);
  80416013c6:	ba 01 00 00 00       	mov    $0x1,%edx
  80416013cb:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80416013cf:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80416013d3:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416013da:	00 00 00 
  80416013dd:	ff d0                	call   *%rax
  80416013df:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
        entry += sizeof(Dwarf_Small);
        if (buf && bufsize >= sizeof(Dwarf_Small))
  80416013e3:	4d 85 e4             	test   %r12,%r12
  80416013e6:	0f 84 e8 03 00 00    	je     80416017d4 <dwarf_read_abbrev_entry+0xa92>
  80416013ec:	45 85 ed             	test   %r13d,%r13d
  80416013ef:	0f 84 df 03 00 00    	je     80416017d4 <dwarf_read_abbrev_entry+0xa92>
            put_unaligned(data, (Dwarf_Small *)buf);
  80416013f5:	41 88 04 24          	mov    %al,(%r12)
        bytes = sizeof(Dwarf_Small);
  80416013f9:	b8 01 00 00 00       	mov    $0x1,%eax
            put_unaligned(data, (Dwarf_Small *)buf);
  80416013fe:	e9 b6 03 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_ref2: {
        Dwarf_Half data = get_unaligned(entry, Dwarf_Half);
  8041601403:	ba 02 00 00 00       	mov    $0x2,%edx
  8041601408:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804160140c:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041601410:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601417:	00 00 00 
  804160141a:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  804160141c:	48 83 45 b8 02       	addq   $0x2,-0x48(%rbp)
        if (buf && bufsize >= sizeof(Dwarf_Half))
  8041601421:	4d 85 e4             	test   %r12,%r12
  8041601424:	74 06                	je     804160142c <dwarf_read_abbrev_entry+0x6ea>
  8041601426:	41 83 fd 01          	cmp    $0x1,%r13d
  804160142a:	77 0a                	ja     8041601436 <dwarf_read_abbrev_entry+0x6f4>
            put_unaligned(data, (Dwarf_Half *)buf);
        bytes = sizeof(Dwarf_Half);
  804160142c:	b8 02 00 00 00       	mov    $0x2,%eax
  8041601431:	e9 83 03 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (Dwarf_Half *)buf);
  8041601436:	ba 02 00 00 00       	mov    $0x2,%edx
  804160143b:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  804160143f:	4c 89 e7             	mov    %r12,%rdi
  8041601442:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601449:	00 00 00 
  804160144c:	ff d0                	call   *%rax
        bytes = sizeof(Dwarf_Half);
  804160144e:	b8 02 00 00 00       	mov    $0x2,%eax
            put_unaligned(data, (Dwarf_Half *)buf);
  8041601453:	e9 61 03 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_ref4: {
        uint32_t data = get_unaligned(entry, uint32_t);
  8041601458:	ba 04 00 00 00       	mov    $0x4,%edx
  804160145d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041601461:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041601465:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160146c:	00 00 00 
  804160146f:	ff d0                	call   *%rax
        entry += sizeof(uint32_t);
  8041601471:	48 83 45 b8 04       	addq   $0x4,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint32_t))
  8041601476:	4d 85 e4             	test   %r12,%r12
  8041601479:	74 06                	je     8041601481 <dwarf_read_abbrev_entry+0x73f>
  804160147b:	41 83 fd 03          	cmp    $0x3,%r13d
  804160147f:	77 0a                	ja     804160148b <dwarf_read_abbrev_entry+0x749>
            put_unaligned(data, (uint32_t *)buf);
        bytes = sizeof(uint32_t);
  8041601481:	b8 04 00 00 00       	mov    $0x4,%eax
  8041601486:	e9 2e 03 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (uint32_t *)buf);
  804160148b:	ba 04 00 00 00       	mov    $0x4,%edx
  8041601490:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041601494:	4c 89 e7             	mov    %r12,%rdi
  8041601497:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160149e:	00 00 00 
  80416014a1:	ff d0                	call   *%rax
        bytes = sizeof(uint32_t);
  80416014a3:	b8 04 00 00 00       	mov    $0x4,%eax
            put_unaligned(data, (uint32_t *)buf);
  80416014a8:	e9 0c 03 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_ref8: {
        uint64_t data = get_unaligned(entry, uint64_t);
  80416014ad:	ba 08 00 00 00       	mov    $0x8,%edx
  80416014b2:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80416014b6:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80416014ba:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416014c1:	00 00 00 
  80416014c4:	ff d0                	call   *%rax
        entry += sizeof(uint64_t);
  80416014c6:	48 83 45 b8 08       	addq   $0x8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  80416014cb:	4d 85 e4             	test   %r12,%r12
  80416014ce:	74 06                	je     80416014d6 <dwarf_read_abbrev_entry+0x794>
  80416014d0:	41 83 fd 07          	cmp    $0x7,%r13d
  80416014d4:	77 0a                	ja     80416014e0 <dwarf_read_abbrev_entry+0x79e>
            put_unaligned(data, (uint64_t *)buf);
        bytes = sizeof(uint64_t);
  80416014d6:	b8 08 00 00 00       	mov    $0x8,%eax
  80416014db:	e9 d9 02 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (uint64_t *)buf);
  80416014e0:	ba 08 00 00 00       	mov    $0x8,%edx
  80416014e5:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80416014e9:	4c 89 e7             	mov    %r12,%rdi
  80416014ec:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416014f3:	00 00 00 
  80416014f6:	ff d0                	call   *%rax
        bytes = sizeof(uint64_t);
  80416014f8:	b8 08 00 00 00       	mov    $0x8,%eax
            put_unaligned(data, (uint64_t *)buf);
  80416014fd:	e9 b7 02 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    } break;
    case DW_FORM_ref_udata: {
        uint64_t data = 0;
        uint32_t count = dwarf_read_uleb128(entry, &data);
  8041601502:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8041601506:	4c 89 c0             	mov    %r8,%rax
    size_t shift = 0, count = 0;
  8041601509:	bb 00 00 00 00       	mov    $0x0,%ebx
  804160150e:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041601513:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  8041601518:	48 83 c0 01          	add    $0x1,%rax
  804160151c:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
        result |= (byte & 0x7FULL) << shift;
  8041601520:	48 89 f2             	mov    %rsi,%rdx
  8041601523:	83 e2 7f             	and    $0x7f,%edx
  8041601526:	48 d3 e2             	shl    %cl,%rdx
  8041601529:	48 09 d7             	or     %rdx,%rdi
        shift += 7;
  804160152c:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601530:	48 89 da             	mov    %rbx,%rdx
  8041601533:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041601537:	40 84 f6             	test   %sil,%sil
  804160153a:	79 06                	jns    8041601542 <dwarf_read_abbrev_entry+0x800>
  804160153c:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601540:	76 d6                	jbe    8041601518 <dwarf_read_abbrev_entry+0x7d6>
    while (byte & 0x80) {
  8041601542:	40 84 f6             	test   %sil,%sil
  8041601545:	79 12                	jns    8041601559 <dwarf_read_abbrev_entry+0x817>
        byte = *addr++;
  8041601547:	48 f7 d2             	not    %rdx
  804160154a:	48 01 d0             	add    %rdx,%rax
  804160154d:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  8041601551:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8041601555:	84 d2                	test   %dl,%dl
  8041601557:	78 f4                	js     804160154d <dwarf_read_abbrev_entry+0x80b>
        entry += count;
  8041601559:	89 d8                	mov    %ebx,%eax
  804160155b:	49 01 c0             	add    %rax,%r8
  804160155e:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(unsigned int))
  8041601562:	4d 85 e4             	test   %r12,%r12
  8041601565:	74 06                	je     804160156d <dwarf_read_abbrev_entry+0x82b>
  8041601567:	41 83 fd 03          	cmp    $0x3,%r13d
  804160156b:	77 07                	ja     8041601574 <dwarf_read_abbrev_entry+0x832>
            put_unaligned(data, (unsigned int *)buf);
        bytes = count;
  804160156d:	89 d8                	mov    %ebx,%eax
    } break;
  804160156f:	e9 45 02 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (unsigned int *)buf);
  8041601574:	89 7d d0             	mov    %edi,-0x30(%rbp)
  8041601577:	ba 04 00 00 00       	mov    $0x4,%edx
  804160157c:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8041601580:	4c 89 e7             	mov    %r12,%rdi
  8041601583:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160158a:	00 00 00 
  804160158d:	ff d0                	call   *%rax
  804160158f:	eb dc                	jmp    804160156d <dwarf_read_abbrev_entry+0x82b>
    case DW_FORM_indirect: {
        uint64_t form = 0;
        uint32_t count = dwarf_read_uleb128(entry, &form);
  8041601591:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8041601595:	4c 89 c0             	mov    %r8,%rax
    size_t shift = 0, count = 0;
  8041601598:	41 be 00 00 00 00    	mov    $0x0,%r14d
  804160159e:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416015a3:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  80416015a8:	48 83 c0 01          	add    $0x1,%rax
  80416015ac:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  80416015b0:	48 89 fa             	mov    %rdi,%rdx
  80416015b3:	83 e2 7f             	and    $0x7f,%edx
  80416015b6:	48 d3 e2             	shl    %cl,%rdx
  80416015b9:	48 09 d6             	or     %rdx,%rsi
        shift += 7;
  80416015bc:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416015c0:	4c 89 f2             	mov    %r14,%rdx
  80416015c3:	49 83 c6 01          	add    $0x1,%r14
    } while (byte & 0x80 && shift < 64);
  80416015c7:	40 84 ff             	test   %dil,%dil
  80416015ca:	79 06                	jns    80416015d2 <dwarf_read_abbrev_entry+0x890>
  80416015cc:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416015d0:	76 d6                	jbe    80416015a8 <dwarf_read_abbrev_entry+0x866>
    while (byte & 0x80) {
  80416015d2:	40 84 ff             	test   %dil,%dil
  80416015d5:	79 13                	jns    80416015ea <dwarf_read_abbrev_entry+0x8a8>
        byte = *addr++;
  80416015d7:	48 f7 d2             	not    %rdx
  80416015da:	48 01 d0             	add    %rdx,%rax
  80416015dd:	42 0f b6 14 30       	movzbl (%rax,%r14,1),%edx
        count++;
  80416015e2:	49 83 c6 01          	add    $0x1,%r14
    while (byte & 0x80) {
  80416015e6:	84 d2                	test   %dl,%dl
  80416015e8:	78 f3                	js     80416015dd <dwarf_read_abbrev_entry+0x89b>
        entry += count;
  80416015ea:	44 89 f7             	mov    %r14d,%edi
  80416015ed:	4c 01 c7             	add    %r8,%rdi
  80416015f0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
        uint32_t read = dwarf_read_abbrev_entry(entry, form, buf, bufsize, address_size);
  80416015f4:	49 89 d8             	mov    %rbx,%r8
  80416015f7:	44 89 e9             	mov    %r13d,%ecx
  80416015fa:	4c 89 e2             	mov    %r12,%rdx
  80416015fd:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  8041601604:	00 00 00 
  8041601607:	ff d0                	call   *%rax
        bytes = count + read;
  8041601609:	44 01 f0             	add    %r14d,%eax
    } break;
  804160160c:	e9 a8 01 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    case DW_FORM_sec_offset: {
        uint64_t length = 0;
        uint32_t count = dwarf_entry_len(entry, &length);
  8041601611:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8041601615:	ba 04 00 00 00       	mov    $0x4,%edx
  804160161a:	4c 89 f6             	mov    %r14,%rsi
  804160161d:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041601621:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601628:	00 00 00 
  804160162b:	ff d0                	call   *%rax
  804160162d:	8b 55 d0             	mov    -0x30(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041601630:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8041601637:	ff ff ff 
  804160163a:	48 01 d0             	add    %rdx,%rax
    uint64_t count = sizeof(uint32_t);
  804160163d:	bb 04 00 00 00       	mov    $0x4,%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041601642:	48 83 f8 0f          	cmp    $0xf,%rax
  8041601646:	77 2f                	ja     8041601677 <dwarf_read_abbrev_entry+0x935>
        if (initial_len == DW_EXT_DWARF64) {
  8041601648:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804160164d:	48 39 c2             	cmp    %rax,%rdx
  8041601650:	74 3b                	je     804160168d <dwarf_read_abbrev_entry+0x94b>
            cprintf("Unknown DWARF extension\n");
  8041601652:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041601659:	00 00 00 
  804160165c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601661:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041601668:	00 00 00 
  804160166b:	ff d2                	call   *%rdx
        uint64_t length = 0;
  804160166d:	ba 00 00 00 00       	mov    $0x0,%edx
            count = 0;
  8041601672:	bb 00 00 00 00       	mov    $0x0,%ebx
        entry += count;
  8041601677:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(unsigned long))
  804160167b:	4d 85 e4             	test   %r12,%r12
  804160167e:	74 06                	je     8041601686 <dwarf_read_abbrev_entry+0x944>
  8041601680:	41 83 fd 07          	cmp    $0x7,%r13d
  8041601684:	77 2b                	ja     80416016b1 <dwarf_read_abbrev_entry+0x96f>
            put_unaligned(length, (unsigned long *)buf);
        bytes = count;
  8041601686:	89 d8                	mov    %ebx,%eax
    } break;
  8041601688:	e9 2c 01 00 00       	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  804160168d:	49 8d 76 20          	lea    0x20(%r14),%rsi
  8041601691:	ba 08 00 00 00       	mov    $0x8,%edx
  8041601696:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  804160169a:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416016a1:	00 00 00 
  80416016a4:	ff d0                	call   *%rax
  80416016a6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
            count += sizeof(uint64_t);
  80416016aa:	bb 0c 00 00 00       	mov    $0xc,%ebx
  80416016af:	eb c6                	jmp    8041601677 <dwarf_read_abbrev_entry+0x935>
            put_unaligned(length, (unsigned long *)buf);
  80416016b1:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80416016b5:	ba 08 00 00 00       	mov    $0x8,%edx
  80416016ba:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80416016be:	4c 89 e7             	mov    %r12,%rdi
  80416016c1:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416016c8:	00 00 00 
  80416016cb:	ff d0                	call   *%rax
  80416016cd:	eb b7                	jmp    8041601686 <dwarf_read_abbrev_entry+0x944>
    case DW_FORM_exprloc: {
        uint64_t length = 0;
        uint64_t count = dwarf_read_uleb128(entry, &length);
  80416016cf:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80416016d3:	48 89 f8             	mov    %rdi,%rax
    size_t shift = 0, count = 0;
  80416016d6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80416016db:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416016e0:	41 be 00 00 00 00    	mov    $0x0,%r14d
        byte = *addr++;
  80416016e6:	48 83 c0 01          	add    $0x1,%rax
  80416016ea:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
        result |= (byte & 0x7FULL) << shift;
  80416016ee:	48 89 f2             	mov    %rsi,%rdx
  80416016f1:	83 e2 7f             	and    $0x7f,%edx
  80416016f4:	48 d3 e2             	shl    %cl,%rdx
  80416016f7:	49 09 d6             	or     %rdx,%r14
        shift += 7;
  80416016fa:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416016fe:	48 89 da             	mov    %rbx,%rdx
  8041601701:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041601705:	40 84 f6             	test   %sil,%sil
  8041601708:	79 06                	jns    8041601710 <dwarf_read_abbrev_entry+0x9ce>
  804160170a:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160170e:	76 d6                	jbe    80416016e6 <dwarf_read_abbrev_entry+0x9a4>
    while (byte & 0x80) {
  8041601710:	40 84 f6             	test   %sil,%sil
  8041601713:	79 12                	jns    8041601727 <dwarf_read_abbrev_entry+0x9e5>
        byte = *addr++;
  8041601715:	48 f7 d2             	not    %rdx
  8041601718:	48 01 d0             	add    %rdx,%rax
  804160171b:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  804160171f:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8041601723:	84 d2                	test   %dl,%dl
  8041601725:	78 f4                	js     804160171b <dwarf_read_abbrev_entry+0x9d9>
        entry += count;
  8041601727:	48 8d 34 1f          	lea    (%rdi,%rbx,1),%rsi
  804160172b:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
        if (buf) memcpy(buf, entry, MIN(length, bufsize));
  804160172f:	4d 85 e4             	test   %r12,%r12
  8041601732:	74 1c                	je     8041601750 <dwarf_read_abbrev_entry+0xa0e>
  8041601734:	4d 63 ed             	movslq %r13d,%r13
  8041601737:	4d 39 f5             	cmp    %r14,%r13
  804160173a:	4c 89 ea             	mov    %r13,%rdx
  804160173d:	49 0f 47 d6          	cmova  %r14,%rdx
  8041601741:	4c 89 e7             	mov    %r12,%rdi
  8041601744:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160174b:	00 00 00 
  804160174e:	ff d0                	call   *%rax
        entry += length;
        bytes = count + length;
  8041601750:	42 8d 04 33          	lea    (%rbx,%r14,1),%eax
    } break;
  8041601754:	eb 63                	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    case DW_FORM_flag_present:
        if (buf && sizeof(buf) >= sizeof(bool)) {
            put_unaligned(true, (bool *)buf);
        }
        bytes = 0;
  8041601756:	b8 00 00 00 00       	mov    $0x0,%eax
        if (buf && sizeof(buf) >= sizeof(bool)) {
  804160175b:	48 85 d2             	test   %rdx,%rdx
  804160175e:	74 59                	je     80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(true, (bool *)buf);
  8041601760:	c6 02 01             	movb   $0x1,(%rdx)
  8041601763:	eb 54                	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
        break;
    case DW_FORM_ref_sig8: {
        uint64_t data = get_unaligned(entry, uint64_t);
  8041601765:	ba 08 00 00 00       	mov    $0x8,%edx
  804160176a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804160176e:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8041601772:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601779:	00 00 00 
  804160177c:	ff d0                	call   *%rax
        entry += sizeof(uint64_t);
  804160177e:	48 83 45 b8 08       	addq   $0x8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  8041601783:	4d 85 e4             	test   %r12,%r12
  8041601786:	74 06                	je     804160178e <dwarf_read_abbrev_entry+0xa4c>
  8041601788:	41 83 fd 07          	cmp    $0x7,%r13d
  804160178c:	77 07                	ja     8041601795 <dwarf_read_abbrev_entry+0xa53>
            put_unaligned(data, (uint64_t *)buf);
        bytes = sizeof(uint64_t);
  804160178e:	b8 08 00 00 00       	mov    $0x8,%eax
    } break;
    }
    return bytes;
  8041601793:	eb 24                	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
            put_unaligned(data, (uint64_t *)buf);
  8041601795:	ba 08 00 00 00       	mov    $0x8,%edx
  804160179a:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  804160179e:	4c 89 e7             	mov    %r12,%rdi
  80416017a1:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416017a8:	00 00 00 
  80416017ab:	ff d0                	call   *%rax
        bytes = sizeof(uint64_t);
  80416017ad:	b8 08 00 00 00       	mov    $0x8,%eax
            put_unaligned(data, (uint64_t *)buf);
  80416017b2:	eb 05                	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
    switch (form) {
  80416017b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80416017b9:	48 83 c4 30          	add    $0x30,%rsp
  80416017bd:	5b                   	pop    %rbx
  80416017be:	41 5c                	pop    %r12
  80416017c0:	41 5d                	pop    %r13
  80416017c2:	41 5e                	pop    %r14
  80416017c4:	5d                   	pop    %rbp
  80416017c5:	c3                   	ret    
        bytes = sizeof(Dwarf_Small);
  80416017c6:	b8 01 00 00 00       	mov    $0x1,%eax
  80416017cb:	eb ec                	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
        bytes = sizeof(Dwarf_Small);
  80416017cd:	b8 01 00 00 00       	mov    $0x1,%eax
  80416017d2:	eb e5                	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>
        bytes = sizeof(Dwarf_Small);
  80416017d4:	b8 01 00 00 00       	mov    $0x1,%eax
  80416017d9:	eb de                	jmp    80416017b9 <dwarf_read_abbrev_entry+0xa77>

00000080416017db <info_by_address>:
    }
    return -E_NO_ENT;
}

int
info_by_address(const struct Dwarf_Addrs *addrs, uintptr_t addr, Dwarf_Off *store) {
  80416017db:	55                   	push   %rbp
  80416017dc:	48 89 e5             	mov    %rsp,%rbp
  80416017df:	41 57                	push   %r15
  80416017e1:	41 56                	push   %r14
  80416017e3:	41 55                	push   %r13
  80416017e5:	41 54                	push   %r12
  80416017e7:	53                   	push   %rbx
  80416017e8:	48 83 ec 48          	sub    $0x48,%rsp
  80416017ec:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80416017f0:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80416017f4:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    const uint8_t *set = addrs->aranges_begin;
  80416017f8:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
    while ((unsigned char *)set < addrs->aranges_end) {
  80416017fc:	48 3b 5f 18          	cmp    0x18(%rdi),%rbx
  8041601800:	72 25                	jb     8041601827 <info_by_address+0x4c>
    const uint8_t *entry = addrs->info_begin;
  8041601802:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8041601806:	48 8b 78 20          	mov    0x20(%rax),%rdi
  804160180a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    while (entry < addrs->info_end) {
  804160180e:	48 39 78 28          	cmp    %rdi,0x28(%rax)
  8041601812:	0f 86 b1 03 00 00    	jbe    8041601bc9 <info_by_address+0x3ee>
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041601818:	49 bf 42 0d 60 41 80 	movabs $0x8041600d42,%r15
  804160181f:	00 00 00 
  8041601822:	e9 dc 02 00 00       	jmp    8041601b03 <info_by_address+0x328>
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8041601827:	ba 04 00 00 00       	mov    $0x4,%edx
  804160182c:	48 89 de             	mov    %rbx,%rsi
  804160182f:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601833:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160183a:	00 00 00 
  804160183d:	ff d0                	call   *%rax
  804160183f:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041601842:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8041601849:	ff ff ff 
  804160184c:	48 01 d0             	add    %rdx,%rax
  804160184f:	48 83 f8 0f          	cmp    $0xf,%rax
  8041601853:	77 ad                	ja     8041601802 <info_by_address+0x27>
        if (initial_len == DW_EXT_DWARF64) {
  8041601855:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804160185a:	48 39 c2             	cmp    %rax,%rdx
  804160185d:	74 1d                	je     804160187c <info_by_address+0xa1>
            cprintf("Unknown DWARF extension\n");
  804160185f:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041601866:	00 00 00 
  8041601869:	b8 00 00 00 00       	mov    $0x0,%eax
  804160186e:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041601875:	00 00 00 
  8041601878:	ff d2                	call   *%rdx
            count = 0;
  804160187a:	eb 86                	jmp    8041601802 <info_by_address+0x27>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  804160187c:	48 8d 73 20          	lea    0x20(%rbx),%rsi
  8041601880:	ba 08 00 00 00       	mov    $0x8,%edx
  8041601885:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601889:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601890:	00 00 00 
  8041601893:	ff d0                	call   *%rax
            count += sizeof(uint64_t);
  8041601895:	e9 68 ff ff ff       	jmp    8041601802 <info_by_address+0x27>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  804160189a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804160189e:	48 8d 70 20          	lea    0x20(%rax),%rsi
  80416018a2:	ba 08 00 00 00       	mov    $0x8,%edx
  80416018a7:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416018ab:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416018b2:	00 00 00 
  80416018b5:	ff d0                	call   *%rax
  80416018b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  80416018bb:	41 bc 0c 00 00 00    	mov    $0xc,%r12d
  80416018c1:	e9 10 03 00 00       	jmp    8041601bd6 <info_by_address+0x3fb>
        assert(version == 4 || version == 2);
  80416018c6:	48 b9 f9 13 61 41 80 	movabs $0x80416113f9,%rcx
  80416018cd:	00 00 00 
  80416018d0:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416018d7:	00 00 00 
  80416018da:	be 1e 01 00 00       	mov    $0x11e,%esi
  80416018df:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  80416018e6:	00 00 00 
  80416018e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80416018ee:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416018f5:	00 00 00 
  80416018f8:	41 ff d0             	call   *%r8
        assert(address_size == sizeof(uintptr_t));
  80416018fb:	48 b9 68 15 61 41 80 	movabs $0x8041611568,%rcx
  8041601902:	00 00 00 
  8041601905:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160190c:	00 00 00 
  804160190f:	be 23 01 00 00       	mov    $0x123,%esi
  8041601914:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  804160191b:	00 00 00 
  804160191e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601923:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160192a:	00 00 00 
  804160192d:	41 ff d0             	call   *%r8
        assert(abbrev_code);
  8041601930:	48 b9 38 14 61 41 80 	movabs $0x8041611438,%rcx
  8041601937:	00 00 00 
  804160193a:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041601941:	00 00 00 
  8041601944:	be 28 01 00 00       	mov    $0x128,%esi
  8041601949:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041601950:	00 00 00 
  8041601953:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601958:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160195f:	00 00 00 
  8041601962:	41 ff d0             	call   *%r8
        assert(table_abbrev_code == abbrev_code);
  8041601965:	48 b9 90 15 61 41 80 	movabs $0x8041611590,%rcx
  804160196c:	00 00 00 
  804160196f:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041601976:	00 00 00 
  8041601979:	be 2e 01 00 00       	mov    $0x12e,%esi
  804160197e:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041601985:	00 00 00 
  8041601988:	b8 00 00 00 00       	mov    $0x0,%eax
  804160198d:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041601994:	00 00 00 
  8041601997:	41 ff d0             	call   *%r8
        assert(tag == DW_TAG_compile_unit);
  804160199a:	48 b9 44 14 61 41 80 	movabs $0x8041611444,%rcx
  80416019a1:	00 00 00 
  80416019a4:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416019ab:	00 00 00 
  80416019ae:	be 31 01 00 00       	mov    $0x131,%esi
  80416019b3:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  80416019ba:	00 00 00 
  80416019bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80416019c2:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416019c9:	00 00 00 
  80416019cc:	41 ff d0             	call   *%r8
                entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  80416019cf:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80416019d5:	b9 08 00 00 00       	mov    $0x8,%ecx
  80416019da:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80416019de:	44 89 ee             	mov    %r13d,%esi
  80416019e1:	4c 89 f7             	mov    %r14,%rdi
  80416019e4:	41 ff d7             	call   *%r15
  80416019e7:	48 98                	cltq   
  80416019e9:	49 01 c6             	add    %rax,%r14
    uint64_t result = 0;
  80416019ec:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80416019ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80416019f4:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416019f9:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  80416019ff:	48 83 c2 01          	add    $0x1,%rdx
  8041601a03:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041601a07:	48 89 fe             	mov    %rdi,%rsi
  8041601a0a:	83 e6 7f             	and    $0x7f,%esi
  8041601a0d:	48 d3 e6             	shl    %cl,%rsi
  8041601a10:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  8041601a13:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601a17:	48 89 c6             	mov    %rax,%rsi
  8041601a1a:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041601a1e:	40 84 ff             	test   %dil,%dil
  8041601a21:	79 06                	jns    8041601a29 <info_by_address+0x24e>
  8041601a23:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601a27:	76 d6                	jbe    80416019ff <info_by_address+0x224>
    while (byte & 0x80) {
  8041601a29:	40 84 ff             	test   %dil,%dil
  8041601a2c:	79 12                	jns    8041601a40 <info_by_address+0x265>
        byte = *addr++;
  8041601a2e:	48 f7 d6             	not    %rsi
  8041601a31:	48 01 f2             	add    %rsi,%rdx
  8041601a34:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041601a38:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041601a3c:	84 c9                	test   %cl,%cl
  8041601a3e:	78 f4                	js     8041601a34 <info_by_address+0x259>
            abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8041601a40:	48 01 c3             	add    %rax,%rbx
  8041601a43:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041601a46:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601a4b:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041601a50:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8041601a56:	48 83 c2 01          	add    $0x1,%rdx
  8041601a5a:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041601a5e:	48 89 fe             	mov    %rdi,%rsi
  8041601a61:	83 e6 7f             	and    $0x7f,%esi
  8041601a64:	48 d3 e6             	shl    %cl,%rsi
  8041601a67:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8041601a6a:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601a6e:	48 89 c6             	mov    %rax,%rsi
  8041601a71:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041601a75:	40 84 ff             	test   %dil,%dil
  8041601a78:	79 06                	jns    8041601a80 <info_by_address+0x2a5>
  8041601a7a:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601a7e:	76 d6                	jbe    8041601a56 <info_by_address+0x27b>
    while (byte & 0x80) {
  8041601a80:	40 84 ff             	test   %dil,%dil
  8041601a83:	79 12                	jns    8041601a97 <info_by_address+0x2bc>
        byte = *addr++;
  8041601a85:	48 f7 d6             	not    %rsi
  8041601a88:	48 01 f2             	add    %rsi,%rdx
  8041601a8b:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041601a8f:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041601a93:	84 c9                	test   %cl,%cl
  8041601a95:	78 f4                	js     8041601a8b <info_by_address+0x2b0>
            abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8041601a97:	48 01 c3             	add    %rax,%rbx
            if (name == DW_AT_low_pc) {
  8041601a9a:	49 83 fc 11          	cmp    $0x11,%r12
  8041601a9e:	0f 84 2b ff ff ff    	je     80416019cf <info_by_address+0x1f4>
            } else if (name == DW_AT_high_pc) {
  8041601aa4:	49 83 fc 12          	cmp    $0x12,%r12
  8041601aa8:	0f 84 c6 00 00 00    	je     8041601b74 <info_by_address+0x399>
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041601aae:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041601ab4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041601ab9:	ba 00 00 00 00       	mov    $0x0,%edx
  8041601abe:	44 89 ee             	mov    %r13d,%esi
  8041601ac1:	4c 89 f7             	mov    %r14,%rdi
  8041601ac4:	41 ff d7             	call   *%r15
  8041601ac7:	48 98                	cltq   
  8041601ac9:	49 01 c6             	add    %rax,%r14
        } while (name || form);
  8041601acc:	4d 09 e5             	or     %r12,%r13
  8041601acf:	0f 85 17 ff ff ff    	jne    80416019ec <info_by_address+0x211>
        if (p >= low_pc && p <= high_pc) {
  8041601ad5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8041601ad9:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8041601add:	72 0a                	jb     8041601ae9 <info_by_address+0x30e>
  8041601adf:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8041601ae3:	0f 86 bf 00 00 00    	jbe    8041601ba8 <info_by_address+0x3cd>
    while (entry < addrs->info_end) {
  8041601ae9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8041601aed:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8041601af1:	48 3b 78 28          	cmp    0x28(%rax),%rdi
  8041601af5:	0f 83 c7 00 00 00    	jae    8041601bc2 <info_by_address+0x3e7>
        entry = entry_end;
  8041601afb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8041601aff:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8041601b03:	ba 04 00 00 00       	mov    $0x4,%edx
  8041601b08:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041601b0c:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601b10:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601b17:	00 00 00 
  8041601b1a:	ff d0                	call   *%rax
  8041601b1c:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041601b1f:	48 bf 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdi
  8041601b26:	ff ff ff 
  8041601b29:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
  8041601b2d:	48 83 fa 0f          	cmp    $0xf,%rdx
  8041601b31:	0f 87 99 00 00 00    	ja     8041601bd0 <info_by_address+0x3f5>
        if (initial_len == DW_EXT_DWARF64) {
  8041601b37:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8041601b3c:	48 39 d0             	cmp    %rdx,%rax
  8041601b3f:	0f 84 55 fd ff ff    	je     804160189a <info_by_address+0xbf>
            cprintf("Unknown DWARF extension\n");
  8041601b45:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041601b4c:	00 00 00 
  8041601b4f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601b54:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041601b5b:	00 00 00 
  8041601b5e:	ff d2                	call   *%rdx
        if (!count) return -E_BAD_DWARF;
  8041601b60:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    int res = info_by_address_debug_aranges(addrs, addr, store);
    if (res < 0) res = info_by_address_debug_info(addrs, addr, store);
    return res;
}
  8041601b65:	48 83 c4 48          	add    $0x48,%rsp
  8041601b69:	5b                   	pop    %rbx
  8041601b6a:	41 5c                	pop    %r12
  8041601b6c:	41 5d                	pop    %r13
  8041601b6e:	41 5e                	pop    %r14
  8041601b70:	41 5f                	pop    %r15
  8041601b72:	5d                   	pop    %rbp
  8041601b73:	c3                   	ret    
                entry += dwarf_read_abbrev_entry(entry, form, &high_pc, sizeof(high_pc), address_size);
  8041601b74:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041601b7a:	b9 08 00 00 00       	mov    $0x8,%ecx
  8041601b7f:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  8041601b83:	44 89 ee             	mov    %r13d,%esi
  8041601b86:	4c 89 f7             	mov    %r14,%rdi
  8041601b89:	41 ff d7             	call   *%r15
  8041601b8c:	48 98                	cltq   
  8041601b8e:	49 01 c6             	add    %rax,%r14
                if (form != DW_FORM_addr) high_pc += low_pc;
  8041601b91:	49 83 fd 01          	cmp    $0x1,%r13
  8041601b95:	0f 84 51 fe ff ff    	je     80416019ec <info_by_address+0x211>
  8041601b9b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8041601b9f:	48 01 45 c8          	add    %rax,-0x38(%rbp)
  8041601ba3:	e9 44 fe ff ff       	jmp    80416019ec <info_by_address+0x211>
            *store = (const unsigned char *)header - addrs->info_begin;
  8041601ba8:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8041601bac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041601bb0:	48 2b 47 20          	sub    0x20(%rdi),%rax
  8041601bb4:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8041601bb8:	48 89 07             	mov    %rax,(%rdi)
            return 0;
  8041601bbb:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601bc0:	eb a3                	jmp    8041601b65 <info_by_address+0x38a>
    return -E_NO_ENT;
  8041601bc2:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8041601bc7:	eb 9c                	jmp    8041601b65 <info_by_address+0x38a>
  8041601bc9:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    return res;
  8041601bce:	eb 95                	jmp    8041601b65 <info_by_address+0x38a>
    uint64_t count = sizeof(uint32_t);
  8041601bd0:	41 bc 04 00 00 00    	mov    $0x4,%r12d
        entry += count = dwarf_entry_len(entry, &len);
  8041601bd6:	4c 03 65 b8          	add    -0x48(%rbp),%r12
        const uint8_t *entry_end = entry + len;
  8041601bda:	4c 01 e0             	add    %r12,%rax
  8041601bdd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  8041601be1:	ba 02 00 00 00       	mov    $0x2,%edx
  8041601be6:	4c 89 e6             	mov    %r12,%rsi
  8041601be9:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601bed:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601bf4:	00 00 00 
  8041601bf7:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  8041601bf9:	49 8d 74 24 02       	lea    0x2(%r12),%rsi
        assert(version == 4 || version == 2);
  8041601bfe:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8041601c02:	83 e8 02             	sub    $0x2,%eax
  8041601c05:	66 a9 fd ff          	test   $0xfffd,%ax
  8041601c09:	0f 85 b7 fc ff ff    	jne    80416018c6 <info_by_address+0xeb>
        Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  8041601c0f:	ba 04 00 00 00       	mov    $0x4,%edx
  8041601c14:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601c18:	49 be b4 fe 60 41 80 	movabs $0x804160feb4,%r14
  8041601c1f:	00 00 00 
  8041601c22:	41 ff d6             	call   *%r14
  8041601c25:	8b 5d c8             	mov    -0x38(%rbp),%ebx
        entry += sizeof(uint32_t);
  8041601c28:	49 8d 74 24 06       	lea    0x6(%r12),%rsi
        Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  8041601c2d:	ba 01 00 00 00       	mov    $0x1,%edx
  8041601c32:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601c36:	41 ff d6             	call   *%r14
        entry += sizeof(Dwarf_Small);
  8041601c39:	4d 8d 74 24 07       	lea    0x7(%r12),%r14
        assert(address_size == sizeof(uintptr_t));
  8041601c3e:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8041601c42:	0f 85 b3 fc ff ff    	jne    80416018fb <info_by_address+0x120>
  8041601c48:	4c 89 f0             	mov    %r14,%rax
    size_t shift = 0, count = 0;
  8041601c4b:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041601c50:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  8041601c55:	48 83 c0 01          	add    $0x1,%rax
  8041601c59:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8041601c5d:	48 89 fa             	mov    %rdi,%rdx
  8041601c60:	83 e2 7f             	and    $0x7f,%edx
  8041601c63:	48 d3 e2             	shl    %cl,%rdx
  8041601c66:	48 09 d6             	or     %rdx,%rsi
        shift += 7;
  8041601c69:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601c6d:	4c 8d 40 f9          	lea    -0x7(%rax),%r8
  8041601c71:	4c 89 c2             	mov    %r8,%rdx
  8041601c74:	4c 29 e2             	sub    %r12,%rdx
    } while (byte & 0x80 && shift < 64);
  8041601c77:	40 84 ff             	test   %dil,%dil
  8041601c7a:	79 06                	jns    8041601c82 <info_by_address+0x4a7>
  8041601c7c:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601c80:	76 d3                	jbe    8041601c55 <info_by_address+0x47a>
    while (byte & 0x80) {
  8041601c82:	40 84 ff             	test   %dil,%dil
  8041601c85:	79 12                	jns    8041601c99 <info_by_address+0x4be>
        byte = *addr++;
  8041601c87:	4d 29 c4             	sub    %r8,%r12
  8041601c8a:	4c 01 e0             	add    %r12,%rax
  8041601c8d:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041601c91:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041601c95:	84 c9                	test   %cl,%cl
  8041601c97:	78 f4                	js     8041601c8d <info_by_address+0x4b2>
        entry += dwarf_read_uleb128(entry, &abbrev_code);
  8041601c99:	49 01 d6             	add    %rdx,%r14
        assert(abbrev_code);
  8041601c9c:	48 85 f6             	test   %rsi,%rsi
  8041601c9f:	0f 84 8b fc ff ff    	je     8041601930 <info_by_address+0x155>
        const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  8041601ca5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8041601ca9:	48 03 18             	add    (%rax),%rbx
  8041601cac:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041601caf:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601cb4:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041601cb9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
        byte = *addr++;
  8041601cbf:	48 83 c2 01          	add    $0x1,%rdx
  8041601cc3:	44 0f b6 4a ff       	movzbl -0x1(%rdx),%r9d
        result |= (byte & 0x7FULL) << shift;
  8041601cc8:	4c 89 cf             	mov    %r9,%rdi
  8041601ccb:	83 e7 7f             	and    $0x7f,%edi
  8041601cce:	48 d3 e7             	shl    %cl,%rdi
  8041601cd1:	49 09 f8             	or     %rdi,%r8
        shift += 7;
  8041601cd4:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601cd8:	48 89 c7             	mov    %rax,%rdi
  8041601cdb:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041601cdf:	45 84 c9             	test   %r9b,%r9b
  8041601ce2:	79 06                	jns    8041601cea <info_by_address+0x50f>
  8041601ce4:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601ce8:	76 d5                	jbe    8041601cbf <info_by_address+0x4e4>
    while (byte & 0x80) {
  8041601cea:	45 84 c9             	test   %r9b,%r9b
  8041601ced:	79 12                	jns    8041601d01 <info_by_address+0x526>
        byte = *addr++;
  8041601cef:	48 f7 d7             	not    %rdi
  8041601cf2:	48 01 fa             	add    %rdi,%rdx
  8041601cf5:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041601cf9:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041601cfd:	84 c9                	test   %cl,%cl
  8041601cff:	78 f4                	js     8041601cf5 <info_by_address+0x51a>
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
  8041601d01:	48 8d 3c 03          	lea    (%rbx,%rax,1),%rdi
        assert(table_abbrev_code == abbrev_code);
  8041601d05:	4c 39 c6             	cmp    %r8,%rsi
  8041601d08:	0f 85 57 fc ff ff    	jne    8041601965 <info_by_address+0x18a>
  8041601d0e:	48 89 fa             	mov    %rdi,%rdx
    size_t shift = 0, count = 0;
  8041601d11:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601d16:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041601d1b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
        byte = *addr++;
  8041601d21:	48 83 c2 01          	add    $0x1,%rdx
  8041601d25:	44 0f b6 4a ff       	movzbl -0x1(%rdx),%r9d
        result |= (byte & 0x7FULL) << shift;
  8041601d2a:	4c 89 ce             	mov    %r9,%rsi
  8041601d2d:	83 e6 7f             	and    $0x7f,%esi
  8041601d30:	48 d3 e6             	shl    %cl,%rsi
  8041601d33:	49 09 f0             	or     %rsi,%r8
        shift += 7;
  8041601d36:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601d3a:	48 89 c6             	mov    %rax,%rsi
  8041601d3d:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041601d41:	45 84 c9             	test   %r9b,%r9b
  8041601d44:	79 06                	jns    8041601d4c <info_by_address+0x571>
  8041601d46:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601d4a:	76 d5                	jbe    8041601d21 <info_by_address+0x546>
    while (byte & 0x80) {
  8041601d4c:	45 84 c9             	test   %r9b,%r9b
  8041601d4f:	79 12                	jns    8041601d63 <info_by_address+0x588>
        byte = *addr++;
  8041601d51:	48 f7 d6             	not    %rsi
  8041601d54:	48 01 f2             	add    %rsi,%rdx
  8041601d57:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041601d5b:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041601d5f:	84 c9                	test   %cl,%cl
  8041601d61:	78 f4                	js     8041601d57 <info_by_address+0x57c>
        assert(tag == DW_TAG_compile_unit);
  8041601d63:	49 83 f8 11          	cmp    $0x11,%r8
  8041601d67:	0f 85 2d fc ff ff    	jne    804160199a <info_by_address+0x1bf>
        abbrev_entry += sizeof(Dwarf_Small);
  8041601d6d:	48 8d 5c 07 01       	lea    0x1(%rdi,%rax,1),%rbx
        uintptr_t low_pc = 0, high_pc = 0;
  8041601d72:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8041601d79:	00 
  8041601d7a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8041601d81:	00 
  8041601d82:	e9 65 fc ff ff       	jmp    80416019ec <info_by_address+0x211>

0000008041601d87 <file_name_by_info>:

int
file_name_by_info(const struct Dwarf_Addrs *addrs, Dwarf_Off offset, char **buf, Dwarf_Off *line_off) {
  8041601d87:	55                   	push   %rbp
  8041601d88:	48 89 e5             	mov    %rsp,%rbp
  8041601d8b:	41 57                	push   %r15
  8041601d8d:	41 56                	push   %r14
  8041601d8f:	41 55                	push   %r13
  8041601d91:	41 54                	push   %r12
  8041601d93:	53                   	push   %rbx
  8041601d94:	48 83 ec 38          	sub    $0x38,%rsp
  8041601d98:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8041601d9c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8041601da0:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    if (offset > addrs->info_end - addrs->info_begin) return -E_INVAL;
  8041601da4:	48 8b 5f 20          	mov    0x20(%rdi),%rbx
  8041601da8:	48 8b 47 28          	mov    0x28(%rdi),%rax
  8041601dac:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8041601db0:	48 29 d8             	sub    %rbx,%rax
  8041601db3:	48 39 f0             	cmp    %rsi,%rax
  8041601db6:	0f 82 34 03 00 00    	jb     80416020f0 <file_name_by_info+0x369>

    const uint8_t *entry = addrs->info_begin + offset;
  8041601dbc:	48 01 f3             	add    %rsi,%rbx
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8041601dbf:	ba 04 00 00 00       	mov    $0x4,%edx
  8041601dc4:	48 89 de             	mov    %rbx,%rsi
  8041601dc7:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601dcb:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601dd2:	00 00 00 
  8041601dd5:	ff d0                	call   *%rax
  8041601dd7:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041601dda:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8041601de1:	ff ff ff 
  8041601de4:	48 01 d0             	add    %rdx,%rax
  8041601de7:	48 83 f8 0f          	cmp    $0xf,%rax
  8041601deb:	0f 87 09 03 00 00    	ja     80416020fa <file_name_by_info+0x373>
        if (initial_len == DW_EXT_DWARF64) {
  8041601df1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8041601df6:	48 39 c2             	cmp    %rax,%rdx
  8041601df9:	74 25                	je     8041601e20 <file_name_by_info+0x99>
            cprintf("Unknown DWARF extension\n");
  8041601dfb:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041601e02:	00 00 00 
  8041601e05:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601e0a:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041601e11:	00 00 00 
  8041601e14:	ff d2                	call   *%rdx
    uint32_t count;
    uint64_t len = 0;
    entry += count = dwarf_entry_len(entry, &len);
    if (!count) return -E_BAD_DWARF;
  8041601e16:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8041601e1b:	e9 41 02 00 00       	jmp    8041602061 <file_name_by_info+0x2da>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041601e20:	48 8d 73 20          	lea    0x20(%rbx),%rsi
  8041601e24:	ba 08 00 00 00       	mov    $0x8,%edx
  8041601e29:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041601e2d:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041601e34:	00 00 00 
  8041601e37:	ff d0                	call   *%rax
            count += sizeof(uint64_t);
  8041601e39:	b8 0c 00 00 00       	mov    $0xc,%eax
  8041601e3e:	e9 bc 02 00 00       	jmp    80416020ff <file_name_by_info+0x378>

    /* Parse compilation unit header */
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
    entry += sizeof(Dwarf_Half);
    assert(version == 4 || version == 2);
  8041601e43:	48 b9 f9 13 61 41 80 	movabs $0x80416113f9,%rcx
  8041601e4a:	00 00 00 
  8041601e4d:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041601e54:	00 00 00 
  8041601e57:	be 61 01 00 00       	mov    $0x161,%esi
  8041601e5c:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041601e63:	00 00 00 
  8041601e66:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601e6b:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041601e72:	00 00 00 
  8041601e75:	41 ff d0             	call   *%r8
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
    entry += sizeof(uint32_t);
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
    entry += sizeof(Dwarf_Small);
    assert(address_size == sizeof(uintptr_t));
  8041601e78:	48 b9 68 15 61 41 80 	movabs $0x8041611568,%rcx
  8041601e7f:	00 00 00 
  8041601e82:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041601e89:	00 00 00 
  8041601e8c:	be 66 01 00 00       	mov    $0x166,%esi
  8041601e91:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041601e98:	00 00 00 
  8041601e9b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601ea0:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041601ea7:	00 00 00 
  8041601eaa:	41 ff d0             	call   *%r8

    /* Read abbreviation code */
    uint64_t abbrev_code = 0;
    entry += dwarf_read_uleb128(entry, &abbrev_code);
    assert(abbrev_code);
  8041601ead:	48 b9 38 14 61 41 80 	movabs $0x8041611438,%rcx
  8041601eb4:	00 00 00 
  8041601eb7:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041601ebe:	00 00 00 
  8041601ec1:	be 6b 01 00 00       	mov    $0x16b,%esi
  8041601ec6:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041601ecd:	00 00 00 
  8041601ed0:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601ed5:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041601edc:	00 00 00 
  8041601edf:	41 ff d0             	call   *%r8

    /* Read abbreviations table */
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
    uint64_t table_abbrev_code = 0;
    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
    assert(table_abbrev_code == abbrev_code);
  8041601ee2:	48 b9 90 15 61 41 80 	movabs $0x8041611590,%rcx
  8041601ee9:	00 00 00 
  8041601eec:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041601ef3:	00 00 00 
  8041601ef6:	be 71 01 00 00       	mov    $0x171,%esi
  8041601efb:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041601f02:	00 00 00 
  8041601f05:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601f0a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041601f11:	00 00 00 
  8041601f14:	41 ff d0             	call   *%r8
    uint64_t tag = 0;
    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &tag);
    assert(tag == DW_TAG_compile_unit);
  8041601f17:	48 b9 44 14 61 41 80 	movabs $0x8041611444,%rcx
  8041601f1e:	00 00 00 
  8041601f21:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041601f28:	00 00 00 
  8041601f2b:	be 74 01 00 00       	mov    $0x174,%esi
  8041601f30:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041601f37:	00 00 00 
  8041601f3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601f3f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041601f46:	00 00 00 
  8041601f49:	41 ff d0             	call   *%r8
    uint64_t name = 0, form = 0;
    do {
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
        if (name == DW_AT_name) {
            if (form == DW_FORM_strp) {
  8041601f4c:	49 83 fd 0e          	cmp    $0xe,%r13
  8041601f50:	0f 84 1a 01 00 00    	je     8041602070 <file_name_by_info+0x2e9>
                uint64_t offset = 0;
                entry += dwarf_read_abbrev_entry(entry, form, &offset, sizeof(uint64_t), address_size);
                if (buf) put_unaligned((const uint8_t *)addrs->str_begin + offset, buf);
            } else {
                entry += dwarf_read_abbrev_entry(entry, form, buf, sizeof(char *), address_size);
  8041601f56:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041601f5c:	b9 08 00 00 00       	mov    $0x8,%ecx
  8041601f61:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8041601f65:	44 89 ee             	mov    %r13d,%esi
  8041601f68:	4c 89 f7             	mov    %r14,%rdi
  8041601f6b:	41 ff d7             	call   *%r15
  8041601f6e:	48 98                	cltq   
  8041601f70:	49 01 c6             	add    %rax,%r14
    uint64_t result = 0;
  8041601f73:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041601f76:	b8 00 00 00 00       	mov    $0x0,%eax
  8041601f7b:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041601f80:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  8041601f86:	48 83 c2 01          	add    $0x1,%rdx
  8041601f8a:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041601f8e:	48 89 fe             	mov    %rdi,%rsi
  8041601f91:	83 e6 7f             	and    $0x7f,%esi
  8041601f94:	48 d3 e6             	shl    %cl,%rsi
  8041601f97:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  8041601f9a:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601f9e:	48 89 c6             	mov    %rax,%rsi
  8041601fa1:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041601fa5:	40 84 ff             	test   %dil,%dil
  8041601fa8:	79 06                	jns    8041601fb0 <file_name_by_info+0x229>
  8041601faa:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041601fae:	76 d6                	jbe    8041601f86 <file_name_by_info+0x1ff>
    while (byte & 0x80) {
  8041601fb0:	40 84 ff             	test   %dil,%dil
  8041601fb3:	79 12                	jns    8041601fc7 <file_name_by_info+0x240>
        byte = *addr++;
  8041601fb5:	48 f7 d6             	not    %rsi
  8041601fb8:	48 01 f2             	add    %rsi,%rdx
  8041601fbb:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041601fbf:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041601fc3:	84 c9                	test   %cl,%cl
  8041601fc5:	78 f4                	js     8041601fbb <file_name_by_info+0x234>
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8041601fc7:	48 01 d8             	add    %rbx,%rax
  8041601fca:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8041601fcd:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041601fd2:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041601fd7:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8041601fdd:	48 83 c2 01          	add    $0x1,%rdx
  8041601fe1:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041601fe5:	48 89 fe             	mov    %rdi,%rsi
  8041601fe8:	83 e6 7f             	and    $0x7f,%esi
  8041601feb:	48 d3 e6             	shl    %cl,%rsi
  8041601fee:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8041601ff1:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041601ff5:	48 89 de             	mov    %rbx,%rsi
  8041601ff8:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041601ffc:	40 84 ff             	test   %dil,%dil
  8041601fff:	79 06                	jns    8041602007 <file_name_by_info+0x280>
  8041602001:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602005:	76 d6                	jbe    8041601fdd <file_name_by_info+0x256>
    while (byte & 0x80) {
  8041602007:	40 84 ff             	test   %dil,%dil
  804160200a:	79 12                	jns    804160201e <file_name_by_info+0x297>
        byte = *addr++;
  804160200c:	48 f7 d6             	not    %rsi
  804160200f:	48 01 f2             	add    %rsi,%rdx
  8041602012:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8041602016:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  804160201a:	84 c9                	test   %cl,%cl
  804160201c:	78 f4                	js     8041602012 <file_name_by_info+0x28b>
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  804160201e:	48 01 c3             	add    %rax,%rbx
        if (name == DW_AT_name) {
  8041602021:	49 83 fc 03          	cmp    $0x3,%r12
  8041602025:	0f 84 21 ff ff ff    	je     8041601f4c <file_name_by_info+0x1c5>
            }
        } else if (name == DW_AT_stmt_list) {
  804160202b:	49 83 fc 10          	cmp    $0x10,%r12
  804160202f:	0f 84 99 00 00 00    	je     80416020ce <file_name_by_info+0x347>
            entry += dwarf_read_abbrev_entry(entry, form, line_off, sizeof(Dwarf_Off), address_size);
        } else {
            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041602035:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804160203b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041602040:	ba 00 00 00 00       	mov    $0x0,%edx
  8041602045:	44 89 ee             	mov    %r13d,%esi
  8041602048:	4c 89 f7             	mov    %r14,%rdi
  804160204b:	41 ff d7             	call   *%r15
  804160204e:	48 98                	cltq   
  8041602050:	49 01 c6             	add    %rax,%r14
        }
    } while (name || form);
  8041602053:	4d 09 e5             	or     %r12,%r13
  8041602056:	0f 85 17 ff ff ff    	jne    8041601f73 <file_name_by_info+0x1ec>

    return 0;
  804160205c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8041602061:	48 83 c4 38          	add    $0x38,%rsp
  8041602065:	5b                   	pop    %rbx
  8041602066:	41 5c                	pop    %r12
  8041602068:	41 5d                	pop    %r13
  804160206a:	41 5e                	pop    %r14
  804160206c:	41 5f                	pop    %r15
  804160206e:	5d                   	pop    %rbp
  804160206f:	c3                   	ret    
                uint64_t offset = 0;
  8041602070:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8041602077:	00 
                entry += dwarf_read_abbrev_entry(entry, form, &offset, sizeof(uint64_t), address_size);
  8041602078:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804160207e:	b9 08 00 00 00       	mov    $0x8,%ecx
  8041602083:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  8041602087:	be 0e 00 00 00       	mov    $0xe,%esi
  804160208c:	4c 89 f7             	mov    %r14,%rdi
  804160208f:	41 ff d7             	call   *%r15
  8041602092:	48 98                	cltq   
  8041602094:	49 01 c6             	add    %rax,%r14
                if (buf) put_unaligned((const uint8_t *)addrs->str_begin + offset, buf);
  8041602097:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804160209b:	48 85 ff             	test   %rdi,%rdi
  804160209e:	0f 84 cf fe ff ff    	je     8041601f73 <file_name_by_info+0x1ec>
  80416020a4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80416020a8:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80416020ac:	48 03 42 40          	add    0x40(%rdx),%rax
  80416020b0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80416020b4:	ba 08 00 00 00       	mov    $0x8,%edx
  80416020b9:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  80416020bd:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416020c4:	00 00 00 
  80416020c7:	ff d0                	call   *%rax
  80416020c9:	e9 a5 fe ff ff       	jmp    8041601f73 <file_name_by_info+0x1ec>
            entry += dwarf_read_abbrev_entry(entry, form, line_off, sizeof(Dwarf_Off), address_size);
  80416020ce:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80416020d4:	b9 08 00 00 00       	mov    $0x8,%ecx
  80416020d9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80416020dd:	44 89 ee             	mov    %r13d,%esi
  80416020e0:	4c 89 f7             	mov    %r14,%rdi
  80416020e3:	41 ff d7             	call   *%r15
  80416020e6:	48 98                	cltq   
  80416020e8:	49 01 c6             	add    %rax,%r14
  80416020eb:	e9 83 fe ff ff       	jmp    8041601f73 <file_name_by_info+0x1ec>
    if (offset > addrs->info_end - addrs->info_begin) return -E_INVAL;
  80416020f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80416020f5:	e9 67 ff ff ff       	jmp    8041602061 <file_name_by_info+0x2da>
    uint64_t count = sizeof(uint32_t);
  80416020fa:	b8 04 00 00 00       	mov    $0x4,%eax
    entry += count = dwarf_entry_len(entry, &len);
  80416020ff:	48 01 c3             	add    %rax,%rbx
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  8041602102:	ba 02 00 00 00       	mov    $0x2,%edx
  8041602107:	48 89 de             	mov    %rbx,%rsi
  804160210a:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160210e:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041602115:	00 00 00 
  8041602118:	ff d0                	call   *%rax
    entry += sizeof(Dwarf_Half);
  804160211a:	48 8d 73 02          	lea    0x2(%rbx),%rsi
    assert(version == 4 || version == 2);
  804160211e:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8041602122:	83 e8 02             	sub    $0x2,%eax
  8041602125:	66 a9 fd ff          	test   $0xfffd,%ax
  8041602129:	0f 85 14 fd ff ff    	jne    8041601e43 <file_name_by_info+0xbc>
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  804160212f:	ba 04 00 00 00       	mov    $0x4,%edx
  8041602134:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602138:	49 bc b4 fe 60 41 80 	movabs $0x804160feb4,%r12
  804160213f:	00 00 00 
  8041602142:	41 ff d4             	call   *%r12
  8041602145:	44 8b 6d c8          	mov    -0x38(%rbp),%r13d
    entry += sizeof(uint32_t);
  8041602149:	48 8d 73 06          	lea    0x6(%rbx),%rsi
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  804160214d:	ba 01 00 00 00       	mov    $0x1,%edx
  8041602152:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602156:	41 ff d4             	call   *%r12
    entry += sizeof(Dwarf_Small);
  8041602159:	4c 8d 73 07          	lea    0x7(%rbx),%r14
    assert(address_size == sizeof(uintptr_t));
  804160215d:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8041602161:	0f 85 11 fd ff ff    	jne    8041601e78 <file_name_by_info+0xf1>
  8041602167:	4c 89 f0             	mov    %r14,%rax
    size_t shift = 0, count = 0;
  804160216a:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804160216f:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  8041602174:	48 83 c0 01          	add    $0x1,%rax
  8041602178:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  804160217c:	48 89 fa             	mov    %rdi,%rdx
  804160217f:	83 e2 7f             	and    $0x7f,%edx
  8041602182:	48 d3 e2             	shl    %cl,%rdx
  8041602185:	48 09 d6             	or     %rdx,%rsi
        shift += 7;
  8041602188:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804160218c:	4c 8d 40 f9          	lea    -0x7(%rax),%r8
  8041602190:	4c 89 c2             	mov    %r8,%rdx
  8041602193:	48 29 da             	sub    %rbx,%rdx
    } while (byte & 0x80 && shift < 64);
  8041602196:	40 84 ff             	test   %dil,%dil
  8041602199:	79 06                	jns    80416021a1 <file_name_by_info+0x41a>
  804160219b:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160219f:	76 d3                	jbe    8041602174 <file_name_by_info+0x3ed>
    while (byte & 0x80) {
  80416021a1:	40 84 ff             	test   %dil,%dil
  80416021a4:	79 12                	jns    80416021b8 <file_name_by_info+0x431>
        byte = *addr++;
  80416021a6:	4c 29 c3             	sub    %r8,%rbx
  80416021a9:	48 01 d8             	add    %rbx,%rax
  80416021ac:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  80416021b0:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  80416021b4:	84 c9                	test   %cl,%cl
  80416021b6:	78 f4                	js     80416021ac <file_name_by_info+0x425>
    entry += dwarf_read_uleb128(entry, &abbrev_code);
  80416021b8:	49 01 d6             	add    %rdx,%r14
    assert(abbrev_code);
  80416021bb:	48 85 f6             	test   %rsi,%rsi
  80416021be:	0f 84 e9 fc ff ff    	je     8041601ead <file_name_by_info+0x126>
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  80416021c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80416021c8:	4c 03 28             	add    (%rax),%r13
  80416021cb:	4c 89 ea             	mov    %r13,%rdx
    size_t shift = 0, count = 0;
  80416021ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80416021d3:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416021d8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
        byte = *addr++;
  80416021de:	48 83 c2 01          	add    $0x1,%rdx
  80416021e2:	44 0f b6 42 ff       	movzbl -0x1(%rdx),%r8d
        result |= (byte & 0x7FULL) << shift;
  80416021e7:	4c 89 c7             	mov    %r8,%rdi
  80416021ea:	83 e7 7f             	and    $0x7f,%edi
  80416021ed:	48 d3 e7             	shl    %cl,%rdi
  80416021f0:	49 09 f9             	or     %rdi,%r9
        shift += 7;
  80416021f3:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416021f7:	48 89 c7             	mov    %rax,%rdi
  80416021fa:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80416021fe:	45 84 c0             	test   %r8b,%r8b
  8041602201:	79 06                	jns    8041602209 <file_name_by_info+0x482>
  8041602203:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602207:	76 d5                	jbe    80416021de <file_name_by_info+0x457>
    while (byte & 0x80) {
  8041602209:	45 84 c0             	test   %r8b,%r8b
  804160220c:	79 12                	jns    8041602220 <file_name_by_info+0x499>
        byte = *addr++;
  804160220e:	48 f7 d7             	not    %rdi
  8041602211:	48 01 fa             	add    %rdi,%rdx
  8041602214:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602218:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804160221c:	84 c9                	test   %cl,%cl
  804160221e:	78 f4                	js     8041602214 <file_name_by_info+0x48d>
    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
  8041602220:	4d 8d 44 05 00       	lea    0x0(%r13,%rax,1),%r8
    assert(table_abbrev_code == abbrev_code);
  8041602225:	4c 39 ce             	cmp    %r9,%rsi
  8041602228:	0f 85 b4 fc ff ff    	jne    8041601ee2 <file_name_by_info+0x15b>
  804160222e:	4c 89 c2             	mov    %r8,%rdx
    size_t shift = 0, count = 0;
  8041602231:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602236:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804160223b:	41 b9 00 00 00 00    	mov    $0x0,%r9d
        byte = *addr++;
  8041602241:	48 83 c2 01          	add    $0x1,%rdx
  8041602245:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041602249:	48 89 fe             	mov    %rdi,%rsi
  804160224c:	83 e6 7f             	and    $0x7f,%esi
  804160224f:	48 d3 e6             	shl    %cl,%rsi
  8041602252:	49 09 f1             	or     %rsi,%r9
        shift += 7;
  8041602255:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602259:	48 89 c6             	mov    %rax,%rsi
  804160225c:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602260:	40 84 ff             	test   %dil,%dil
  8041602263:	79 06                	jns    804160226b <file_name_by_info+0x4e4>
  8041602265:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602269:	76 d6                	jbe    8041602241 <file_name_by_info+0x4ba>
    while (byte & 0x80) {
  804160226b:	40 84 ff             	test   %dil,%dil
  804160226e:	79 12                	jns    8041602282 <file_name_by_info+0x4fb>
        byte = *addr++;
  8041602270:	48 f7 d6             	not    %rsi
  8041602273:	48 01 f2             	add    %rsi,%rdx
  8041602276:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  804160227a:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804160227e:	84 c9                	test   %cl,%cl
  8041602280:	78 f4                	js     8041602276 <file_name_by_info+0x4ef>
    assert(tag == DW_TAG_compile_unit);
  8041602282:	49 83 f9 11          	cmp    $0x11,%r9
  8041602286:	0f 85 8b fc ff ff    	jne    8041601f17 <file_name_by_info+0x190>
    abbrev_entry += sizeof(Dwarf_Small);
  804160228c:	49 8d 5c 00 01       	lea    0x1(%r8,%rax,1),%rbx
            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041602291:	49 bf 42 0d 60 41 80 	movabs $0x8041600d42,%r15
  8041602298:	00 00 00 
  804160229b:	e9 d3 fc ff ff       	jmp    8041601f73 <file_name_by_info+0x1ec>

00000080416022a0 <function_by_info>:

int
function_by_info(const struct Dwarf_Addrs *addrs, uintptr_t p, Dwarf_Off cu_offset, char **buf, uintptr_t *offset) {
  80416022a0:	55                   	push   %rbp
  80416022a1:	48 89 e5             	mov    %rsp,%rbp
  80416022a4:	41 57                	push   %r15
  80416022a6:	41 56                	push   %r14
  80416022a8:	41 55                	push   %r13
  80416022aa:	41 54                	push   %r12
  80416022ac:	53                   	push   %rbx
  80416022ad:	48 83 ec 68          	sub    $0x68,%rsp
  80416022b1:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80416022b5:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
  80416022bc:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
  80416022c0:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    uint64_t len = 0;
    uint32_t count;

    const void *entry = addrs->info_begin + cu_offset;
  80416022c7:	48 03 57 20          	add    0x20(%rdi),%rdx
  80416022cb:	49 89 d6             	mov    %rdx,%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80416022ce:	ba 04 00 00 00       	mov    $0x4,%edx
  80416022d3:	4c 89 f6             	mov    %r14,%rsi
  80416022d6:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416022da:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416022e1:	00 00 00 
  80416022e4:	ff d0                	call   *%rax
  80416022e6:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80416022e9:	48 ba 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdx
  80416022f0:	ff ff ff 
  80416022f3:	48 01 c2             	add    %rax,%rdx
  80416022f6:	48 83 fa 0f          	cmp    $0xf,%rdx
  80416022fa:	0f 87 03 06 00 00    	ja     8041602903 <function_by_info+0x663>
        if (initial_len == DW_EXT_DWARF64) {
  8041602300:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8041602305:	48 39 d0             	cmp    %rdx,%rax
  8041602308:	74 25                	je     804160232f <function_by_info+0x8f>
            cprintf("Unknown DWARF extension\n");
  804160230a:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041602311:	00 00 00 
  8041602314:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602319:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041602320:	00 00 00 
  8041602323:	ff d2                	call   *%rdx
    entry += count = dwarf_entry_len(entry, &len);
    if (!count) return -E_BAD_DWARF;
  8041602325:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  804160232a:	e9 c5 05 00 00       	jmp    80416028f4 <function_by_info+0x654>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  804160232f:	49 8d 76 20          	lea    0x20(%r14),%rsi
  8041602333:	ba 08 00 00 00       	mov    $0x8,%edx
  8041602338:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160233c:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041602343:	00 00 00 
  8041602346:	ff d0                	call   *%rax
  8041602348:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  804160234c:	ba 0c 00 00 00       	mov    $0xc,%edx
  8041602351:	e9 b2 05 00 00       	jmp    8041602908 <function_by_info+0x668>
    const void *entry_end = entry + len;

    /* Parse compilation unit header */
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
    entry += sizeof(Dwarf_Half);
    assert(version == 4 || version == 2);
  8041602356:	48 b9 f9 13 61 41 80 	movabs $0x80416113f9,%rcx
  804160235d:	00 00 00 
  8041602360:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041602367:	00 00 00 
  804160236a:	be 9b 01 00 00       	mov    $0x19b,%esi
  804160236f:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041602376:	00 00 00 
  8041602379:	b8 00 00 00 00       	mov    $0x0,%eax
  804160237e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041602385:	00 00 00 
  8041602388:	41 ff d0             	call   *%r8
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
    entry += sizeof(uint32_t);
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
    entry += sizeof(Dwarf_Small);
    assert(address_size == sizeof(uintptr_t));
  804160238b:	48 b9 68 15 61 41 80 	movabs $0x8041611568,%rcx
  8041602392:	00 00 00 
  8041602395:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160239c:	00 00 00 
  804160239f:	be a0 01 00 00       	mov    $0x1a0,%esi
  80416023a4:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  80416023ab:	00 00 00 
  80416023ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80416023b3:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416023ba:	00 00 00 
  80416023bd:	41 ff d0             	call   *%r8
    while (byte & 0x80) {
  80416023c0:	40 84 ff             	test   %dil,%dil
  80416023c3:	79 12                	jns    80416023d7 <function_by_info+0x137>
        byte = *addr++;
  80416023c5:	48 f7 d6             	not    %rsi
  80416023c8:	48 01 f2             	add    %rsi,%rdx
  80416023cb:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  80416023cf:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80416023d3:	84 c9                	test   %cl,%cl
  80416023d5:	78 f4                	js     80416023cb <function_by_info+0x12b>
    uint64_t table_abbrev_code = 0;
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;

    while (entry < entry_end) {
        /* Read info abbreviation code */
        entry += dwarf_read_uleb128(entry, &abbrev_code);
  80416023d7:	49 01 c6             	add    %rax,%r14
        if (!abbrev_code) continue;
  80416023da:	4d 85 c0             	test   %r8,%r8
  80416023dd:	75 49                	jne    8041602428 <function_by_info+0x188>
    while (entry < entry_end) {
  80416023df:	4c 3b 75 80          	cmp    -0x80(%rbp),%r14
  80416023e3:	0f 83 06 05 00 00    	jae    80416028ef <function_by_info+0x64f>
  80416023e9:	4c 89 f2             	mov    %r14,%rdx
    size_t shift = 0, count = 0;
  80416023ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80416023f1:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416023f6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
        byte = *addr++;
  80416023fc:	48 83 c2 01          	add    $0x1,%rdx
  8041602400:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041602404:	48 89 fe             	mov    %rdi,%rsi
  8041602407:	83 e6 7f             	and    $0x7f,%esi
  804160240a:	48 d3 e6             	shl    %cl,%rsi
  804160240d:	49 09 f0             	or     %rsi,%r8
        shift += 7;
  8041602410:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602414:	48 89 c6             	mov    %rax,%rsi
  8041602417:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  804160241b:	40 84 ff             	test   %dil,%dil
  804160241e:	79 a0                	jns    80416023c0 <function_by_info+0x120>
  8041602420:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602424:	76 d6                	jbe    80416023fc <function_by_info+0x15c>
  8041602426:	eb 98                	jmp    80416023c0 <function_by_info+0x120>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
        uint64_t name = 0, form = 0, tag = 0;

        /* Find abbreviation in abbrev section */
        /* UNSAFE Needs to be replaced */
        while (curr_abbrev_entry < addrs->abbrev_end) {
  8041602428:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804160242c:	4c 8b 48 08          	mov    0x8(%rax),%r9
  8041602430:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8041602434:	4c 39 c8             	cmp    %r9,%rax
  8041602437:	0f 82 d2 00 00 00    	jb     804160250f <function_by_info+0x26f>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
  804160243d:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8041602441:	e9 0c 04 00 00       	jmp    8041602852 <function_by_info+0x5b2>
    while (byte & 0x80) {
  8041602446:	45 84 e4             	test   %r12b,%r12b
  8041602449:	79 12                	jns    804160245d <function_by_info+0x1bd>
        byte = *addr++;
  804160244b:	49 f7 d3             	not    %r11
  804160244e:	4c 01 de             	add    %r11,%rsi
  8041602451:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
        count++;
  8041602455:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602459:	84 c9                	test   %cl,%cl
  804160245b:	78 f4                	js     8041602451 <function_by_info+0x1b1>
            if (table_abbrev_code == abbrev_code) break;

            /* Skip attributes */
            do {
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  804160245d:	48 01 d0             	add    %rdx,%rax
            } while (name != 0 || form != 0);
  8041602460:	4c 09 d3             	or     %r10,%rbx
  8041602463:	0f 84 9d 00 00 00    	je     8041602506 <function_by_info+0x266>
    uint64_t result = 0;
  8041602469:	48 89 c6             	mov    %rax,%rsi
    size_t shift = 0, count = 0;
  804160246c:	ba 00 00 00 00       	mov    $0x0,%edx
  8041602471:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602476:	41 ba 00 00 00 00    	mov    $0x0,%r10d
        byte = *addr++;
  804160247c:	48 83 c6 01          	add    $0x1,%rsi
  8041602480:	0f b6 5e ff          	movzbl -0x1(%rsi),%ebx
        result |= (byte & 0x7FULL) << shift;
  8041602484:	49 89 db             	mov    %rbx,%r11
  8041602487:	41 83 e3 7f          	and    $0x7f,%r11d
  804160248b:	49 d3 e3             	shl    %cl,%r11
  804160248e:	4d 09 da             	or     %r11,%r10
        shift += 7;
  8041602491:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602495:	49 89 d3             	mov    %rdx,%r11
  8041602498:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  804160249c:	84 db                	test   %bl,%bl
  804160249e:	79 06                	jns    80416024a6 <function_by_info+0x206>
  80416024a0:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416024a4:	76 d6                	jbe    804160247c <function_by_info+0x1dc>
    while (byte & 0x80) {
  80416024a6:	84 db                	test   %bl,%bl
  80416024a8:	79 12                	jns    80416024bc <function_by_info+0x21c>
        byte = *addr++;
  80416024aa:	49 f7 d3             	not    %r11
  80416024ad:	4c 01 de             	add    %r11,%rsi
  80416024b0:	0f b6 0c 16          	movzbl (%rsi,%rdx,1),%ecx
        count++;
  80416024b4:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  80416024b8:	84 c9                	test   %cl,%cl
  80416024ba:	78 f4                	js     80416024b0 <function_by_info+0x210>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  80416024bc:	48 01 c2             	add    %rax,%rdx
  80416024bf:	48 89 d6             	mov    %rdx,%rsi
    size_t shift = 0, count = 0;
  80416024c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80416024c7:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416024cc:	bb 00 00 00 00       	mov    $0x0,%ebx
        byte = *addr++;
  80416024d1:	48 83 c6 01          	add    $0x1,%rsi
  80416024d5:	44 0f b6 66 ff       	movzbl -0x1(%rsi),%r12d
        result |= (byte & 0x7FULL) << shift;
  80416024da:	4d 89 e3             	mov    %r12,%r11
  80416024dd:	41 83 e3 7f          	and    $0x7f,%r11d
  80416024e1:	49 d3 e3             	shl    %cl,%r11
  80416024e4:	4c 09 db             	or     %r11,%rbx
        shift += 7;
  80416024e7:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416024eb:	49 89 c3             	mov    %rax,%r11
  80416024ee:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80416024f2:	45 84 e4             	test   %r12b,%r12b
  80416024f5:	0f 89 4b ff ff ff    	jns    8041602446 <function_by_info+0x1a6>
  80416024fb:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416024ff:	76 d0                	jbe    80416024d1 <function_by_info+0x231>
  8041602501:	e9 40 ff ff ff       	jmp    8041602446 <function_by_info+0x1a6>
        while (curr_abbrev_entry < addrs->abbrev_end) {
  8041602506:	4c 39 c8             	cmp    %r9,%rax
  8041602509:	0f 83 b8 00 00 00    	jae    80416025c7 <function_by_info+0x327>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
  804160250f:	48 89 c6             	mov    %rax,%rsi
    size_t shift = 0, count = 0;
  8041602512:	ba 00 00 00 00       	mov    $0x0,%edx
  8041602517:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804160251c:	41 ba 00 00 00 00    	mov    $0x0,%r10d
        byte = *addr++;
  8041602522:	48 83 c6 01          	add    $0x1,%rsi
  8041602526:	44 0f b6 5e ff       	movzbl -0x1(%rsi),%r11d
        result |= (byte & 0x7FULL) << shift;
  804160252b:	4c 89 df             	mov    %r11,%rdi
  804160252e:	83 e7 7f             	and    $0x7f,%edi
  8041602531:	48 d3 e7             	shl    %cl,%rdi
  8041602534:	49 09 fa             	or     %rdi,%r10
        shift += 7;
  8041602537:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804160253b:	48 89 d7             	mov    %rdx,%rdi
  804160253e:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  8041602542:	45 84 db             	test   %r11b,%r11b
  8041602545:	79 06                	jns    804160254d <function_by_info+0x2ad>
  8041602547:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160254b:	76 d5                	jbe    8041602522 <function_by_info+0x282>
    while (byte & 0x80) {
  804160254d:	45 84 db             	test   %r11b,%r11b
  8041602550:	79 12                	jns    8041602564 <function_by_info+0x2c4>
        byte = *addr++;
  8041602552:	48 f7 d7             	not    %rdi
  8041602555:	48 01 fe             	add    %rdi,%rsi
  8041602558:	0f b6 0c 16          	movzbl (%rsi,%rdx,1),%ecx
        count++;
  804160255c:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041602560:	84 c9                	test   %cl,%cl
  8041602562:	78 f4                	js     8041602558 <function_by_info+0x2b8>
            curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &table_abbrev_code);
  8041602564:	48 01 c2             	add    %rax,%rdx
  8041602567:	48 89 d6             	mov    %rdx,%rsi
    size_t shift = 0, count = 0;
  804160256a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160256f:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602574:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  8041602579:	48 83 c6 01          	add    $0x1,%rsi
  804160257d:	0f b6 5e ff          	movzbl -0x1(%rsi),%ebx
        result |= (byte & 0x7FULL) << shift;
  8041602581:	49 89 db             	mov    %rbx,%r11
  8041602584:	41 83 e3 7f          	and    $0x7f,%r11d
  8041602588:	49 d3 e3             	shl    %cl,%r11
  804160258b:	4c 09 df             	or     %r11,%rdi
        shift += 7;
  804160258e:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602592:	49 89 c3             	mov    %rax,%r11
  8041602595:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602599:	84 db                	test   %bl,%bl
  804160259b:	79 06                	jns    80416025a3 <function_by_info+0x303>
  804160259d:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416025a1:	76 d6                	jbe    8041602579 <function_by_info+0x2d9>
    while (byte & 0x80) {
  80416025a3:	84 db                	test   %bl,%bl
  80416025a5:	79 12                	jns    80416025b9 <function_by_info+0x319>
        byte = *addr++;
  80416025a7:	49 f7 d3             	not    %r11
  80416025aa:	4c 01 de             	add    %r11,%rsi
  80416025ad:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
        count++;
  80416025b1:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80416025b5:	84 c9                	test   %cl,%cl
  80416025b7:	78 f4                	js     80416025ad <function_by_info+0x30d>
            curr_abbrev_entry += sizeof(Dwarf_Small);
  80416025b9:	48 8d 44 02 01       	lea    0x1(%rdx,%rax,1),%rax
            if (table_abbrev_code == abbrev_code) break;
  80416025be:	4d 39 d0             	cmp    %r10,%r8
  80416025c1:	0f 85 a2 fe ff ff    	jne    8041602469 <function_by_info+0x1c9>
        }
        /* Parse subprogram DIE */
        if (tag == DW_TAG_subprogram) {
  80416025c7:	48 89 c3             	mov    %rax,%rbx
  80416025ca:	48 83 ff 2e          	cmp    $0x2e,%rdi
  80416025ce:	0f 85 7e 02 00 00    	jne    8041602852 <function_by_info+0x5b2>
            uintptr_t low_pc = 0, high_pc = 0;
  80416025d4:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  80416025db:	00 
  80416025dc:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80416025e3:	00 
            const uint8_t *fn_name_entry = 0;
            uint64_t name_form = 0;
  80416025e4:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  80416025eb:	00 
            const uint8_t *fn_name_entry = 0;
  80416025ec:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80416025f3:	00 
  80416025f4:	eb 71                	jmp    8041602667 <function_by_info+0x3c7>
  80416025f6:	40 84 ff             	test   %dil,%dil
  80416025f9:	79 12                	jns    804160260d <function_by_info+0x36d>
        byte = *addr++;
  80416025fb:	48 f7 d6             	not    %rsi
  80416025fe:	48 01 f2             	add    %rsi,%rdx
  8041602601:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602605:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602609:	84 c9                	test   %cl,%cl
  804160260b:	78 f4                	js     8041602601 <function_by_info+0x361>
            do {
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  804160260d:	48 01 c3             	add    %rax,%rbx
                if (name == DW_AT_low_pc) {
  8041602610:	49 83 fc 11          	cmp    $0x11,%r12
  8041602614:	0f 84 ea 00 00 00    	je     8041602704 <function_by_info+0x464>
                    entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
                } else if (name == DW_AT_high_pc) {
  804160261a:	49 83 fc 12          	cmp    $0x12,%r12
  804160261e:	0f 84 02 01 00 00    	je     8041602726 <function_by_info+0x486>
        result |= (byte & 0x7FULL) << shift;
  8041602624:	49 83 fc 03          	cmp    $0x3,%r12
  8041602628:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804160262c:	49 0f 44 c5          	cmove  %r13,%rax
  8041602630:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8041602634:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8041602638:	49 0f 44 c6          	cmove  %r14,%rax
  804160263c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                } else {
                    if (name == DW_AT_name) {
                        fn_name_entry = entry;
                        name_form = form;
                    }
                    entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041602640:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041602646:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160264b:	ba 00 00 00 00       	mov    $0x0,%edx
  8041602650:	44 89 ee             	mov    %r13d,%esi
  8041602653:	4c 89 f7             	mov    %r14,%rdi
  8041602656:	41 ff d7             	call   *%r15
  8041602659:	48 98                	cltq   
  804160265b:	49 01 c6             	add    %rax,%r14
                }
            } while (name || form);
  804160265e:	4d 09 e5             	or     %r12,%r13
  8041602661:	0f 84 f3 00 00 00    	je     804160275a <function_by_info+0x4ba>
            const uint8_t *fn_name_entry = 0;
  8041602667:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  804160266a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160266f:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602674:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  804160267a:	48 83 c2 01          	add    $0x1,%rdx
  804160267e:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041602682:	48 89 fe             	mov    %rdi,%rsi
  8041602685:	83 e6 7f             	and    $0x7f,%esi
  8041602688:	48 d3 e6             	shl    %cl,%rsi
  804160268b:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  804160268e:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602692:	48 89 c6             	mov    %rax,%rsi
  8041602695:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602699:	40 84 ff             	test   %dil,%dil
  804160269c:	79 06                	jns    80416026a4 <function_by_info+0x404>
  804160269e:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416026a2:	76 d6                	jbe    804160267a <function_by_info+0x3da>
    while (byte & 0x80) {
  80416026a4:	40 84 ff             	test   %dil,%dil
  80416026a7:	79 12                	jns    80416026bb <function_by_info+0x41b>
        byte = *addr++;
  80416026a9:	48 f7 d6             	not    %rsi
  80416026ac:	48 01 f2             	add    %rsi,%rdx
  80416026af:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  80416026b3:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80416026b7:	84 c9                	test   %cl,%cl
  80416026b9:	78 f4                	js     80416026af <function_by_info+0x40f>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  80416026bb:	48 01 c3             	add    %rax,%rbx
  80416026be:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80416026c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80416026c6:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416026cb:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  80416026d1:	48 83 c2 01          	add    $0x1,%rdx
  80416026d5:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80416026d9:	48 89 fe             	mov    %rdi,%rsi
  80416026dc:	83 e6 7f             	and    $0x7f,%esi
  80416026df:	48 d3 e6             	shl    %cl,%rsi
  80416026e2:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  80416026e5:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416026e9:	48 89 c6             	mov    %rax,%rsi
  80416026ec:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80416026f0:	40 84 ff             	test   %dil,%dil
  80416026f3:	0f 89 fd fe ff ff    	jns    80416025f6 <function_by_info+0x356>
  80416026f9:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416026fd:	76 d2                	jbe    80416026d1 <function_by_info+0x431>
  80416026ff:	e9 f2 fe ff ff       	jmp    80416025f6 <function_by_info+0x356>
                    entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  8041602704:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804160270a:	b9 08 00 00 00       	mov    $0x8,%ecx
  804160270f:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
  8041602713:	44 89 ee             	mov    %r13d,%esi
  8041602716:	4c 89 f7             	mov    %r14,%rdi
  8041602719:	41 ff d7             	call   *%r15
  804160271c:	48 98                	cltq   
  804160271e:	49 01 c6             	add    %rax,%r14
  8041602721:	e9 41 ff ff ff       	jmp    8041602667 <function_by_info+0x3c7>
                    entry += dwarf_read_abbrev_entry(entry, form, &high_pc, sizeof(high_pc), address_size);
  8041602726:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804160272c:	b9 08 00 00 00       	mov    $0x8,%ecx
  8041602731:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8041602735:	44 89 ee             	mov    %r13d,%esi
  8041602738:	4c 89 f7             	mov    %r14,%rdi
  804160273b:	41 ff d7             	call   *%r15
  804160273e:	48 98                	cltq   
  8041602740:	49 01 c6             	add    %rax,%r14
                    if (form != DW_FORM_addr) high_pc += low_pc;
  8041602743:	49 83 fd 01          	cmp    $0x1,%r13
  8041602747:	0f 84 1a ff ff ff    	je     8041602667 <function_by_info+0x3c7>
  804160274d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8041602751:	48 01 45 b8          	add    %rax,-0x48(%rbp)
  8041602755:	e9 0d ff ff ff       	jmp    8041602667 <function_by_info+0x3c7>

            /* Load info and finish if address is inside of the function */
            if (p >= low_pc && p <= high_pc) {
  804160275a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804160275e:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
  8041602765:	48 39 f8             	cmp    %rdi,%rax
  8041602768:	0f 87 71 fc ff ff    	ja     80416023df <function_by_info+0x13f>
  804160276e:	48 39 7d b8          	cmp    %rdi,-0x48(%rbp)
  8041602772:	0f 82 67 fc ff ff    	jb     80416023df <function_by_info+0x13f>
                *offset = low_pc;
  8041602778:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  804160277f:	48 89 07             	mov    %rax,(%rdi)
                if (name_form == DW_FORM_strp) {
  8041602782:	48 83 7d a0 0e       	cmpq   $0xe,-0x60(%rbp)
  8041602787:	74 2c                	je     80416027b5 <function_by_info+0x515>
                    uintptr_t str_offset = 0;
                    entry += dwarf_read_abbrev_entry(fn_name_entry, name_form, &str_offset, sizeof(uintptr_t), address_size);
                    (void)entry;
                    if (buf) put_unaligned((const uint8_t *)addrs->str_begin + str_offset, buf);
                } else {
                    entry += dwarf_read_abbrev_entry(fn_name_entry, name_form, buf, sizeof(uint8_t *), address_size);
  8041602789:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804160278f:	b9 08 00 00 00       	mov    $0x8,%ecx
  8041602794:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8041602798:	8b 75 a0             	mov    -0x60(%rbp),%esi
  804160279b:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  804160279f:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  80416027a6:	00 00 00 
  80416027a9:	ff d0                	call   *%rax
                    (void)entry;
                }
                return 0;
  80416027ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80416027b0:	e9 3f 01 00 00       	jmp    80416028f4 <function_by_info+0x654>
                    uintptr_t str_offset = 0;
  80416027b5:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80416027bc:	00 
                    entry += dwarf_read_abbrev_entry(fn_name_entry, name_form, &str_offset, sizeof(uintptr_t), address_size);
  80416027bd:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80416027c3:	b9 08 00 00 00       	mov    $0x8,%ecx
  80416027c8:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80416027cc:	be 0e 00 00 00       	mov    $0xe,%esi
  80416027d1:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  80416027d5:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  80416027dc:	00 00 00 
  80416027df:	ff d0                	call   *%rax
                    if (buf) put_unaligned((const uint8_t *)addrs->str_begin + str_offset, buf);
  80416027e1:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  80416027e5:	48 85 ff             	test   %rdi,%rdi
  80416027e8:	74 c1                	je     80416027ab <function_by_info+0x50b>
  80416027ea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80416027ee:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  80416027f2:	48 03 43 40          	add    0x40(%rbx),%rax
  80416027f6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80416027fa:	ba 08 00 00 00       	mov    $0x8,%edx
  80416027ff:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  8041602803:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160280a:	00 00 00 
  804160280d:	ff d0                	call   *%rax
  804160280f:	eb 9a                	jmp    80416027ab <function_by_info+0x50b>
    while (byte & 0x80) {
  8041602811:	40 84 ff             	test   %dil,%dil
  8041602814:	79 12                	jns    8041602828 <function_by_info+0x588>
        byte = *addr++;
  8041602816:	48 f7 d6             	not    %rsi
  8041602819:	48 01 f2             	add    %rsi,%rdx
  804160281c:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602820:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602824:	84 c9                	test   %cl,%cl
  8041602826:	78 f4                	js     804160281c <function_by_info+0x57c>
            }
        } else {
            /* Skip if not a subprogram */
            do {
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  8041602828:	48 01 c3             	add    %rax,%rbx
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  804160282b:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041602831:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041602836:	ba 00 00 00 00       	mov    $0x0,%edx
  804160283b:	44 89 e6             	mov    %r12d,%esi
  804160283e:	4c 89 f7             	mov    %r14,%rdi
  8041602841:	41 ff d7             	call   *%r15
  8041602844:	48 98                	cltq   
  8041602846:	49 01 c6             	add    %rax,%r14
            } while (name || form);
  8041602849:	4d 09 ec             	or     %r13,%r12
  804160284c:	0f 84 8d fb ff ff    	je     80416023df <function_by_info+0x13f>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
  8041602852:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041602855:	b8 00 00 00 00       	mov    $0x0,%eax
  804160285a:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804160285f:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8041602865:	48 83 c2 01          	add    $0x1,%rdx
  8041602869:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  804160286d:	48 89 fe             	mov    %rdi,%rsi
  8041602870:	83 e6 7f             	and    $0x7f,%esi
  8041602873:	48 d3 e6             	shl    %cl,%rsi
  8041602876:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8041602879:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804160287d:	48 89 c6             	mov    %rax,%rsi
  8041602880:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602884:	40 84 ff             	test   %dil,%dil
  8041602887:	79 06                	jns    804160288f <function_by_info+0x5ef>
  8041602889:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160288d:	76 d6                	jbe    8041602865 <function_by_info+0x5c5>
    while (byte & 0x80) {
  804160288f:	40 84 ff             	test   %dil,%dil
  8041602892:	79 12                	jns    80416028a6 <function_by_info+0x606>
        byte = *addr++;
  8041602894:	48 f7 d6             	not    %rsi
  8041602897:	48 01 f2             	add    %rsi,%rdx
  804160289a:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  804160289e:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80416028a2:	84 c9                	test   %cl,%cl
  80416028a4:	78 f4                	js     804160289a <function_by_info+0x5fa>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  80416028a6:	48 01 c3             	add    %rax,%rbx
  80416028a9:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80416028ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80416028b1:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416028b6:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  80416028bc:	48 83 c2 01          	add    $0x1,%rdx
  80416028c0:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80416028c4:	48 89 fe             	mov    %rdi,%rsi
  80416028c7:	83 e6 7f             	and    $0x7f,%esi
  80416028ca:	48 d3 e6             	shl    %cl,%rsi
  80416028cd:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  80416028d0:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416028d4:	48 89 c6             	mov    %rax,%rsi
  80416028d7:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80416028db:	40 84 ff             	test   %dil,%dil
  80416028de:	0f 89 2d ff ff ff    	jns    8041602811 <function_by_info+0x571>
  80416028e4:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416028e8:	76 d2                	jbe    80416028bc <function_by_info+0x61c>
  80416028ea:	e9 22 ff ff ff       	jmp    8041602811 <function_by_info+0x571>
        }
    }
    return -E_NO_ENT;
  80416028ef:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  80416028f4:	48 83 c4 68          	add    $0x68,%rsp
  80416028f8:	5b                   	pop    %rbx
  80416028f9:	41 5c                	pop    %r12
  80416028fb:	41 5d                	pop    %r13
  80416028fd:	41 5e                	pop    %r14
  80416028ff:	41 5f                	pop    %r15
  8041602901:	5d                   	pop    %rbp
  8041602902:	c3                   	ret    
    uint64_t count = sizeof(uint32_t);
  8041602903:	ba 04 00 00 00       	mov    $0x4,%edx
    entry += count = dwarf_entry_len(entry, &len);
  8041602908:	49 01 d6             	add    %rdx,%r14
    const void *entry_end = entry + len;
  804160290b:	4c 01 f0             	add    %r14,%rax
  804160290e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  8041602912:	ba 02 00 00 00       	mov    $0x2,%edx
  8041602917:	4c 89 f6             	mov    %r14,%rsi
  804160291a:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160291e:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041602925:	00 00 00 
  8041602928:	ff d0                	call   *%rax
    entry += sizeof(Dwarf_Half);
  804160292a:	49 8d 76 02          	lea    0x2(%r14),%rsi
    assert(version == 4 || version == 2);
  804160292e:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8041602932:	83 e8 02             	sub    $0x2,%eax
  8041602935:	66 a9 fd ff          	test   $0xfffd,%ax
  8041602939:	0f 85 17 fa ff ff    	jne    8041602356 <function_by_info+0xb6>
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  804160293f:	ba 04 00 00 00       	mov    $0x4,%edx
  8041602944:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602948:	49 bc b4 fe 60 41 80 	movabs $0x804160feb4,%r12
  804160294f:	00 00 00 
  8041602952:	41 ff d4             	call   *%r12
  8041602955:	8b 5d c8             	mov    -0x38(%rbp),%ebx
    entry += sizeof(uint32_t);
  8041602958:	49 8d 76 06          	lea    0x6(%r14),%rsi
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  804160295c:	ba 01 00 00 00       	mov    $0x1,%edx
  8041602961:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602965:	41 ff d4             	call   *%r12
    entry += sizeof(Dwarf_Small);
  8041602968:	49 83 c6 07          	add    $0x7,%r14
    assert(address_size == sizeof(uintptr_t));
  804160296c:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8041602970:	0f 85 15 fa ff ff    	jne    804160238b <function_by_info+0xeb>
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  8041602976:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804160297a:	48 03 18             	add    (%rax),%rbx
  804160297d:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041602981:	49 bf 42 0d 60 41 80 	movabs $0x8041600d42,%r15
  8041602988:	00 00 00 
    while (entry < entry_end) {
  804160298b:	e9 4f fa ff ff       	jmp    80416023df <function_by_info+0x13f>

0000008041602990 <address_by_fname>:

int
address_by_fname(const struct Dwarf_Addrs *addrs, const char *fname, uintptr_t *offset) {
  8041602990:	55                   	push   %rbp
  8041602991:	48 89 e5             	mov    %rsp,%rbp
  8041602994:	41 57                	push   %r15
  8041602996:	41 56                	push   %r14
  8041602998:	41 55                	push   %r13
  804160299a:	41 54                	push   %r12
  804160299c:	53                   	push   %rbx
  804160299d:	48 83 ec 48          	sub    $0x48,%rsp
  80416029a1:	48 89 fb             	mov    %rdi,%rbx
  80416029a4:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80416029a8:	48 89 f7             	mov    %rsi,%rdi
  80416029ab:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80416029af:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    const int flen = strlen(fname);
  80416029b3:	48 b8 1b fc 60 41 80 	movabs $0x804160fc1b,%rax
  80416029ba:	00 00 00 
  80416029bd:	ff d0                	call   *%rax
    if (!flen) return -E_INVAL;
  80416029bf:	85 c0                	test   %eax,%eax
  80416029c1:	0f 84 ab 05 00 00    	je     8041602f72 <address_by_fname+0x5e2>

    const uint8_t *pubnames_entry = addrs->pubnames_begin;
  80416029c7:	48 8b 5b 50          	mov    0x50(%rbx),%rbx
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80416029cb:	49 be b4 fe 60 41 80 	movabs $0x804160feb4,%r14
  80416029d2:	00 00 00 
    uint32_t count = 0;
    uint64_t len = 0;
    Dwarf_Off cu_offset = 0, func_offset = 0;

    /* parse pubnames section */
    while (pubnames_entry < addrs->pubnames_end) {
  80416029d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80416029d9:	48 3b 58 58          	cmp    0x58(%rax),%rbx
  80416029dd:	0f 83 84 05 00 00    	jae    8041602f67 <address_by_fname+0x5d7>
  80416029e3:	ba 04 00 00 00       	mov    $0x4,%edx
  80416029e8:	48 89 de             	mov    %rbx,%rsi
  80416029eb:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416029ef:	41 ff d6             	call   *%r14
  80416029f2:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80416029f5:	48 bf 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdi
  80416029fc:	ff ff ff 
  80416029ff:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
  8041602a03:	48 83 fa 0f          	cmp    $0xf,%rdx
  8041602a07:	0f 87 54 06 00 00    	ja     8041603061 <address_by_fname+0x6d1>
        if (initial_len == DW_EXT_DWARF64) {
  8041602a0d:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8041602a12:	48 39 d0             	cmp    %rdx,%rax
  8041602a15:	74 33                	je     8041602a4a <address_by_fname+0xba>
            cprintf("Unknown DWARF extension\n");
  8041602a17:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041602a1e:	00 00 00 
  8041602a21:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602a26:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041602a2d:	00 00 00 
  8041602a30:	ff d2                	call   *%rdx
        count = dwarf_entry_len(pubnames_entry, &len);
        if (!count) return -E_BAD_DWARF;
  8041602a32:	41 bc fa ff ff ff    	mov    $0xfffffffa,%r12d
            }
            pubnames_entry += strlen((const char *)pubnames_entry) + 1;
        }
    }
    return -E_NO_ENT;
}
  8041602a38:	44 89 e0             	mov    %r12d,%eax
  8041602a3b:	48 83 c4 48          	add    $0x48,%rsp
  8041602a3f:	5b                   	pop    %rbx
  8041602a40:	41 5c                	pop    %r12
  8041602a42:	41 5d                	pop    %r13
  8041602a44:	41 5e                	pop    %r14
  8041602a46:	41 5f                	pop    %r15
  8041602a48:	5d                   	pop    %rbp
  8041602a49:	c3                   	ret    
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041602a4a:	48 8d 73 20          	lea    0x20(%rbx),%rsi
  8041602a4e:	ba 08 00 00 00       	mov    $0x8,%edx
  8041602a53:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602a57:	41 ff d6             	call   *%r14
  8041602a5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  8041602a5e:	ba 0c 00 00 00       	mov    $0xc,%edx
  8041602a63:	e9 fe 05 00 00       	jmp    8041603066 <address_by_fname+0x6d6>
        assert(version == 2);
  8041602a68:	48 b9 09 14 61 41 80 	movabs $0x8041611409,%rcx
  8041602a6f:	00 00 00 
  8041602a72:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041602a79:	00 00 00 
  8041602a7c:	be ff 01 00 00       	mov    $0x1ff,%esi
  8041602a81:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041602a88:	00 00 00 
  8041602a8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602a90:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041602a97:	00 00 00 
  8041602a9a:	41 ff d0             	call   *%r8
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041602a9d:	48 8d 73 26          	lea    0x26(%rbx),%rsi
  8041602aa1:	ba 08 00 00 00       	mov    $0x8,%edx
  8041602aa6:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602aaa:	41 ff d6             	call   *%r14
            count += sizeof(uint64_t);
  8041602aad:	b8 0c 00 00 00       	mov    $0xc,%eax
  8041602ab2:	e9 46 06 00 00       	jmp    80416030fd <address_by_fname+0x76d>
        cu_offset = get_unaligned(pubnames_entry, uint32_t);
  8041602ab7:	8b 45 a4             	mov    -0x5c(%rbp),%eax
                const uint8_t *entry = addrs->info_begin + cu_offset;
  8041602aba:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8041602abe:	48 03 47 20          	add    0x20(%rdi),%rax
  8041602ac2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8041602ac6:	ba 04 00 00 00       	mov    $0x4,%edx
  8041602acb:	48 89 c6             	mov    %rax,%rsi
  8041602ace:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602ad2:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041602ad9:	00 00 00 
  8041602adc:	ff d0                	call   *%rax
  8041602ade:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041602ae1:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8041602ae8:	ff ff ff 
  8041602aeb:	48 01 d0             	add    %rdx,%rax
  8041602aee:	48 83 f8 0f          	cmp    $0xf,%rax
  8041602af2:	0f 87 85 04 00 00    	ja     8041602f7d <address_by_fname+0x5ed>
        if (initial_len == DW_EXT_DWARF64) {
  8041602af8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8041602afd:	48 39 c2             	cmp    %rax,%rdx
  8041602b00:	74 26                	je     8041602b28 <address_by_fname+0x198>
            cprintf("Unknown DWARF extension\n");
  8041602b02:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041602b09:	00 00 00 
  8041602b0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602b11:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041602b18:	00 00 00 
  8041602b1b:	ff d2                	call   *%rdx
                if (!count) return -E_BAD_DWARF;
  8041602b1d:	41 bc fa ff ff ff    	mov    $0xfffffffa,%r12d
  8041602b23:	e9 10 ff ff ff       	jmp    8041602a38 <address_by_fname+0xa8>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041602b28:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041602b2c:	48 8d 70 20          	lea    0x20(%rax),%rsi
  8041602b30:	ba 08 00 00 00       	mov    $0x8,%edx
  8041602b35:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602b39:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041602b40:	00 00 00 
  8041602b43:	ff d0                	call   *%rax
            count += sizeof(uint64_t);
  8041602b45:	41 be 0c 00 00 00    	mov    $0xc,%r14d
  8041602b4b:	e9 33 04 00 00       	jmp    8041602f83 <address_by_fname+0x5f3>
                assert(version == 4 || version == 2);
  8041602b50:	48 b9 f9 13 61 41 80 	movabs $0x80416113f9,%rcx
  8041602b57:	00 00 00 
  8041602b5a:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041602b61:	00 00 00 
  8041602b64:	be 14 02 00 00       	mov    $0x214,%esi
  8041602b69:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041602b70:	00 00 00 
  8041602b73:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602b78:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041602b7f:	00 00 00 
  8041602b82:	41 ff d0             	call   *%r8
                assert(address_size == sizeof(uintptr_t));
  8041602b85:	48 b9 68 15 61 41 80 	movabs $0x8041611568,%rcx
  8041602b8c:	00 00 00 
  8041602b8f:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041602b96:	00 00 00 
  8041602b99:	be 1a 02 00 00       	mov    $0x21a,%esi
  8041602b9e:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041602ba5:	00 00 00 
  8041602ba8:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602bad:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041602bb4:	00 00 00 
  8041602bb7:	41 ff d0             	call   *%r8
    while (byte & 0x80) {
  8041602bba:	45 84 ed             	test   %r13b,%r13b
  8041602bbd:	79 12                	jns    8041602bd1 <address_by_fname+0x241>
        byte = *addr++;
  8041602bbf:	49 f7 d3             	not    %r11
  8041602bc2:	4c 01 da             	add    %r11,%rdx
  8041602bc5:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8041602bc9:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8041602bcd:	84 c9                	test   %cl,%cl
  8041602bcf:	78 f4                	js     8041602bc5 <address_by_fname+0x235>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8041602bd1:	48 01 c3             	add    %rax,%rbx
                    } while (name || form);
  8041602bd4:	49 09 f2             	or     %rsi,%r10
  8041602bd7:	0f 84 a0 00 00 00    	je     8041602c7d <address_by_fname+0x2ed>
    uint64_t result = 0;
  8041602bdd:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041602be0:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602be5:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602bea:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  8041602bef:	48 83 c2 01          	add    $0x1,%rdx
  8041602bf3:	44 0f b6 5a ff       	movzbl -0x1(%rdx),%r11d
        result |= (byte & 0x7FULL) << shift;
  8041602bf8:	4d 89 da             	mov    %r11,%r10
  8041602bfb:	41 83 e2 7f          	and    $0x7f,%r10d
  8041602bff:	49 d3 e2             	shl    %cl,%r10
  8041602c02:	4c 09 d6             	or     %r10,%rsi
        shift += 7;
  8041602c05:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602c09:	49 89 c2             	mov    %rax,%r10
  8041602c0c:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602c10:	45 84 db             	test   %r11b,%r11b
  8041602c13:	79 06                	jns    8041602c1b <address_by_fname+0x28b>
  8041602c15:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602c19:	76 d4                	jbe    8041602bef <address_by_fname+0x25f>
    while (byte & 0x80) {
  8041602c1b:	45 84 db             	test   %r11b,%r11b
  8041602c1e:	79 12                	jns    8041602c32 <address_by_fname+0x2a2>
        byte = *addr++;
  8041602c20:	49 f7 d2             	not    %r10
  8041602c23:	4c 01 d2             	add    %r10,%rdx
  8041602c26:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602c2a:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602c2e:	84 c9                	test   %cl,%cl
  8041602c30:	78 f4                	js     8041602c26 <address_by_fname+0x296>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8041602c32:	48 01 d8             	add    %rbx,%rax
  8041602c35:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8041602c38:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041602c3d:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602c42:	41 ba 00 00 00 00    	mov    $0x0,%r10d
        byte = *addr++;
  8041602c48:	48 83 c2 01          	add    $0x1,%rdx
  8041602c4c:	44 0f b6 6a ff       	movzbl -0x1(%rdx),%r13d
        result |= (byte & 0x7FULL) << shift;
  8041602c51:	4d 89 eb             	mov    %r13,%r11
  8041602c54:	41 83 e3 7f          	and    $0x7f,%r11d
  8041602c58:	49 d3 e3             	shl    %cl,%r11
  8041602c5b:	4d 09 da             	or     %r11,%r10
        shift += 7;
  8041602c5e:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602c62:	49 89 db             	mov    %rbx,%r11
  8041602c65:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041602c69:	45 84 ed             	test   %r13b,%r13b
  8041602c6c:	0f 89 48 ff ff ff    	jns    8041602bba <address_by_fname+0x22a>
  8041602c72:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602c76:	76 d0                	jbe    8041602c48 <address_by_fname+0x2b8>
  8041602c78:	e9 3d ff ff ff       	jmp    8041602bba <address_by_fname+0x22a>
                while (abbrev_entry < addrs->abbrev_end) {
  8041602c7d:	49 39 d9             	cmp    %rbx,%r9
  8041602c80:	0f 86 ba 00 00 00    	jbe    8041602d40 <address_by_fname+0x3b0>
    uint64_t result = 0;
  8041602c86:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041602c89:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602c8e:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602c93:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  8041602c98:	48 83 c2 01          	add    $0x1,%rdx
  8041602c9c:	44 0f b6 52 ff       	movzbl -0x1(%rdx),%r10d
        result |= (byte & 0x7FULL) << shift;
  8041602ca1:	4c 89 d7             	mov    %r10,%rdi
  8041602ca4:	83 e7 7f             	and    $0x7f,%edi
  8041602ca7:	48 d3 e7             	shl    %cl,%rdi
  8041602caa:	48 09 fe             	or     %rdi,%rsi
        shift += 7;
  8041602cad:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602cb1:	48 89 c7             	mov    %rax,%rdi
  8041602cb4:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602cb8:	45 84 d2             	test   %r10b,%r10b
  8041602cbb:	79 06                	jns    8041602cc3 <address_by_fname+0x333>
  8041602cbd:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602cc1:	76 d5                	jbe    8041602c98 <address_by_fname+0x308>
    while (byte & 0x80) {
  8041602cc3:	45 84 d2             	test   %r10b,%r10b
  8041602cc6:	79 12                	jns    8041602cda <address_by_fname+0x34a>
        byte = *addr++;
  8041602cc8:	48 f7 d7             	not    %rdi
  8041602ccb:	48 01 fa             	add    %rdi,%rdx
  8041602cce:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602cd2:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602cd6:	84 c9                	test   %cl,%cl
  8041602cd8:	78 f4                	js     8041602cce <address_by_fname+0x33e>
                    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
  8041602cda:	48 01 c3             	add    %rax,%rbx
  8041602cdd:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041602ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602ce5:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602cea:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  8041602cef:	48 83 c2 01          	add    $0x1,%rdx
  8041602cf3:	44 0f b6 5a ff       	movzbl -0x1(%rdx),%r11d
        result |= (byte & 0x7FULL) << shift;
  8041602cf8:	4d 89 da             	mov    %r11,%r10
  8041602cfb:	41 83 e2 7f          	and    $0x7f,%r10d
  8041602cff:	49 d3 e2             	shl    %cl,%r10
  8041602d02:	4c 09 d7             	or     %r10,%rdi
        shift += 7;
  8041602d05:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602d09:	49 89 c2             	mov    %rax,%r10
  8041602d0c:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602d10:	45 84 db             	test   %r11b,%r11b
  8041602d13:	79 06                	jns    8041602d1b <address_by_fname+0x38b>
  8041602d15:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602d19:	76 d4                	jbe    8041602cef <address_by_fname+0x35f>
    while (byte & 0x80) {
  8041602d1b:	45 84 db             	test   %r11b,%r11b
  8041602d1e:	79 12                	jns    8041602d32 <address_by_fname+0x3a2>
        byte = *addr++;
  8041602d20:	49 f7 d2             	not    %r10
  8041602d23:	4c 01 d2             	add    %r10,%rdx
  8041602d26:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602d2a:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602d2e:	84 c9                	test   %cl,%cl
  8041602d30:	78 f4                	js     8041602d26 <address_by_fname+0x396>
                    abbrev_entry += sizeof(Dwarf_Small);
  8041602d32:	48 8d 5c 03 01       	lea    0x1(%rbx,%rax,1),%rbx
                    if (table_abbrev_code == abbrev_code) break;
  8041602d37:	49 39 f0             	cmp    %rsi,%r8
  8041602d3a:	0f 85 9d fe ff ff    	jne    8041602bdd <address_by_fname+0x24d>
                if (tag == DW_TAG_subprogram) {
  8041602d40:	48 83 ff 2e          	cmp    $0x2e,%rdi
  8041602d44:	0f 85 80 01 00 00    	jne    8041602eca <address_by_fname+0x53a>
                    uintptr_t low_pc = 0;
  8041602d4a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8041602d51:	00 
  8041602d52:	eb 54                	jmp    8041602da8 <address_by_fname+0x418>
  8041602d54:	40 84 ff             	test   %dil,%dil
  8041602d57:	79 12                	jns    8041602d6b <address_by_fname+0x3db>
        byte = *addr++;
  8041602d59:	48 f7 d6             	not    %rsi
  8041602d5c:	48 01 f2             	add    %rsi,%rdx
  8041602d5f:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8041602d63:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8041602d67:	84 c9                	test   %cl,%cl
  8041602d69:	78 f4                	js     8041602d5f <address_by_fname+0x3cf>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8041602d6b:	48 01 c3             	add    %rax,%rbx
                        if (name == DW_AT_low_pc) 
  8041602d6e:	49 83 fd 11          	cmp    $0x11,%r13
  8041602d72:	0f 84 cd 00 00 00    	je     8041602e45 <address_by_fname+0x4b5>
                            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041602d78:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041602d7e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041602d83:	ba 00 00 00 00       	mov    $0x0,%edx
  8041602d88:	44 89 f6             	mov    %r14d,%esi
  8041602d8b:	4c 89 ff             	mov    %r15,%rdi
  8041602d8e:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  8041602d95:	00 00 00 
  8041602d98:	ff d0                	call   *%rax
  8041602d9a:	48 98                	cltq   
  8041602d9c:	49 01 c7             	add    %rax,%r15
                    } while (name || form);
  8041602d9f:	4d 09 ee             	or     %r13,%r14
  8041602da2:	0f 84 c8 00 00 00    	je     8041602e70 <address_by_fname+0x4e0>
    uint64_t result = 0;
  8041602da8:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041602dab:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602db0:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602db5:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8041602dbb:	48 83 c2 01          	add    $0x1,%rdx
  8041602dbf:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041602dc3:	48 89 fe             	mov    %rdi,%rsi
  8041602dc6:	83 e6 7f             	and    $0x7f,%esi
  8041602dc9:	48 d3 e6             	shl    %cl,%rsi
  8041602dcc:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8041602dcf:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602dd3:	48 89 c6             	mov    %rax,%rsi
  8041602dd6:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602dda:	40 84 ff             	test   %dil,%dil
  8041602ddd:	79 06                	jns    8041602de5 <address_by_fname+0x455>
  8041602ddf:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602de3:	76 d6                	jbe    8041602dbb <address_by_fname+0x42b>
    while (byte & 0x80) {
  8041602de5:	40 84 ff             	test   %dil,%dil
  8041602de8:	79 12                	jns    8041602dfc <address_by_fname+0x46c>
        byte = *addr++;
  8041602dea:	48 f7 d6             	not    %rsi
  8041602ded:	48 01 f2             	add    %rsi,%rdx
  8041602df0:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602df4:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602df8:	84 c9                	test   %cl,%cl
  8041602dfa:	78 f4                	js     8041602df0 <address_by_fname+0x460>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8041602dfc:	48 01 d8             	add    %rbx,%rax
  8041602dff:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8041602e02:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041602e07:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602e0c:	41 be 00 00 00 00    	mov    $0x0,%r14d
        byte = *addr++;
  8041602e12:	48 83 c2 01          	add    $0x1,%rdx
  8041602e16:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041602e1a:	48 89 fe             	mov    %rdi,%rsi
  8041602e1d:	83 e6 7f             	and    $0x7f,%esi
  8041602e20:	48 d3 e6             	shl    %cl,%rsi
  8041602e23:	49 09 f6             	or     %rsi,%r14
        shift += 7;
  8041602e26:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602e2a:	48 89 de             	mov    %rbx,%rsi
  8041602e2d:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041602e31:	40 84 ff             	test   %dil,%dil
  8041602e34:	0f 89 1a ff ff ff    	jns    8041602d54 <address_by_fname+0x3c4>
  8041602e3a:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602e3e:	76 d2                	jbe    8041602e12 <address_by_fname+0x482>
  8041602e40:	e9 0f ff ff ff       	jmp    8041602d54 <address_by_fname+0x3c4>
                            entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  8041602e45:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041602e4b:	b9 08 00 00 00       	mov    $0x8,%ecx
  8041602e50:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  8041602e54:	44 89 f6             	mov    %r14d,%esi
  8041602e57:	4c 89 ff             	mov    %r15,%rdi
  8041602e5a:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  8041602e61:	00 00 00 
  8041602e64:	ff d0                	call   *%rax
  8041602e66:	48 98                	cltq   
  8041602e68:	49 01 c7             	add    %rax,%r15
                    } while (name || form);
  8041602e6b:	e9 38 ff ff ff       	jmp    8041602da8 <address_by_fname+0x418>
                    *offset = low_pc;
  8041602e70:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8041602e74:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8041602e78:	48 89 07             	mov    %rax,(%rdi)
  8041602e7b:	e9 b8 fb ff ff       	jmp    8041602a38 <address_by_fname+0xa8>
    while (byte & 0x80) {
  8041602e80:	40 84 ff             	test   %dil,%dil
  8041602e83:	79 12                	jns    8041602e97 <address_by_fname+0x507>
        byte = *addr++;
  8041602e85:	48 f7 d6             	not    %rsi
  8041602e88:	48 01 f2             	add    %rsi,%rdx
  8041602e8b:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8041602e8f:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8041602e93:	84 c9                	test   %cl,%cl
  8041602e95:	78 f4                	js     8041602e8b <address_by_fname+0x4fb>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8041602e97:	48 01 c3             	add    %rax,%rbx
                        entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041602e9a:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041602ea0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041602ea5:	ba 00 00 00 00       	mov    $0x0,%edx
  8041602eaa:	44 89 ee             	mov    %r13d,%esi
  8041602ead:	4c 89 ff             	mov    %r15,%rdi
  8041602eb0:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  8041602eb7:	00 00 00 
  8041602eba:	ff d0                	call   *%rax
  8041602ebc:	48 98                	cltq   
  8041602ebe:	49 01 c7             	add    %rax,%r15
                    } while (name || form);
  8041602ec1:	4d 09 f5             	or     %r14,%r13
  8041602ec4:	0f 84 6e fb ff ff    	je     8041602a38 <address_by_fname+0xa8>
    uint64_t result = 0;
  8041602eca:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041602ecd:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602ed2:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602ed7:	41 be 00 00 00 00    	mov    $0x0,%r14d
        byte = *addr++;
  8041602edd:	48 83 c2 01          	add    $0x1,%rdx
  8041602ee1:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041602ee5:	48 89 fe             	mov    %rdi,%rsi
  8041602ee8:	83 e6 7f             	and    $0x7f,%esi
  8041602eeb:	48 d3 e6             	shl    %cl,%rsi
  8041602eee:	49 09 f6             	or     %rsi,%r14
        shift += 7;
  8041602ef1:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602ef5:	48 89 c6             	mov    %rax,%rsi
  8041602ef8:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041602efc:	40 84 ff             	test   %dil,%dil
  8041602eff:	79 06                	jns    8041602f07 <address_by_fname+0x577>
  8041602f01:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602f05:	76 d6                	jbe    8041602edd <address_by_fname+0x54d>
    while (byte & 0x80) {
  8041602f07:	40 84 ff             	test   %dil,%dil
  8041602f0a:	79 12                	jns    8041602f1e <address_by_fname+0x58e>
        byte = *addr++;
  8041602f0c:	48 f7 d6             	not    %rsi
  8041602f0f:	48 01 f2             	add    %rsi,%rdx
  8041602f12:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041602f16:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041602f1a:	84 c9                	test   %cl,%cl
  8041602f1c:	78 f4                	js     8041602f12 <address_by_fname+0x582>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8041602f1e:	48 01 d8             	add    %rbx,%rax
  8041602f21:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8041602f24:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041602f29:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602f2e:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8041602f34:	48 83 c2 01          	add    $0x1,%rdx
  8041602f38:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041602f3c:	48 89 fe             	mov    %rdi,%rsi
  8041602f3f:	83 e6 7f             	and    $0x7f,%esi
  8041602f42:	48 d3 e6             	shl    %cl,%rsi
  8041602f45:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8041602f48:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041602f4c:	48 89 de             	mov    %rbx,%rsi
  8041602f4f:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041602f53:	40 84 ff             	test   %dil,%dil
  8041602f56:	0f 89 24 ff ff ff    	jns    8041602e80 <address_by_fname+0x4f0>
  8041602f5c:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041602f60:	76 d2                	jbe    8041602f34 <address_by_fname+0x5a4>
  8041602f62:	e9 19 ff ff ff       	jmp    8041602e80 <address_by_fname+0x4f0>
    return -E_NO_ENT;
  8041602f67:	41 bc f6 ff ff ff    	mov    $0xfffffff6,%r12d
  8041602f6d:	e9 c6 fa ff ff       	jmp    8041602a38 <address_by_fname+0xa8>
    if (!flen) return -E_INVAL;
  8041602f72:	41 bc fd ff ff ff    	mov    $0xfffffffd,%r12d
  8041602f78:	e9 bb fa ff ff       	jmp    8041602a38 <address_by_fname+0xa8>
    uint64_t count = sizeof(uint32_t);
  8041602f7d:	41 be 04 00 00 00    	mov    $0x4,%r14d
                entry += count = dwarf_entry_len(entry, &len);
  8041602f83:	4c 03 75 b8          	add    -0x48(%rbp),%r14
                Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  8041602f87:	ba 02 00 00 00       	mov    $0x2,%edx
  8041602f8c:	4c 89 f6             	mov    %r14,%rsi
  8041602f8f:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602f93:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041602f9a:	00 00 00 
  8041602f9d:	ff d0                	call   *%rax
                assert(version == 4 || version == 2);
  8041602f9f:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8041602fa3:	83 e8 02             	sub    $0x2,%eax
  8041602fa6:	66 a9 fd ff          	test   $0xfffd,%ax
  8041602faa:	0f 85 a0 fb ff ff    	jne    8041602b50 <address_by_fname+0x1c0>
                entry += sizeof(Dwarf_Half);
  8041602fb0:	49 8d 76 02          	lea    0x2(%r14),%rsi
                Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  8041602fb4:	ba 04 00 00 00       	mov    $0x4,%edx
  8041602fb9:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602fbd:	49 bf b4 fe 60 41 80 	movabs $0x804160feb4,%r15
  8041602fc4:	00 00 00 
  8041602fc7:	41 ff d7             	call   *%r15
  8041602fca:	8b 5d c8             	mov    -0x38(%rbp),%ebx
                const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  8041602fcd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8041602fd1:	48 03 18             	add    (%rax),%rbx
                entry += sizeof(uint32_t);
  8041602fd4:	49 8d 76 06          	lea    0x6(%r14),%rsi
                Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  8041602fd8:	ba 01 00 00 00       	mov    $0x1,%edx
  8041602fdd:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041602fe1:	41 ff d7             	call   *%r15
                assert(address_size == sizeof(uintptr_t));
  8041602fe4:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8041602fe8:	0f 85 97 fb ff ff    	jne    8041602b85 <address_by_fname+0x1f5>
                const uint8_t *func_entry = entry + func_offset;
  8041602fee:	4c 03 6d b8          	add    -0x48(%rbp),%r13
  8041602ff2:	4c 89 ea             	mov    %r13,%rdx
    size_t shift = 0, count = 0;
  8041602ff5:	b8 00 00 00 00       	mov    $0x0,%eax
  8041602ffa:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041602fff:	41 b8 00 00 00 00    	mov    $0x0,%r8d
        byte = *addr++;
  8041603005:	48 83 c2 01          	add    $0x1,%rdx
  8041603009:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  804160300d:	48 89 fe             	mov    %rdi,%rsi
  8041603010:	83 e6 7f             	and    $0x7f,%esi
  8041603013:	48 d3 e6             	shl    %cl,%rsi
  8041603016:	49 09 f0             	or     %rsi,%r8
        shift += 7;
  8041603019:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804160301d:	48 89 c6             	mov    %rax,%rsi
  8041603020:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041603024:	40 84 ff             	test   %dil,%dil
  8041603027:	79 06                	jns    804160302f <address_by_fname+0x69f>
  8041603029:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160302d:	76 d6                	jbe    8041603005 <address_by_fname+0x675>
    while (byte & 0x80) {
  804160302f:	40 84 ff             	test   %dil,%dil
  8041603032:	79 12                	jns    8041603046 <address_by_fname+0x6b6>
        byte = *addr++;
  8041603034:	48 f7 d6             	not    %rsi
  8041603037:	48 01 f2             	add    %rsi,%rdx
  804160303a:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  804160303e:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041603042:	84 c9                	test   %cl,%cl
  8041603044:	78 f4                	js     804160303a <address_by_fname+0x6aa>
                entry += dwarf_read_uleb128(entry, &abbrev_code);
  8041603046:	4d 8d 7c 05 00       	lea    0x0(%r13,%rax,1),%r15
                while (abbrev_entry < addrs->abbrev_end) {
  804160304b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804160304f:	4c 8b 48 08          	mov    0x8(%rax),%r9
  8041603053:	4c 39 cb             	cmp    %r9,%rbx
  8041603056:	0f 82 2a fc ff ff    	jb     8041602c86 <address_by_fname+0x2f6>
  804160305c:	e9 69 fe ff ff       	jmp    8041602eca <address_by_fname+0x53a>
    uint64_t count = sizeof(uint32_t);
  8041603061:	ba 04 00 00 00       	mov    $0x4,%edx
        pubnames_entry += count;
  8041603066:	48 01 d3             	add    %rdx,%rbx
        const uint8_t *pubnames_entry_end = pubnames_entry + len;
  8041603069:	48 01 d8             	add    %rbx,%rax
  804160306c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        Dwarf_Half version = get_unaligned(pubnames_entry, Dwarf_Half);
  8041603070:	ba 02 00 00 00       	mov    $0x2,%edx
  8041603075:	48 89 de             	mov    %rbx,%rsi
  8041603078:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160307c:	41 ff d6             	call   *%r14
        assert(version == 2);
  804160307f:	66 83 7d c8 02       	cmpw   $0x2,-0x38(%rbp)
  8041603084:	0f 85 de f9 ff ff    	jne    8041602a68 <address_by_fname+0xd8>
        pubnames_entry += sizeof(Dwarf_Half);
  804160308a:	48 8d 73 02          	lea    0x2(%rbx),%rsi
        cu_offset = get_unaligned(pubnames_entry, uint32_t);
  804160308e:	ba 04 00 00 00       	mov    $0x4,%edx
  8041603093:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603097:	41 ff d6             	call   *%r14
  804160309a:	8b 45 c8             	mov    -0x38(%rbp),%eax
  804160309d:	89 45 a4             	mov    %eax,-0x5c(%rbp)
        pubnames_entry += sizeof(uint32_t);
  80416030a0:	4c 8d 63 06          	lea    0x6(%rbx),%r12
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80416030a4:	ba 04 00 00 00       	mov    $0x4,%edx
  80416030a9:	4c 89 e6             	mov    %r12,%rsi
  80416030ac:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416030b0:	41 ff d6             	call   *%r14
  80416030b3:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80416030b6:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  80416030bd:	ff ff ff 
  80416030c0:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
    uint64_t count = sizeof(uint32_t);
  80416030c4:	b8 04 00 00 00       	mov    $0x4,%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80416030c9:	48 83 f9 0f          	cmp    $0xf,%rcx
  80416030cd:	77 2e                	ja     80416030fd <address_by_fname+0x76d>
        if (initial_len == DW_EXT_DWARF64) {
  80416030cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80416030d4:	48 39 c2             	cmp    %rax,%rdx
  80416030d7:	0f 84 c0 f9 ff ff    	je     8041602a9d <address_by_fname+0x10d>
            cprintf("Unknown DWARF extension\n");
  80416030dd:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  80416030e4:	00 00 00 
  80416030e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80416030ec:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  80416030f3:	00 00 00 
  80416030f6:	ff d2                	call   *%rdx
            count = 0;
  80416030f8:	b8 00 00 00 00       	mov    $0x0,%eax
        pubnames_entry += count;
  80416030fd:	49 8d 1c 04          	lea    (%r12,%rax,1),%rbx
        while (pubnames_entry < pubnames_entry_end) {
  8041603101:	48 39 5d b8          	cmp    %rbx,-0x48(%rbp)
  8041603105:	76 59                	jbe    8041603160 <address_by_fname+0x7d0>
            pubnames_entry += strlen((const char *)pubnames_entry) + 1;
  8041603107:	49 bf 1b fc 60 41 80 	movabs $0x804160fc1b,%r15
  804160310e:	00 00 00 
            func_offset = get_unaligned(pubnames_entry, uint32_t);
  8041603111:	ba 04 00 00 00       	mov    $0x4,%edx
  8041603116:	48 89 de             	mov    %rbx,%rsi
  8041603119:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160311d:	41 ff d6             	call   *%r14
  8041603120:	44 8b 6d c8          	mov    -0x38(%rbp),%r13d
            pubnames_entry += sizeof(uint32_t);
  8041603124:	48 83 c3 04          	add    $0x4,%rbx
            if (!func_offset) break;
  8041603128:	4d 85 ed             	test   %r13,%r13
  804160312b:	0f 84 a4 f8 ff ff    	je     80416029d5 <address_by_fname+0x45>
            if (!strcmp(fname, (const char *)pubnames_entry)) {
  8041603131:	48 89 de             	mov    %rbx,%rsi
  8041603134:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8041603138:	48 b8 f6 fc 60 41 80 	movabs $0x804160fcf6,%rax
  804160313f:	00 00 00 
  8041603142:	ff d0                	call   *%rax
  8041603144:	41 89 c4             	mov    %eax,%r12d
  8041603147:	85 c0                	test   %eax,%eax
  8041603149:	0f 84 68 f9 ff ff    	je     8041602ab7 <address_by_fname+0x127>
            pubnames_entry += strlen((const char *)pubnames_entry) + 1;
  804160314f:	48 89 df             	mov    %rbx,%rdi
  8041603152:	41 ff d7             	call   *%r15
  8041603155:	48 8d 5c 03 01       	lea    0x1(%rbx,%rax,1),%rbx
        while (pubnames_entry < pubnames_entry_end) {
  804160315a:	48 39 5d b8          	cmp    %rbx,-0x48(%rbp)
  804160315e:	77 b1                	ja     8041603111 <address_by_fname+0x781>
    while (pubnames_entry < addrs->pubnames_end) {
  8041603160:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8041603164:	48 39 58 58          	cmp    %rbx,0x58(%rax)
  8041603168:	0f 87 75 f8 ff ff    	ja     80416029e3 <address_by_fname+0x53>
    return -E_NO_ENT;
  804160316e:	41 bc f6 ff ff ff    	mov    $0xfffffff6,%r12d
  8041603174:	e9 bf f8 ff ff       	jmp    8041602a38 <address_by_fname+0xa8>

0000008041603179 <naive_address_by_fname>:

int
naive_address_by_fname(const struct Dwarf_Addrs *addrs, const char *fname, uintptr_t *offset) {
  8041603179:	55                   	push   %rbp
  804160317a:	48 89 e5             	mov    %rsp,%rbp
  804160317d:	41 57                	push   %r15
  804160317f:	41 56                	push   %r14
  8041603181:	41 55                	push   %r13
  8041603183:	41 54                	push   %r12
  8041603185:	53                   	push   %rbx
  8041603186:	48 83 ec 48          	sub    $0x48,%rsp
  804160318a:	48 89 fb             	mov    %rdi,%rbx
  804160318d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8041603191:	48 89 f7             	mov    %rsi,%rdi
  8041603194:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8041603198:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    const int flen = strlen(fname);
  804160319c:	48 b8 1b fc 60 41 80 	movabs $0x804160fc1b,%rax
  80416031a3:	00 00 00 
  80416031a6:	ff d0                	call   *%rax
    if (!flen) return -E_INVAL;
  80416031a8:	85 c0                	test   %eax,%eax
  80416031aa:	0f 84 36 06 00 00    	je     80416037e6 <naive_address_by_fname+0x66d>

    for (const uint8_t *entry = addrs->info_begin; (const unsigned char *)entry < addrs->info_end;) {
  80416031b0:	4c 8b 7b 20          	mov    0x20(%rbx),%r15
  80416031b4:	4c 3b 7b 28          	cmp    0x28(%rbx),%r15
  80416031b8:	0f 82 b6 05 00 00    	jb     8041603774 <naive_address_by_fname+0x5fb>
                } while (name || form);
            }
        }
    }

    return -E_NO_ENT;
  80416031be:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80416031c3:	e9 08 06 00 00       	jmp    80416037d0 <naive_address_by_fname+0x657>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  80416031c8:	49 8d 77 20          	lea    0x20(%r15),%rsi
  80416031cc:	ba 08 00 00 00       	mov    $0x8,%edx
  80416031d1:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416031d5:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416031dc:	00 00 00 
  80416031df:	ff d0                	call   *%rax
  80416031e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  80416031e5:	bb 0c 00 00 00       	mov    $0xc,%ebx
  80416031ea:	e9 03 06 00 00       	jmp    80416037f2 <naive_address_by_fname+0x679>
        assert(version == 4 || version == 2);
  80416031ef:	48 b9 f9 13 61 41 80 	movabs $0x80416113f9,%rcx
  80416031f6:	00 00 00 
  80416031f9:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041603200:	00 00 00 
  8041603203:	be 67 02 00 00       	mov    $0x267,%esi
  8041603208:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  804160320f:	00 00 00 
  8041603212:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603217:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160321e:	00 00 00 
  8041603221:	41 ff d0             	call   *%r8
        assert(address_size == sizeof(uintptr_t));
  8041603224:	48 b9 68 15 61 41 80 	movabs $0x8041611568,%rcx
  804160322b:	00 00 00 
  804160322e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041603235:	00 00 00 
  8041603238:	be 6c 02 00 00       	mov    $0x26c,%esi
  804160323d:	48 bf 2b 14 61 41 80 	movabs $0x804161142b,%rdi
  8041603244:	00 00 00 
  8041603247:	b8 00 00 00 00       	mov    $0x0,%eax
  804160324c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041603253:	00 00 00 
  8041603256:	41 ff d0             	call   *%r8
    while (byte & 0x80) {
  8041603259:	40 84 ff             	test   %dil,%dil
  804160325c:	79 12                	jns    8041603270 <naive_address_by_fname+0xf7>
        byte = *addr++;
  804160325e:	48 f7 d6             	not    %rsi
  8041603261:	48 01 f2             	add    %rsi,%rdx
  8041603264:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041603268:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804160326c:	84 c9                	test   %cl,%cl
  804160326e:	78 f4                	js     8041603264 <naive_address_by_fname+0xeb>
            entry += count;
  8041603270:	89 c0                	mov    %eax,%eax
  8041603272:	49 01 c7             	add    %rax,%r15
            if (!abbrev_code) continue;
  8041603275:	4d 85 d2             	test   %r10,%r10
  8041603278:	75 49                	jne    80416032c3 <naive_address_by_fname+0x14a>
        while (entry < entry_end) {
  804160327a:	4c 3b 7d 98          	cmp    -0x68(%rbp),%r15
  804160327e:	0f 83 e6 04 00 00    	jae    804160376a <naive_address_by_fname+0x5f1>
  8041603284:	4c 89 fa             	mov    %r15,%rdx
    size_t shift = 0, count = 0;
  8041603287:	b8 00 00 00 00       	mov    $0x0,%eax
  804160328c:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041603291:	41 ba 00 00 00 00    	mov    $0x0,%r10d
        byte = *addr++;
  8041603297:	48 83 c2 01          	add    $0x1,%rdx
  804160329b:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  804160329f:	48 89 fe             	mov    %rdi,%rsi
  80416032a2:	83 e6 7f             	and    $0x7f,%esi
  80416032a5:	48 d3 e6             	shl    %cl,%rsi
  80416032a8:	49 09 f2             	or     %rsi,%r10
        shift += 7;
  80416032ab:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416032af:	48 89 c6             	mov    %rax,%rsi
  80416032b2:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80416032b6:	40 84 ff             	test   %dil,%dil
  80416032b9:	79 9e                	jns    8041603259 <naive_address_by_fname+0xe0>
  80416032bb:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416032bf:	76 d6                	jbe    8041603297 <naive_address_by_fname+0x11e>
  80416032c1:	eb 96                	jmp    8041603259 <naive_address_by_fname+0xe0>
            while ((const unsigned char *)curr_abbrev_entry < addrs->abbrev_end) {
  80416032c3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80416032c7:	4c 8b 58 08          	mov    0x8(%rax),%r11
  80416032cb:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  80416032cf:	4c 39 db             	cmp    %r11,%rbx
  80416032d2:	0f 83 a5 03 00 00    	jae    804160367d <naive_address_by_fname+0x504>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  80416032d8:	48 89 d8             	mov    %rbx,%rax
  80416032db:	e9 c8 00 00 00       	jmp    80416033a8 <naive_address_by_fname+0x22f>
    while (byte & 0x80) {
  80416032e0:	45 84 ed             	test   %r13b,%r13b
  80416032e3:	79 12                	jns    80416032f7 <naive_address_by_fname+0x17e>
        byte = *addr++;
  80416032e5:	49 f7 d0             	not    %r8
  80416032e8:	4c 01 c6             	add    %r8,%rsi
  80416032eb:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
        count++;
  80416032ef:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80416032f3:	84 c9                	test   %cl,%cl
  80416032f5:	78 f4                	js     80416032eb <naive_address_by_fname+0x172>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  80416032f7:	48 01 d0             	add    %rdx,%rax
                } while (name || form);
  80416032fa:	48 09 fb             	or     %rdi,%rbx
  80416032fd:	0f 84 9c 00 00 00    	je     804160339f <naive_address_by_fname+0x226>
    uint64_t result = 0;
  8041603303:	48 89 c6             	mov    %rax,%rsi
    size_t shift = 0, count = 0;
  8041603306:	ba 00 00 00 00       	mov    $0x0,%edx
  804160330b:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041603310:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  8041603315:	48 83 c6 01          	add    $0x1,%rsi
  8041603319:	0f b6 5e ff          	movzbl -0x1(%rsi),%ebx
        result |= (byte & 0x7FULL) << shift;
  804160331d:	49 89 d8             	mov    %rbx,%r8
  8041603320:	41 83 e0 7f          	and    $0x7f,%r8d
  8041603324:	49 d3 e0             	shl    %cl,%r8
  8041603327:	4c 09 c7             	or     %r8,%rdi
        shift += 7;
  804160332a:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804160332e:	49 89 d0             	mov    %rdx,%r8
  8041603331:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603335:	84 db                	test   %bl,%bl
  8041603337:	79 06                	jns    804160333f <naive_address_by_fname+0x1c6>
  8041603339:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160333d:	76 d6                	jbe    8041603315 <naive_address_by_fname+0x19c>
    while (byte & 0x80) {
  804160333f:	84 db                	test   %bl,%bl
  8041603341:	79 12                	jns    8041603355 <naive_address_by_fname+0x1dc>
        byte = *addr++;
  8041603343:	49 f7 d0             	not    %r8
  8041603346:	4c 01 c6             	add    %r8,%rsi
  8041603349:	0f b6 0c 16          	movzbl (%rsi,%rdx,1),%ecx
        count++;
  804160334d:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603351:	84 c9                	test   %cl,%cl
  8041603353:	78 f4                	js     8041603349 <naive_address_by_fname+0x1d0>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  8041603355:	48 01 c2             	add    %rax,%rdx
  8041603358:	48 89 d6             	mov    %rdx,%rsi
    size_t shift = 0, count = 0;
  804160335b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603360:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041603365:	bb 00 00 00 00       	mov    $0x0,%ebx
        byte = *addr++;
  804160336a:	48 83 c6 01          	add    $0x1,%rsi
  804160336e:	44 0f b6 6e ff       	movzbl -0x1(%rsi),%r13d
        result |= (byte & 0x7FULL) << shift;
  8041603373:	4d 89 e8             	mov    %r13,%r8
  8041603376:	41 83 e0 7f          	and    $0x7f,%r8d
  804160337a:	49 d3 e0             	shl    %cl,%r8
  804160337d:	4c 09 c3             	or     %r8,%rbx
        shift += 7;
  8041603380:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603384:	49 89 c0             	mov    %rax,%r8
  8041603387:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  804160338b:	45 84 ed             	test   %r13b,%r13b
  804160338e:	0f 89 4c ff ff ff    	jns    80416032e0 <naive_address_by_fname+0x167>
  8041603394:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603398:	76 d0                	jbe    804160336a <naive_address_by_fname+0x1f1>
  804160339a:	e9 41 ff ff ff       	jmp    80416032e0 <naive_address_by_fname+0x167>
            while ((const unsigned char *)curr_abbrev_entry < addrs->abbrev_end) {
  804160339f:	4c 39 d8             	cmp    %r11,%rax
  80416033a2:	0f 83 c6 00 00 00    	jae    804160346e <naive_address_by_fname+0x2f5>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  80416033a8:	48 89 c6             	mov    %rax,%rsi
    size_t shift = 0, count = 0;
  80416033ab:	ba 00 00 00 00       	mov    $0x0,%edx
  80416033b0:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416033b5:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  80416033ba:	48 83 c6 01          	add    $0x1,%rsi
  80416033be:	44 0f b6 4e ff       	movzbl -0x1(%rsi),%r9d
        result |= (byte & 0x7FULL) << shift;
  80416033c3:	4d 89 c8             	mov    %r9,%r8
  80416033c6:	41 83 e0 7f          	and    $0x7f,%r8d
  80416033ca:	49 d3 e0             	shl    %cl,%r8
  80416033cd:	4c 09 c7             	or     %r8,%rdi
        shift += 7;
  80416033d0:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416033d4:	49 89 d0             	mov    %rdx,%r8
  80416033d7:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  80416033db:	45 84 c9             	test   %r9b,%r9b
  80416033de:	79 06                	jns    80416033e6 <naive_address_by_fname+0x26d>
  80416033e0:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416033e4:	76 d4                	jbe    80416033ba <naive_address_by_fname+0x241>
    while (byte & 0x80) {
  80416033e6:	45 84 c9             	test   %r9b,%r9b
  80416033e9:	79 12                	jns    80416033fd <naive_address_by_fname+0x284>
        byte = *addr++;
  80416033eb:	49 f7 d0             	not    %r8
  80416033ee:	4c 01 c6             	add    %r8,%rsi
  80416033f1:	0f b6 0c 16          	movzbl (%rsi,%rdx,1),%ecx
        count++;
  80416033f5:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  80416033f9:	84 c9                	test   %cl,%cl
  80416033fb:	78 f4                	js     80416033f1 <naive_address_by_fname+0x278>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &table_abbrev_code);
  80416033fd:	48 01 c2             	add    %rax,%rdx
  8041603400:	48 89 d6             	mov    %rdx,%rsi
    size_t shift = 0, count = 0;
  8041603403:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603408:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804160340d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
        byte = *addr++;
  8041603413:	48 83 c6 01          	add    $0x1,%rsi
  8041603417:	0f b6 5e ff          	movzbl -0x1(%rsi),%ebx
        result |= (byte & 0x7FULL) << shift;
  804160341b:	49 89 d8             	mov    %rbx,%r8
  804160341e:	41 83 e0 7f          	and    $0x7f,%r8d
  8041603422:	49 d3 e0             	shl    %cl,%r8
  8041603425:	4d 09 c1             	or     %r8,%r9
        shift += 7;
  8041603428:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804160342c:	49 89 c5             	mov    %rax,%r13
  804160342f:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041603433:	41 89 d8             	mov    %ebx,%r8d
  8041603436:	41 c0 e8 07          	shr    $0x7,%r8b
  804160343a:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804160343e:	41 0f 96 c4          	setbe  %r12b
  8041603442:	45 20 e0             	and    %r12b,%r8b
  8041603445:	75 cc                	jne    8041603413 <naive_address_by_fname+0x29a>
    while (byte & 0x80) {
  8041603447:	45 89 c4             	mov    %r8d,%r12d
  804160344a:	84 db                	test   %bl,%bl
  804160344c:	79 12                	jns    8041603460 <naive_address_by_fname+0x2e7>
        byte = *addr++;
  804160344e:	49 f7 d5             	not    %r13
  8041603451:	4c 01 ee             	add    %r13,%rsi
  8041603454:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
        count++;
  8041603458:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804160345c:	84 c9                	test   %cl,%cl
  804160345e:	78 f4                	js     8041603454 <naive_address_by_fname+0x2db>
                curr_abbrev_entry += sizeof(Dwarf_Small);
  8041603460:	48 8d 44 02 01       	lea    0x1(%rdx,%rax,1),%rax
                if (table_abbrev_code == abbrev_code) break;
  8041603465:	49 39 fa             	cmp    %rdi,%r10
  8041603468:	0f 85 95 fe ff ff    	jne    8041603303 <naive_address_by_fname+0x18a>
            if (tag == DW_TAG_subprogram || tag == DW_TAG_label) {
  804160346e:	48 89 c3             	mov    %rax,%rbx
  8041603471:	49 83 f9 2e          	cmp    $0x2e,%r9
  8041603475:	0f 94 c2             	sete   %dl
  8041603478:	49 83 f9 0a          	cmp    $0xa,%r9
  804160347c:	0f 94 c0             	sete   %al
  804160347f:	08 c2                	or     %al,%dl
  8041603481:	88 55 b7             	mov    %dl,-0x49(%rbp)
  8041603484:	0f 84 43 02 00 00    	je     80416036cd <naive_address_by_fname+0x554>
                uintptr_t low_pc = 0;
  804160348a:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8041603491:	00 
                bool found = 0;
  8041603492:	e9 b3 00 00 00       	jmp    804160354a <naive_address_by_fname+0x3d1>
                        entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  8041603497:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804160349d:	b9 08 00 00 00       	mov    $0x8,%ecx
  80416034a2:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80416034a6:	44 89 f6             	mov    %r14d,%esi
  80416034a9:	4c 89 ff             	mov    %r15,%rdi
  80416034ac:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  80416034b3:	00 00 00 
  80416034b6:	ff d0                	call   *%rax
  80416034b8:	48 98                	cltq   
  80416034ba:	49 01 c7             	add    %rax,%r15
  80416034bd:	e9 88 00 00 00       	jmp    804160354a <naive_address_by_fname+0x3d1>
                            uint64_t str_offset = 0;
  80416034c2:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80416034c9:	00 
                            entry += dwarf_read_abbrev_entry(entry, form, &str_offset, sizeof(uint64_t), address_size);
  80416034ca:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80416034d0:	b9 08 00 00 00       	mov    $0x8,%ecx
  80416034d5:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  80416034d9:	be 0e 00 00 00       	mov    $0xe,%esi
  80416034de:	4c 89 ff             	mov    %r15,%rdi
  80416034e1:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  80416034e8:	00 00 00 
  80416034eb:	ff d0                	call   *%rax
  80416034ed:	48 98                	cltq   
  80416034ef:	49 01 c7             	add    %rax,%r15
                            if (!strcmp(fname, (const char *)addrs->str_begin + str_offset)) found = 1;
  80416034f2:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80416034f6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80416034fa:	48 03 70 40          	add    0x40(%rax),%rsi
  80416034fe:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8041603502:	48 b8 f6 fc 60 41 80 	movabs $0x804160fcf6,%rax
  8041603509:	00 00 00 
  804160350c:	ff d0                	call   *%rax
  804160350e:	85 c0                	test   %eax,%eax
  8041603510:	0f b6 45 b7          	movzbl -0x49(%rbp),%eax
  8041603514:	44 0f 44 e0          	cmove  %eax,%r12d
  8041603518:	eb 30                	jmp    804160354a <naive_address_by_fname+0x3d1>
                        entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  804160351a:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041603520:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041603525:	ba 00 00 00 00       	mov    $0x0,%edx
  804160352a:	44 89 f6             	mov    %r14d,%esi
  804160352d:	4c 89 ff             	mov    %r15,%rdi
  8041603530:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  8041603537:	00 00 00 
  804160353a:	ff d0                	call   *%rax
  804160353c:	48 98                	cltq   
  804160353e:	49 01 c7             	add    %rax,%r15
                } while (name || form);
  8041603541:	4d 09 ee             	or     %r13,%r14
  8041603544:	0f 84 15 01 00 00    	je     804160365f <naive_address_by_fname+0x4e6>
    uint64_t result = 0;
  804160354a:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  804160354d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603552:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041603557:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  804160355d:	48 83 c2 01          	add    $0x1,%rdx
  8041603561:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8041603565:	48 89 fe             	mov    %rdi,%rsi
  8041603568:	83 e6 7f             	and    $0x7f,%esi
  804160356b:	48 d3 e6             	shl    %cl,%rsi
  804160356e:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8041603571:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603575:	48 89 c6             	mov    %rax,%rsi
  8041603578:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  804160357c:	40 84 ff             	test   %dil,%dil
  804160357f:	79 06                	jns    8041603587 <naive_address_by_fname+0x40e>
  8041603581:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603585:	76 d6                	jbe    804160355d <naive_address_by_fname+0x3e4>
    while (byte & 0x80) {
  8041603587:	40 84 ff             	test   %dil,%dil
  804160358a:	79 12                	jns    804160359e <naive_address_by_fname+0x425>
        byte = *addr++;
  804160358c:	48 f7 d6             	not    %rsi
  804160358f:	48 01 f2             	add    %rsi,%rdx
  8041603592:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041603596:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804160359a:	84 c9                	test   %cl,%cl
  804160359c:	78 f4                	js     8041603592 <naive_address_by_fname+0x419>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  804160359e:	48 01 c3             	add    %rax,%rbx
  80416035a1:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80416035a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80416035a9:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416035ae:	41 be 00 00 00 00    	mov    $0x0,%r14d
        byte = *addr++;
  80416035b4:	48 83 c2 01          	add    $0x1,%rdx
  80416035b8:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80416035bc:	48 89 fe             	mov    %rdi,%rsi
  80416035bf:	83 e6 7f             	and    $0x7f,%esi
  80416035c2:	48 d3 e6             	shl    %cl,%rsi
  80416035c5:	49 09 f6             	or     %rsi,%r14
        shift += 7;
  80416035c8:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416035cc:	48 89 c6             	mov    %rax,%rsi
  80416035cf:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80416035d3:	40 84 ff             	test   %dil,%dil
  80416035d6:	79 06                	jns    80416035de <naive_address_by_fname+0x465>
  80416035d8:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80416035dc:	76 d6                	jbe    80416035b4 <naive_address_by_fname+0x43b>
    while (byte & 0x80) {
  80416035de:	40 84 ff             	test   %dil,%dil
  80416035e1:	79 12                	jns    80416035f5 <naive_address_by_fname+0x47c>
        byte = *addr++;
  80416035e3:	48 f7 d6             	not    %rsi
  80416035e6:	48 01 f2             	add    %rsi,%rdx
  80416035e9:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  80416035ed:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80416035f1:	84 c9                	test   %cl,%cl
  80416035f3:	78 f4                	js     80416035e9 <naive_address_by_fname+0x470>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  80416035f5:	48 01 c3             	add    %rax,%rbx
                    if (name == DW_AT_low_pc) {
  80416035f8:	49 83 fd 11          	cmp    $0x11,%r13
  80416035fc:	0f 84 95 fe ff ff    	je     8041603497 <naive_address_by_fname+0x31e>
                    } else if (name == DW_AT_name) {
  8041603602:	49 83 fd 03          	cmp    $0x3,%r13
  8041603606:	0f 85 0e ff ff ff    	jne    804160351a <naive_address_by_fname+0x3a1>
                        if (form == DW_FORM_strp) {
  804160360c:	49 83 fe 0e          	cmp    $0xe,%r14
  8041603610:	0f 84 ac fe ff ff    	je     80416034c2 <naive_address_by_fname+0x349>
                            if (!strcmp(fname, (const char *)entry)) found = 1;
  8041603616:	4c 89 fe             	mov    %r15,%rsi
  8041603619:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  804160361d:	48 b8 f6 fc 60 41 80 	movabs $0x804160fcf6,%rax
  8041603624:	00 00 00 
  8041603627:	ff d0                	call   *%rax
  8041603629:	85 c0                	test   %eax,%eax
  804160362b:	0f b6 45 b7          	movzbl -0x49(%rbp),%eax
  804160362f:	44 0f 44 e0          	cmove  %eax,%r12d
                            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8041603633:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8041603639:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160363e:	ba 00 00 00 00       	mov    $0x0,%edx
  8041603643:	44 89 f6             	mov    %r14d,%esi
  8041603646:	4c 89 ff             	mov    %r15,%rdi
  8041603649:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  8041603650:	00 00 00 
  8041603653:	ff d0                	call   *%rax
  8041603655:	48 98                	cltq   
  8041603657:	49 01 c7             	add    %rax,%r15
  804160365a:	e9 eb fe ff ff       	jmp    804160354a <naive_address_by_fname+0x3d1>
                if (found) {
  804160365f:	45 84 e4             	test   %r12b,%r12b
  8041603662:	0f 84 12 fc ff ff    	je     804160327a <naive_address_by_fname+0x101>
                    *offset = low_pc;
  8041603668:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804160366c:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  8041603670:	48 89 07             	mov    %rax,(%rdi)
                    return 0;
  8041603673:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603678:	e9 53 01 00 00       	jmp    80416037d0 <naive_address_by_fname+0x657>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  804160367d:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  8041603681:	eb 4a                	jmp    80416036cd <naive_address_by_fname+0x554>
  8041603683:	40 84 ff             	test   %dil,%dil
  8041603686:	79 12                	jns    804160369a <naive_address_by_fname+0x521>
        byte = *addr++;
  8041603688:	48 f7 d6             	not    %rsi
  804160368b:	48 01 f2             	add    %rsi,%rdx
  804160368e:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041603692:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041603696:	84 c9                	test   %cl,%cl
  8041603698:	78 f4                	js     804160368e <naive_address_by_fname+0x515>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  804160369a:	48 01 c3             	add    %rax,%rbx
                    entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  804160369d:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80416036a3:	b9 00 00 00 00       	mov    $0x0,%ecx
  80416036a8:	ba 00 00 00 00       	mov    $0x0,%edx
  80416036ad:	44 89 ee             	mov    %r13d,%esi
  80416036b0:	4c 89 ff             	mov    %r15,%rdi
  80416036b3:	48 b8 42 0d 60 41 80 	movabs $0x8041600d42,%rax
  80416036ba:	00 00 00 
  80416036bd:	ff d0                	call   *%rax
  80416036bf:	48 98                	cltq   
  80416036c1:	49 01 c7             	add    %rax,%r15
                } while (name || form);
  80416036c4:	4d 09 e5             	or     %r12,%r13
  80416036c7:	0f 84 ad fb ff ff    	je     804160327a <naive_address_by_fname+0x101>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  80416036cd:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80416036d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80416036d5:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80416036da:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  80416036e0:	48 83 c2 01          	add    $0x1,%rdx
  80416036e4:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80416036e8:	48 89 fe             	mov    %rdi,%rsi
  80416036eb:	83 e6 7f             	and    $0x7f,%esi
  80416036ee:	48 d3 e6             	shl    %cl,%rsi
  80416036f1:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  80416036f4:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80416036f8:	48 89 c6             	mov    %rax,%rsi
  80416036fb:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80416036ff:	40 84 ff             	test   %dil,%dil
  8041603702:	79 06                	jns    804160370a <naive_address_by_fname+0x591>
  8041603704:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603708:	76 d6                	jbe    80416036e0 <naive_address_by_fname+0x567>
    while (byte & 0x80) {
  804160370a:	40 84 ff             	test   %dil,%dil
  804160370d:	79 12                	jns    8041603721 <naive_address_by_fname+0x5a8>
        byte = *addr++;
  804160370f:	48 f7 d6             	not    %rsi
  8041603712:	48 01 f2             	add    %rsi,%rdx
  8041603715:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041603719:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804160371d:	84 c9                	test   %cl,%cl
  804160371f:	78 f4                	js     8041603715 <naive_address_by_fname+0x59c>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  8041603721:	48 01 c3             	add    %rax,%rbx
  8041603724:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041603727:	b8 00 00 00 00       	mov    $0x0,%eax
  804160372c:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041603731:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8041603737:	48 83 c2 01          	add    $0x1,%rdx
  804160373b:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  804160373f:	48 89 fe             	mov    %rdi,%rsi
  8041603742:	83 e6 7f             	and    $0x7f,%esi
  8041603745:	48 d3 e6             	shl    %cl,%rsi
  8041603748:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  804160374b:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804160374f:	48 89 c6             	mov    %rax,%rsi
  8041603752:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041603756:	40 84 ff             	test   %dil,%dil
  8041603759:	0f 89 24 ff ff ff    	jns    8041603683 <naive_address_by_fname+0x50a>
  804160375f:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603763:	76 d2                	jbe    8041603737 <naive_address_by_fname+0x5be>
  8041603765:	e9 19 ff ff ff       	jmp    8041603683 <naive_address_by_fname+0x50a>
    for (const uint8_t *entry = addrs->info_begin; (const unsigned char *)entry < addrs->info_end;) {
  804160376a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804160376e:	4c 39 78 28          	cmp    %r15,0x28(%rax)
  8041603772:	76 6b                	jbe    80416037df <naive_address_by_fname+0x666>
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8041603774:	ba 04 00 00 00       	mov    $0x4,%edx
  8041603779:	4c 89 fe             	mov    %r15,%rsi
  804160377c:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603780:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041603787:	00 00 00 
  804160378a:	ff d0                	call   *%rax
  804160378c:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804160378f:	48 ba 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdx
  8041603796:	ff ff ff 
  8041603799:	48 01 c2             	add    %rax,%rdx
  804160379c:	48 83 fa 0f          	cmp    $0xf,%rdx
  80416037a0:	77 4b                	ja     80416037ed <naive_address_by_fname+0x674>
        if (initial_len == DW_EXT_DWARF64) {
  80416037a2:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80416037a7:	48 39 d0             	cmp    %rdx,%rax
  80416037aa:	0f 84 18 fa ff ff    	je     80416031c8 <naive_address_by_fname+0x4f>
            cprintf("Unknown DWARF extension\n");
  80416037b0:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  80416037b7:	00 00 00 
  80416037ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80416037bf:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  80416037c6:	00 00 00 
  80416037c9:	ff d2                	call   *%rdx
        if (!count) return -E_BAD_DWARF;
  80416037cb:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
}
  80416037d0:	48 83 c4 48          	add    $0x48,%rsp
  80416037d4:	5b                   	pop    %rbx
  80416037d5:	41 5c                	pop    %r12
  80416037d7:	41 5d                	pop    %r13
  80416037d9:	41 5e                	pop    %r14
  80416037db:	41 5f                	pop    %r15
  80416037dd:	5d                   	pop    %rbp
  80416037de:	c3                   	ret    
    return -E_NO_ENT;
  80416037df:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80416037e4:	eb ea                	jmp    80416037d0 <naive_address_by_fname+0x657>
    if (!flen) return -E_INVAL;
  80416037e6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80416037eb:	eb e3                	jmp    80416037d0 <naive_address_by_fname+0x657>
    uint64_t count = sizeof(uint32_t);
  80416037ed:	bb 04 00 00 00       	mov    $0x4,%ebx
        entry += count;
  80416037f2:	49 01 df             	add    %rbx,%r15
        const uint8_t *entry_end = entry + len;
  80416037f5:	4c 01 f8             	add    %r15,%rax
  80416037f8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  80416037fc:	ba 02 00 00 00       	mov    $0x2,%edx
  8041603801:	4c 89 fe             	mov    %r15,%rsi
  8041603804:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603808:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160380f:	00 00 00 
  8041603812:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  8041603814:	49 8d 77 02          	lea    0x2(%r15),%rsi
        assert(version == 4 || version == 2);
  8041603818:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  804160381c:	83 e8 02             	sub    $0x2,%eax
  804160381f:	66 a9 fd ff          	test   $0xfffd,%ax
  8041603823:	0f 85 c6 f9 ff ff    	jne    80416031ef <naive_address_by_fname+0x76>
        Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  8041603829:	ba 04 00 00 00       	mov    $0x4,%edx
  804160382e:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603832:	48 bb b4 fe 60 41 80 	movabs $0x804160feb4,%rbx
  8041603839:	00 00 00 
  804160383c:	ff d3                	call   *%rbx
  804160383e:	44 8b 65 c8          	mov    -0x38(%rbp),%r12d
        /**/ entry += sizeof(uint32_t);
  8041603842:	49 8d 77 06          	lea    0x6(%r15),%rsi
        Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  8041603846:	ba 01 00 00 00       	mov    $0x1,%edx
  804160384b:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160384f:	ff d3                	call   *%rbx
        entry += sizeof(Dwarf_Small);
  8041603851:	49 83 c7 07          	add    $0x7,%r15
        assert(address_size == sizeof(uintptr_t));
  8041603855:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8041603859:	0f 85 c5 f9 ff ff    	jne    8041603224 <naive_address_by_fname+0xab>
        const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  804160385f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041603863:	4c 03 20             	add    (%rax),%r12
  8041603866:	4c 89 65 a8          	mov    %r12,-0x58(%rbp)
        while (entry < entry_end) {
  804160386a:	e9 0b fa ff ff       	jmp    804160327a <naive_address_by_fname+0x101>

000000804160386f <line_for_address>:
 * contain an offset in .debug_line of entry associated with compilation unit,
 * in which we search address `p`. This offset can be obtained from .debug_info
 * section, using the `file_name_by_info` function. */
int
line_for_address(const struct Dwarf_Addrs *addrs, uintptr_t p,
                 Dwarf_Off line_offset, int *lineno_store) {
  804160386f:	55                   	push   %rbp
  8041603870:	48 89 e5             	mov    %rsp,%rbp
  8041603873:	41 57                	push   %r15
  8041603875:	41 56                	push   %r14
  8041603877:	41 55                	push   %r13
  8041603879:	41 54                	push   %r12
  804160387b:	53                   	push   %rbx
  804160387c:	48 83 ec 48          	sub    $0x48,%rsp
  8041603880:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8041603884:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
    if (line_offset > addrs->line_end - addrs->line_begin)
  8041603888:	4c 8b 67 30          	mov    0x30(%rdi),%r12
  804160388c:	48 8b 47 38          	mov    0x38(%rdi),%rax
  8041603890:	4c 29 e0             	sub    %r12,%rax
        return -E_INVAL;
    if (!lineno_store)
  8041603893:	48 39 d0             	cmp    %rdx,%rax
  8041603896:	0f 82 3c 07 00 00    	jb     8041603fd8 <line_for_address+0x769>
  804160389c:	48 85 c9             	test   %rcx,%rcx
  804160389f:	0f 84 33 07 00 00    	je     8041603fd8 <line_for_address+0x769>
        return -E_INVAL;

    const void *curr_addr = addrs->line_begin + line_offset;
  80416038a5:	49 01 d4             	add    %rdx,%r12
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80416038a8:	ba 04 00 00 00       	mov    $0x4,%edx
  80416038ad:	4c 89 e6             	mov    %r12,%rsi
  80416038b0:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416038b4:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416038bb:	00 00 00 
  80416038be:	ff d0                	call   *%rax
  80416038c0:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80416038c3:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  80416038ca:	ff ff ff 
  80416038cd:	48 01 d0             	add    %rdx,%rax
  80416038d0:	48 83 f8 0f          	cmp    $0xf,%rax
  80416038d4:	0f 87 d0 07 00 00    	ja     80416040aa <line_for_address+0x83b>
        if (initial_len == DW_EXT_DWARF64) {
  80416038da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80416038df:	48 39 c2             	cmp    %rax,%rdx
  80416038e2:	74 25                	je     8041603909 <line_for_address+0x9a>
            cprintf("Unknown DWARF extension\n");
  80416038e4:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  80416038eb:	00 00 00 
  80416038ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80416038f3:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  80416038fa:	00 00 00 
  80416038fd:	ff d2                	call   *%rdx
    uint64_t unit_length = 0;
    uint32_t count;

    curr_addr += count = dwarf_entry_len(curr_addr, &unit_length);
    if (!count)
        return -E_BAD_DWARF;
  80416038ff:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8041603904:	e9 c0 06 00 00       	jmp    8041603fc9 <line_for_address+0x75a>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041603909:	49 8d 74 24 20       	lea    0x20(%r12),%rsi
  804160390e:	ba 08 00 00 00       	mov    $0x8,%edx
  8041603913:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603917:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160391e:	00 00 00 
  8041603921:	ff d0                	call   *%rax
  8041603923:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
            count += sizeof(uint64_t);
  8041603927:	b8 0c 00 00 00       	mov    $0xc,%eax
  804160392c:	e9 7e 07 00 00       	jmp    80416040af <line_for_address+0x840>

    const void *unit_end = curr_addr + unit_length;
    Dwarf_Half version = get_unaligned(curr_addr, Dwarf_Half);
    curr_addr += sizeof(Dwarf_Half);
    assert(version == 4 || version == 3 || version == 2);
  8041603931:	48 b9 f8 15 61 41 80 	movabs $0x80416115f8,%rcx
  8041603938:	00 00 00 
  804160393b:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041603942:	00 00 00 
  8041603945:	be dd 00 00 00       	mov    $0xdd,%esi
  804160394a:	48 bf b1 15 61 41 80 	movabs $0x80416115b1,%rdi
  8041603951:	00 00 00 
  8041603954:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603959:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041603960:	00 00 00 
  8041603963:	41 ff d0             	call   *%r8
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8041603966:	49 8d 74 24 22       	lea    0x22(%r12),%rsi
  804160396b:	ba 08 00 00 00       	mov    $0x8,%edx
  8041603970:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603974:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160397b:	00 00 00 
  804160397e:	ff d0                	call   *%rax
  8041603980:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
            count += sizeof(uint64_t);
  8041603984:	b8 0c 00 00 00       	mov    $0xc,%eax
  8041603989:	e9 56 06 00 00       	jmp    8041603fe4 <line_for_address+0x775>
        return -E_BAD_DWARF;

    const uint8_t *program_addr = curr_addr + header_length;
    Dwarf_Small minimum_instruction_length =
            get_unaligned(curr_addr, Dwarf_Small);
    assert(minimum_instruction_length == 1);
  804160398e:	48 b9 28 16 61 41 80 	movabs $0x8041611628,%rcx
  8041603995:	00 00 00 
  8041603998:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160399f:	00 00 00 
  80416039a2:	be e7 00 00 00       	mov    $0xe7,%esi
  80416039a7:	48 bf b1 15 61 41 80 	movabs $0x80416115b1,%rdi
  80416039ae:	00 00 00 
  80416039b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80416039b6:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416039bd:	00 00 00 
  80416039c0:	41 ff d0             	call   *%r8
    curr_addr += sizeof(Dwarf_Small);

    Dwarf_Small maximum_operations_per_instruction;
    if (version == 4) {
        maximum_operations_per_instruction = get_unaligned(curr_addr, Dwarf_Small);
  80416039c3:	ba 01 00 00 00       	mov    $0x1,%edx
  80416039c8:	4c 89 e6             	mov    %r12,%rsi
  80416039cb:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416039cf:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416039d6:	00 00 00 
  80416039d9:	ff d0                	call   *%rax
        curr_addr += sizeof(Dwarf_Small);
  80416039db:	4d 8d 65 02          	lea    0x2(%r13),%r12
    } else {
        maximum_operations_per_instruction = 1;
    }
    assert(maximum_operations_per_instruction == 1);
  80416039df:	80 7d c8 01          	cmpb   $0x1,-0x38(%rbp)
  80416039e3:	0f 84 32 06 00 00    	je     804160401b <line_for_address+0x7ac>
  80416039e9:	48 b9 48 16 61 41 80 	movabs $0x8041611648,%rcx
  80416039f0:	00 00 00 
  80416039f3:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416039fa:	00 00 00 
  80416039fd:	be f1 00 00 00       	mov    $0xf1,%esi
  8041603a02:	48 bf b1 15 61 41 80 	movabs $0x80416115b1,%rdi
  8041603a09:	00 00 00 
  8041603a0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603a11:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041603a18:	00 00 00 
  8041603a1b:	41 ff d0             	call   *%r8
  8041603a1e:	48 89 f0             	mov    %rsi,%rax
    size_t shift = 0, count = 0;
  8041603a21:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8041603a26:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  8041603a2c:	49 89 d8             	mov    %rbx,%r8
        byte = *addr++;
  8041603a2f:	48 83 c0 01          	add    $0x1,%rax
  8041603a33:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8041603a37:	48 89 fa             	mov    %rdi,%rdx
  8041603a3a:	83 e2 7f             	and    $0x7f,%edx
  8041603a3d:	48 d3 e2             	shl    %cl,%rdx
  8041603a40:	49 09 d4             	or     %rdx,%r12
        shift += 7;
  8041603a43:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603a47:	4c 8d 48 ff          	lea    -0x1(%rax),%r9
  8041603a4b:	4c 89 ca             	mov    %r9,%rdx
  8041603a4e:	48 29 da             	sub    %rbx,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603a51:	40 84 ff             	test   %dil,%dil
  8041603a54:	79 06                	jns    8041603a5c <line_for_address+0x1ed>
  8041603a56:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603a5a:	76 d3                	jbe    8041603a2f <line_for_address+0x1c0>
    while (byte & 0x80) {
  8041603a5c:	40 84 ff             	test   %dil,%dil
  8041603a5f:	79 12                	jns    8041603a73 <line_for_address+0x204>
        byte = *addr++;
  8041603a61:	4d 29 c8             	sub    %r9,%r8
  8041603a64:	4c 01 c0             	add    %r8,%rax
  8041603a67:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041603a6b:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603a6f:	84 c9                	test   %cl,%cl
  8041603a71:	78 f4                	js     8041603a67 <line_for_address+0x1f8>
            program_addr += count;
  8041603a73:	89 d2                	mov    %edx,%edx
  8041603a75:	4c 8d 2c 16          	lea    (%rsi,%rdx,1),%r13
            const uint8_t *opcode_end = program_addr + length;
  8041603a79:	4d 01 ec             	add    %r13,%r12
            opcode = get_unaligned(program_addr, Dwarf_Small);
  8041603a7c:	ba 01 00 00 00       	mov    $0x1,%edx
  8041603a81:	4c 89 ee             	mov    %r13,%rsi
  8041603a84:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603a88:	41 ff d7             	call   *%r15
  8041603a8b:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
            program_addr += sizeof(Dwarf_Small);
  8041603a8f:	49 8d 5d 01          	lea    0x1(%r13),%rbx
            switch (opcode) {
  8041603a93:	3c 03                	cmp    $0x3,%al
  8041603a95:	0f 84 ef 00 00 00    	je     8041603b8a <line_for_address+0x31b>
  8041603a9b:	77 65                	ja     8041603b02 <line_for_address+0x293>
  8041603a9d:	3c 01                	cmp    $0x1,%al
  8041603a9f:	0f 84 af 00 00 00    	je     8041603b54 <line_for_address+0x2e5>
  8041603aa5:	3c 02                	cmp    $0x2,%al
  8041603aa7:	0f 85 bb 01 00 00    	jne    8041603c68 <line_for_address+0x3f9>
                state->address = get_unaligned(program_addr, uintptr_t);
  8041603aad:	ba 08 00 00 00       	mov    $0x8,%edx
  8041603ab2:	48 89 de             	mov    %rbx,%rsi
  8041603ab5:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603ab9:	41 ff d7             	call   *%r15
  8041603abc:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
                program_addr += sizeof(uintptr_t);
  8041603ac0:	49 8d 5d 09          	lea    0x9(%r13),%rbx
            assert(program_addr == opcode_end);
  8041603ac4:	49 39 dc             	cmp    %rbx,%r12
  8041603ac7:	0f 84 79 04 00 00    	je     8041603f46 <line_for_address+0x6d7>
  8041603acd:	48 b9 d7 15 61 41 80 	movabs $0x80416115d7,%rcx
  8041603ad4:	00 00 00 
  8041603ad7:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041603ade:	00 00 00 
  8041603ae1:	be 61 00 00 00       	mov    $0x61,%esi
  8041603ae6:	48 bf b1 15 61 41 80 	movabs $0x80416115b1,%rdi
  8041603aed:	00 00 00 
  8041603af0:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603af5:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041603afc:	00 00 00 
  8041603aff:	41 ff d0             	call   *%r8
            switch (opcode) {
  8041603b02:	3c 04                	cmp    $0x4,%al
  8041603b04:	0f 85 5e 01 00 00    	jne    8041603c68 <line_for_address+0x3f9>
  8041603b0a:	48 89 d8             	mov    %rbx,%rax
  8041603b0d:	b9 00 00 00 00       	mov    $0x0,%ecx
        byte = *addr++;
  8041603b12:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8041603b16:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603b1a:	48 8d 78 ff          	lea    -0x1(%rax),%rdi
  8041603b1e:	48 89 fa             	mov    %rdi,%rdx
  8041603b21:	4c 29 ea             	sub    %r13,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603b24:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
  8041603b28:	40 84 f6             	test   %sil,%sil
  8041603b2b:	79 06                	jns    8041603b33 <line_for_address+0x2c4>
  8041603b2d:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603b31:	76 df                	jbe    8041603b12 <line_for_address+0x2a3>
    while (byte & 0x80) {
  8041603b33:	40 84 f6             	test   %sil,%sil
  8041603b36:	79 12                	jns    8041603b4a <line_for_address+0x2db>
        byte = *addr++;
  8041603b38:	49 29 fd             	sub    %rdi,%r13
  8041603b3b:	4c 01 e8             	add    %r13,%rax
  8041603b3e:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041603b42:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603b46:	84 c9                	test   %cl,%cl
  8041603b48:	78 f4                	js     8041603b3e <line_for_address+0x2cf>
                program_addr += count;
  8041603b4a:	89 d2                	mov    %edx,%edx
  8041603b4c:	48 01 d3             	add    %rdx,%rbx
            } break;
  8041603b4f:	e9 70 ff ff ff       	jmp    8041603ac4 <line_for_address+0x255>
                if (last_state.address <= destination_addr &&
  8041603b54:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8041603b58:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  8041603b5c:	48 39 f0             	cmp    %rsi,%rax
  8041603b5f:	0f 82 31 01 00 00    	jb     8041603c96 <line_for_address+0x427>
  8041603b65:	4c 39 f0             	cmp    %r14,%rax
  8041603b68:	0f 82 37 04 00 00    	jb     8041603fa5 <line_for_address+0x736>
                last_state = *state;
  8041603b6e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8041603b71:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8041603b74:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
                *state = (struct Line_Number_State){
  8041603b78:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  8041603b7f:	41 be 00 00 00 00    	mov    $0x0,%r14d
  8041603b85:	e9 3a ff ff ff       	jmp    8041603ac4 <line_for_address+0x255>
                while (*program_addr++)
  8041603b8a:	48 83 c3 01          	add    $0x1,%rbx
  8041603b8e:	80 7b ff 00          	cmpb   $0x0,-0x1(%rbx)
  8041603b92:	75 f6                	jne    8041603b8a <line_for_address+0x31b>
  8041603b94:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041603b97:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603b9c:	b9 00 00 00 00       	mov    $0x0,%ecx
        byte = *addr++;
  8041603ba1:	48 83 c2 01          	add    $0x1,%rdx
        shift += 7;
  8041603ba5:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603ba9:	48 89 c7             	mov    %rax,%rdi
  8041603bac:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041603bb0:	0f b6 72 ff          	movzbl -0x1(%rdx),%esi
  8041603bb4:	40 84 f6             	test   %sil,%sil
  8041603bb7:	79 06                	jns    8041603bbf <line_for_address+0x350>
  8041603bb9:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603bbd:	76 e2                	jbe    8041603ba1 <line_for_address+0x332>
    while (byte & 0x80) {
  8041603bbf:	40 84 f6             	test   %sil,%sil
  8041603bc2:	79 12                	jns    8041603bd6 <line_for_address+0x367>
        byte = *addr++;
  8041603bc4:	48 f7 d7             	not    %rdi
  8041603bc7:	48 01 fa             	add    %rdi,%rdx
  8041603bca:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041603bce:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041603bd2:	84 c9                	test   %cl,%cl
  8041603bd4:	78 f4                	js     8041603bca <line_for_address+0x35b>
                program_addr += dwarf_read_uleb128(program_addr, &dir_index);
  8041603bd6:	48 01 c3             	add    %rax,%rbx
  8041603bd9:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8041603bdc:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603be1:	b9 00 00 00 00       	mov    $0x0,%ecx
        byte = *addr++;
  8041603be6:	48 83 c2 01          	add    $0x1,%rdx
        shift += 7;
  8041603bea:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603bee:	48 89 c7             	mov    %rax,%rdi
  8041603bf1:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8041603bf5:	0f b6 72 ff          	movzbl -0x1(%rdx),%esi
  8041603bf9:	40 84 f6             	test   %sil,%sil
  8041603bfc:	79 06                	jns    8041603c04 <line_for_address+0x395>
  8041603bfe:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603c02:	76 e2                	jbe    8041603be6 <line_for_address+0x377>
    while (byte & 0x80) {
  8041603c04:	40 84 f6             	test   %sil,%sil
  8041603c07:	79 12                	jns    8041603c1b <line_for_address+0x3ac>
        byte = *addr++;
  8041603c09:	48 f7 d7             	not    %rdi
  8041603c0c:	48 01 fa             	add    %rdi,%rdx
  8041603c0f:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8041603c13:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8041603c17:	84 c9                	test   %cl,%cl
  8041603c19:	78 f4                	js     8041603c0f <line_for_address+0x3a0>
                program_addr += dwarf_read_uleb128(program_addr, &last_mod);
  8041603c1b:	48 01 d8             	add    %rbx,%rax
  8041603c1e:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8041603c21:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041603c26:	b9 00 00 00 00       	mov    $0x0,%ecx
        byte = *addr++;
  8041603c2b:	48 83 c2 01          	add    $0x1,%rdx
        shift += 7;
  8041603c2f:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603c33:	48 89 df             	mov    %rbx,%rdi
  8041603c36:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8041603c3a:	0f b6 72 ff          	movzbl -0x1(%rdx),%esi
  8041603c3e:	40 84 f6             	test   %sil,%sil
  8041603c41:	79 06                	jns    8041603c49 <line_for_address+0x3da>
  8041603c43:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603c47:	76 e2                	jbe    8041603c2b <line_for_address+0x3bc>
    while (byte & 0x80) {
  8041603c49:	40 84 f6             	test   %sil,%sil
  8041603c4c:	79 12                	jns    8041603c60 <line_for_address+0x3f1>
        byte = *addr++;
  8041603c4e:	48 f7 d7             	not    %rdi
  8041603c51:	48 01 fa             	add    %rdi,%rdx
  8041603c54:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8041603c58:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8041603c5c:	84 c9                	test   %cl,%cl
  8041603c5e:	78 f4                	js     8041603c54 <line_for_address+0x3e5>
                program_addr += dwarf_read_uleb128(program_addr, &length);
  8041603c60:	48 01 c3             	add    %rax,%rbx
            } break;
  8041603c63:	e9 5c fe ff ff       	jmp    8041603ac4 <line_for_address+0x255>
            switch (opcode) {
  8041603c68:	0f b6 c8             	movzbl %al,%ecx
                panic("Unknown opcode: %x", opcode);
  8041603c6b:	48 ba c4 15 61 41 80 	movabs $0x80416115c4,%rdx
  8041603c72:	00 00 00 
  8041603c75:	be 5e 00 00 00       	mov    $0x5e,%esi
  8041603c7a:	48 bf b1 15 61 41 80 	movabs $0x80416115b1,%rdi
  8041603c81:	00 00 00 
  8041603c84:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603c89:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041603c90:	00 00 00 
  8041603c93:	41 ff d0             	call   *%r8
                last_state = *state;
  8041603c96:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8041603c99:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8041603c9c:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
                *state = (struct Line_Number_State){
  8041603ca0:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  8041603ca7:	41 be 00 00 00 00    	mov    $0x0,%r14d
  8041603cad:	e9 12 fe ff ff       	jmp    8041603ac4 <line_for_address+0x255>
                if (last_state.address <= destination_addr &&
  8041603cb2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8041603cb6:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  8041603cba:	48 39 d8             	cmp    %rbx,%rax
  8041603cbd:	0f 82 ca 02 00 00    	jb     8041603f8d <line_for_address+0x71e>
  8041603cc3:	4c 39 f0             	cmp    %r14,%rax
  8041603cc6:	0f 82 e1 02 00 00    	jb     8041603fad <line_for_address+0x73e>
                last_state = *state;
  8041603ccc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8041603ccf:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8041603cd2:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
        program_addr += sizeof(Dwarf_Small);
  8041603cd6:	48 89 f3             	mov    %rsi,%rbx
  8041603cd9:	e9 68 02 00 00       	jmp    8041603f46 <line_for_address+0x6d7>
            switch (opcode) {
  8041603cde:	48 89 f0             	mov    %rsi,%rax
  8041603ce1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041603ce6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8041603cec:	49 89 d9             	mov    %rbx,%r9
        byte = *addr++;
  8041603cef:	48 83 c0 01          	add    $0x1,%rax
  8041603cf3:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8041603cf7:	48 89 fa             	mov    %rdi,%rdx
  8041603cfa:	83 e2 7f             	and    $0x7f,%edx
  8041603cfd:	48 d3 e2             	shl    %cl,%rdx
  8041603d00:	49 09 d0             	or     %rdx,%r8
        shift += 7;
  8041603d03:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603d07:	4c 8d 50 ff          	lea    -0x1(%rax),%r10
  8041603d0b:	4c 89 d2             	mov    %r10,%rdx
  8041603d0e:	48 29 da             	sub    %rbx,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603d11:	40 84 ff             	test   %dil,%dil
  8041603d14:	79 06                	jns    8041603d1c <line_for_address+0x4ad>
  8041603d16:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603d1a:	76 d3                	jbe    8041603cef <line_for_address+0x480>
    while (byte & 0x80) {
  8041603d1c:	40 84 ff             	test   %dil,%dil
  8041603d1f:	79 12                	jns    8041603d33 <line_for_address+0x4c4>
        byte = *addr++;
  8041603d21:	4d 29 d1             	sub    %r10,%r9
  8041603d24:	4c 01 c8             	add    %r9,%rax
  8041603d27:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041603d2b:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603d2f:	84 c9                	test   %cl,%cl
  8041603d31:	78 f4                	js     8041603d27 <line_for_address+0x4b8>
                state->address += info->minimum_instruction_length *
  8041603d33:	4d 01 c6             	add    %r8,%r14
                program_addr += count;
  8041603d36:	89 d2                	mov    %edx,%edx
  8041603d38:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8041603d3c:	e9 05 02 00 00       	jmp    8041603f46 <line_for_address+0x6d7>
            switch (opcode) {
  8041603d41:	48 89 f0             	mov    %rsi,%rax
  8041603d44:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8041603d4a:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041603d4f:	49 89 d9             	mov    %rbx,%r9
        byte = *addr++;
  8041603d52:	48 83 c0 01          	add    $0x1,%rax
  8041603d56:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8041603d5a:	48 89 fa             	mov    %rdi,%rdx
  8041603d5d:	83 e2 7f             	and    $0x7f,%edx
  8041603d60:	48 d3 e2             	shl    %cl,%rdx
  8041603d63:	49 09 d0             	or     %rdx,%r8
        shift += 7;
  8041603d66:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603d6a:	4c 8d 50 ff          	lea    -0x1(%rax),%r10
  8041603d6e:	4c 89 d2             	mov    %r10,%rdx
  8041603d71:	48 29 da             	sub    %rbx,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603d74:	40 84 ff             	test   %dil,%dil
  8041603d77:	79 06                	jns    8041603d7f <line_for_address+0x510>
  8041603d79:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603d7d:	76 d3                	jbe    8041603d52 <line_for_address+0x4e3>
    while (byte & 0x80) {
  8041603d7f:	40 84 ff             	test   %dil,%dil
  8041603d82:	79 21                	jns    8041603da5 <line_for_address+0x536>
        byte = *addr++;
  8041603d84:	4d 29 d1             	sub    %r10,%r9
  8041603d87:	4c 01 c8             	add    %r9,%rax
  8041603d8a:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041603d8e:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603d92:	84 c9                	test   %cl,%cl
  8041603d94:	78 f4                	js     8041603d8a <line_for_address+0x51b>
                state->line += (int)line_incr;
  8041603d96:	44 01 45 b8          	add    %r8d,-0x48(%rbp)
                program_addr += count;
  8041603d9a:	89 d2                	mov    %edx,%edx
  8041603d9c:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8041603da0:	e9 a1 01 00 00       	jmp    8041603f46 <line_for_address+0x6d7>
    if (shift < 8 * sizeof(result) && byte & 0x40)
  8041603da5:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603da9:	77 eb                	ja     8041603d96 <line_for_address+0x527>
  8041603dab:	40 f6 c7 40          	test   $0x40,%dil
  8041603daf:	74 e5                	je     8041603d96 <line_for_address+0x527>
        result |= (-1U << shift);
  8041603db1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8041603db6:	d3 e0                	shl    %cl,%eax
  8041603db8:	49 09 c0             	or     %rax,%r8
  8041603dbb:	eb d9                	jmp    8041603d96 <line_for_address+0x527>
            switch (opcode) {
  8041603dbd:	48 89 f0             	mov    %rsi,%rax
  8041603dc0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041603dc5:	49 89 d9             	mov    %rbx,%r9
        byte = *addr++;
  8041603dc8:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8041603dcc:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603dd0:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
  8041603dd4:	4c 89 c2             	mov    %r8,%rdx
  8041603dd7:	48 29 da             	sub    %rbx,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603dda:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
  8041603dde:	40 84 ff             	test   %dil,%dil
  8041603de1:	79 06                	jns    8041603de9 <line_for_address+0x57a>
  8041603de3:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603de7:	76 df                	jbe    8041603dc8 <line_for_address+0x559>
    while (byte & 0x80) {
  8041603de9:	40 84 ff             	test   %dil,%dil
  8041603dec:	79 15                	jns    8041603e03 <line_for_address+0x594>
        byte = *addr++;
  8041603dee:	4c 89 c9             	mov    %r9,%rcx
  8041603df1:	4c 29 c1             	sub    %r8,%rcx
  8041603df4:	48 01 c8             	add    %rcx,%rax
  8041603df7:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041603dfb:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603dff:	84 c9                	test   %cl,%cl
  8041603e01:	78 f4                	js     8041603df7 <line_for_address+0x588>
                program_addr += count;
  8041603e03:	89 d2                	mov    %edx,%edx
  8041603e05:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8041603e09:	e9 38 01 00 00       	jmp    8041603f46 <line_for_address+0x6d7>
            switch (opcode) {
  8041603e0e:	48 89 f0             	mov    %rsi,%rax
  8041603e11:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041603e16:	49 89 d9             	mov    %rbx,%r9
        byte = *addr++;
  8041603e19:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8041603e1d:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603e21:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
  8041603e25:	4c 89 c2             	mov    %r8,%rdx
  8041603e28:	48 29 da             	sub    %rbx,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603e2b:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
  8041603e2f:	40 84 ff             	test   %dil,%dil
  8041603e32:	79 06                	jns    8041603e3a <line_for_address+0x5cb>
  8041603e34:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603e38:	76 df                	jbe    8041603e19 <line_for_address+0x5aa>
    while (byte & 0x80) {
  8041603e3a:	40 84 ff             	test   %dil,%dil
  8041603e3d:	79 15                	jns    8041603e54 <line_for_address+0x5e5>
        byte = *addr++;
  8041603e3f:	4c 89 c9             	mov    %r9,%rcx
  8041603e42:	4c 29 c1             	sub    %r8,%rcx
  8041603e45:	48 01 c8             	add    %rcx,%rax
  8041603e48:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041603e4c:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603e50:	84 c9                	test   %cl,%cl
  8041603e52:	78 f4                	js     8041603e48 <line_for_address+0x5d9>
                program_addr += count;
  8041603e54:	89 d2                	mov    %edx,%edx
  8041603e56:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8041603e5a:	e9 e7 00 00 00       	jmp    8041603f46 <line_for_address+0x6d7>
                int op_advance = adjusted_opcode / info->line_range;
  8041603e5f:	0f b7 45 9a          	movzwl -0x66(%rbp),%eax
  8041603e63:	f6 75 be             	divb   -0x42(%rbp)
                state->address += info->minimum_instruction_length *
  8041603e66:	0f b6 c0             	movzbl %al,%eax
  8041603e69:	49 01 c6             	add    %rax,%r14
        program_addr += sizeof(Dwarf_Small);
  8041603e6c:	48 89 f3             	mov    %rsi,%rbx
            } break;
  8041603e6f:	e9 d2 00 00 00       	jmp    8041603f46 <line_for_address+0x6d7>
                state->address += get_unaligned(program_addr, Dwarf_Half);
  8041603e74:	ba 02 00 00 00       	mov    $0x2,%edx
  8041603e79:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603e7d:	41 ff d7             	call   *%r15
  8041603e80:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8041603e84:	49 01 c6             	add    %rax,%r14
                program_addr += sizeof(Dwarf_Half);
  8041603e87:	48 83 c3 03          	add    $0x3,%rbx
            } break;
  8041603e8b:	e9 b6 00 00 00       	jmp    8041603f46 <line_for_address+0x6d7>
            switch (opcode) {
  8041603e90:	48 89 f0             	mov    %rsi,%rax
  8041603e93:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041603e98:	49 89 d9             	mov    %rbx,%r9
        byte = *addr++;
  8041603e9b:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8041603e9f:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8041603ea3:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
  8041603ea7:	4c 89 c2             	mov    %r8,%rdx
  8041603eaa:	48 29 da             	sub    %rbx,%rdx
    } while (byte & 0x80 && shift < 64);
  8041603ead:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
  8041603eb1:	40 84 ff             	test   %dil,%dil
  8041603eb4:	79 06                	jns    8041603ebc <line_for_address+0x64d>
  8041603eb6:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8041603eba:	76 df                	jbe    8041603e9b <line_for_address+0x62c>
    while (byte & 0x80) {
  8041603ebc:	40 84 ff             	test   %dil,%dil
  8041603ebf:	79 15                	jns    8041603ed6 <line_for_address+0x667>
        byte = *addr++;
  8041603ec1:	4c 89 c9             	mov    %r9,%rcx
  8041603ec4:	4c 29 c1             	sub    %r8,%rcx
  8041603ec7:	48 01 c8             	add    %rcx,%rax
  8041603eca:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8041603ece:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8041603ed2:	84 c9                	test   %cl,%cl
  8041603ed4:	78 f4                	js     8041603eca <line_for_address+0x65b>
                program_addr += count;
  8041603ed6:	89 d2                	mov    %edx,%edx
  8041603ed8:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8041603edc:	eb 68                	jmp    8041603f46 <line_for_address+0x6d7>
            switch (opcode) {
  8041603ede:	0f b6 c8             	movzbl %al,%ecx
                panic("Unknown opcode: %x", opcode);
  8041603ee1:	48 ba c4 15 61 41 80 	movabs $0x80416115c4,%rdx
  8041603ee8:	00 00 00 
  8041603eeb:	be a5 00 00 00       	mov    $0xa5,%esi
  8041603ef0:	48 bf b1 15 61 41 80 	movabs $0x80416115b1,%rdi
  8041603ef7:	00 00 00 
  8041603efa:	b8 00 00 00 00       	mov    $0x0,%eax
  8041603eff:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041603f06:	00 00 00 
  8041603f09:	41 ff d0             	call   *%r8
            Dwarf_Small adjusted_opcode = opcode - info->opcode_base;
  8041603f0c:	2a 45 bf             	sub    -0x41(%rbp),%al
            state->line += (info->line_base + (adjusted_opcode % info->line_range));
  8041603f0f:	0f b6 c0             	movzbl %al,%eax
  8041603f12:	f6 75 be             	divb   -0x42(%rbp)
  8041603f15:	0f b6 d4             	movzbl %ah,%edx
  8041603f18:	0f be 4d bd          	movsbl -0x43(%rbp),%ecx
  8041603f1c:	01 ca                	add    %ecx,%edx
  8041603f1e:	01 55 b8             	add    %edx,-0x48(%rbp)
            state->address += info->minimum_instruction_length *
  8041603f21:	0f b6 c0             	movzbl %al,%eax
  8041603f24:	49 01 c6             	add    %rax,%r14
            if (last_state.address <= destination_addr && destination_addr < state->address) {
  8041603f27:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8041603f2b:	4c 39 f0             	cmp    %r14,%rax
  8041603f2e:	73 09                	jae    8041603f39 <line_for_address+0x6ca>
  8041603f30:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  8041603f34:	48 39 d8             	cmp    %rbx,%rax
  8041603f37:	73 7c                	jae    8041603fb5 <line_for_address+0x746>
            last_state = *state;
  8041603f39:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8041603f3c:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8041603f3f:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
        program_addr += sizeof(Dwarf_Small);
  8041603f43:	48 89 f3             	mov    %rsi,%rbx
    while (program_addr < end_addr) {
  8041603f46:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  8041603f4a:	76 6f                	jbe    8041603fbb <line_for_address+0x74c>
        Dwarf_Small opcode = get_unaligned(program_addr, Dwarf_Small);
  8041603f4c:	ba 01 00 00 00       	mov    $0x1,%edx
  8041603f51:	48 89 de             	mov    %rbx,%rsi
  8041603f54:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603f58:	41 ff d7             	call   *%r15
  8041603f5b:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
        program_addr += sizeof(Dwarf_Small);
  8041603f5f:	48 8d 73 01          	lea    0x1(%rbx),%rsi
        if (opcode == 0) {
  8041603f63:	84 c0                	test   %al,%al
  8041603f65:	0f 84 b3 fa ff ff    	je     8041603a1e <line_for_address+0x1af>
        } else if (opcode < info->opcode_base) {
  8041603f6b:	38 45 bf             	cmp    %al,-0x41(%rbp)
  8041603f6e:	76 9c                	jbe    8041603f0c <line_for_address+0x69d>
            switch (opcode) {
  8041603f70:	3c 0c                	cmp    $0xc,%al
  8041603f72:	0f 87 66 ff ff ff    	ja     8041603ede <line_for_address+0x66f>
  8041603f78:	0f b6 d0             	movzbl %al,%edx
  8041603f7b:	48 bf 70 16 61 41 80 	movabs $0x8041611670,%rdi
  8041603f82:	00 00 00 
  8041603f85:	ff 24 d7             	jmp    *(%rdi,%rdx,8)
  8041603f88:	48 89 f3             	mov    %rsi,%rbx
  8041603f8b:	eb b9                	jmp    8041603f46 <line_for_address+0x6d7>
                last_state = *state;
  8041603f8d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8041603f90:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8041603f93:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
        program_addr += sizeof(Dwarf_Small);
  8041603f97:	48 89 f3             	mov    %rsi,%rbx
  8041603f9a:	eb aa                	jmp    8041603f46 <line_for_address+0x6d7>
    struct Line_Number_State current_state = {
  8041603f9c:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  8041603fa3:	eb 16                	jmp    8041603fbb <line_for_address+0x74c>
                    *state = last_state;
  8041603fa5:	8b 45 9c             	mov    -0x64(%rbp),%eax
  8041603fa8:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8041603fab:	eb 0e                	jmp    8041603fbb <line_for_address+0x74c>
                    *state = last_state;
  8041603fad:	8b 45 9c             	mov    -0x64(%rbp),%eax
  8041603fb0:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8041603fb3:	eb 06                	jmp    8041603fbb <line_for_address+0x74c>
                *state = last_state;
  8041603fb5:	8b 45 9c             	mov    -0x64(%rbp),%eax
  8041603fb8:	89 45 b8             	mov    %eax,-0x48(%rbp)
            .standard_opcode_lengths = standard_opcode_lengths,
    };

    run_line_number_program(program_addr, unit_end, &info, &current_state, p);

    *lineno_store = current_state.line;
  8041603fbb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8041603fbf:	8b 75 b8             	mov    -0x48(%rbp),%esi
  8041603fc2:	89 30                	mov    %esi,(%rax)

    return 0;
  8041603fc4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8041603fc9:	48 83 c4 48          	add    $0x48,%rsp
  8041603fcd:	5b                   	pop    %rbx
  8041603fce:	41 5c                	pop    %r12
  8041603fd0:	41 5d                	pop    %r13
  8041603fd2:	41 5e                	pop    %r14
  8041603fd4:	41 5f                	pop    %r15
  8041603fd6:	5d                   	pop    %rbp
  8041603fd7:	c3                   	ret    
        return -E_INVAL;
  8041603fd8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8041603fdd:	eb ea                	jmp    8041603fc9 <line_for_address+0x75a>
    uint64_t count = sizeof(uint32_t);
  8041603fdf:	b8 04 00 00 00       	mov    $0x4,%eax
    curr_addr += count = dwarf_entry_len(curr_addr, &header_length);
  8041603fe4:	49 01 c5             	add    %rax,%r13
    const uint8_t *program_addr = curr_addr + header_length;
  8041603fe7:	4c 01 eb             	add    %r13,%rbx
            get_unaligned(curr_addr, Dwarf_Small);
  8041603fea:	ba 01 00 00 00       	mov    $0x1,%edx
  8041603fef:	4c 89 ee             	mov    %r13,%rsi
  8041603ff2:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041603ff6:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041603ffd:	00 00 00 
  8041604000:	ff d0                	call   *%rax
    assert(minimum_instruction_length == 1);
  8041604002:	80 7d c8 01          	cmpb   $0x1,-0x38(%rbp)
  8041604006:	0f 85 82 f9 ff ff    	jne    804160398e <line_for_address+0x11f>
    curr_addr += sizeof(Dwarf_Small);
  804160400c:	4d 8d 65 01          	lea    0x1(%r13),%r12
    if (version == 4) {
  8041604010:	66 41 83 fe 04       	cmp    $0x4,%r14w
  8041604015:	0f 84 a8 f9 ff ff    	je     80416039c3 <line_for_address+0x154>
    curr_addr += sizeof(Dwarf_Small);
  804160401b:	49 8d 74 24 01       	lea    0x1(%r12),%rsi
    int8_t line_base = get_unaligned(curr_addr, int8_t);
  8041604020:	ba 01 00 00 00       	mov    $0x1,%edx
  8041604025:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041604029:	49 bd b4 fe 60 41 80 	movabs $0x804160feb4,%r13
  8041604030:	00 00 00 
  8041604033:	41 ff d5             	call   *%r13
  8041604036:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  804160403a:	88 45 bd             	mov    %al,-0x43(%rbp)
    curr_addr += sizeof(int8_t);
  804160403d:	49 8d 74 24 02       	lea    0x2(%r12),%rsi
    Dwarf_Small line_range = get_unaligned(curr_addr, Dwarf_Small);
  8041604042:	ba 01 00 00 00       	mov    $0x1,%edx
  8041604047:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160404b:	41 ff d5             	call   *%r13
  804160404e:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  8041604052:	88 45 be             	mov    %al,-0x42(%rbp)
    curr_addr += sizeof(Dwarf_Small);
  8041604055:	49 8d 74 24 03       	lea    0x3(%r12),%rsi
    Dwarf_Small opcode_base = get_unaligned(curr_addr, Dwarf_Small);
  804160405a:	ba 01 00 00 00       	mov    $0x1,%edx
  804160405f:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8041604063:	41 ff d5             	call   *%r13
  8041604066:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  804160406a:	88 45 bf             	mov    %al,-0x41(%rbp)
    curr_addr += sizeof(Dwarf_Small);
  804160406d:	49 8d 74 24 04       	lea    0x4(%r12),%rsi
    Dwarf_Small *standard_opcode_lengths = (Dwarf_Small *)get_unaligned(curr_addr, Dwarf_Small *);
  8041604072:	ba 08 00 00 00       	mov    $0x8,%edx
  8041604077:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160407b:	41 ff d5             	call   *%r13
    while (program_addr < end_addr) {
  804160407e:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  8041604082:	0f 86 14 ff ff ff    	jbe    8041603f9c <line_for_address+0x72d>
    struct Line_Number_State current_state = {
  8041604088:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  804160408f:	41 be 00 00 00 00    	mov    $0x0,%r14d
        Dwarf_Small opcode = get_unaligned(program_addr, Dwarf_Small);
  8041604095:	4d 89 ef             	mov    %r13,%r15
                Dwarf_Small adjusted_opcode = opcode - info->opcode_base;
  8041604098:	0f b6 45 bf          	movzbl -0x41(%rbp),%eax
  804160409c:	f7 d0                	not    %eax
                int op_advance = adjusted_opcode / info->line_range;
  804160409e:	0f b6 c0             	movzbl %al,%eax
  80416040a1:	66 89 45 9a          	mov    %ax,-0x66(%rbp)
  80416040a5:	e9 a2 fe ff ff       	jmp    8041603f4c <line_for_address+0x6dd>
  80416040aa:	b8 04 00 00 00       	mov    $0x4,%eax
    curr_addr += count = dwarf_entry_len(curr_addr, &unit_length);
  80416040af:	49 01 c4             	add    %rax,%r12
    const void *unit_end = curr_addr + unit_length;
  80416040b2:	49 8d 04 14          	lea    (%r12,%rdx,1),%rax
  80416040b6:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    Dwarf_Half version = get_unaligned(curr_addr, Dwarf_Half);
  80416040ba:	ba 02 00 00 00       	mov    $0x2,%edx
  80416040bf:	4c 89 e6             	mov    %r12,%rsi
  80416040c2:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416040c6:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416040cd:	00 00 00 
  80416040d0:	ff d0                	call   *%rax
  80416040d2:	44 0f b7 75 c8       	movzwl -0x38(%rbp),%r14d
    curr_addr += sizeof(Dwarf_Half);
  80416040d7:	4d 8d 6c 24 02       	lea    0x2(%r12),%r13
    assert(version == 4 || version == 3 || version == 2);
  80416040dc:	41 8d 46 fe          	lea    -0x2(%r14),%eax
  80416040e0:	66 83 f8 02          	cmp    $0x2,%ax
  80416040e4:	0f 87 47 f8 ff ff    	ja     8041603931 <line_for_address+0xc2>
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80416040ea:	ba 04 00 00 00       	mov    $0x4,%edx
  80416040ef:	4c 89 ee             	mov    %r13,%rsi
  80416040f2:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80416040f6:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  80416040fd:	00 00 00 
  8041604100:	ff d0                	call   *%rax
  8041604102:	8b 5d c8             	mov    -0x38(%rbp),%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8041604105:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  804160410c:	ff ff ff 
  804160410f:	48 01 d8             	add    %rbx,%rax
  8041604112:	48 83 f8 0f          	cmp    $0xf,%rax
  8041604116:	0f 87 c3 fe ff ff    	ja     8041603fdf <line_for_address+0x770>
        if (initial_len == DW_EXT_DWARF64) {
  804160411c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8041604121:	48 39 c3             	cmp    %rax,%rbx
  8041604124:	0f 84 3c f8 ff ff    	je     8041603966 <line_for_address+0xf7>
            cprintf("Unknown DWARF extension\n");
  804160412a:	48 bf e0 13 61 41 80 	movabs $0x80416113e0,%rdi
  8041604131:	00 00 00 
  8041604134:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604139:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041604140:	00 00 00 
  8041604143:	ff d2                	call   *%rdx
        return -E_BAD_DWARF;
  8041604145:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  804160414a:	e9 7a fe ff ff       	jmp    8041603fc9 <line_for_address+0x75a>

000000804160414f <mon_junk>:
#define NCOMMANDS (sizeof(commands) / sizeof(commands[0]))

/* Implementations of basic kernel monitor commands */

int
mon_junk(int argc, char **argv, struct Trapframe *tf) {
  804160414f:	55                   	push   %rbp
  8041604150:	48 89 e5             	mov    %rsp,%rbp
    cprintf("Printing junk\n");
  8041604153:	48 bf d8 16 61 41 80 	movabs $0x80416116d8,%rdi
  804160415a:	00 00 00 
  804160415d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604162:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041604169:	00 00 00 
  804160416c:	ff d2                	call   *%rdx
    return 0;
}
  804160416e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604173:	5d                   	pop    %rbp
  8041604174:	c3                   	ret    

0000008041604175 <mon_help>:

int
mon_help(int argc, char **argv, struct Trapframe *tf) {
  8041604175:	55                   	push   %rbp
  8041604176:	48 89 e5             	mov    %rsp,%rbp
  8041604179:	41 55                	push   %r13
  804160417b:	41 54                	push   %r12
  804160417d:	53                   	push   %rbx
  804160417e:	48 83 ec 08          	sub    $0x8,%rsp
    for (size_t i = 0; i < NCOMMANDS; i++)
  8041604182:	48 bb a0 1a 61 41 80 	movabs $0x8041611aa0,%rbx
  8041604189:	00 00 00 
  804160418c:	4c 8d ab 38 01 00 00 	lea    0x138(%rbx),%r13
        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  8041604193:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  804160419a:	00 00 00 
  804160419d:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  80416041a1:	48 8b 33             	mov    (%rbx),%rsi
  80416041a4:	48 bf e7 16 61 41 80 	movabs $0x80416116e7,%rdi
  80416041ab:	00 00 00 
  80416041ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80416041b3:	41 ff d4             	call   *%r12
    for (size_t i = 0; i < NCOMMANDS; i++)
  80416041b6:	48 83 c3 18          	add    $0x18,%rbx
  80416041ba:	4c 39 eb             	cmp    %r13,%rbx
  80416041bd:	75 de                	jne    804160419d <mon_help+0x28>
    return 0;
}
  80416041bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80416041c4:	48 83 c4 08          	add    $0x8,%rsp
  80416041c8:	5b                   	pop    %rbx
  80416041c9:	41 5c                	pop    %r12
  80416041cb:	41 5d                	pop    %r13
  80416041cd:	5d                   	pop    %rbp
  80416041ce:	c3                   	ret    

00000080416041cf <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf) {
  80416041cf:	55                   	push   %rbp
  80416041d0:	48 89 e5             	mov    %rsp,%rbp
  80416041d3:	41 55                	push   %r13
  80416041d5:	41 54                	push   %r12
  80416041d7:	53                   	push   %rbx
  80416041d8:	48 83 ec 08          	sub    $0x8,%rsp
    extern char _head64[], entry[], etext[], edata[], end[];

    cprintf("Special kernel symbols:\n");
  80416041dc:	48 bf f0 16 61 41 80 	movabs $0x80416116f0,%rdi
  80416041e3:	00 00 00 
  80416041e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80416041eb:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  80416041f2:	00 00 00 
  80416041f5:	41 ff d4             	call   *%r12
    cprintf("  _head64 %16lx (virt)  %16lx (phys)\n", (unsigned long)_head64, (unsigned long)_head64);
  80416041f8:	48 be 00 00 50 01 00 	movabs $0x1500000,%rsi
  80416041ff:	00 00 00 
  8041604202:	48 89 f2             	mov    %rsi,%rdx
  8041604205:	48 bf b8 18 61 41 80 	movabs $0x80416118b8,%rdi
  804160420c:	00 00 00 
  804160420f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604214:	41 ff d4             	call   *%r12
    cprintf("  entry   %16lx (virt)  %16lx (phys)\n", (unsigned long)entry, (unsigned long)entry - KERN_BASE_ADDR);
  8041604217:	49 bd 00 00 60 41 80 	movabs $0x8041600000,%r13
  804160421e:	00 00 00 
  8041604221:	48 ba 00 00 60 01 00 	movabs $0x1600000,%rdx
  8041604228:	00 00 00 
  804160422b:	4c 89 ee             	mov    %r13,%rsi
  804160422e:	48 bf e0 18 61 41 80 	movabs $0x80416118e0,%rdi
  8041604235:	00 00 00 
  8041604238:	b8 00 00 00 00       	mov    $0x0,%eax
  804160423d:	41 ff d4             	call   *%r12
    cprintf("  etext   %16lx (virt)  %16lx (phys)\n", (unsigned long)etext, (unsigned long)etext - KERN_BASE_ADDR);
  8041604240:	48 ba a8 10 61 01 00 	movabs $0x16110a8,%rdx
  8041604247:	00 00 00 
  804160424a:	48 be a8 10 61 41 80 	movabs $0x80416110a8,%rsi
  8041604251:	00 00 00 
  8041604254:	48 bf 08 19 61 41 80 	movabs $0x8041611908,%rdi
  804160425b:	00 00 00 
  804160425e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604263:	41 ff d4             	call   *%r12
    cprintf("  edata   %16lx (virt)  %16lx (phys)\n", (unsigned long)edata, (unsigned long)edata - KERN_BASE_ADDR);
  8041604266:	48 ba 18 8a cc 01 00 	movabs $0x1cc8a18,%rdx
  804160426d:	00 00 00 
  8041604270:	48 be 18 8a cc 41 80 	movabs $0x8041cc8a18,%rsi
  8041604277:	00 00 00 
  804160427a:	48 bf 30 19 61 41 80 	movabs $0x8041611930,%rdi
  8041604281:	00 00 00 
  8041604284:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604289:	41 ff d4             	call   *%r12
    cprintf("  end     %16lx (virt)  %16lx (phys)\n", (unsigned long)end, (unsigned long)end - KERN_BASE_ADDR);
  804160428c:	48 bb 00 60 40 42 80 	movabs $0x8042406000,%rbx
  8041604293:	00 00 00 
  8041604296:	48 ba 00 60 40 02 00 	movabs $0x2406000,%rdx
  804160429d:	00 00 00 
  80416042a0:	48 89 de             	mov    %rbx,%rsi
  80416042a3:	48 bf 58 19 61 41 80 	movabs $0x8041611958,%rdi
  80416042aa:	00 00 00 
  80416042ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80416042b2:	41 ff d4             	call   *%r12
    cprintf("Kernel executable memory footprint: %luKB\n", (unsigned long)ROUNDUP(end - entry, 1024) / 1024);
  80416042b5:	4c 29 eb             	sub    %r13,%rbx
  80416042b8:	48 8d b3 ff 03 00 00 	lea    0x3ff(%rbx),%rsi
  80416042bf:	48 c1 ee 0a          	shr    $0xa,%rsi
  80416042c3:	48 bf 80 19 61 41 80 	movabs $0x8041611980,%rdi
  80416042ca:	00 00 00 
  80416042cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80416042d2:	41 ff d4             	call   *%r12
    return 0;
}
  80416042d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80416042da:	48 83 c4 08          	add    $0x8,%rsp
  80416042de:	5b                   	pop    %rbx
  80416042df:	41 5c                	pop    %r12
  80416042e1:	41 5d                	pop    %r13
  80416042e3:	5d                   	pop    %rbp
  80416042e4:	c3                   	ret    

00000080416042e5 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf) {
  80416042e5:	55                   	push   %rbp
  80416042e6:	48 89 e5             	mov    %rsp,%rbp
  80416042e9:	41 56                	push   %r14
  80416042eb:	41 55                	push   %r13
  80416042ed:	41 54                	push   %r12
  80416042ef:	53                   	push   %rbx
  80416042f0:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
}

static inline uint64_t __attribute__((always_inline))
read_rbp(void) {
    uint64_t rbp;
    asm volatile("movq %%rbp,%0"
  80416042f7:	49 89 ed             	mov    %rbp,%r13
    // LAB 2: Your code here
    uint64_t cur_rbp = read_rbp();
    uint64_t cur_rip = *((uint64_t*)(cur_rbp + sizeof(uintptr_t)));
  80416042fa:	4d 8b 65 08          	mov    0x8(%r13),%r12

    cprintf("Stack trace:\n");
  80416042fe:	48 bf 09 17 61 41 80 	movabs $0x8041611709,%rdi
  8041604305:	00 00 00 
  8041604308:	b8 00 00 00 00       	mov    $0x0,%eax
  804160430d:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041604314:	00 00 00 
  8041604317:	ff d2                	call   *%rdx
    struct Ripdebuginfo dbg_info;
    debuginfo_rip(cur_rip, &dbg_info);
  8041604319:	48 8d b5 c8 fd ff ff 	lea    -0x238(%rbp),%rsi
  8041604320:	4c 89 e7             	mov    %r12,%rdi
  8041604323:	48 b8 f6 ee 60 41 80 	movabs $0x804160eef6,%rax
  804160432a:	00 00 00 
  804160432d:	ff d0                	call   *%rax
    while (cur_rbp != 0) {
  804160432f:	4d 85 ed             	test   %r13,%r13
  8041604332:	74 77                	je     80416043ab <mon_backtrace+0xc6>
  8041604334:	4c 89 eb             	mov    %r13,%rbx

        cprintf(" rbp %016lx rip %016lx\n", cur_rbp, cur_rip);
  8041604337:	49 bd 99 c8 60 41 80 	movabs $0x804160c899,%r13
  804160433e:	00 00 00 
                                       dbg_info.rip_fn_name, 
                                       cur_rip - dbg_info.rip_fn_addr);
        cur_rbp =  *(uint64_t*)cur_rbp;
        cur_rip = *((uint64_t*)(cur_rbp + sizeof(uintptr_t)));
        if (cur_rbp != 0)
            debuginfo_rip(cur_rip, &dbg_info);
  8041604341:	49 be f6 ee 60 41 80 	movabs $0x804160eef6,%r14
  8041604348:	00 00 00 
  804160434b:	eb 11                	jmp    804160435e <mon_backtrace+0x79>
        cur_rip = *((uint64_t*)(cur_rbp + sizeof(uintptr_t)));
  804160434d:	4c 8b 63 08          	mov    0x8(%rbx),%r12
            debuginfo_rip(cur_rip, &dbg_info);
  8041604351:	48 8d b5 c8 fd ff ff 	lea    -0x238(%rbp),%rsi
  8041604358:	4c 89 e7             	mov    %r12,%rdi
  804160435b:	41 ff d6             	call   *%r14
        cprintf(" rbp %016lx rip %016lx\n", cur_rbp, cur_rip);
  804160435e:	4c 89 e2             	mov    %r12,%rdx
  8041604361:	48 89 de             	mov    %rbx,%rsi
  8041604364:	48 bf 17 17 61 41 80 	movabs $0x8041611717,%rdi
  804160436b:	00 00 00 
  804160436e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604373:	41 ff d5             	call   *%r13
        cprintf("   %s:%d: %s+%ld\n", dbg_info.rip_file, 
  8041604376:	4d 89 e0             	mov    %r12,%r8
  8041604379:	4c 2b 45 d0          	sub    -0x30(%rbp),%r8
  804160437d:	48 8d 8d cc fe ff ff 	lea    -0x134(%rbp),%rcx
  8041604384:	8b 95 c8 fe ff ff    	mov    -0x138(%rbp),%edx
  804160438a:	48 8d b5 c8 fd ff ff 	lea    -0x238(%rbp),%rsi
  8041604391:	48 bf 2f 17 61 41 80 	movabs $0x804161172f,%rdi
  8041604398:	00 00 00 
  804160439b:	b8 00 00 00 00       	mov    $0x0,%eax
  80416043a0:	41 ff d5             	call   *%r13
        cur_rbp =  *(uint64_t*)cur_rbp;
  80416043a3:	48 8b 1b             	mov    (%rbx),%rbx
        if (cur_rbp != 0)
  80416043a6:	48 85 db             	test   %rbx,%rbx
  80416043a9:	75 a2                	jne    804160434d <mon_backtrace+0x68>

    }   
    return 0;
}
  80416043ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80416043b0:	48 81 c4 20 02 00 00 	add    $0x220,%rsp
  80416043b7:	5b                   	pop    %rbx
  80416043b8:	41 5c                	pop    %r12
  80416043ba:	41 5d                	pop    %r13
  80416043bc:	41 5e                	pop    %r14
  80416043be:	5d                   	pop    %rbp
  80416043bf:	c3                   	ret    

00000080416043c0 <mon_dumpcmos>:

int
mon_dumpcmos(int argc, char **argv, struct Trapframe *tf) {
  80416043c0:	55                   	push   %rbp
  80416043c1:	48 89 e5             	mov    %rsp,%rbp
  80416043c4:	41 55                	push   %r13
  80416043c6:	41 54                	push   %r12
  80416043c8:	53                   	push   %rbx
  80416043c9:	48 83 ec 08          	sub    $0x8,%rsp
    // 00: 00 11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
    // 10: 00 ..
    // Make sure you understand the values read.
    // Hint: Use cmos_read8()/cmos_write8() functions.
    // LAB 4: Your code here
    for (int i = 0; i < CMOS_SIZE; ++i) {
  80416043cd:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (i % 16 == 0)
           cprintf("%02x: ", i);
  80416043d2:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  80416043d9:	00 00 00 
        cprintf("%02x ", cmos_read8(i));
  80416043dc:	49 bd 8e c2 60 41 80 	movabs $0x804160c28e,%r13
  80416043e3:	00 00 00 
  80416043e6:	eb 4b                	jmp    8041604433 <mon_dumpcmos+0x73>
           cprintf("%02x: ", i);
  80416043e8:	89 de                	mov    %ebx,%esi
  80416043ea:	48 bf 41 17 61 41 80 	movabs $0x8041611741,%rdi
  80416043f1:	00 00 00 
  80416043f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80416043f9:	41 ff d4             	call   *%r12
        cprintf("%02x ", cmos_read8(i));
  80416043fc:	89 df                	mov    %ebx,%edi
  80416043fe:	41 ff d5             	call   *%r13
  8041604401:	0f b6 f0             	movzbl %al,%esi
  8041604404:	48 bf 48 17 61 41 80 	movabs $0x8041611748,%rdi
  804160440b:	00 00 00 
  804160440e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604413:	41 ff d4             	call   *%r12
        if (i % 16 == 15)
  8041604416:	89 da                	mov    %ebx,%edx
  8041604418:	c1 fa 1f             	sar    $0x1f,%edx
  804160441b:	c1 ea 1c             	shr    $0x1c,%edx
  804160441e:	8d 04 13             	lea    (%rbx,%rdx,1),%eax
  8041604421:	83 e0 0f             	and    $0xf,%eax
  8041604424:	29 d0                	sub    %edx,%eax
  8041604426:	83 f8 0f             	cmp    $0xf,%eax
  8041604429:	74 0f                	je     804160443a <mon_dumpcmos+0x7a>
    for (int i = 0; i < CMOS_SIZE; ++i) {
  804160442b:	83 c3 01             	add    $0x1,%ebx
  804160442e:	83 fb 32             	cmp    $0x32,%ebx
  8041604431:	74 1b                	je     804160444e <mon_dumpcmos+0x8e>
        if (i % 16 == 0)
  8041604433:	f6 c3 0f             	test   $0xf,%bl
  8041604436:	75 c4                	jne    80416043fc <mon_dumpcmos+0x3c>
  8041604438:	eb ae                	jmp    80416043e8 <mon_dumpcmos+0x28>
           cprintf("\n");
  804160443a:	48 bf 88 11 61 41 80 	movabs $0x8041611188,%rdi
  8041604441:	00 00 00 
  8041604444:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604449:	41 ff d4             	call   *%r12
  804160444c:	eb dd                	jmp    804160442b <mon_dumpcmos+0x6b>
    }
    cprintf("\n");
  804160444e:	48 bf 88 11 61 41 80 	movabs $0x8041611188,%rdi
  8041604455:	00 00 00 
  8041604458:	b8 00 00 00 00       	mov    $0x0,%eax
  804160445d:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041604464:	00 00 00 
  8041604467:	ff d2                	call   *%rdx
    return 0;
}
  8041604469:	b8 00 00 00 00       	mov    $0x0,%eax
  804160446e:	48 83 c4 08          	add    $0x8,%rsp
  8041604472:	5b                   	pop    %rbx
  8041604473:	41 5c                	pop    %r12
  8041604475:	41 5d                	pop    %r13
  8041604477:	5d                   	pop    %rbp
  8041604478:	c3                   	ret    

0000008041604479 <mon_start>:

/* Implement timer_start (mon_start), timer_stop (mon_stop), timer_freq (mon_frequency) commands. */
// LAB 5: Your code here:
int
mon_start(int argc, char **argv, struct Trapframe *tf) {
  8041604479:	55                   	push   %rbp
  804160447a:	48 89 e5             	mov    %rsp,%rbp
    if (argc > 2) {
  804160447d:	83 ff 02             	cmp    $0x2,%edi
  8041604480:	7f 17                	jg     8041604499 <mon_start+0x20>
        cprintf("Wrong number of arguments\n");
        return 1;
    }
    timer_start(argv[1]);
  8041604482:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  8041604486:	48 b8 be 02 61 41 80 	movabs $0x80416102be,%rax
  804160448d:	00 00 00 
  8041604490:	ff d0                	call   *%rax
    return 0;
  8041604492:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8041604497:	5d                   	pop    %rbp
  8041604498:	c3                   	ret    
        cprintf("Wrong number of arguments\n");
  8041604499:	48 bf 4e 17 61 41 80 	movabs $0x804161174e,%rdi
  80416044a0:	00 00 00 
  80416044a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80416044a8:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  80416044af:	00 00 00 
  80416044b2:	ff d2                	call   *%rdx
        return 1;
  80416044b4:	b8 01 00 00 00       	mov    $0x1,%eax
  80416044b9:	eb dc                	jmp    8041604497 <mon_start+0x1e>

00000080416044bb <mon_stop>:

int
mon_stop(int argc, char **argv, struct Trapframe *tf) {
  80416044bb:	55                   	push   %rbp
  80416044bc:	48 89 e5             	mov    %rsp,%rbp
    timer_stop();
  80416044bf:	48 b8 69 03 61 41 80 	movabs $0x8041610369,%rax
  80416044c6:	00 00 00 
  80416044c9:	ff d0                	call   *%rax
    return 0;
}
  80416044cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80416044d0:	5d                   	pop    %rbp
  80416044d1:	c3                   	ret    

00000080416044d2 <mon_frequency>:

int
mon_frequency(int argc, char **argv, struct Trapframe *tf) {
  80416044d2:	55                   	push   %rbp
  80416044d3:	48 89 e5             	mov    %rsp,%rbp
    if (argc > 2) {
  80416044d6:	83 ff 02             	cmp    $0x2,%edi
  80416044d9:	7f 17                	jg     80416044f2 <mon_frequency+0x20>
        cprintf("Wrong number of arguments\n");
        return 1;
    }
    timer_cpu_frequency(argv[1]);
  80416044db:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  80416044df:	48 b8 f3 03 61 41 80 	movabs $0x80416103f3,%rax
  80416044e6:	00 00 00 
  80416044e9:	ff d0                	call   *%rax
    return 0;
  80416044eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80416044f0:	5d                   	pop    %rbp
  80416044f1:	c3                   	ret    
        cprintf("Wrong number of arguments\n");
  80416044f2:	48 bf 4e 17 61 41 80 	movabs $0x804161174e,%rdi
  80416044f9:	00 00 00 
  80416044fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604501:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041604508:	00 00 00 
  804160450b:	ff d2                	call   *%rdx
        return 1;
  804160450d:	b8 01 00 00 00       	mov    $0x1,%eax
  8041604512:	eb dc                	jmp    80416044f0 <mon_frequency+0x1e>

0000008041604514 <mon_memory>:
/* Implement memory (mon_memory) command.
 * This command should call dump_memory_lists()
 */
// LAB 6: Your code here

int mon_memory(int argc, char **argv, struct Trapframe *tf) {
  8041604514:	55                   	push   %rbp
  8041604515:	48 89 e5             	mov    %rsp,%rbp
    dump_memory_lists();
  8041604518:	48 b8 9c 8b 60 41 80 	movabs $0x8041608b9c,%rax
  804160451f:	00 00 00 
  8041604522:	ff d0                	call   *%rax
    return 0;
}
  8041604524:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604529:	5d                   	pop    %rbp
  804160452a:	c3                   	ret    

000000804160452b <mon_allocate_all>:


int mon_allocate_all(int argc, char **argv, struct Trapframe *tf) {
  804160452b:	55                   	push   %rbp
  804160452c:	48 89 e5             	mov    %rsp,%rbp
    test_alloc_all(0, 0);
  804160452f:	be 00 00 00 00       	mov    $0x0,%esi
  8041604534:	bf 00 00 00 00       	mov    $0x0,%edi
  8041604539:	48 b8 45 8c 60 41 80 	movabs $0x8041608c45,%rax
  8041604540:	00 00 00 
  8041604543:	ff d0                	call   *%rax
    return 0;
}
  8041604545:	b8 00 00 00 00       	mov    $0x0,%eax
  804160454a:	5d                   	pop    %rbp
  804160454b:	c3                   	ret    

000000804160454c <mon_free_last>:

int mon_free_last(int argc, char **argv, struct Trapframe *tf) {
  804160454c:	55                   	push   %rbp
  804160454d:	48 89 e5             	mov    %rsp,%rbp
    test_free_last_alloc();
  8041604550:	48 b8 ab 8c 60 41 80 	movabs $0x8041608cab,%rax
  8041604557:	00 00 00 
  804160455a:	ff d0                	call   *%rax
    return 0;
}
  804160455c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604561:	5d                   	pop    %rbp
  8041604562:	c3                   	ret    

0000008041604563 <mon_pagetable>:
/* Implement mon_pagetable() and mon_virt()
 * (using dump_virtual_tree(), dump_page_table())*/
// LAB 7: Your code here
int mon_pagetable(int argc, char **argv, struct Trapframe *tf) {
  8041604563:	55                   	push   %rbp
  8041604564:	48 89 e5             	mov    %rsp,%rbp
    dump_page_table(current_space->pml4);
  8041604567:	48 a1 a0 00 40 42 80 	movabs 0x80424000a0,%rax
  804160456e:	00 00 00 
  8041604571:	48 8b 38             	mov    (%rax),%rdi
  8041604574:	48 b8 34 8d 60 41 80 	movabs $0x8041608d34,%rax
  804160457b:	00 00 00 
  804160457e:	ff d0                	call   *%rax
    return 0;
}
  8041604580:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604585:	5d                   	pop    %rbp
  8041604586:	c3                   	ret    

0000008041604587 <mon_virt>:

int mon_virt(int argc, char **argv, struct Trapframe *tf) {
  8041604587:	55                   	push   %rbp
  8041604588:	48 89 e5             	mov    %rsp,%rbp
    dump_virtual_tree(current_space->root, MAX_CLASS);
  804160458b:	48 a1 a0 00 40 42 80 	movabs 0x80424000a0,%rax
  8041604592:	00 00 00 
  8041604595:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8041604599:	be 30 00 00 00       	mov    $0x30,%esi
  804160459e:	48 b8 9c 8a 60 41 80 	movabs $0x8041608a9c,%rax
  80416045a5:	00 00 00 
  80416045a8:	ff d0                	call   *%rax
    return 0;
}
  80416045aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80416045af:	5d                   	pop    %rbp
  80416045b0:	c3                   	ret    

00000080416045b1 <monitor>:
    cprintf("Unknown command '%s'\n", argv[0]);
    return 0;
}

void
monitor(struct Trapframe *tf) {
  80416045b1:	55                   	push   %rbp
  80416045b2:	48 89 e5             	mov    %rsp,%rbp
  80416045b5:	41 57                	push   %r15
  80416045b7:	41 56                	push   %r14
  80416045b9:	41 55                	push   %r13
  80416045bb:	41 54                	push   %r12
  80416045bd:	53                   	push   %rbx
  80416045be:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  80416045c5:	49 89 ff             	mov    %rdi,%r15
  80416045c8:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)

    cprintf("Welcome to the JOS kernel monitor!\n");
  80416045cf:	48 bf b0 19 61 41 80 	movabs $0x80416119b0,%rdi
  80416045d6:	00 00 00 
  80416045d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80416045de:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  80416045e5:	00 00 00 
  80416045e8:	ff d3                	call   *%rbx
    cprintf("Type 'help' for a list of commands.\n");
  80416045ea:	48 bf d8 19 61 41 80 	movabs $0x80416119d8,%rdi
  80416045f1:	00 00 00 
  80416045f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80416045f9:	ff d3                	call   *%rbx

    if (tf) print_trapframe(tf);
  80416045fb:	4d 85 ff             	test   %r15,%r15
  80416045fe:	74 0f                	je     804160460f <monitor+0x5e>
  8041604600:	4c 89 ff             	mov    %r15,%rdi
  8041604603:	48 b8 cd d1 60 41 80 	movabs $0x804160d1cd,%rax
  804160460a:	00 00 00 
  804160460d:	ff d0                	call   *%rax

    char *buf;
    do buf = readline("K> ");
  804160460f:	49 bf df fa 60 41 80 	movabs $0x804160fadf,%r15
  8041604616:	00 00 00 
        while (*buf && strchr(WHITESPACE, *buf)) *buf++ = 0;
  8041604619:	49 bc 57 fd 60 41 80 	movabs $0x804160fd57,%r12
  8041604620:	00 00 00 
  8041604623:	e9 ff 00 00 00       	jmp    8041604727 <monitor+0x176>
  8041604628:	40 0f be f6          	movsbl %sil,%esi
  804160462c:	48 bf 6d 17 61 41 80 	movabs $0x804161176d,%rdi
  8041604633:	00 00 00 
  8041604636:	41 ff d4             	call   *%r12
  8041604639:	48 85 c0             	test   %rax,%rax
  804160463c:	74 0c                	je     804160464a <monitor+0x99>
  804160463e:	c6 03 00             	movb   $0x0,(%rbx)
  8041604641:	45 89 ee             	mov    %r13d,%r14d
  8041604644:	48 8d 5b 01          	lea    0x1(%rbx),%rbx
  8041604648:	eb 48                	jmp    8041604692 <monitor+0xe1>
        if (!*buf) break;
  804160464a:	80 3b 00             	cmpb   $0x0,(%rbx)
  804160464d:	74 4e                	je     804160469d <monitor+0xec>
        if (argc == MAXARGS - 1) {
  804160464f:	41 83 fd 0f          	cmp    $0xf,%r13d
  8041604653:	0f 84 b3 00 00 00    	je     804160470c <monitor+0x15b>
        argv[argc++] = buf;
  8041604659:	45 8d 75 01          	lea    0x1(%r13),%r14d
  804160465d:	4d 63 ed             	movslq %r13d,%r13
  8041604660:	4a 89 9c ed 50 ff ff 	mov    %rbx,-0xb0(%rbp,%r13,8)
  8041604667:	ff 
        while (*buf && !strchr(WHITESPACE, *buf)) buf++;
  8041604668:	0f b6 33             	movzbl (%rbx),%esi
  804160466b:	40 84 f6             	test   %sil,%sil
  804160466e:	74 22                	je     8041604692 <monitor+0xe1>
  8041604670:	40 0f be f6          	movsbl %sil,%esi
  8041604674:	48 bf 6d 17 61 41 80 	movabs $0x804161176d,%rdi
  804160467b:	00 00 00 
  804160467e:	41 ff d4             	call   *%r12
  8041604681:	48 85 c0             	test   %rax,%rax
  8041604684:	75 0c                	jne    8041604692 <monitor+0xe1>
  8041604686:	48 83 c3 01          	add    $0x1,%rbx
  804160468a:	0f b6 33             	movzbl (%rbx),%esi
  804160468d:	40 84 f6             	test   %sil,%sil
  8041604690:	75 de                	jne    8041604670 <monitor+0xbf>
        while (*buf && strchr(WHITESPACE, *buf)) *buf++ = 0;
  8041604692:	45 89 f5             	mov    %r14d,%r13d
  8041604695:	0f b6 33             	movzbl (%rbx),%esi
  8041604698:	40 84 f6             	test   %sil,%sil
  804160469b:	75 8b                	jne    8041604628 <monitor+0x77>
    argv[argc] = NULL;
  804160469d:	49 63 c5             	movslq %r13d,%rax
  80416046a0:	48 c7 84 c5 50 ff ff 	movq   $0x0,-0xb0(%rbp,%rax,8)
  80416046a7:	ff 00 00 00 00 
    if (!argc) return 0;
  80416046ac:	45 85 ed             	test   %r13d,%r13d
  80416046af:	74 76                	je     8041604727 <monitor+0x176>
  80416046b1:	49 be a0 1a 61 41 80 	movabs $0x8041611aa0,%r14
  80416046b8:	00 00 00 
    for (size_t i = 0; i < NCOMMANDS; i++) {
  80416046bb:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (strcmp(argv[0], commands[i].name) == 0)
  80416046c0:	49 8b 36             	mov    (%r14),%rsi
  80416046c3:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  80416046ca:	48 b8 f6 fc 60 41 80 	movabs $0x804160fcf6,%rax
  80416046d1:	00 00 00 
  80416046d4:	ff d0                	call   *%rax
  80416046d6:	85 c0                	test   %eax,%eax
  80416046d8:	74 78                	je     8041604752 <monitor+0x1a1>
    for (size_t i = 0; i < NCOMMANDS; i++) {
  80416046da:	48 83 c3 01          	add    $0x1,%rbx
  80416046de:	49 83 c6 18          	add    $0x18,%r14
  80416046e2:	48 83 fb 0d          	cmp    $0xd,%rbx
  80416046e6:	75 d8                	jne    80416046c0 <monitor+0x10f>
    cprintf("Unknown command '%s'\n", argv[0]);
  80416046e8:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  80416046ef:	48 bf 8f 17 61 41 80 	movabs $0x804161178f,%rdi
  80416046f6:	00 00 00 
  80416046f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80416046fe:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041604705:	00 00 00 
  8041604708:	ff d2                	call   *%rdx
    return 0;
  804160470a:	eb 1b                	jmp    8041604727 <monitor+0x176>
            cprintf("Too many arguments (max %d)\n", MAXARGS);
  804160470c:	be 10 00 00 00       	mov    $0x10,%esi
  8041604711:	48 bf 72 17 61 41 80 	movabs $0x8041611772,%rdi
  8041604718:	00 00 00 
  804160471b:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041604722:	00 00 00 
  8041604725:	ff d2                	call   *%rdx
    do buf = readline("K> ");
  8041604727:	48 bf 69 17 61 41 80 	movabs $0x8041611769,%rdi
  804160472e:	00 00 00 
  8041604731:	41 ff d7             	call   *%r15
  8041604734:	48 89 c3             	mov    %rax,%rbx
    while (!buf || runcmd(buf, tf) >= 0);
  8041604737:	48 85 c0             	test   %rax,%rax
  804160473a:	74 eb                	je     8041604727 <monitor+0x176>
    argv[0] = NULL;
  804160473c:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  8041604743:	00 00 00 00 
    int argc = 0;
  8041604747:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  804160474d:	e9 43 ff ff ff       	jmp    8041604695 <monitor+0xe4>
            return commands[i].func(argc, argv, tf);
  8041604752:	48 8d 0c 5b          	lea    (%rbx,%rbx,2),%rcx
  8041604756:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  804160475d:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  8041604764:	44 89 ef             	mov    %r13d,%edi
  8041604767:	48 b8 a0 1a 61 41 80 	movabs $0x8041611aa0,%rax
  804160476e:	00 00 00 
  8041604771:	ff 54 c8 10          	call   *0x10(%rax,%rcx,8)
    while (!buf || runcmd(buf, tf) >= 0);
  8041604775:	85 c0                	test   %eax,%eax
  8041604777:	79 ae                	jns    8041604727 <monitor+0x176>
}
  8041604779:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8041604780:	5b                   	pop    %rbx
  8041604781:	41 5c                	pop    %r12
  8041604783:	41 5d                	pop    %r13
  8041604785:	41 5e                	pop    %r14
  8041604787:	41 5f                	pop    %r15
  8041604789:	5d                   	pop    %rbp
  804160478a:	c3                   	ret    

000000804160478b <free_descriptor>:
 * NOTE: Use list_init() on deleted List element
 */
inline static struct List *__attribute__((always_inline))
list_del(struct List *list) {
    // LAB 6: Your code here.
    list->prev->next = list->next;
  804160478b:	48 8b 17             	mov    (%rdi),%rdx
  804160478e:	48 8b 47 08          	mov    0x8(%rdi),%rax
  8041604792:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list->next->prev = list->prev;
  8041604796:	48 8b 17             	mov    (%rdi),%rdx
  8041604799:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  804160479c:	48 89 3f             	mov    %rdi,(%rdi)
  804160479f:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
    list->next->prev = new;
  80416047a3:	48 b8 20 41 40 42 80 	movabs $0x8042404120,%rax
  80416047aa:	00 00 00 
  80416047ad:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80416047b1:	48 89 3a             	mov    %rdi,(%rdx)
    new->next = list->next;
  80416047b4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80416047b8:	48 89 57 08          	mov    %rdx,0x8(%rdi)
    list->next = new;
  80416047bc:	48 89 78 08          	mov    %rdi,0x8(%rax)
    new->prev = list;
  80416047c0:	48 89 07             	mov    %rax,(%rdi)

static void
free_descriptor(struct Page *page) {
    list_del((struct List *)page);
    list_append(&free_descriptors, (struct List *)page);
    free_desc_count++;
  80416047c3:	48 b8 10 41 40 42 80 	movabs $0x8042404110,%rax
  80416047ca:	00 00 00 
  80416047cd:	48 83 00 01          	addq   $0x1,(%rax)
}
  80416047d1:	c3                   	ret    

00000080416047d2 <page_ref>:
    return node;
}

static void
page_ref(struct Page *node) {
    if (!node) return;
  80416047d2:	48 85 ff             	test   %rdi,%rdi
  80416047d5:	74 4e                	je     8041604825 <page_ref+0x53>
page_ref(struct Page *node) {
  80416047d7:	55                   	push   %rbp
  80416047d8:	48 89 e5             	mov    %rsp,%rbp
  80416047db:	41 54                	push   %r12
  80416047dd:	53                   	push   %rbx
  80416047de:	48 89 fb             	mov    %rdi,%rbx

    /* If parent is allocated
     * all of its children are allocated too,
     * so need to reference them recursively
     * when refc transitions from 0 to 1 */
    if (!node->refc++) {
  80416047e1:	8b 47 30             	mov    0x30(%rdi),%eax
  80416047e4:	8d 50 01             	lea    0x1(%rax),%edx
  80416047e7:	89 57 30             	mov    %edx,0x30(%rdi)
  80416047ea:	85 c0                	test   %eax,%eax
  80416047ec:	74 05                	je     80416047f3 <page_ref+0x21>
        list_del((struct List *)node);
        list_init((struct List *)node);
        page_ref(node->left);
        page_ref(node->right);
    }
}
  80416047ee:	5b                   	pop    %rbx
  80416047ef:	41 5c                	pop    %r12
  80416047f1:	5d                   	pop    %rbp
  80416047f2:	c3                   	ret    
    list->prev->next = list->next;
  80416047f3:	48 8b 17             	mov    (%rdi),%rdx
  80416047f6:	48 8b 47 08          	mov    0x8(%rdi),%rax
  80416047fa:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list->next->prev = list->prev;
  80416047fe:	48 8b 17             	mov    (%rdi),%rdx
  8041604801:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8041604804:	48 89 3f             	mov    %rdi,(%rdi)
  8041604807:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
        page_ref(node->left);
  804160480b:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  804160480f:	49 bc d2 47 60 41 80 	movabs $0x80416047d2,%r12
  8041604816:	00 00 00 
  8041604819:	41 ff d4             	call   *%r12
        page_ref(node->right);
  804160481c:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8041604820:	41 ff d4             	call   *%r12
  8041604823:	eb c9                	jmp    80416047ee <page_ref+0x1c>
  8041604825:	c3                   	ret    

0000008041604826 <free_desc_rec>:
    while (p) {
  8041604826:	48 85 ff             	test   %rdi,%rdi
  8041604829:	0f 84 81 00 00 00    	je     80416048b0 <free_desc_rec+0x8a>
free_desc_rec(struct Page *p) {
  804160482f:	55                   	push   %rbp
  8041604830:	48 89 e5             	mov    %rsp,%rbp
  8041604833:	41 56                	push   %r14
  8041604835:	41 55                	push   %r13
  8041604837:	41 54                	push   %r12
  8041604839:	53                   	push   %rbx
  804160483a:	48 89 fb             	mov    %rdi,%rbx
        free_desc_rec(p->right);
  804160483d:	49 be 26 48 60 41 80 	movabs $0x8041604826,%r14
  8041604844:	00 00 00 
        free_descriptor(p);
  8041604847:	49 bd 8b 47 60 41 80 	movabs $0x804160478b,%r13
  804160484e:	00 00 00 
  8041604851:	eb 03                	jmp    8041604856 <free_desc_rec+0x30>
        p = tmp;
  8041604853:	4c 89 e3             	mov    %r12,%rbx
        assert(!p->refc);
  8041604856:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  804160485a:	75 1f                	jne    804160487b <free_desc_rec+0x55>
        free_desc_rec(p->right);
  804160485c:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8041604860:	41 ff d6             	call   *%r14
        struct Page *tmp = p->left;
  8041604863:	4c 8b 63 10          	mov    0x10(%rbx),%r12
        free_descriptor(p);
  8041604867:	48 89 df             	mov    %rbx,%rdi
  804160486a:	41 ff d5             	call   *%r13
    while (p) {
  804160486d:	4d 85 e4             	test   %r12,%r12
  8041604870:	75 e1                	jne    8041604853 <free_desc_rec+0x2d>
}
  8041604872:	5b                   	pop    %rbx
  8041604873:	41 5c                	pop    %r12
  8041604875:	41 5d                	pop    %r13
  8041604877:	41 5e                	pop    %r14
  8041604879:	5d                   	pop    %rbp
  804160487a:	c3                   	ret    
        assert(!p->refc);
  804160487b:	48 b9 d8 1b 61 41 80 	movabs $0x8041611bd8,%rcx
  8041604882:	00 00 00 
  8041604885:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160488c:	00 00 00 
  804160488f:	be 9d 00 00 00       	mov    $0x9d,%esi
  8041604894:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160489b:	00 00 00 
  804160489e:	b8 00 00 00 00       	mov    $0x0,%eax
  80416048a3:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416048aa:	00 00 00 
  80416048ad:	41 ff d0             	call   *%r8
  80416048b0:	c3                   	ret    

00000080416048b1 <page_unref>:

static void
page_unref(struct Page *page) {
    if (!page) return;
  80416048b1:	48 85 ff             	test   %rdi,%rdi
  80416048b4:	0f 84 9d 02 00 00    	je     8041604b57 <page_unref+0x2a6>
page_unref(struct Page *page) {
  80416048ba:	55                   	push   %rbp
  80416048bb:	48 89 e5             	mov    %rsp,%rbp
  80416048be:	41 56                	push   %r14
  80416048c0:	41 55                	push   %r13
  80416048c2:	41 54                	push   %r12
  80416048c4:	53                   	push   %rbx
  80416048c5:	48 89 fb             	mov    %rdi,%rbx
    assert_physical(page);
  80416048c8:	8b 47 28             	mov    0x28(%rdi),%eax
  80416048cb:	25 00 00 f0 00       	and    $0xf00000,%eax
  80416048d0:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  80416048d5:	76 2f                	jbe    8041604906 <page_unref+0x55>
    assert(page->refc);
  80416048d7:	8b 47 30             	mov    0x30(%rdi),%eax
  80416048da:	85 c0                	test   %eax,%eax
  80416048dc:	74 5d                	je     804160493b <page_unref+0x8a>

    /* NOTE Decrementing refc after
     * this if statement is important
     * to prevent double frees */

    if (page->refc == 1) {
  80416048de:	83 f8 01             	cmp    $0x1,%eax
  80416048e1:	0f 84 84 00 00 00    	je     804160496b <page_unref+0xba>
        page_unref(page->left);
        page_unref(page->right);
    }

    page->refc--;
  80416048e7:	8b 43 30             	mov    0x30(%rbx),%eax
  80416048ea:	83 e8 01             	sub    $0x1,%eax
  80416048ed:	89 43 30             	mov    %eax,0x30(%rbx)

    /* Try to merge free page with adjacent */
    if (PAGE_IS_FREE(page)) {
  80416048f0:	75 0b                	jne    80416048fd <page_unref+0x4c>
  80416048f2:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  80416048f7:	0f 84 8b 00 00 00    	je     8041604988 <page_unref+0xd7>
        if (current_space) {
            platform_asan_poison(KADDR(page2pa(page)), CLASS_SIZE(page->class));
        }
#endif
    }
}
  80416048fd:	5b                   	pop    %rbx
  80416048fe:	41 5c                	pop    %r12
  8041604900:	41 5d                	pop    %r13
  8041604902:	41 5e                	pop    %r14
  8041604904:	5d                   	pop    %rbp
  8041604905:	c3                   	ret    
    assert_physical(page);
  8041604906:	48 b9 b8 1e 61 41 80 	movabs $0x8041611eb8,%rcx
  804160490d:	00 00 00 
  8041604910:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604917:	00 00 00 
  804160491a:	be 20 01 00 00       	mov    $0x120,%esi
  804160491f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604926:	00 00 00 
  8041604929:	b8 00 00 00 00       	mov    $0x0,%eax
  804160492e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604935:	00 00 00 
  8041604938:	41 ff d0             	call   *%r8
    assert(page->refc);
  804160493b:	48 b9 55 1d 61 41 80 	movabs $0x8041611d55,%rcx
  8041604942:	00 00 00 
  8041604945:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160494c:	00 00 00 
  804160494f:	be 21 01 00 00       	mov    $0x121,%esi
  8041604954:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160495b:	00 00 00 
  804160495e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604965:	00 00 00 
  8041604968:	41 ff d0             	call   *%r8
        page_unref(page->left);
  804160496b:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  804160496f:	49 bc b1 48 60 41 80 	movabs $0x80416048b1,%r12
  8041604976:	00 00 00 
  8041604979:	41 ff d4             	call   *%r12
        page_unref(page->right);
  804160497c:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8041604980:	41 ff d4             	call   *%r12
  8041604983:	e9 5f ff ff ff       	jmp    80416048e7 <page_unref+0x36>
    if (PAGE_IS_FREE(page)) {
  8041604988:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  804160498d:	0f 85 6a ff ff ff    	jne    80416048fd <page_unref+0x4c>
        while (page != &root) {
  8041604993:	48 b8 60 00 40 42 80 	movabs $0x8042400060,%rax
  804160499a:	00 00 00 
  804160499d:	48 39 c3             	cmp    %rax,%rbx
  80416049a0:	0f 84 ac 01 00 00    	je     8041604b52 <page_unref+0x2a1>
                free_descriptor(par->left);
  80416049a6:	49 bc 8b 47 60 41 80 	movabs $0x804160478b,%r12
  80416049ad:	00 00 00 
    list->next->prev = new;
  80416049b0:	49 be 40 41 40 42 80 	movabs $0x8042404140,%r14
  80416049b7:	00 00 00 
        while (page != &root) {
  80416049ba:	49 89 c5             	mov    %rax,%r13
  80416049bd:	eb 73                	jmp    8041604a32 <page_unref+0x181>
            assert_physical(par);
  80416049bf:	48 b9 f0 1e 61 41 80 	movabs $0x8041611ef0,%rcx
  80416049c6:	00 00 00 
  80416049c9:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416049d0:	00 00 00 
  80416049d3:	be 32 01 00 00       	mov    $0x132,%esi
  80416049d8:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416049df:	00 00 00 
  80416049e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80416049e7:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416049ee:	00 00 00 
  80416049f1:	41 ff d0             	call   *%r8
                    assert(list_empty((struct List *)par));
  80416049f4:	48 b9 20 1f 61 41 80 	movabs $0x8041611f20,%rcx
  80416049fb:	00 00 00 
  80416049fe:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604a05:	00 00 00 
  8041604a08:	be 3d 01 00 00       	mov    $0x13d,%esi
  8041604a0d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604a14:	00 00 00 
  8041604a17:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604a1c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604a23:	00 00 00 
  8041604a26:	41 ff d0             	call   *%r8
        while (page != &root) {
  8041604a29:	4c 39 eb             	cmp    %r13,%rbx
  8041604a2c:	0f 84 bf 00 00 00    	je     8041604af1 <page_unref+0x240>
            struct Page *par = page->parent;
  8041604a32:	48 89 da             	mov    %rbx,%rdx
  8041604a35:	48 8b 5b 20          	mov    0x20(%rbx),%rbx
            assert_physical(par);
  8041604a39:	8b 43 28             	mov    0x28(%rbx),%eax
  8041604a3c:	89 c1                	mov    %eax,%ecx
  8041604a3e:	81 e1 00 00 f0 00    	and    $0xf00000,%ecx
  8041604a44:	81 f9 ff ff 2f 00    	cmp    $0x2fffff,%ecx
  8041604a4a:	0f 86 6f ff ff ff    	jbe    80416049bf <page_unref+0x10e>
            if (par->state == page->state &&
  8041604a50:	3b 42 28             	cmp    0x28(%rdx),%eax
  8041604a53:	0f 85 9b 00 00 00    	jne    8041604af4 <page_unref+0x243>
                PAGE_IS_FREE(par->left) &&
  8041604a59:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
            if (par->state == page->state &&
  8041604a5d:	83 7f 30 00          	cmpl   $0x0,0x30(%rdi)
  8041604a61:	0f 85 8d 00 00 00    	jne    8041604af4 <page_unref+0x243>
                PAGE_IS_FREE(par->left) &&
  8041604a67:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
  8041604a6c:	0f 85 82 00 00 00    	jne    8041604af4 <page_unref+0x243>
  8041604a72:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
  8041604a77:	75 7b                	jne    8041604af4 <page_unref+0x243>
                PAGE_IS_FREE(par->right)) {
  8041604a79:	48 8b 43 18          	mov    0x18(%rbx),%rax
                PAGE_IS_FREE(par->left) &&
  8041604a7d:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041604a81:	75 71                	jne    8041604af4 <page_unref+0x243>
                PAGE_IS_FREE(par->right)) {
  8041604a83:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  8041604a88:	75 6a                	jne    8041604af4 <page_unref+0x243>
  8041604a8a:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  8041604a8f:	75 63                	jne    8041604af4 <page_unref+0x243>
                free_descriptor(par->left);
  8041604a91:	41 ff d4             	call   *%r12
                par->left = NULL;
  8041604a94:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  8041604a9b:	00 
                free_descriptor(par->right);
  8041604a9c:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8041604aa0:	41 ff d4             	call   *%r12
                par->right = NULL;
  8041604aa3:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  8041604aaa:	00 
                if (par->state == ALLOCATABLE_NODE) {
  8041604aab:	81 7b 28 00 00 40 00 	cmpl   $0x400000,0x28(%rbx)
  8041604ab2:	0f 85 71 ff ff ff    	jne    8041604a29 <page_unref+0x178>
                    assert(list_empty((struct List *)par));
  8041604ab8:	48 3b 5b 08          	cmp    0x8(%rbx),%rbx
  8041604abc:	0f 85 32 ff ff ff    	jne    80416049f4 <page_unref+0x143>
                    list_append(&free_classes[par->class], (struct List *)par);
  8041604ac2:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
    list->next->prev = new;
  8041604ac6:	48 89 c2             	mov    %rax,%rdx
  8041604ac9:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  8041604acf:	48 c1 e2 04          	shl    $0x4,%rdx
  8041604ad3:	4c 01 f2             	add    %r14,%rdx
  8041604ad6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8041604ada:	48 89 19             	mov    %rbx,(%rcx)
    new->next = list->next;
  8041604add:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8041604ae1:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    list->next = new;
  8041604ae5:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
                    list_append(&free_classes[par->class], (struct List *)par);
  8041604ae9:	48 89 13             	mov    %rdx,(%rbx)
}
  8041604aec:	e9 38 ff ff ff       	jmp    8041604a29 <page_unref+0x178>
            struct Page *par = page->parent;
  8041604af1:	48 89 da             	mov    %rbx,%rdx
    list->prev->next = list->next;
  8041604af4:	48 8b 0a             	mov    (%rdx),%rcx
  8041604af7:	48 8b 42 08          	mov    0x8(%rdx),%rax
  8041604afb:	48 89 41 08          	mov    %rax,0x8(%rcx)
    list->next->prev = list->prev;
  8041604aff:	48 8b 0a             	mov    (%rdx),%rcx
  8041604b02:	48 89 08             	mov    %rcx,(%rax)
    list->next = list->prev = list;
  8041604b05:	48 89 12             	mov    %rdx,(%rdx)
  8041604b08:	48 89 52 08          	mov    %rdx,0x8(%rdx)
        if (page->state == ALLOCATABLE_NODE)
  8041604b0c:	81 7a 28 00 00 40 00 	cmpl   $0x400000,0x28(%rdx)
  8041604b13:	0f 85 e4 fd ff ff    	jne    80416048fd <page_unref+0x4c>
            list_append(&free_classes[page->class], (struct List *)page);
  8041604b19:	0f b7 42 34          	movzwl 0x34(%rdx),%eax
    list->next->prev = new;
  8041604b1d:	48 be 40 41 40 42 80 	movabs $0x8042404140,%rsi
  8041604b24:	00 00 00 
  8041604b27:	48 89 c1             	mov    %rax,%rcx
  8041604b2a:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041604b30:	48 c1 e1 04          	shl    $0x4,%rcx
  8041604b34:	48 01 f1             	add    %rsi,%rcx
  8041604b37:	48 8b 79 08          	mov    0x8(%rcx),%rdi
  8041604b3b:	48 89 17             	mov    %rdx,(%rdi)
    new->next = list->next;
  8041604b3e:	48 8b 79 08          	mov    0x8(%rcx),%rdi
  8041604b42:	48 89 7a 08          	mov    %rdi,0x8(%rdx)
    list->next = new;
  8041604b46:	48 89 51 08          	mov    %rdx,0x8(%rcx)
            list_append(&free_classes[page->class], (struct List *)page);
  8041604b4a:	48 89 0a             	mov    %rcx,(%rdx)
}
  8041604b4d:	e9 ab fd ff ff       	jmp    80416048fd <page_unref+0x4c>
        while (page != &root) {
  8041604b52:	48 89 da             	mov    %rbx,%rdx
  8041604b55:	eb 9d                	jmp    8041604af4 <page_unref+0x243>
  8041604b57:	c3                   	ret    

0000008041604b58 <unmap_page_remove>:
    }
}

static void
unmap_page_remove(struct Page *node) {
    if (!node) return;
  8041604b58:	48 85 ff             	test   %rdi,%rdi
  8041604b5b:	0f 84 82 01 00 00    	je     8041604ce3 <unmap_page_remove+0x18b>
unmap_page_remove(struct Page *node) {
  8041604b61:	55                   	push   %rbp
  8041604b62:	48 89 e5             	mov    %rsp,%rbp
  8041604b65:	41 54                	push   %r12
  8041604b67:	53                   	push   %rbx
  8041604b68:	48 89 fb             	mov    %rdi,%rbx
    assert_virtual(node);
  8041604b6b:	8b 47 28             	mov    0x28(%rdi),%eax
  8041604b6e:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041604b73:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8041604b78:	77 68                	ja     8041604be2 <unmap_page_remove+0x8a>

    if (node->phy) {
  8041604b7a:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
  8041604b7e:	48 85 ff             	test   %rdi,%rdi
  8041604b81:	0f 84 fa 00 00 00    	je     8041604c81 <unmap_page_remove+0x129>
        assert(!node->left && !node->right);
  8041604b87:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  8041604b8c:	0f 85 85 00 00 00    	jne    8041604c17 <unmap_page_remove+0xbf>
  8041604b92:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8041604b97:	75 7e                	jne    8041604c17 <unmap_page_remove+0xbf>
        assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8041604b99:	3d 00 00 10 00       	cmp    $0x100000,%eax
  8041604b9e:	0f 85 a8 00 00 00    	jne    8041604c4c <unmap_page_remove+0xf4>
        page_unref(node->phy);
  8041604ba4:	48 b8 b1 48 60 41 80 	movabs $0x80416048b1,%rax
  8041604bab:	00 00 00 
  8041604bae:	ff d0                	call   *%rax
        assert((node->state & NODE_TYPE_MASK) == INTERMEDIATE_NODE);
        unmap_page_remove(node->left);
        unmap_page_remove(node->right);
    }

    if (node->parent) {
  8041604bb0:	48 8b 43 20          	mov    0x20(%rbx),%rax
  8041604bb4:	48 85 c0             	test   %rax,%rax
  8041604bb7:	74 15                	je     8041604bce <unmap_page_remove+0x76>
        *(node->parent->left == node ?
                  &node->parent->left :
  8041604bb9:	48 8d 50 18          	lea    0x18(%rax),%rdx
  8041604bbd:	48 39 58 10          	cmp    %rbx,0x10(%rax)
  8041604bc1:	0f 84 13 01 00 00    	je     8041604cda <unmap_page_remove+0x182>
                  &node->parent->right) = NULL;
  8041604bc7:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    }

    free_descriptor(node);
  8041604bce:	48 89 df             	mov    %rbx,%rdi
  8041604bd1:	48 b8 8b 47 60 41 80 	movabs $0x804160478b,%rax
  8041604bd8:	00 00 00 
  8041604bdb:	ff d0                	call   *%rax
}
  8041604bdd:	5b                   	pop    %rbx
  8041604bde:	41 5c                	pop    %r12
  8041604be0:	5d                   	pop    %rbp
  8041604be1:	c3                   	ret    
    assert_virtual(node);
  8041604be2:	48 b9 40 1f 61 41 80 	movabs $0x8041611f40,%rcx
  8041604be9:	00 00 00 
  8041604bec:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604bf3:	00 00 00 
  8041604bf6:	be cb 01 00 00       	mov    $0x1cb,%esi
  8041604bfb:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604c02:	00 00 00 
  8041604c05:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604c0a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604c11:	00 00 00 
  8041604c14:	41 ff d0             	call   *%r8
        assert(!node->left && !node->right);
  8041604c17:	48 b9 ed 1b 61 41 80 	movabs $0x8041611bed,%rcx
  8041604c1e:	00 00 00 
  8041604c21:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604c28:	00 00 00 
  8041604c2b:	be ce 01 00 00       	mov    $0x1ce,%esi
  8041604c30:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604c37:	00 00 00 
  8041604c3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604c3f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604c46:	00 00 00 
  8041604c49:	41 ff d0             	call   *%r8
        assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8041604c4c:	48 b9 70 1f 61 41 80 	movabs $0x8041611f70,%rcx
  8041604c53:	00 00 00 
  8041604c56:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604c5d:	00 00 00 
  8041604c60:	be cf 01 00 00       	mov    $0x1cf,%esi
  8041604c65:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604c6c:	00 00 00 
  8041604c6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604c74:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604c7b:	00 00 00 
  8041604c7e:	41 ff d0             	call   *%r8
        assert((node->state & NODE_TYPE_MASK) == INTERMEDIATE_NODE);
  8041604c81:	3d 00 00 20 00       	cmp    $0x200000,%eax
  8041604c86:	75 1d                	jne    8041604ca5 <unmap_page_remove+0x14d>
        unmap_page_remove(node->left);
  8041604c88:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8041604c8c:	49 bc 58 4b 60 41 80 	movabs $0x8041604b58,%r12
  8041604c93:	00 00 00 
  8041604c96:	41 ff d4             	call   *%r12
        unmap_page_remove(node->right);
  8041604c99:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8041604c9d:	41 ff d4             	call   *%r12
  8041604ca0:	e9 0b ff ff ff       	jmp    8041604bb0 <unmap_page_remove+0x58>
        assert((node->state & NODE_TYPE_MASK) == INTERMEDIATE_NODE);
  8041604ca5:	48 b9 a0 1f 61 41 80 	movabs $0x8041611fa0,%rcx
  8041604cac:	00 00 00 
  8041604caf:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604cb6:	00 00 00 
  8041604cb9:	be d2 01 00 00       	mov    $0x1d2,%esi
  8041604cbe:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604cc5:	00 00 00 
  8041604cc8:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604ccd:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604cd4:	00 00 00 
  8041604cd7:	41 ff d0             	call   *%r8
                  &node->parent->left :
  8041604cda:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8041604cde:	e9 e4 fe ff ff       	jmp    8041604bc7 <unmap_page_remove+0x6f>
  8041604ce3:	c3                   	ret    

0000008041604ce4 <check_virtual_class>:
    while (node->parent) class ++, node = node->parent;
  8041604ce4:	48 8b 47 20          	mov    0x20(%rdi),%rax
  8041604ce8:	48 85 c0             	test   %rax,%rax
  8041604ceb:	74 0c                	je     8041604cf9 <check_virtual_class+0x15>
  8041604ced:	83 c6 01             	add    $0x1,%esi
  8041604cf0:	48 8b 40 20          	mov    0x20(%rax),%rax
  8041604cf4:	48 85 c0             	test   %rax,%rax
  8041604cf7:	75 f4                	jne    8041604ced <check_virtual_class+0x9>
    assert(class == MAX_CLASS);
  8041604cf9:	83 fe 30             	cmp    $0x30,%esi
  8041604cfc:	75 01                	jne    8041604cff <check_virtual_class+0x1b>
  8041604cfe:	c3                   	ret    
check_virtual_class(struct Page *node, int class) {
  8041604cff:	55                   	push   %rbp
  8041604d00:	48 89 e5             	mov    %rsp,%rbp
    assert(class == MAX_CLASS);
  8041604d03:	48 b9 0f 1c 61 41 80 	movabs $0x8041611c0f,%rcx
  8041604d0a:	00 00 00 
  8041604d0d:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604d14:	00 00 00 
  8041604d17:	be 73 01 00 00       	mov    $0x173,%esi
  8041604d1c:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604d23:	00 00 00 
  8041604d26:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604d2b:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604d32:	00 00 00 
  8041604d35:	41 ff d0             	call   *%r8

0000008041604d38 <check_physical_tree>:
            base & PTE_PS ? 'S' : '-',
            step);
}

static void
check_physical_tree(struct Page *page) {
  8041604d38:	55                   	push   %rbp
  8041604d39:	48 89 e5             	mov    %rsp,%rbp
  8041604d3c:	41 54                	push   %r12
  8041604d3e:	53                   	push   %rbx
    assert_physical(page);
  8041604d3f:	44 8b 57 28          	mov    0x28(%rdi),%r10d
  8041604d43:	44 89 d0             	mov    %r10d,%eax
  8041604d46:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041604d4b:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8041604d50:	0f 86 99 00 00 00    	jbe    8041604def <check_physical_tree+0xb7>
  8041604d56:	48 89 fb             	mov    %rdi,%rbx
/* Number of PML4 entries taken by userspace */
#define NUSERPML4 1

inline static physaddr_t __attribute__((always_inline))
page2pa(struct Page *page) {
    return page->addr << CLASS_BASE;
  8041604d59:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8041604d60:	ff 0f 00 
  8041604d63:	49 89 c1             	mov    %rax,%r9
  8041604d66:	4c 23 4f 38          	and    0x38(%rdi),%r9
  8041604d6a:	4d 89 c8             	mov    %r9,%r8
  8041604d6d:	49 c1 e0 0c          	shl    $0xc,%r8
  8041604d71:	49 21 c0             	and    %rax,%r8
    assert(page->class >= 0);
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  8041604d74:	0f b7 47 34          	movzwl 0x34(%rdi),%eax
  8041604d78:	89 c2                	mov    %eax,%edx
  8041604d7a:	66 81 e2 ff 0f       	and    $0xfff,%dx
  8041604d7f:	25 ff 0f 00 00       	and    $0xfff,%eax
  8041604d84:	8d 48 0c             	lea    0xc(%rax),%ecx
  8041604d87:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
  8041604d8e:	48 d3 e6             	shl    %cl,%rsi
  8041604d91:	48 f7 d6             	not    %rsi
  8041604d94:	4c 85 c6             	test   %r8,%rsi
  8041604d97:	0f 85 87 00 00 00    	jne    8041604e24 <check_physical_tree+0xec>
    if (page->state == ALLOCATABLE_NODE || page->state == RESERVED_NODE) {
  8041604d9d:	44 89 d1             	mov    %r10d,%ecx
  8041604da0:	81 e1 ff ff ef ff    	and    $0xffefffff,%ecx
  8041604da6:	81 f9 00 00 40 00    	cmp    $0x400000,%ecx
  8041604dac:	0f 85 11 01 00 00    	jne    8041604ec3 <check_physical_tree+0x18b>
        if (page->left) assert(page->left->state == page->state);
  8041604db2:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8041604db6:	48 85 ff             	test   %rdi,%rdi
  8041604db9:	0f 84 8e 05 00 00    	je     804160534d <check_physical_tree+0x615>
  8041604dbf:	44 3b 57 28          	cmp    0x28(%rdi),%r10d
  8041604dc3:	0f 85 90 00 00 00    	jne    8041604e59 <check_physical_tree+0x121>
        if (page->right) assert(page->right->state == page->state);
  8041604dc9:	4c 8b 63 18          	mov    0x18(%rbx),%r12
  8041604dcd:	4d 85 e4             	test   %r12,%r12
  8041604dd0:	0f 84 f6 00 00 00    	je     8041604ecc <check_physical_tree+0x194>
  8041604dd6:	45 3b 54 24 28       	cmp    0x28(%r12),%r10d
  8041604ddb:	0f 85 ad 00 00 00    	jne    8041604e8e <check_physical_tree+0x156>
    }
    if (page->left) {
  8041604de1:	48 85 ff             	test   %rdi,%rdi
  8041604de4:	0f 85 e2 00 00 00    	jne    8041604ecc <check_physical_tree+0x194>
  8041604dea:	e9 1c 01 00 00       	jmp    8041604f0b <check_physical_tree+0x1d3>
    assert_physical(page);
  8041604def:	48 b9 b8 1e 61 41 80 	movabs $0x8041611eb8,%rcx
  8041604df6:	00 00 00 
  8041604df9:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604e00:	00 00 00 
  8041604e03:	be 14 02 00 00       	mov    $0x214,%esi
  8041604e08:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604e0f:	00 00 00 
  8041604e12:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604e17:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604e1e:	00 00 00 
  8041604e21:	41 ff d0             	call   *%r8
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  8041604e24:	48 b9 d8 1f 61 41 80 	movabs $0x8041611fd8,%rcx
  8041604e2b:	00 00 00 
  8041604e2e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604e35:	00 00 00 
  8041604e38:	be 16 02 00 00       	mov    $0x216,%esi
  8041604e3d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604e44:	00 00 00 
  8041604e47:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604e4c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604e53:	00 00 00 
  8041604e56:	41 ff d0             	call   *%r8
        if (page->left) assert(page->left->state == page->state);
  8041604e59:	48 b9 08 20 61 41 80 	movabs $0x8041612008,%rcx
  8041604e60:	00 00 00 
  8041604e63:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604e6a:	00 00 00 
  8041604e6d:	be 18 02 00 00       	mov    $0x218,%esi
  8041604e72:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604e79:	00 00 00 
  8041604e7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604e81:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604e88:	00 00 00 
  8041604e8b:	41 ff d0             	call   *%r8
        if (page->right) assert(page->right->state == page->state);
  8041604e8e:	48 b9 30 20 61 41 80 	movabs $0x8041612030,%rcx
  8041604e95:	00 00 00 
  8041604e98:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604e9f:	00 00 00 
  8041604ea2:	be 19 02 00 00       	mov    $0x219,%esi
  8041604ea7:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604eae:	00 00 00 
  8041604eb1:	b8 00 00 00 00       	mov    $0x0,%eax
  8041604eb6:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041604ebd:	00 00 00 
  8041604ec0:	41 ff d0             	call   *%r8
    if (page->left) {
  8041604ec3:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8041604ec7:	48 85 ff             	test   %rdi,%rdi
  8041604eca:	74 36                	je     8041604f02 <check_physical_tree+0x1ca>
        assert(page->left->class + 1 == page->class);
  8041604ecc:	0f b7 4f 34          	movzwl 0x34(%rdi),%ecx
  8041604ed0:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041604ed6:	83 c1 01             	add    $0x1,%ecx
  8041604ed9:	39 c8                	cmp    %ecx,%eax
  8041604edb:	0f 85 32 01 00 00    	jne    8041605013 <check_physical_tree+0x2db>
  8041604ee1:	48 be ff ff ff ff ff 	movabs $0xfffffffffffff,%rsi
  8041604ee8:	ff 0f 00 
  8041604eeb:	48 89 f1             	mov    %rsi,%rcx
  8041604eee:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8041604ef2:	48 c1 e1 0c          	shl    $0xc,%rcx
  8041604ef6:	48 21 f1             	and    %rsi,%rcx
        assert(page2pa(page) == page2pa(page->left));
  8041604ef9:	49 39 c8             	cmp    %rcx,%r8
  8041604efc:	0f 85 46 01 00 00    	jne    8041605048 <check_physical_tree+0x310>
    }
    if (page->right) {
  8041604f02:	4c 8b 63 18          	mov    0x18(%rbx),%r12
  8041604f06:	4d 85 e4             	test   %r12,%r12
  8041604f09:	74 3d                	je     8041604f48 <check_physical_tree+0x210>
        assert(page->right->class + 1 == page->class);
  8041604f0b:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  8041604f11:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041604f17:	83 c1 01             	add    $0x1,%ecx
  8041604f1a:	39 c8                	cmp    %ecx,%eax
  8041604f1c:	0f 85 5b 01 00 00    	jne    804160507d <check_physical_tree+0x345>
        assert(page->addr + (1ULL << (page->class - 1)) == page->right->addr);
  8041604f22:	8d 48 ff             	lea    -0x1(%rax),%ecx
  8041604f25:	be 01 00 00 00       	mov    $0x1,%esi
  8041604f2a:	48 d3 e6             	shl    %cl,%rsi
  8041604f2d:	4c 01 ce             	add    %r9,%rsi
  8041604f30:	48 b9 ff ff ff ff ff 	movabs $0xfffffffffffff,%rcx
  8041604f37:	ff 0f 00 
  8041604f3a:	49 23 4c 24 38       	and    0x38(%r12),%rcx
  8041604f3f:	48 39 ce             	cmp    %rcx,%rsi
  8041604f42:	0f 85 6a 01 00 00    	jne    80416050b2 <check_physical_tree+0x37a>
    }
    if (page->parent) {
  8041604f48:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  8041604f4c:	48 85 f6             	test   %rsi,%rsi
  8041604f4f:	0f 84 fc 01 00 00    	je     8041605151 <check_physical_tree+0x419>
        assert(page->parent->class - 1 == page->class);
  8041604f55:	0f b7 4e 34          	movzwl 0x34(%rsi),%ecx
  8041604f59:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041604f5f:	83 e9 01             	sub    $0x1,%ecx
  8041604f62:	39 c8                	cmp    %ecx,%eax
  8041604f64:	0f 85 7d 01 00 00    	jne    80416050e7 <check_physical_tree+0x3af>
        assert((page->parent->left == page) ^ (page->parent->right == page));
  8041604f6a:	48 39 5e 10          	cmp    %rbx,0x10(%rsi)
  8041604f6e:	0f 95 c1             	setne  %cl
  8041604f71:	48 39 5e 18          	cmp    %rbx,0x18(%rsi)
  8041604f75:	0f 94 c0             	sete   %al
  8041604f78:	38 c1                	cmp    %al,%cl
  8041604f7a:	0f 85 9c 01 00 00    	jne    804160511c <check_physical_tree+0x3e4>
    } else {
        assert(page->class == MAX_CLASS);
        assert(page == &root);
    }
    if (!page->refc) {
  8041604f80:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  8041604f84:	0f 85 87 02 00 00    	jne    8041605211 <check_physical_tree+0x4d9>
        assert(page->head.next && page->head.prev);
  8041604f8a:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8041604f8e:	48 85 c0             	test   %rax,%rax
  8041604f91:	0f 84 45 02 00 00    	je     80416051dc <check_physical_tree+0x4a4>
  8041604f97:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  8041604f9b:	0f 84 3b 02 00 00    	je     80416051dc <check_physical_tree+0x4a4>
        if (!list_empty((struct List *)page)) {
  8041604fa1:	48 39 d8             	cmp    %rbx,%rax
  8041604fa4:	0f 84 90 02 00 00    	je     804160523a <check_physical_tree+0x502>
            for (struct List *n = page->head.next;
                 n != &free_classes[page->class]; n = n->next) {
  8041604faa:	0f b7 d2             	movzwl %dx,%edx
  8041604fad:	48 c1 e2 04          	shl    $0x4,%rdx
  8041604fb1:	48 b9 40 41 40 42 80 	movabs $0x8042404140,%rcx
  8041604fb8:	00 00 00 
  8041604fbb:	48 01 ca             	add    %rcx,%rdx
            for (struct List *n = page->head.next;
  8041604fbe:	48 39 d0             	cmp    %rdx,%rax
  8041604fc1:	0f 84 73 02 00 00    	je     804160523a <check_physical_tree+0x502>
                assert(n != &page->head);
  8041604fc7:	48 39 d8             	cmp    %rbx,%rax
  8041604fca:	74 12                	je     8041604fde <check_physical_tree+0x2a6>
                 n != &free_classes[page->class]; n = n->next) {
  8041604fcc:	48 8b 40 08          	mov    0x8(%rax),%rax
            for (struct List *n = page->head.next;
  8041604fd0:	48 39 c2             	cmp    %rax,%rdx
  8041604fd3:	0f 84 61 02 00 00    	je     804160523a <check_physical_tree+0x502>
                assert(n != &page->head);
  8041604fd9:	48 39 c3             	cmp    %rax,%rbx
  8041604fdc:	75 ee                	jne    8041604fcc <check_physical_tree+0x294>
  8041604fde:	48 b9 30 1c 61 41 80 	movabs $0x8041611c30,%rcx
  8041604fe5:	00 00 00 
  8041604fe8:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041604fef:	00 00 00 
  8041604ff2:	be 2f 02 00 00       	mov    $0x22f,%esi
  8041604ff7:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041604ffe:	00 00 00 
  8041605001:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605006:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160500d:	00 00 00 
  8041605010:	41 ff d0             	call   *%r8
        assert(page->left->class + 1 == page->class);
  8041605013:	48 b9 58 20 61 41 80 	movabs $0x8041612058,%rcx
  804160501a:	00 00 00 
  804160501d:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605024:	00 00 00 
  8041605027:	be 1c 02 00 00       	mov    $0x21c,%esi
  804160502c:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605033:	00 00 00 
  8041605036:	b8 00 00 00 00       	mov    $0x0,%eax
  804160503b:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605042:	00 00 00 
  8041605045:	41 ff d0             	call   *%r8
        assert(page2pa(page) == page2pa(page->left));
  8041605048:	48 b9 80 20 61 41 80 	movabs $0x8041612080,%rcx
  804160504f:	00 00 00 
  8041605052:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605059:	00 00 00 
  804160505c:	be 1d 02 00 00       	mov    $0x21d,%esi
  8041605061:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605068:	00 00 00 
  804160506b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605070:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605077:	00 00 00 
  804160507a:	41 ff d0             	call   *%r8
        assert(page->right->class + 1 == page->class);
  804160507d:	48 b9 a8 20 61 41 80 	movabs $0x80416120a8,%rcx
  8041605084:	00 00 00 
  8041605087:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160508e:	00 00 00 
  8041605091:	be 20 02 00 00       	mov    $0x220,%esi
  8041605096:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160509d:	00 00 00 
  80416050a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80416050a5:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416050ac:	00 00 00 
  80416050af:	41 ff d0             	call   *%r8
        assert(page->addr + (1ULL << (page->class - 1)) == page->right->addr);
  80416050b2:	48 b9 d0 20 61 41 80 	movabs $0x80416120d0,%rcx
  80416050b9:	00 00 00 
  80416050bc:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416050c3:	00 00 00 
  80416050c6:	be 21 02 00 00       	mov    $0x221,%esi
  80416050cb:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416050d2:	00 00 00 
  80416050d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80416050da:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416050e1:	00 00 00 
  80416050e4:	41 ff d0             	call   *%r8
        assert(page->parent->class - 1 == page->class);
  80416050e7:	48 b9 10 21 61 41 80 	movabs $0x8041612110,%rcx
  80416050ee:	00 00 00 
  80416050f1:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416050f8:	00 00 00 
  80416050fb:	be 24 02 00 00       	mov    $0x224,%esi
  8041605100:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605107:	00 00 00 
  804160510a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160510f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605116:	00 00 00 
  8041605119:	41 ff d0             	call   *%r8
        assert((page->parent->left == page) ^ (page->parent->right == page));
  804160511c:	48 b9 38 21 61 41 80 	movabs $0x8041612138,%rcx
  8041605123:	00 00 00 
  8041605126:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160512d:	00 00 00 
  8041605130:	be 25 02 00 00       	mov    $0x225,%esi
  8041605135:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160513c:	00 00 00 
  804160513f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605144:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160514b:	00 00 00 
  804160514e:	41 ff d0             	call   *%r8
        assert(page->class == MAX_CLASS);
  8041605151:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
  8041605155:	66 25 ff 0f          	and    $0xfff,%ax
  8041605159:	66 83 f8 30          	cmp    $0x30,%ax
  804160515d:	75 48                	jne    80416051a7 <check_physical_tree+0x46f>
        assert(page == &root);
  804160515f:	48 b8 60 00 40 42 80 	movabs $0x8042400060,%rax
  8041605166:	00 00 00 
  8041605169:	48 39 c3             	cmp    %rax,%rbx
  804160516c:	0f 84 0e fe ff ff    	je     8041604f80 <check_physical_tree+0x248>
  8041605172:	48 b9 22 1c 61 41 80 	movabs $0x8041611c22,%rcx
  8041605179:	00 00 00 
  804160517c:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605183:	00 00 00 
  8041605186:	be 28 02 00 00       	mov    $0x228,%esi
  804160518b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605192:	00 00 00 
  8041605195:	b8 00 00 00 00       	mov    $0x0,%eax
  804160519a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416051a1:	00 00 00 
  80416051a4:	41 ff d0             	call   *%r8
        assert(page->class == MAX_CLASS);
  80416051a7:	48 b9 09 1c 61 41 80 	movabs $0x8041611c09,%rcx
  80416051ae:	00 00 00 
  80416051b1:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416051b8:	00 00 00 
  80416051bb:	be 27 02 00 00       	mov    $0x227,%esi
  80416051c0:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416051c7:	00 00 00 
  80416051ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80416051cf:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416051d6:	00 00 00 
  80416051d9:	41 ff d0             	call   *%r8
        assert(page->head.next && page->head.prev);
  80416051dc:	48 b9 78 21 61 41 80 	movabs $0x8041612178,%rcx
  80416051e3:	00 00 00 
  80416051e6:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416051ed:	00 00 00 
  80416051f0:	be 2b 02 00 00       	mov    $0x22b,%esi
  80416051f5:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416051fc:	00 00 00 
  80416051ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605204:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160520b:	00 00 00 
  804160520e:	41 ff d0             	call   *%r8
            }
        }
    } else {
        for (struct List *n = (struct List *)page->head.next;
  8041605211:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8041605215:	48 39 c3             	cmp    %rax,%rbx
  8041605218:	74 20                	je     804160523a <check_physical_tree+0x502>
             (struct List *)page != n; n = n->next) {
            struct Page *v = (struct Page *)n;
            assert_virtual(v);
  804160521a:	8b 50 28             	mov    0x28(%rax),%edx
  804160521d:	81 e2 00 00 f0 00    	and    $0xf00000,%edx
  8041605223:	81 fa ff ff 2f 00    	cmp    $0x2fffff,%edx
  8041605229:	77 4e                	ja     8041605279 <check_physical_tree+0x541>
            assert(v->phy == page);
  804160522b:	48 39 58 30          	cmp    %rbx,0x30(%rax)
  804160522f:	75 7d                	jne    80416052ae <check_physical_tree+0x576>
             (struct List *)page != n; n = n->next) {
  8041605231:	48 8b 40 08          	mov    0x8(%rax),%rax
        for (struct List *n = (struct List *)page->head.next;
  8041605235:	48 39 c3             	cmp    %rax,%rbx
  8041605238:	75 e0                	jne    804160521a <check_physical_tree+0x4e2>
        }
    }
    if (page->left) {
  804160523a:	48 85 ff             	test   %rdi,%rdi
  804160523d:	74 16                	je     8041605255 <check_physical_tree+0x51d>
        assert(page->left->parent == page);
  804160523f:	48 39 5f 20          	cmp    %rbx,0x20(%rdi)
  8041605243:	0f 85 9a 00 00 00    	jne    80416052e3 <check_physical_tree+0x5ab>
        check_physical_tree(page->left);
  8041605249:	48 b8 38 4d 60 41 80 	movabs $0x8041604d38,%rax
  8041605250:	00 00 00 
  8041605253:	ff d0                	call   *%rax
    }
    if (page->right) {
  8041605255:	4d 85 e4             	test   %r12,%r12
  8041605258:	74 1a                	je     8041605274 <check_physical_tree+0x53c>
        assert(page->right->parent == page);
  804160525a:	49 39 5c 24 20       	cmp    %rbx,0x20(%r12)
  804160525f:	0f 85 b3 00 00 00    	jne    8041605318 <check_physical_tree+0x5e0>
        check_physical_tree(page->right);
  8041605265:	4c 89 e7             	mov    %r12,%rdi
  8041605268:	48 b8 38 4d 60 41 80 	movabs $0x8041604d38,%rax
  804160526f:	00 00 00 
  8041605272:	ff d0                	call   *%rax
    }
}
  8041605274:	5b                   	pop    %rbx
  8041605275:	41 5c                	pop    %r12
  8041605277:	5d                   	pop    %rbp
  8041605278:	c3                   	ret    
            assert_virtual(v);
  8041605279:	48 b9 a0 21 61 41 80 	movabs $0x80416121a0,%rcx
  8041605280:	00 00 00 
  8041605283:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160528a:	00 00 00 
  804160528d:	be 36 02 00 00       	mov    $0x236,%esi
  8041605292:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605299:	00 00 00 
  804160529c:	b8 00 00 00 00       	mov    $0x0,%eax
  80416052a1:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416052a8:	00 00 00 
  80416052ab:	41 ff d0             	call   *%r8
            assert(v->phy == page);
  80416052ae:	48 b9 41 1c 61 41 80 	movabs $0x8041611c41,%rcx
  80416052b5:	00 00 00 
  80416052b8:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416052bf:	00 00 00 
  80416052c2:	be 37 02 00 00       	mov    $0x237,%esi
  80416052c7:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416052ce:	00 00 00 
  80416052d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80416052d6:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416052dd:	00 00 00 
  80416052e0:	41 ff d0             	call   *%r8
        assert(page->left->parent == page);
  80416052e3:	48 b9 50 1c 61 41 80 	movabs $0x8041611c50,%rcx
  80416052ea:	00 00 00 
  80416052ed:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416052f4:	00 00 00 
  80416052f7:	be 3b 02 00 00       	mov    $0x23b,%esi
  80416052fc:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605303:	00 00 00 
  8041605306:	b8 00 00 00 00       	mov    $0x0,%eax
  804160530b:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605312:	00 00 00 
  8041605315:	41 ff d0             	call   *%r8
        assert(page->right->parent == page);
  8041605318:	48 b9 6b 1c 61 41 80 	movabs $0x8041611c6b,%rcx
  804160531f:	00 00 00 
  8041605322:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605329:	00 00 00 
  804160532c:	be 3f 02 00 00       	mov    $0x23f,%esi
  8041605331:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605338:	00 00 00 
  804160533b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605340:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605347:	00 00 00 
  804160534a:	41 ff d0             	call   *%r8
        if (page->right) assert(page->right->state == page->state);
  804160534d:	4c 8b 63 18          	mov    0x18(%rbx),%r12
  8041605351:	4d 85 e4             	test   %r12,%r12
  8041605354:	0f 85 7c fa ff ff    	jne    8041604dd6 <check_physical_tree+0x9e>
    if (page->left) {
  804160535a:	4c 89 e7             	mov    %r12,%rdi
  804160535d:	e9 e6 fb ff ff       	jmp    8041604f48 <check_physical_tree+0x210>

0000008041605362 <check_virtual_tree>:

static void
check_virtual_tree(struct Page *page, int class) {
  8041605362:	55                   	push   %rbp
  8041605363:	48 89 e5             	mov    %rsp,%rbp
  8041605366:	41 54                	push   %r12
  8041605368:	53                   	push   %rbx
    assert(class >= 0);
  8041605369:	85 f6                	test   %esi,%esi
  804160536b:	0f 88 8c 00 00 00    	js     80416053fd <check_virtual_tree+0x9b>
  8041605371:	48 89 fb             	mov    %rdi,%rbx
  8041605374:	41 89 f4             	mov    %esi,%r12d
    assert_virtual(page);
  8041605377:	8b 47 28             	mov    0x28(%rdi),%eax
  804160537a:	89 c2                	mov    %eax,%edx
  804160537c:	81 e2 00 00 f0 00    	and    $0xf00000,%edx
  8041605382:	81 fa ff ff 2f 00    	cmp    $0x2fffff,%edx
  8041605388:	0f 87 a4 00 00 00    	ja     8041605432 <check_virtual_tree+0xd0>
    if ((page->state & NODE_TYPE_MASK) == MAPPING_NODE) {
  804160538e:	81 fa 00 00 10 00    	cmp    $0x100000,%edx
  8041605394:	0f 84 cd 00 00 00    	je     8041605467 <check_virtual_tree+0x105>
        assert(!page->left && !page->right);
        assert(page->phy);
        if (!(page->phy->class == class)) cprintf("%d %d\n", page->phy->class, class);
        assert(page->phy->class == class);
    } else {
        assert(!page->phy);
  804160539a:	48 83 7f 30 00       	cmpq   $0x0,0x30(%rdi)
  804160539f:	0f 85 10 02 00 00    	jne    80416055b5 <check_virtual_tree+0x253>
        assert(page->state == INTERMEDIATE_NODE);
  80416053a5:	3d 00 00 20 00       	cmp    $0x200000,%eax
  80416053aa:	0f 85 3a 02 00 00    	jne    80416055ea <check_virtual_tree+0x288>
    }
    if (page->left) {
  80416053b0:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  80416053b4:	48 85 ff             	test   %rdi,%rdi
  80416053b7:	74 1b                	je     80416053d4 <check_virtual_tree+0x72>
        assert(page->left->parent == page);
  80416053b9:	48 39 5f 20          	cmp    %rbx,0x20(%rdi)
  80416053bd:	0f 85 5c 02 00 00    	jne    804160561f <check_virtual_tree+0x2bd>
        check_virtual_tree(page->left, class - 1);
  80416053c3:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  80416053c8:	48 b8 62 53 60 41 80 	movabs $0x8041605362,%rax
  80416053cf:	00 00 00 
  80416053d2:	ff d0                	call   *%rax
    }
    if (page->right) {
  80416053d4:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  80416053d8:	48 85 ff             	test   %rdi,%rdi
  80416053db:	74 1b                	je     80416053f8 <check_virtual_tree+0x96>
        assert(page->right->parent == page);
  80416053dd:	48 39 5f 20          	cmp    %rbx,0x20(%rdi)
  80416053e1:	0f 85 6d 02 00 00    	jne    8041605654 <check_virtual_tree+0x2f2>
        check_virtual_tree(page->right, class - 1);
  80416053e7:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  80416053ec:	48 b8 62 53 60 41 80 	movabs $0x8041605362,%rax
  80416053f3:	00 00 00 
  80416053f6:	ff d0                	call   *%rax
    }
}
  80416053f8:	5b                   	pop    %rbx
  80416053f9:	41 5c                	pop    %r12
  80416053fb:	5d                   	pop    %rbp
  80416053fc:	c3                   	ret    
    assert(class >= 0);
  80416053fd:	48 b9 87 1c 61 41 80 	movabs $0x8041611c87,%rcx
  8041605404:	00 00 00 
  8041605407:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160540e:	00 00 00 
  8041605411:	be 46 02 00 00       	mov    $0x246,%esi
  8041605416:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160541d:	00 00 00 
  8041605420:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605425:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160542c:	00 00 00 
  804160542f:	41 ff d0             	call   *%r8
    assert_virtual(page);
  8041605432:	48 b9 d0 21 61 41 80 	movabs $0x80416121d0,%rcx
  8041605439:	00 00 00 
  804160543c:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605443:	00 00 00 
  8041605446:	be 47 02 00 00       	mov    $0x247,%esi
  804160544b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605452:	00 00 00 
  8041605455:	b8 00 00 00 00       	mov    $0x0,%eax
  804160545a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605461:	00 00 00 
  8041605464:	41 ff d0             	call   *%r8
        assert(page->phy);
  8041605467:	48 8b 57 30          	mov    0x30(%rdi),%rdx
  804160546b:	48 85 d2             	test   %rdx,%rdx
  804160546e:	0f 84 a2 00 00 00    	je     8041605516 <check_virtual_tree+0x1b4>
        assert(!(page->state & PROT_LAZY) || !(page->state & PROT_SHARE));
  8041605474:	25 c0 00 00 00       	and    $0xc0,%eax
  8041605479:	3d c0 00 00 00       	cmp    $0xc0,%eax
  804160547e:	0f 84 c7 00 00 00    	je     804160554b <check_virtual_tree+0x1e9>
        assert(!page->left && !page->right);
  8041605484:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
  8041605489:	0f 85 f1 00 00 00    	jne    8041605580 <check_virtual_tree+0x21e>
  804160548f:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
  8041605494:	0f 85 e6 00 00 00    	jne    8041605580 <check_virtual_tree+0x21e>
        if (!(page->phy->class == class)) cprintf("%d %d\n", page->phy->class, class);
  804160549a:	0f b7 72 34          	movzwl 0x34(%rdx),%esi
  804160549e:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
  80416054a4:	44 39 e6             	cmp    %r12d,%esi
  80416054a7:	0f 84 27 ff ff ff    	je     80416053d4 <check_virtual_tree+0x72>
  80416054ad:	44 89 e2             	mov    %r12d,%edx
  80416054b0:	48 bf ae 1c 61 41 80 	movabs $0x8041611cae,%rdi
  80416054b7:	00 00 00 
  80416054ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80416054bf:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  80416054c6:	00 00 00 
  80416054c9:	ff d1                	call   *%rcx
        assert(page->phy->class == class);
  80416054cb:	48 8b 43 30          	mov    0x30(%rbx),%rax
  80416054cf:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80416054d3:	25 ff 0f 00 00       	and    $0xfff,%eax
  80416054d8:	44 39 e0             	cmp    %r12d,%eax
  80416054db:	0f 84 cf fe ff ff    	je     80416053b0 <check_virtual_tree+0x4e>
  80416054e1:	48 b9 b5 1c 61 41 80 	movabs $0x8041611cb5,%rcx
  80416054e8:	00 00 00 
  80416054eb:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416054f2:	00 00 00 
  80416054f5:	be 4e 02 00 00       	mov    $0x24e,%esi
  80416054fa:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605501:	00 00 00 
  8041605504:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605509:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605510:	00 00 00 
  8041605513:	41 ff d0             	call   *%r8
        assert(page->phy);
  8041605516:	48 b9 d0 1c 61 41 80 	movabs $0x8041611cd0,%rcx
  804160551d:	00 00 00 
  8041605520:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605527:	00 00 00 
  804160552a:	be 49 02 00 00       	mov    $0x249,%esi
  804160552f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605536:	00 00 00 
  8041605539:	b8 00 00 00 00       	mov    $0x0,%eax
  804160553e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605545:	00 00 00 
  8041605548:	41 ff d0             	call   *%r8
        assert(!(page->state & PROT_LAZY) || !(page->state & PROT_SHARE));
  804160554b:	48 b9 00 22 61 41 80 	movabs $0x8041612200,%rcx
  8041605552:	00 00 00 
  8041605555:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160555c:	00 00 00 
  804160555f:	be 4a 02 00 00       	mov    $0x24a,%esi
  8041605564:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160556b:	00 00 00 
  804160556e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605573:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160557a:	00 00 00 
  804160557d:	41 ff d0             	call   *%r8
        assert(!page->left && !page->right);
  8041605580:	48 b9 92 1c 61 41 80 	movabs $0x8041611c92,%rcx
  8041605587:	00 00 00 
  804160558a:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605591:	00 00 00 
  8041605594:	be 4b 02 00 00       	mov    $0x24b,%esi
  8041605599:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416055a0:	00 00 00 
  80416055a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80416055a8:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416055af:	00 00 00 
  80416055b2:	41 ff d0             	call   *%r8
        assert(!page->phy);
  80416055b5:	48 b9 cf 1c 61 41 80 	movabs $0x8041611ccf,%rcx
  80416055bc:	00 00 00 
  80416055bf:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416055c6:	00 00 00 
  80416055c9:	be 50 02 00 00       	mov    $0x250,%esi
  80416055ce:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416055d5:	00 00 00 
  80416055d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80416055dd:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416055e4:	00 00 00 
  80416055e7:	41 ff d0             	call   *%r8
        assert(page->state == INTERMEDIATE_NODE);
  80416055ea:	48 b9 40 22 61 41 80 	movabs $0x8041612240,%rcx
  80416055f1:	00 00 00 
  80416055f4:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416055fb:	00 00 00 
  80416055fe:	be 51 02 00 00       	mov    $0x251,%esi
  8041605603:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160560a:	00 00 00 
  804160560d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605612:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605619:	00 00 00 
  804160561c:	41 ff d0             	call   *%r8
        assert(page->left->parent == page);
  804160561f:	48 b9 50 1c 61 41 80 	movabs $0x8041611c50,%rcx
  8041605626:	00 00 00 
  8041605629:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605630:	00 00 00 
  8041605633:	be 54 02 00 00       	mov    $0x254,%esi
  8041605638:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160563f:	00 00 00 
  8041605642:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605647:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160564e:	00 00 00 
  8041605651:	41 ff d0             	call   *%r8
        assert(page->right->parent == page);
  8041605654:	48 b9 6b 1c 61 41 80 	movabs $0x8041611c6b,%rcx
  804160565b:	00 00 00 
  804160565e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605665:	00 00 00 
  8041605668:	be 58 02 00 00       	mov    $0x258,%esi
  804160566d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605674:	00 00 00 
  8041605677:	b8 00 00 00 00       	mov    $0x0,%eax
  804160567c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605683:	00 00 00 
  8041605686:	41 ff d0             	call   *%r8

0000008041605689 <ensure_free_desc>:
ensure_free_desc(size_t count) {
  8041605689:	55                   	push   %rbp
  804160568a:	48 89 e5             	mov    %rsp,%rbp
  804160568d:	53                   	push   %rbx
  804160568e:	48 83 ec 08          	sub    $0x8,%rsp
    if (free_desc_count < count) {
  8041605692:	48 b8 10 41 40 42 80 	movabs $0x8042404110,%rax
  8041605699:	00 00 00 
  804160569c:	48 39 38             	cmp    %rdi,(%rax)
  804160569f:	72 1a                	jb     80416056bb <ensure_free_desc+0x32>
    return list->next == list;
  80416056a1:	48 b8 20 41 40 42 80 	movabs $0x8042404120,%rax
  80416056a8:	00 00 00 
    assert(!list_empty(&free_descriptors));
  80416056ab:	48 39 40 08          	cmp    %rax,0x8(%rax)
  80416056af:	0f 84 8d 00 00 00    	je     8041605742 <ensure_free_desc+0xb9>
}
  80416056b5:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80416056b9:	c9                   	leave  
  80416056ba:	c3                   	ret    
  80416056bb:	48 89 fb             	mov    %rdi,%rbx
        struct Page *res = alloc_page(POOL_CLASS, ALLOC_POOL);
  80416056be:	be 00 00 01 00       	mov    $0x10000,%esi
  80416056c3:	bf 01 00 00 00       	mov    $0x1,%edi
  80416056c8:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  80416056cf:	00 00 00 
  80416056d2:	ff d0                	call   *%rax
        if (!res) panic("Out of memory\n");
  80416056d4:	48 85 c0             	test   %rax,%rax
  80416056d7:	74 44                	je     804160571d <ensure_free_desc+0x94>
    assert(free_desc_count >= count);
  80416056d9:	48 b8 10 41 40 42 80 	movabs $0x8042404110,%rax
  80416056e0:	00 00 00 
  80416056e3:	48 39 18             	cmp    %rbx,(%rax)
  80416056e6:	73 b9                	jae    80416056a1 <ensure_free_desc+0x18>
  80416056e8:	48 b9 e9 1c 61 41 80 	movabs $0x8041611ce9,%rcx
  80416056ef:	00 00 00 
  80416056f2:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416056f9:	00 00 00 
  80416056fc:	be 7a 00 00 00       	mov    $0x7a,%esi
  8041605701:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605708:	00 00 00 
  804160570b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605710:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605717:	00 00 00 
  804160571a:	41 ff d0             	call   *%r8
        if (!res) panic("Out of memory\n");
  804160571d:	48 ba da 1c 61 41 80 	movabs $0x8041611cda,%rdx
  8041605724:	00 00 00 
  8041605727:	be 77 00 00 00       	mov    $0x77,%esi
  804160572c:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605733:	00 00 00 
  8041605736:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160573d:	00 00 00 
  8041605740:	ff d1                	call   *%rcx
    assert(!list_empty(&free_descriptors));
  8041605742:	48 b9 68 22 61 41 80 	movabs $0x8041612268,%rcx
  8041605749:	00 00 00 
  804160574c:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605753:	00 00 00 
  8041605756:	be 7b 00 00 00       	mov    $0x7b,%esi
  804160575b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605762:	00 00 00 
  8041605765:	b8 00 00 00 00       	mov    $0x0,%eax
  804160576a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605771:	00 00 00 
  8041605774:	41 ff d0             	call   *%r8

0000008041605777 <alloc_descriptor>:
alloc_descriptor(enum PageState state) {
  8041605777:	55                   	push   %rbp
  8041605778:	48 89 e5             	mov    %rsp,%rbp
  804160577b:	41 54                	push   %r12
  804160577d:	53                   	push   %rbx
  804160577e:	41 89 fc             	mov    %edi,%r12d
    ensure_free_desc(1);
  8041605781:	bf 01 00 00 00       	mov    $0x1,%edi
  8041605786:	48 b8 89 56 60 41 80 	movabs $0x8041605689,%rax
  804160578d:	00 00 00 
  8041605790:	ff d0                	call   *%rax
    struct Page *new = (struct Page *)list_del(free_descriptors.next);
  8041605792:	48 b8 28 41 40 42 80 	movabs $0x8042404128,%rax
  8041605799:	00 00 00 
  804160579c:	48 8b 18             	mov    (%rax),%rbx
    list->prev->next = list->next;
  804160579f:	48 8b 13             	mov    (%rbx),%rdx
  80416057a2:	48 8b 43 08          	mov    0x8(%rbx),%rax
  80416057a6:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list->next->prev = list->prev;
  80416057aa:	48 8b 13             	mov    (%rbx),%rdx
  80416057ad:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  80416057b0:	48 89 1b             	mov    %rbx,(%rbx)
  80416057b3:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
    memset(new, 0, sizeof *new);
  80416057b7:	ba 40 00 00 00       	mov    $0x40,%edx
  80416057bc:	be 00 00 00 00       	mov    $0x0,%esi
  80416057c1:	48 89 df             	mov    %rbx,%rdi
  80416057c4:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  80416057cb:	00 00 00 
  80416057ce:	ff d0                	call   *%rax
    list->next = list->prev = list;
  80416057d0:	48 89 1b             	mov    %rbx,(%rbx)
  80416057d3:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
    new->state = state;
  80416057d7:	44 89 63 28          	mov    %r12d,0x28(%rbx)
    free_desc_count--;
  80416057db:	48 b8 10 41 40 42 80 	movabs $0x8042404110,%rax
  80416057e2:	00 00 00 
  80416057e5:	48 83 28 01          	subq   $0x1,(%rax)
}
  80416057e9:	48 89 d8             	mov    %rbx,%rax
  80416057ec:	5b                   	pop    %rbx
  80416057ed:	41 5c                	pop    %r12
  80416057ef:	5d                   	pop    %rbp
  80416057f0:	c3                   	ret    

00000080416057f1 <alloc_child>:
alloc_child(struct Page *parent, bool right) {
  80416057f1:	55                   	push   %rbp
  80416057f2:	48 89 e5             	mov    %rsp,%rbp
  80416057f5:	41 54                	push   %r12
  80416057f7:	53                   	push   %rbx
  80416057f8:	48 89 fb             	mov    %rdi,%rbx
    assert_physical(parent);
  80416057fb:	8b 7f 28             	mov    0x28(%rdi),%edi
  80416057fe:	89 f8                	mov    %edi,%eax
  8041605800:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041605805:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  804160580a:	0f 86 8c 00 00 00    	jbe    804160589c <alloc_child+0xab>
  8041605810:	41 89 f4             	mov    %esi,%r12d
    struct Page *new = alloc_descriptor(parent->state);
  8041605813:	48 b8 77 57 60 41 80 	movabs $0x8041605777,%rax
  804160581a:	00 00 00 
  804160581d:	ff d0                	call   *%rax
    new->refc = parent->refc != 0;
  804160581f:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  8041605823:	0f 95 c2             	setne  %dl
  8041605826:	0f b6 d2             	movzbl %dl,%edx
  8041605829:	89 50 30             	mov    %edx,0x30(%rax)
    new->class = parent->class - 1;
  804160582c:	0f b7 73 34          	movzwl 0x34(%rbx),%esi
  8041605830:	8d 96 ff 0f 00 00    	lea    0xfff(%rsi),%edx
  8041605836:	89 d1                	mov    %edx,%ecx
  8041605838:	66 81 e1 ff 0f       	and    $0xfff,%cx
  804160583d:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  8041605841:	66 81 e2 00 f0       	and    $0xf000,%dx
  8041605846:	09 ca                	or     %ecx,%edx
  8041605848:	66 89 50 34          	mov    %dx,0x34(%rax)
    new->parent = parent;
  804160584c:	48 89 58 20          	mov    %rbx,0x20(%rax)
    if (right) {
  8041605850:	45 84 e4             	test   %r12b,%r12b
  8041605853:	74 7c                	je     80416058d1 <alloc_child+0xe0>
        parent->right = new;
  8041605855:	48 89 43 18          	mov    %rax,0x18(%rbx)
        new->addr = parent->addr + (1ULL << new->class);
  8041605859:	0f b7 48 34          	movzwl 0x34(%rax),%ecx
  804160585d:	ba 01 00 00 00       	mov    $0x1,%edx
  8041605862:	48 d3 e2             	shl    %cl,%rdx
  8041605865:	48 b9 ff ff ff ff ff 	movabs $0xfffffffffffff,%rcx
  804160586c:	ff 0f 00 
  804160586f:	48 23 4b 38          	and    0x38(%rbx),%rcx
  8041605873:	48 01 ca             	add    %rcx,%rdx
  8041605876:	89 50 38             	mov    %edx,0x38(%rax)
  8041605879:	48 89 d1             	mov    %rdx,%rcx
  804160587c:	48 c1 e9 20          	shr    $0x20,%rcx
  8041605880:	66 89 48 3c          	mov    %cx,0x3c(%rax)
  8041605884:	48 c1 ea 30          	shr    $0x30,%rdx
  8041605888:	83 e2 0f             	and    $0xf,%edx
  804160588b:	0f b6 48 3e          	movzbl 0x3e(%rax),%ecx
  804160588f:	83 e1 f0             	and    $0xfffffff0,%ecx
  8041605892:	09 ca                	or     %ecx,%edx
  8041605894:	88 50 3e             	mov    %dl,0x3e(%rax)
}
  8041605897:	5b                   	pop    %rbx
  8041605898:	41 5c                	pop    %r12
  804160589a:	5d                   	pop    %rbp
  804160589b:	c3                   	ret    
    assert_physical(parent);
  804160589c:	48 b9 88 22 61 41 80 	movabs $0x8041612288,%rcx
  80416058a3:	00 00 00 
  80416058a6:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416058ad:	00 00 00 
  80416058b0:	be b9 00 00 00       	mov    $0xb9,%esi
  80416058b5:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416058bc:	00 00 00 
  80416058bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80416058c4:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416058cb:	00 00 00 
  80416058ce:	41 ff d0             	call   *%r8
        parent->left = new;
  80416058d1:	48 89 43 10          	mov    %rax,0x10(%rbx)
        new->addr = parent->addr;
  80416058d5:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  80416058dc:	ff 0f 00 
  80416058df:	48 23 53 38          	and    0x38(%rbx),%rdx
  80416058e3:	89 50 38             	mov    %edx,0x38(%rax)
  80416058e6:	48 89 d1             	mov    %rdx,%rcx
  80416058e9:	48 c1 e9 20          	shr    $0x20,%rcx
  80416058ed:	66 89 48 3c          	mov    %cx,0x3c(%rax)
  80416058f1:	48 c1 ea 30          	shr    $0x30,%rdx
  80416058f5:	0f b6 48 3e          	movzbl 0x3e(%rax),%ecx
  80416058f9:	83 e1 f0             	and    $0xfffffff0,%ecx
  80416058fc:	09 ca                	or     %ecx,%edx
  80416058fe:	88 50 3e             	mov    %dl,0x3e(%rax)
    return new;
  8041605901:	eb 94                	jmp    8041605897 <alloc_child+0xa6>

0000008041605903 <page_lookup>:
page_lookup(struct Page *hint, uintptr_t addr, int class, enum PageState type, bool alloc) {
  8041605903:	55                   	push   %rbp
  8041605904:	48 89 e5             	mov    %rsp,%rbp
  8041605907:	41 57                	push   %r15
  8041605909:	41 56                	push   %r14
  804160590b:	41 55                	push   %r13
  804160590d:	41 54                	push   %r12
  804160590f:	53                   	push   %rbx
  8041605910:	48 83 ec 28          	sub    $0x28,%rsp
  8041605914:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  8041605918:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  804160591b:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
    assert(class >= 0);
  804160591f:	85 d2                	test   %edx,%edx
  8041605921:	78 43                	js     8041605966 <page_lookup+0x63>
  8041605923:	48 89 fb             	mov    %rdi,%rbx
  8041605926:	41 89 d5             	mov    %edx,%r13d
  8041605929:	45 89 c7             	mov    %r8d,%r15d
    if (hint) assert_physical(hint);
  804160592c:	48 85 ff             	test   %rdi,%rdi
  804160592f:	0f 84 5e 04 00 00    	je     8041605d93 <page_lookup+0x490>
  8041605935:	8b 47 28             	mov    0x28(%rdi),%eax
  8041605938:	25 00 00 f0 00       	and    $0xf00000,%eax
  804160593d:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8041605942:	76 57                	jbe    804160599b <page_lookup+0x98>
    assert(!(addr & CLASS_MASK(class)));
  8041605944:	41 8d 4d 0c          	lea    0xc(%r13),%ecx
  8041605948:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  804160594f:	48 d3 e0             	shl    %cl,%rax
  8041605952:	48 f7 d0             	not    %rax
  8041605955:	48 85 45 c8          	test   %rax,-0x38(%rbp)
  8041605959:	75 75                	jne    80416059d0 <page_lookup+0xcd>
        bool right = addr & CLASS_SIZE(node->class - 1);
  804160595b:	41 be 01 00 00 00    	mov    $0x1,%r14d
  8041605961:	e9 46 02 00 00       	jmp    8041605bac <page_lookup+0x2a9>
    assert(class >= 0);
  8041605966:	48 b9 87 1c 61 41 80 	movabs $0x8041611c87,%rcx
  804160596d:	00 00 00 
  8041605970:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605977:	00 00 00 
  804160597a:	be d4 00 00 00       	mov    $0xd4,%esi
  804160597f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605986:	00 00 00 
  8041605989:	b8 00 00 00 00       	mov    $0x0,%eax
  804160598e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605995:	00 00 00 
  8041605998:	41 ff d0             	call   *%r8
    if (hint) assert_physical(hint);
  804160599b:	48 b9 c0 22 61 41 80 	movabs $0x80416122c0,%rcx
  80416059a2:	00 00 00 
  80416059a5:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416059ac:	00 00 00 
  80416059af:	be d5 00 00 00       	mov    $0xd5,%esi
  80416059b4:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416059bb:	00 00 00 
  80416059be:	b8 00 00 00 00       	mov    $0x0,%eax
  80416059c3:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416059ca:	00 00 00 
  80416059cd:	41 ff d0             	call   *%r8
    assert(!(addr & CLASS_MASK(class)));
  80416059d0:	48 b9 02 1d 61 41 80 	movabs $0x8041611d02,%rcx
  80416059d7:	00 00 00 
  80416059da:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416059e1:	00 00 00 
  80416059e4:	be d8 00 00 00       	mov    $0xd8,%esi
  80416059e9:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416059f0:	00 00 00 
  80416059f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80416059f8:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416059ff:	00 00 00 
  8041605a02:	41 ff d0             	call   *%r8
            ensure_free_desc((node->class - class + 1) * 2);
  8041605a05:	44 29 e8             	sub    %r13d,%eax
  8041605a08:	8d 7c 00 02          	lea    0x2(%rax,%rax,1),%edi
  8041605a0c:	48 63 ff             	movslq %edi,%rdi
  8041605a0f:	48 b8 89 56 60 41 80 	movabs $0x8041605689,%rax
  8041605a16:	00 00 00 
  8041605a19:	ff d0                	call   *%rax
            bool was_free = node->state == ALLOCATABLE_NODE && PAGE_IS_FREE(node);
  8041605a1b:	81 7b 28 00 00 40 00 	cmpl   $0x400000,0x28(%rbx)
  8041605a22:	74 51                	je     8041605a75 <page_lookup+0x172>
            if (!node->left) alloc_child(node, 0);
  8041605a24:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  8041605a29:	74 62                	je     8041605a8d <page_lookup+0x18a>
            if (!node->right) alloc_child(node, 1);
  8041605a2b:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8041605a30:	0f 84 e0 00 00 00    	je     8041605b16 <page_lookup+0x213>
            if (type != PARTIAL_NODE && node->state != type)
  8041605a36:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8041605a39:	3d 00 00 30 00       	cmp    $0x300000,%eax
  8041605a3e:	74 0c                	je     8041605a4c <page_lookup+0x149>
  8041605a40:	39 43 28             	cmp    %eax,0x28(%rbx)
  8041605a43:	74 07                	je     8041605a4c <page_lookup+0x149>
                node->state = PARTIAL_NODE;
  8041605a45:	c7 43 28 00 00 30 00 	movl   $0x300000,0x28(%rbx)
        assert((node->left && node->right) || !alloc);
  8041605a4c:	48 8b 43 10          	mov    0x10(%rbx),%rax
  8041605a50:	48 85 c0             	test   %rax,%rax
  8041605a53:	0f 84 15 01 00 00    	je     8041605b6e <page_lookup+0x26b>
  8041605a59:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8041605a5e:	0f 84 0a 01 00 00    	je     8041605b6e <page_lookup+0x26b>
        node = right ? node->right : node->left;
  8041605a64:	4d 85 e4             	test   %r12,%r12
  8041605a67:	0f 85 36 01 00 00    	jne    8041605ba3 <page_lookup+0x2a0>
  8041605a6d:	48 89 c3             	mov    %rax,%rbx
  8041605a70:	e9 37 01 00 00       	jmp    8041605bac <page_lookup+0x2a9>
            bool was_free = node->state == ALLOCATABLE_NODE && PAGE_IS_FREE(node);
  8041605a75:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  8041605a79:	75 a9                	jne    8041605a24 <page_lookup+0x121>
  8041605a7b:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  8041605a80:	75 a9                	jne    8041605a2b <page_lookup+0x128>
  8041605a82:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8041605a87:	0f 94 45 c3          	sete   -0x3d(%rbp)
  8041605a8b:	eb 04                	jmp    8041605a91 <page_lookup+0x18e>
  8041605a8d:	c6 45 c3 00          	movb   $0x0,-0x3d(%rbp)
            if (!node->left) alloc_child(node, 0);
  8041605a91:	be 00 00 00 00       	mov    $0x0,%esi
  8041605a96:	48 89 df             	mov    %rbx,%rdi
  8041605a99:	48 b8 f1 57 60 41 80 	movabs $0x80416057f1,%rax
  8041605aa0:	00 00 00 
  8041605aa3:	ff d0                	call   *%rax
            if (!node->right) alloc_child(node, 1);
  8041605aa5:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8041605aaa:	74 6e                	je     8041605b1a <page_lookup+0x217>
            if (was_free) {
  8041605aac:	80 7d c3 00          	cmpb   $0x0,-0x3d(%rbp)
  8041605ab0:	74 84                	je     8041605a36 <page_lookup+0x133>
                struct Page *other = !right ? node->right : node->left;
  8041605ab2:	4d 85 e4             	test   %r12,%r12
  8041605ab5:	75 7c                	jne    8041605b33 <page_lookup+0x230>
  8041605ab7:	48 8b 53 18          	mov    0x18(%rbx),%rdx
                assert(other->state == ALLOCATABLE_NODE);
  8041605abb:	81 7a 28 00 00 40 00 	cmpl   $0x400000,0x28(%rdx)
  8041605ac2:	75 75                	jne    8041605b39 <page_lookup+0x236>
    list->prev->next = list->next;
  8041605ac4:	48 8b 0b             	mov    (%rbx),%rcx
  8041605ac7:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8041605acb:	48 89 41 08          	mov    %rax,0x8(%rcx)
    list->next->prev = list->prev;
  8041605acf:	48 8b 0b             	mov    (%rbx),%rcx
  8041605ad2:	48 89 08             	mov    %rcx,(%rax)
    list->next = list->prev = list;
  8041605ad5:	48 89 1b             	mov    %rbx,(%rbx)
  8041605ad8:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
                list_append(&free_classes[node->class - 1], (struct List *)other);
  8041605adc:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
  8041605ae0:	25 ff 0f 00 00       	and    $0xfff,%eax
  8041605ae5:	83 e8 01             	sub    $0x1,%eax
    list->next->prev = new;
  8041605ae8:	48 98                	cltq   
  8041605aea:	48 c1 e0 04          	shl    $0x4,%rax
  8041605aee:	48 be 40 41 40 42 80 	movabs $0x8042404140,%rsi
  8041605af5:	00 00 00 
  8041605af8:	48 01 f0             	add    %rsi,%rax
  8041605afb:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8041605aff:	48 89 11             	mov    %rdx,(%rcx)
    new->next = list->next;
  8041605b02:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8041605b06:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
    list->next = new;
  8041605b0a:	48 89 50 08          	mov    %rdx,0x8(%rax)
                list_append(&free_classes[node->class - 1], (struct List *)other);
  8041605b0e:	48 89 02             	mov    %rax,(%rdx)
}
  8041605b11:	e9 20 ff ff ff       	jmp    8041605a36 <page_lookup+0x133>
            if (!node->right) alloc_child(node, 1);
  8041605b16:	c6 45 c3 00          	movb   $0x0,-0x3d(%rbp)
  8041605b1a:	be 01 00 00 00       	mov    $0x1,%esi
  8041605b1f:	48 89 df             	mov    %rbx,%rdi
  8041605b22:	48 b8 f1 57 60 41 80 	movabs $0x80416057f1,%rax
  8041605b29:	00 00 00 
  8041605b2c:	ff d0                	call   *%rax
  8041605b2e:	e9 79 ff ff ff       	jmp    8041605aac <page_lookup+0x1a9>
                struct Page *other = !right ? node->right : node->left;
  8041605b33:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  8041605b37:	eb 82                	jmp    8041605abb <page_lookup+0x1b8>
                assert(other->state == ALLOCATABLE_NODE);
  8041605b39:	48 b9 f8 22 61 41 80 	movabs $0x80416122f8,%rcx
  8041605b40:	00 00 00 
  8041605b43:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605b4a:	00 00 00 
  8041605b4d:	be e8 00 00 00       	mov    $0xe8,%esi
  8041605b52:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605b59:	00 00 00 
  8041605b5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605b61:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605b68:	00 00 00 
  8041605b6b:	41 ff d0             	call   *%r8
        assert((node->left && node->right) || !alloc);
  8041605b6e:	48 b9 20 23 61 41 80 	movabs $0x8041612320,%rcx
  8041605b75:	00 00 00 
  8041605b78:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605b7f:	00 00 00 
  8041605b82:	be f1 00 00 00       	mov    $0xf1,%esi
  8041605b87:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605b8e:	00 00 00 
  8041605b91:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605b96:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605b9d:	00 00 00 
  8041605ba0:	41 ff d0             	call   *%r8
        node = right ? node->right : node->left;
  8041605ba3:	48 8b 5b 18          	mov    0x18(%rbx),%rbx
    while (node && node->class > class) {
  8041605ba7:	48 85 db             	test   %rbx,%rbx
  8041605baa:	74 42                	je     8041605bee <page_lookup+0x2eb>
  8041605bac:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
  8041605bb0:	25 ff 0f 00 00       	and    $0xfff,%eax
  8041605bb5:	44 39 e8             	cmp    %r13d,%eax
  8041605bb8:	7e 73                	jle    8041605c2d <page_lookup+0x32a>
        bool right = addr & CLASS_SIZE(node->class - 1);
  8041605bba:	8d 48 0b             	lea    0xb(%rax),%ecx
  8041605bbd:	4d 89 f4             	mov    %r14,%r12
  8041605bc0:	49 d3 e4             	shl    %cl,%r12
  8041605bc3:	4c 23 65 c8          	and    -0x38(%rbp),%r12
        if (alloc) {
  8041605bc7:	45 84 ff             	test   %r15b,%r15b
  8041605bca:	0f 85 35 fe ff ff    	jne    8041605a05 <page_lookup+0x102>
        assert((node->left && node->right) || !alloc);
  8041605bd0:	48 8b 43 10          	mov    0x10(%rbx),%rax
  8041605bd4:	48 85 c0             	test   %rax,%rax
  8041605bd7:	74 0b                	je     8041605be4 <page_lookup+0x2e1>
  8041605bd9:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8041605bde:	0f 85 80 fe ff ff    	jne    8041605a64 <page_lookup+0x161>
        node = right ? node->right : node->left;
  8041605be4:	4d 85 e4             	test   %r12,%r12
  8041605be7:	75 ba                	jne    8041605ba3 <page_lookup+0x2a0>
  8041605be9:	48 89 c3             	mov    %rax,%rbx
  8041605bec:	eb b9                	jmp    8041605ba7 <page_lookup+0x2a4>
    if (alloc) assert(node);
  8041605bee:	80 7d bc 00          	cmpb   $0x0,-0x44(%rbp)
  8041605bf2:	0f 84 e6 00 00 00    	je     8041605cde <page_lookup+0x3db>
  8041605bf8:	48 b9 1e 1d 61 41 80 	movabs $0x8041611d1e,%rcx
  8041605bff:	00 00 00 
  8041605c02:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605c09:	00 00 00 
  8041605c0c:	be f6 00 00 00       	mov    $0xf6,%esi
  8041605c11:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605c18:	00 00 00 
  8041605c1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605c20:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605c27:	00 00 00 
  8041605c2a:	41 ff d0             	call   *%r8
    if (alloc && type != PARTIAL_NODE) /* Attach new memory */ {
  8041605c2d:	81 7d c4 00 00 30 00 	cmpl   $0x300000,-0x3c(%rbp)
  8041605c34:	74 6a                	je     8041605ca0 <page_lookup+0x39d>
  8041605c36:	80 7d bc 00          	cmpb   $0x0,-0x44(%rbp)
  8041605c3a:	74 64                	je     8041605ca0 <page_lookup+0x39d>
        assert(!node->refc);
  8041605c3c:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  8041605c40:	0f 85 aa 00 00 00    	jne    8041605cf0 <page_lookup+0x3ed>
        free_desc_rec(node->left);
  8041605c46:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8041605c4a:	49 bc 26 48 60 41 80 	movabs $0x8041604826,%r12
  8041605c51:	00 00 00 
  8041605c54:	41 ff d4             	call   *%r12
        free_desc_rec(node->right);
  8041605c57:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8041605c5b:	41 ff d4             	call   *%r12
        node->left = node->right = NULL;
  8041605c5e:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  8041605c65:	00 
  8041605c66:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  8041605c6d:	00 
    list->prev->next = list->next;
  8041605c6e:	48 8b 13             	mov    (%rbx),%rdx
  8041605c71:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8041605c75:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list->next->prev = list->prev;
  8041605c79:	48 8b 13             	mov    (%rbx),%rdx
  8041605c7c:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8041605c7f:	48 89 1b             	mov    %rbx,(%rbx)
  8041605c82:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
        if (type != PARTIAL_NODE && node->state != RESERVED_NODE) node->state = type;
  8041605c86:	81 7b 28 00 00 50 00 	cmpl   $0x500000,0x28(%rbx)
  8041605c8d:	74 11                	je     8041605ca0 <page_lookup+0x39d>
  8041605c8f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8041605c92:	89 43 28             	mov    %eax,0x28(%rbx)
        if (node->state == ALLOCATABLE_NODE) list_append(&free_classes[node->class], (struct List *)node);
  8041605c95:	3d 00 00 40 00       	cmp    $0x400000,%eax
  8041605c9a:	0f 84 85 00 00 00    	je     8041605d25 <page_lookup+0x422>
    if (node) assert(!(page2pa(node) & CLASS_MASK(node->class)));
  8041605ca0:	0f b7 4b 34          	movzwl 0x34(%rbx),%ecx
  8041605ca4:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041605caa:	83 c1 0c             	add    $0xc,%ecx
  8041605cad:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8041605cb4:	48 d3 e0             	shl    %cl,%rax
  8041605cb7:	48 f7 d0             	not    %rax
  8041605cba:	48 89 c2             	mov    %rax,%rdx
  8041605cbd:	48 b9 ff ff ff ff ff 	movabs $0xfffffffffffff,%rcx
  8041605cc4:	ff 0f 00 
  8041605cc7:	48 89 c8             	mov    %rcx,%rax
  8041605cca:	48 23 43 38          	and    0x38(%rbx),%rax
  8041605cce:	48 c1 e0 0c          	shl    $0xc,%rax
  8041605cd2:	48 21 c8             	and    %rcx,%rax
  8041605cd5:	48 85 c2             	test   %rax,%rdx
  8041605cd8:	0f 85 80 00 00 00    	jne    8041605d5e <page_lookup+0x45b>
}
  8041605cde:	48 89 d8             	mov    %rbx,%rax
  8041605ce1:	48 83 c4 28          	add    $0x28,%rsp
  8041605ce5:	5b                   	pop    %rbx
  8041605ce6:	41 5c                	pop    %r12
  8041605ce8:	41 5d                	pop    %r13
  8041605cea:	41 5e                	pop    %r14
  8041605cec:	41 5f                	pop    %r15
  8041605cee:	5d                   	pop    %rbp
  8041605cef:	c3                   	ret    
        assert(!node->refc);
  8041605cf0:	48 b9 23 1d 61 41 80 	movabs $0x8041611d23,%rcx
  8041605cf7:	00 00 00 
  8041605cfa:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605d01:	00 00 00 
  8041605d04:	be f9 00 00 00       	mov    $0xf9,%esi
  8041605d09:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605d10:	00 00 00 
  8041605d13:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605d18:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605d1f:	00 00 00 
  8041605d22:	41 ff d0             	call   *%r8
        if (node->state == ALLOCATABLE_NODE) list_append(&free_classes[node->class], (struct List *)node);
  8041605d25:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
    list->next->prev = new;
  8041605d29:	48 b9 40 41 40 42 80 	movabs $0x8042404140,%rcx
  8041605d30:	00 00 00 
  8041605d33:	48 89 c2             	mov    %rax,%rdx
  8041605d36:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  8041605d3c:	48 c1 e2 04          	shl    $0x4,%rdx
  8041605d40:	48 01 ca             	add    %rcx,%rdx
  8041605d43:	48 8b 72 08          	mov    0x8(%rdx),%rsi
  8041605d47:	48 89 1e             	mov    %rbx,(%rsi)
    new->next = list->next;
  8041605d4a:	48 8b 72 08          	mov    0x8(%rdx),%rsi
  8041605d4e:	48 89 73 08          	mov    %rsi,0x8(%rbx)
    list->next = new;
  8041605d52:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
        if (node->state == ALLOCATABLE_NODE) list_append(&free_classes[node->class], (struct List *)node);
  8041605d56:	48 89 13             	mov    %rdx,(%rbx)
}
  8041605d59:	e9 42 ff ff ff       	jmp    8041605ca0 <page_lookup+0x39d>
    if (node) assert(!(page2pa(node) & CLASS_MASK(node->class)));
  8041605d5e:	48 b9 48 23 61 41 80 	movabs $0x8041612348,%rcx
  8041605d65:	00 00 00 
  8041605d68:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605d6f:	00 00 00 
  8041605d72:	be 08 01 00 00       	mov    $0x108,%esi
  8041605d77:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605d7e:	00 00 00 
  8041605d81:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605d86:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605d8d:	00 00 00 
  8041605d90:	41 ff d0             	call   *%r8
    struct Page *node = hint ? hint : &root;
  8041605d93:	48 bb 60 00 40 42 80 	movabs $0x8042400060,%rbx
  8041605d9a:	00 00 00 
  8041605d9d:	e9 a2 fb ff ff       	jmp    8041605944 <page_lookup+0x41>

0000008041605da2 <alloc_page>:
    }
}

/* Just allocate page, without mapping it */
static struct Page *
alloc_page(int class, int flags) {
  8041605da2:	55                   	push   %rbp
  8041605da3:	48 89 e5             	mov    %rsp,%rbp
  8041605da6:	41 54                	push   %r12
  8041605da8:	53                   	push   %rbx
  8041605da9:	41 89 f2             	mov    %esi,%r10d
    struct List *li = NULL;
    struct Page *peer = NULL;

    if (flags & ALLOC_POOL) flags |= ALLOC_BOOTMEM;
  8041605dac:	89 f0                	mov    %esi,%eax
  8041605dae:	0d 00 00 04 00       	or     $0x40000,%eax
  8041605db3:	f7 c6 00 00 01 00    	test   $0x10000,%esi
  8041605db9:	44 0f 45 d0          	cmovne %eax,%r10d
#ifndef SANITIZE_SHADOW_BASE
    if (current_space) flags &= ~ALLOC_BOOTMEM;
  8041605dbd:	44 89 d0             	mov    %r10d,%eax
  8041605dc0:	25 ff ff fb ff       	and    $0xfffbffff,%eax
  8041605dc5:	48 ba a0 00 40 42 80 	movabs $0x80424000a0,%rdx
  8041605dcc:	00 00 00 
  8041605dcf:	48 83 3a 00          	cmpq   $0x0,(%rdx)
  8041605dd3:	44 0f 45 d0          	cmovne %eax,%r10d
#endif

    /* Find page that is not smaller than requested
     * (Pool memory should also be within BOOT_MEM_SIZE) */
    for (int pclass = class; pclass < MAX_CLASS; pclass++, li = NULL) {
  8041605dd7:	83 ff 2f             	cmp    $0x2f,%edi
  8041605dda:	0f 8f e1 03 00 00    	jg     80416061c1 <alloc_page+0x41f>
  8041605de0:	41 89 f9             	mov    %edi,%r9d
        for (li = free_classes[pclass].next; li != &free_classes[pclass]; li = li->next) {
            peer = (struct Page *)li;
            assert(peer->state == ALLOCATABLE_NODE);
            assert_physical(peer);
            if (!(flags & ALLOC_BOOTMEM) || page2pa(peer) + CLASS_SIZE(class) < BOOT_MEM_SIZE) goto found;
  8041605de3:	8d 4f 0c             	lea    0xc(%rdi),%ecx
  8041605de6:	b8 01 00 00 00       	mov    $0x1,%eax
  8041605deb:	48 d3 e0             	shl    %cl,%rax
  8041605dee:	48 89 c1             	mov    %rax,%rcx
  8041605df1:	48 63 d7             	movslq %edi,%rdx
  8041605df4:	49 89 d3             	mov    %rdx,%r11
  8041605df7:	49 c1 e3 04          	shl    $0x4,%r11
  8041605dfb:	48 b8 40 41 40 42 80 	movabs $0x8042404140,%rax
  8041605e02:	00 00 00 
  8041605e05:	49 01 c3             	add    %rax,%r11
  8041605e08:	b8 2f 00 00 00       	mov    $0x2f,%eax
  8041605e0d:	29 f8                	sub    %edi,%eax
  8041605e0f:	48 01 d0             	add    %rdx,%rax
  8041605e12:	48 c1 e0 04          	shl    $0x4,%rax
  8041605e16:	48 bb 50 41 40 42 80 	movabs $0x8042404150,%rbx
  8041605e1d:	00 00 00 
  8041605e20:	48 01 c3             	add    %rax,%rbx
  8041605e23:	44 89 d6             	mov    %r10d,%esi
  8041605e26:	81 e6 00 00 04 00    	and    $0x40000,%esi
  8041605e2c:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041605e33:	ff 0f 00 
        for (li = free_classes[pclass].next; li != &free_classes[pclass]; li = li->next) {
  8041605e36:	4d 89 d8             	mov    %r11,%r8
  8041605e39:	49 8b 7b 08          	mov    0x8(%r11),%rdi
  8041605e3d:	4c 39 df             	cmp    %r11,%rdi
  8041605e40:	74 2f                	je     8041605e71 <alloc_page+0xcf>
            assert(peer->state == ALLOCATABLE_NODE);
  8041605e42:	81 7f 28 00 00 40 00 	cmpl   $0x400000,0x28(%rdi)
  8041605e49:	75 39                	jne    8041605e84 <alloc_page+0xe2>
            if (!(flags & ALLOC_BOOTMEM) || page2pa(peer) + CLASS_SIZE(class) < BOOT_MEM_SIZE) goto found;
  8041605e4b:	85 f6                	test   %esi,%esi
  8041605e4d:	74 6a                	je     8041605eb9 <alloc_page+0x117>
  8041605e4f:	48 89 d0             	mov    %rdx,%rax
  8041605e52:	48 23 47 38          	and    0x38(%rdi),%rax
  8041605e56:	48 c1 e0 0c          	shl    $0xc,%rax
  8041605e5a:	48 21 d0             	and    %rdx,%rax
  8041605e5d:	48 01 c8             	add    %rcx,%rax
  8041605e60:	48 3d ff ff ff 3f    	cmp    $0x3fffffff,%rax
  8041605e66:	76 51                	jbe    8041605eb9 <alloc_page+0x117>
        for (li = free_classes[pclass].next; li != &free_classes[pclass]; li = li->next) {
  8041605e68:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  8041605e6c:	4c 39 c7             	cmp    %r8,%rdi
  8041605e6f:	75 d1                	jne    8041605e42 <alloc_page+0xa0>
    for (int pclass = class; pclass < MAX_CLASS; pclass++, li = NULL) {
  8041605e71:	49 83 c3 10          	add    $0x10,%r11
  8041605e75:	49 39 db             	cmp    %rbx,%r11
  8041605e78:	75 bc                	jne    8041605e36 <alloc_page+0x94>
        }
    }
    return NULL;
  8041605e7a:	bb 00 00 00 00       	mov    $0x0,%ebx
  8041605e7f:	e9 f3 03 00 00       	jmp    8041606277 <alloc_page+0x4d5>
            assert(peer->state == ALLOCATABLE_NODE);
  8041605e84:	48 b9 78 23 61 41 80 	movabs $0x8041612378,%rcx
  8041605e8b:	00 00 00 
  8041605e8e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041605e95:	00 00 00 
  8041605e98:	be 46 04 00 00       	mov    $0x446,%esi
  8041605e9d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041605ea4:	00 00 00 
  8041605ea7:	b8 00 00 00 00       	mov    $0x0,%eax
  8041605eac:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041605eb3:	00 00 00 
  8041605eb6:	41 ff d0             	call   *%r8
    list->prev->next = list->next;
  8041605eb9:	48 8b 17             	mov    (%rdi),%rdx
  8041605ebc:	48 8b 47 08          	mov    0x8(%rdi),%rax
  8041605ec0:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list->next->prev = list->prev;
  8041605ec4:	48 8b 17             	mov    (%rdi),%rdx
  8041605ec7:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8041605eca:	48 89 3f             	mov    %rdi,(%rdi)
  8041605ecd:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
found:
    list_del(li);

    size_t ndesc = 0;
    static bool allocating_pool;
    if (flags & ALLOC_POOL) {
  8041605ed1:	41 f7 c2 00 00 01 00 	test   $0x10000,%r10d
  8041605ed8:	0f 84 ed 02 00 00    	je     80416061cb <alloc_page+0x429>
        assert(!allocating_pool);
  8041605ede:	48 b8 e0 40 40 42 80 	movabs $0x80424040e0,%rax
  8041605ee5:	00 00 00 
  8041605ee8:	80 38 00             	cmpb   $0x0,(%rax)
  8041605eeb:	0f 85 39 01 00 00    	jne    804160602a <alloc_page+0x288>
        allocating_pool = 1;
  8041605ef1:	48 b8 e0 40 40 42 80 	movabs $0x80424040e0,%rax
  8041605ef8:	00 00 00 
  8041605efb:	c6 00 01             	movb   $0x1,(%rax)
  8041605efe:	48 b9 ff ff ff ff ff 	movabs $0xfffffffffffff,%rcx
  8041605f05:	ff 0f 00 
  8041605f08:	48 89 c8             	mov    %rcx,%rax
  8041605f0b:	48 23 47 38          	and    0x38(%rdi),%rax
  8041605f0f:	48 c1 e0 0c          	shl    $0xc,%rax
  8041605f13:	48 89 c2             	mov    %rax,%rdx
  8041605f16:	48 21 ca             	and    %rcx,%rdx
    if (pa > max_memory_map_addr)
  8041605f19:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041605f20:	00 00 00 
  8041605f23:	48 39 c2             	cmp    %rax,%rdx
  8041605f26:	0f 87 33 01 00 00    	ja     804160605f <alloc_page+0x2bd>
    return (void *)(pa + KERN_BASE_ADDR);
  8041605f2c:	49 ba 00 00 00 40 80 	movabs $0x8040000000,%r10
  8041605f33:	00 00 00 
  8041605f36:	49 01 d2             	add    %rdx,%r10
        struct PagePool *newpool = KADDR(page2pa(peer));
#ifdef SANITIZE_SHADOW_BASE
        /* Need to unpoison early to initiallize lists inplace */
        if (current_space) platform_asan_unpoison(newpool, CLASS_SIZE(class));
#endif
        ndesc = POOL_ENTRIES_FOR_SIZE(CLASS_SIZE(class));
  8041605f39:	41 8d 49 0c          	lea    0xc(%r9),%ecx
  8041605f3d:	b8 01 00 00 00       	mov    $0x1,%eax
  8041605f42:	48 d3 e0             	shl    %cl,%rax
  8041605f45:	48 83 e8 10          	sub    $0x10,%rax
  8041605f49:	49 89 c0             	mov    %rax,%r8
  8041605f4c:	49 c1 e8 06          	shr    $0x6,%r8
        for (size_t i = 0; i < ndesc; i++)
  8041605f50:	48 83 f8 3f          	cmp    $0x3f,%rax
  8041605f54:	76 3f                	jbe    8041605f95 <alloc_page+0x1f3>
  8041605f56:	48 b8 10 00 00 40 80 	movabs $0x8040000010,%rax
  8041605f5d:	00 00 00 
  8041605f60:	48 01 d0             	add    %rdx,%rax
  8041605f63:	b9 00 00 00 00       	mov    $0x0,%ecx
    list->next->prev = new;
  8041605f68:	48 ba 20 41 40 42 80 	movabs $0x8042404120,%rdx
  8041605f6f:	00 00 00 
  8041605f72:	48 8b 72 08          	mov    0x8(%rdx),%rsi
  8041605f76:	48 89 06             	mov    %rax,(%rsi)
    new->next = list->next;
  8041605f79:	48 8b 72 08          	mov    0x8(%rdx),%rsi
  8041605f7d:	48 89 70 08          	mov    %rsi,0x8(%rax)
    list->next = new;
  8041605f81:	48 89 42 08          	mov    %rax,0x8(%rdx)
    new->prev = list;
  8041605f85:	48 89 10             	mov    %rdx,(%rax)
        for (size_t i = 0; i < ndesc; i++)
  8041605f88:	48 83 c1 01          	add    $0x1,%rcx
  8041605f8c:	48 83 c0 40          	add    $0x40,%rax
  8041605f90:	49 39 c8             	cmp    %rcx,%r8
  8041605f93:	77 dd                	ja     8041605f72 <alloc_page+0x1d0>
            list_append(&free_descriptors, (struct List *)&newpool->data[i]);
        newpool->next = first_pool;
  8041605f95:	48 b8 30 41 40 42 80 	movabs $0x8042404130,%rax
  8041605f9c:	00 00 00 
  8041605f9f:	48 8b 10             	mov    (%rax),%rdx
  8041605fa2:	49 89 52 08          	mov    %rdx,0x8(%r10)
        first_pool = newpool;
  8041605fa6:	4c 89 10             	mov    %r10,(%rax)
        free_desc_count += ndesc;
  8041605fa9:	48 b8 10 41 40 42 80 	movabs $0x8042404110,%rax
  8041605fb0:	00 00 00 
  8041605fb3:	4c 01 00             	add    %r8,(%rax)
    return page->addr << CLASS_BASE;
  8041605fb6:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8041605fbd:	ff 0f 00 
  8041605fc0:	48 89 c6             	mov    %rax,%rsi
  8041605fc3:	48 23 77 38          	and    0x38(%rdi),%rsi
  8041605fc7:	48 c1 e6 0c          	shl    $0xc,%rsi
  8041605fcb:	48 21 c6             	and    %rax,%rsi
        if (trace_memory_more) cprintf("Allocated pool of size %zu at [%08lX, %08lX]\n",
                ndesc, page2pa(peer), page2pa(peer) + (long)CLASS_MASK(class));
    }

    struct Page *new = page_lookup(peer, page2pa(peer), class, PARTIAL_NODE, 1);
  8041605fce:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8041605fd4:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8041605fd9:	44 89 ca             	mov    %r9d,%edx
  8041605fdc:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  8041605fe3:	00 00 00 
  8041605fe6:	ff d0                	call   *%rax
  8041605fe8:	48 89 c3             	mov    %rax,%rbx
    assert(!new->refc);
  8041605feb:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041605fef:	0f 84 9b 00 00 00    	je     8041606090 <alloc_page+0x2ee>
  8041605ff5:	48 b9 40 1d 61 41 80 	movabs $0x8041611d40,%rcx
  8041605ffc:	00 00 00 
  8041605fff:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606006:	00 00 00 
  8041606009:	be 66 04 00 00       	mov    $0x466,%esi
  804160600e:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606015:	00 00 00 
  8041606018:	b8 00 00 00 00       	mov    $0x0,%eax
  804160601d:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606024:	00 00 00 
  8041606027:	41 ff d0             	call   *%r8
        assert(!allocating_pool);
  804160602a:	48 b9 2f 1d 61 41 80 	movabs $0x8041611d2f,%rcx
  8041606031:	00 00 00 
  8041606034:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160603b:	00 00 00 
  804160603e:	be 53 04 00 00       	mov    $0x453,%esi
  8041606043:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160604a:	00 00 00 
  804160604d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606052:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606059:	00 00 00 
  804160605c:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804160605f:	49 89 c0             	mov    %rax,%r8
  8041606062:	48 89 d1             	mov    %rdx,%rcx
  8041606065:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160606c:	00 00 00 
  804160606f:	be 56 04 00 00       	mov    $0x456,%esi
  8041606074:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160607b:	00 00 00 
  804160607e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606083:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160608a:	00 00 00 
  804160608d:	41 ff d1             	call   *%r9
    return page->addr << CLASS_BASE;
  8041606090:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8041606097:	ff 0f 00 
  804160609a:	48 89 c1             	mov    %rax,%rcx
  804160609d:	48 23 4b 38          	and    0x38(%rbx),%rcx
  80416060a1:	48 c1 e1 0c          	shl    $0xc,%rcx
  80416060a5:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  80416060a8:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  80416060af:	00 00 00 
  80416060b2:	48 39 c1             	cmp    %rax,%rcx
  80416060b5:	77 44                	ja     80416060fb <alloc_page+0x359>

    if (flags & ALLOC_POOL) {
        assert(KADDR(page2pa(new)) == first_pool);
  80416060b7:	48 b8 30 41 40 42 80 	movabs $0x8042404130,%rax
  80416060be:	00 00 00 
  80416060c1:	4c 8b 20             	mov    (%rax),%r12
    return (void *)(pa + KERN_BASE_ADDR);
  80416060c4:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80416060cb:	00 00 00 
  80416060ce:	48 01 c1             	add    %rax,%rcx
  80416060d1:	49 39 cc             	cmp    %rcx,%r12
  80416060d4:	75 53                	jne    8041606129 <alloc_page+0x387>
#ifdef SANITIZE_SHADOW_BASE
        assert(page2pa(new) + CLASS_SIZE(new->class) <= BOOT_MEM_SIZE);
#endif
        page_ref(new);
  80416060d6:	48 89 df             	mov    %rbx,%rdi
  80416060d9:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  80416060e0:	00 00 00 
  80416060e3:	ff d0                	call   *%rax
        first_pool->peer = new;
  80416060e5:	49 89 1c 24          	mov    %rbx,(%r12)
        allocating_pool = 0;
  80416060e9:	48 b8 e0 40 40 42 80 	movabs $0x80424040e0,%rax
  80416060f0:	00 00 00 
  80416060f3:	c6 00 00             	movb   $0x0,(%rax)
  80416060f6:	e9 0f 01 00 00       	jmp    804160620a <alloc_page+0x468>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  80416060fb:	49 89 c0             	mov    %rax,%r8
  80416060fe:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041606105:	00 00 00 
  8041606108:	be 69 04 00 00       	mov    $0x469,%esi
  804160610d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606114:	00 00 00 
  8041606117:	b8 00 00 00 00       	mov    $0x0,%eax
  804160611c:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041606123:	00 00 00 
  8041606126:	41 ff d1             	call   *%r9
        assert(KADDR(page2pa(new)) == first_pool);
  8041606129:	48 b9 d8 23 61 41 80 	movabs $0x80416123d8,%rcx
  8041606130:	00 00 00 
  8041606133:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160613a:	00 00 00 
  804160613d:	be 69 04 00 00       	mov    $0x469,%esi
  8041606142:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606149:	00 00 00 
  804160614c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606151:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606158:	00 00 00 
  804160615b:	41 ff d0             	call   *%r8
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804160615e:	48 89 d1             	mov    %rdx,%rcx
  8041606161:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  8041606168:	00 00 00 
  804160616b:	be 75 04 00 00       	mov    $0x475,%esi
  8041606170:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606177:	00 00 00 
  804160617a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160617f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606186:	00 00 00 
  8041606189:	41 ff d0             	call   *%r8
    } else {
        if (trace_memory_more) cprintf("Allocated page at [%08lX, %08lX] class=%d\n",
                page2pa(new), page2pa(new) + (long)CLASS_MASK(new->class), new->class);
    }

    assert(page2pa(new) >= PADDR(end) || page2pa(new) + CLASS_MASK(new->class) < IOPHYSMEM);
  804160618c:	48 b9 28 24 61 41 80 	movabs $0x8041612428,%rcx
  8041606193:	00 00 00 
  8041606196:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160619d:	00 00 00 
  80416061a0:	be 75 04 00 00       	mov    $0x475,%esi
  80416061a5:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416061ac:	00 00 00 
  80416061af:	b8 00 00 00 00       	mov    $0x0,%eax
  80416061b4:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416061bb:	00 00 00 
  80416061be:	41 ff d0             	call   *%r8
    return NULL;
  80416061c1:	bb 00 00 00 00       	mov    $0x0,%ebx
  80416061c6:	e9 ac 00 00 00       	jmp    8041606277 <alloc_page+0x4d5>
    return page->addr << CLASS_BASE;
  80416061cb:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  80416061d2:	ff 0f 00 
  80416061d5:	48 89 c6             	mov    %rax,%rsi
  80416061d8:	48 23 77 38          	and    0x38(%rdi),%rsi
  80416061dc:	48 c1 e6 0c          	shl    $0xc,%rsi
  80416061e0:	48 21 c6             	and    %rax,%rsi
    struct Page *new = page_lookup(peer, page2pa(peer), class, PARTIAL_NODE, 1);
  80416061e3:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80416061e9:	b9 00 00 30 00       	mov    $0x300000,%ecx
  80416061ee:	44 89 ca             	mov    %r9d,%edx
  80416061f1:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  80416061f8:	00 00 00 
  80416061fb:	ff d0                	call   *%rax
  80416061fd:	48 89 c3             	mov    %rax,%rbx
    assert(!new->refc);
  8041606200:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041606204:	0f 85 eb fd ff ff    	jne    8041605ff5 <alloc_page+0x253>
  804160620a:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041606211:	ff 0f 00 
  8041606214:	48 89 d0             	mov    %rdx,%rax
  8041606217:	48 23 43 38          	and    0x38(%rbx),%rax
  804160621b:	48 c1 e0 0c          	shl    $0xc,%rax
  804160621f:	48 21 d0             	and    %rdx,%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  8041606222:	48 ba 00 60 40 42 80 	movabs $0x8042406000,%rdx
  8041606229:	00 00 00 
  804160622c:	48 b9 ff ff ff 3f 80 	movabs $0x803fffffff,%rcx
  8041606233:	00 00 00 
  8041606236:	48 39 ca             	cmp    %rcx,%rdx
  8041606239:	0f 86 1f ff ff ff    	jbe    804160615e <alloc_page+0x3bc>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804160623f:	48 b9 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rcx
  8041606246:	ff ff ff 
  8041606249:	48 01 ca             	add    %rcx,%rdx
    assert(page2pa(new) >= PADDR(end) || page2pa(new) + CLASS_MASK(new->class) < IOPHYSMEM);
  804160624c:	48 39 d0             	cmp    %rdx,%rax
  804160624f:	73 26                	jae    8041606277 <alloc_page+0x4d5>
  8041606251:	0f b7 4b 34          	movzwl 0x34(%rbx),%ecx
  8041606255:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  804160625b:	83 c1 0c             	add    $0xc,%ecx
  804160625e:	ba 01 00 00 00       	mov    $0x1,%edx
  8041606263:	48 d3 e2             	shl    %cl,%rdx
  8041606266:	48 8d 44 10 ff       	lea    -0x1(%rax,%rdx,1),%rax
  804160626b:	48 3d ff ff 09 00    	cmp    $0x9ffff,%rax
  8041606271:	0f 87 15 ff ff ff    	ja     804160618c <alloc_page+0x3ea>

    return new;
}
  8041606277:	48 89 d8             	mov    %rbx,%rax
  804160627a:	5b                   	pop    %rbx
  804160627b:	41 5c                	pop    %r12
  804160627d:	5d                   	pop    %rbp
  804160627e:	c3                   	ret    

000000804160627f <alloc_fill_pt>:
alloc_fill_pt(pte_t *dst, pte_t base, size_t step, size_t i0, size_t i1) {
  804160627f:	55                   	push   %rbp
  8041606280:	48 89 e5             	mov    %rsp,%rbp
  8041606283:	41 57                	push   %r15
  8041606285:	41 56                	push   %r14
  8041606287:	41 55                	push   %r13
  8041606289:	41 54                	push   %r12
  804160628b:	53                   	push   %rbx
  804160628c:	48 83 ec 28          	sub    $0x28,%rsp
    assert(i0 != i1);
  8041606290:	4c 39 c1             	cmp    %r8,%rcx
  8041606293:	74 4c                	je     80416062e1 <alloc_fill_pt+0x62>
  8041606295:	48 89 f3             	mov    %rsi,%rbx
  8041606298:	49 89 d6             	mov    %rdx,%r14
  804160629b:	49 89 cc             	mov    %rcx,%r12
  804160629e:	4d 89 c7             	mov    %r8,%r15
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  80416062a1:	48 81 fa 00 00 00 40 	cmp    $0x40000000,%rdx
  80416062a8:	77 15                	ja     80416062bf <alloc_fill_pt+0x40>
  80416062aa:	48 81 fa 00 10 00 00 	cmp    $0x1000,%rdx
  80416062b1:	0f 95 c2             	setne  %dl
  80416062b4:	48 89 f0             	mov    %rsi,%rax
  80416062b7:	0c 80                	or     $0x80,%al
  80416062b9:	84 d2                	test   %dl,%dl
  80416062bb:	48 0f 45 d8          	cmovne %rax,%rbx
            res = alloc_fill_pt(dst + i, base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  80416062bf:	4c 89 f0             	mov    %r14,%rax
  80416062c2:	48 c1 e8 09          	shr    $0x9,%rax
  80416062c6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80416062ca:	4e 8d 2c e7          	lea    (%rdi,%r12,8),%r13
    return 0;
  80416062ce:	b8 00 00 00 00       	mov    $0x0,%eax
    for (size_t i = i0; i < i1; i++, base += step) {
  80416062d3:	4d 39 fc             	cmp    %r15,%r12
  80416062d6:	0f 82 b6 01 00 00    	jb     8041606492 <alloc_fill_pt+0x213>
  80416062dc:	e9 87 01 00 00       	jmp    8041606468 <alloc_fill_pt+0x1e9>
    assert(i0 != i1);
  80416062e1:	48 b9 4b 1d 61 41 80 	movabs $0x8041611d4b,%rcx
  80416062e8:	00 00 00 
  80416062eb:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416062f2:	00 00 00 
  80416062f5:	be 01 03 00 00       	mov    $0x301,%esi
  80416062fa:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606301:	00 00 00 
  8041606304:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606309:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606310:	00 00 00 
  8041606313:	41 ff d0             	call   *%r8
            int res = alloc_pt(dst + i);
  8041606316:	4c 89 6d c8          	mov    %r13,-0x38(%rbp)
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  804160631a:	49 8b 45 00          	mov    0x0(%r13),%rax
  804160631e:	25 81 00 00 00       	and    $0x81,%eax
  8041606323:	48 83 f8 01          	cmp    $0x1,%rax
  8041606327:	75 2f                	jne    8041606358 <alloc_fill_pt+0xd9>
            res = alloc_fill_pt(dst + i, base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  8041606329:	41 b8 00 02 00 00    	mov    $0x200,%r8d
  804160632f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041606334:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8041606338:	48 89 de             	mov    %rbx,%rsi
  804160633b:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160633f:	48 b8 7f 62 60 41 80 	movabs $0x804160627f,%rax
  8041606346:	00 00 00 
  8041606349:	ff d0                	call   *%rax
            if (res < 0) return res;
  804160634b:	85 c0                	test   %eax,%eax
  804160634d:	0f 89 2f 01 00 00    	jns    8041606482 <alloc_fill_pt+0x203>
  8041606353:	e9 10 01 00 00       	jmp    8041606468 <alloc_fill_pt+0x1e9>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8041606358:	be 00 00 04 00       	mov    $0x40000,%esi
  804160635d:	bf 00 00 00 00       	mov    $0x0,%edi
  8041606362:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  8041606369:	00 00 00 
  804160636c:	ff d0                	call   *%rax
  804160636e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (!page) return -E_NO_MEM;
  8041606372:	48 85 c0             	test   %rax,%rax
  8041606375:	0f 84 fc 00 00 00    	je     8041606477 <alloc_fill_pt+0x1f8>
        assert(!page->refc);
  804160637b:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  804160637f:	75 7c                	jne    80416063fd <alloc_fill_pt+0x17e>
        page_ref(page);
  8041606381:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8041606385:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  804160638c:	00 00 00 
  804160638f:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041606391:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041606398:	ff 0f 00 
  804160639b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160639f:	48 89 d0             	mov    %rdx,%rax
  80416063a2:	48 23 46 38          	and    0x38(%rsi),%rax
  80416063a6:	48 c1 e0 0c          	shl    $0xc,%rax
  80416063aa:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  80416063ad:	48 83 c8 07          	or     $0x7,%rax
  80416063b1:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80416063b5:	48 89 01             	mov    %rax,(%rcx)
  80416063b8:	48 89 d7             	mov    %rdx,%rdi
  80416063bb:	48 23 7e 38          	and    0x38(%rsi),%rdi
  80416063bf:	48 c1 e7 0c          	shl    $0xc,%rdi
  80416063c3:	48 21 d7             	and    %rdx,%rdi
    if (pa > max_memory_map_addr)
  80416063c6:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  80416063cd:	00 00 00 
  80416063d0:	48 39 c7             	cmp    %rax,%rdi
  80416063d3:	77 5d                	ja     8041606432 <alloc_fill_pt+0x1b3>
    return (void *)(pa + KERN_BASE_ADDR);
  80416063d5:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80416063dc:	00 00 00 
  80416063df:	48 01 c7             	add    %rax,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  80416063e2:	ba 00 10 00 00       	mov    $0x1000,%edx
  80416063e7:	be 00 00 00 00       	mov    $0x0,%esi
  80416063ec:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  80416063f3:	00 00 00 
  80416063f6:	ff d0                	call   *%rax
  80416063f8:	e9 2c ff ff ff       	jmp    8041606329 <alloc_fill_pt+0xaa>
        assert(!page->refc);
  80416063fd:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041606404:	00 00 00 
  8041606407:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160640e:	00 00 00 
  8041606411:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041606416:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160641d:	00 00 00 
  8041606420:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606425:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160642c:	00 00 00 
  804160642f:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041606432:	48 89 f9             	mov    %rdi,%rcx
  8041606435:	49 89 c0             	mov    %rax,%r8
  8041606438:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160643f:	00 00 00 
  8041606442:	be db 02 00 00       	mov    $0x2db,%esi
  8041606447:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160644e:	00 00 00 
  8041606451:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606456:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160645d:	00 00 00 
  8041606460:	41 ff d1             	call   *%r9
    return 0;
  8041606463:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8041606468:	48 83 c4 28          	add    $0x28,%rsp
  804160646c:	5b                   	pop    %rbx
  804160646d:	41 5c                	pop    %r12
  804160646f:	41 5d                	pop    %r13
  8041606471:	41 5e                	pop    %r14
  8041606473:	41 5f                	pop    %r15
  8041606475:	5d                   	pop    %rbp
  8041606476:	c3                   	ret    
        if (!page) return -E_NO_MEM;
  8041606477:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  804160647c:	eb ea                	jmp    8041606468 <alloc_fill_pt+0x1e9>
            dst[i] = base;
  804160647e:	49 89 5d 00          	mov    %rbx,0x0(%r13)
    for (size_t i = i0; i < i1; i++, base += step) {
  8041606482:	49 83 c4 01          	add    $0x1,%r12
  8041606486:	4c 01 f3             	add    %r14,%rbx
  8041606489:	49 83 c5 08          	add    $0x8,%r13
  804160648d:	4d 39 e7             	cmp    %r12,%r15
  8041606490:	74 d1                	je     8041606463 <alloc_fill_pt+0x1e4>
        if (need_recur) {
  8041606492:	49 81 fe 00 00 00 40 	cmp    $0x40000000,%r14
  8041606499:	0f 87 77 fe ff ff    	ja     8041606316 <alloc_fill_pt+0x97>
            if ((PTE_ADDR(base) & (step - 1))) cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  804160649f:	49 8d 46 ff          	lea    -0x1(%r14),%rax
  80416064a3:	48 21 d8             	and    %rbx,%rax
  80416064a6:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  80416064ad:	ff ff 7f 
  80416064b0:	48 85 c8             	test   %rcx,%rax
  80416064b3:	74 c9                	je     804160647e <alloc_fill_pt+0x1ff>
  80416064b5:	48 89 ce             	mov    %rcx,%rsi
  80416064b8:	48 21 de             	and    %rbx,%rsi
  80416064bb:	4c 89 f2             	mov    %r14,%rdx
  80416064be:	48 bf 60 1d 61 41 80 	movabs $0x8041611d60,%rdi
  80416064c5:	00 00 00 
  80416064c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80416064cd:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  80416064d4:	00 00 00 
  80416064d7:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  80416064d9:	48 b9 78 24 61 41 80 	movabs $0x8041612478,%rcx
  80416064e0:	00 00 00 
  80416064e3:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416064ea:	00 00 00 
  80416064ed:	be 0f 03 00 00       	mov    $0x30f,%esi
  80416064f2:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416064f9:	00 00 00 
  80416064fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606501:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606508:	00 00 00 
  804160650b:	41 ff d0             	call   *%r8

000000804160650e <propagate_one_pml4>:
propagate_one_pml4(struct AddressSpace *dst, struct AddressSpace *src) {
  804160650e:	55                   	push   %rbp
  804160650f:	48 89 e5             	mov    %rsp,%rbp
  8041606512:	41 57                	push   %r15
  8041606514:	41 56                	push   %r14
  8041606516:	41 55                	push   %r13
  8041606518:	41 54                	push   %r12
  804160651a:	53                   	push   %rbx
  804160651b:	48 83 ec 08          	sub    $0x8,%rsp
  804160651f:	49 89 fc             	mov    %rdi,%r12
  8041606522:	49 89 f5             	mov    %rsi,%r13
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  8041606525:	bb 01 00 00 00       	mov    $0x1,%ebx
            page_ref(page_lookup(NULL, PTE_ADDR(src->pml4[i]), 0, PARTIAL_NODE, 0));
  804160652a:	49 bf 03 59 60 41 80 	movabs $0x8041605903,%r15
  8041606531:	00 00 00 
  8041606534:	49 be d2 47 60 41 80 	movabs $0x80416047d2,%r14
  804160653b:	00 00 00 
  804160653e:	eb 38                	jmp    8041606578 <propagate_one_pml4+0x6a>
  8041606540:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8041606547:	ff ff 7f 
  804160654a:	48 21 c6             	and    %rax,%rsi
  804160654d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8041606553:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8041606558:	ba 00 00 00 00       	mov    $0x0,%edx
  804160655d:	bf 00 00 00 00       	mov    $0x0,%edi
  8041606562:	41 ff d7             	call   *%r15
  8041606565:	48 89 c7             	mov    %rax,%rdi
  8041606568:	41 ff d6             	call   *%r14
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  804160656b:	48 83 c3 01          	add    $0x1,%rbx
  804160656f:	48 81 fb 00 02 00 00 	cmp    $0x200,%rbx
  8041606576:	74 16                	je     804160658e <propagate_one_pml4+0x80>
        if (src->pml4[i] & PTE_P && i != PML4_INDEX(UVPT))
  8041606578:	49 8b 45 00          	mov    0x0(%r13),%rax
  804160657c:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  8041606580:	40 f6 c6 01          	test   $0x1,%sil
  8041606584:	74 e5                	je     804160656b <propagate_one_pml4+0x5d>
  8041606586:	48 83 fb 02          	cmp    $0x2,%rbx
  804160658a:	74 df                	je     804160656b <propagate_one_pml4+0x5d>
  804160658c:	eb b2                	jmp    8041606540 <propagate_one_pml4+0x32>
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  804160658e:	bb 01 00 00 00       	mov    $0x1,%ebx
            page_ref(page_lookup(NULL, PTE_ADDR(dst->pml4[i]), 0, PARTIAL_NODE, 0));
  8041606593:	49 bf 03 59 60 41 80 	movabs $0x8041605903,%r15
  804160659a:	00 00 00 
  804160659d:	49 be d2 47 60 41 80 	movabs $0x80416047d2,%r14
  80416065a4:	00 00 00 
  80416065a7:	eb 38                	jmp    80416065e1 <propagate_one_pml4+0xd3>
  80416065a9:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  80416065b0:	ff ff 7f 
  80416065b3:	48 21 c6             	and    %rax,%rsi
  80416065b6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80416065bc:	b9 00 00 30 00       	mov    $0x300000,%ecx
  80416065c1:	ba 00 00 00 00       	mov    $0x0,%edx
  80416065c6:	bf 00 00 00 00       	mov    $0x0,%edi
  80416065cb:	41 ff d7             	call   *%r15
  80416065ce:	48 89 c7             	mov    %rax,%rdi
  80416065d1:	41 ff d6             	call   *%r14
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  80416065d4:	48 83 c3 01          	add    $0x1,%rbx
  80416065d8:	48 81 fb 00 02 00 00 	cmp    $0x200,%rbx
  80416065df:	74 16                	je     80416065f7 <propagate_one_pml4+0xe9>
        if (dst->pml4[i] & PTE_P && i != PML4_INDEX(UVPT))
  80416065e1:	49 8b 04 24          	mov    (%r12),%rax
  80416065e5:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  80416065e9:	40 f6 c6 01          	test   $0x1,%sil
  80416065ed:	74 e5                	je     80416065d4 <propagate_one_pml4+0xc6>
  80416065ef:	48 83 fb 02          	cmp    $0x2,%rbx
  80416065f3:	74 df                	je     80416065d4 <propagate_one_pml4+0xc6>
  80416065f5:	eb b2                	jmp    80416065a9 <propagate_one_pml4+0x9b>
    pte_t uvpt = dst->pml4[PML4_INDEX(UVPT)];
  80416065f7:	49 8b 04 24          	mov    (%r12),%rax
  80416065fb:	48 8b 58 10          	mov    0x10(%rax),%rbx
    memcpy(dst->pml4 + NUSERPML4, src->pml4 + NUSERPML4,
  80416065ff:	49 8b 75 00          	mov    0x0(%r13),%rsi
  8041606603:	48 83 c6 08          	add    $0x8,%rsi
  8041606607:	48 8d 78 08          	lea    0x8(%rax),%rdi
  804160660b:	ba f8 0f 00 00       	mov    $0xff8,%edx
  8041606610:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  8041606617:	00 00 00 
  804160661a:	ff d0                	call   *%rax
    dst->pml4[PML4_INDEX(UVPT)] = uvpt;
  804160661c:	49 8b 04 24          	mov    (%r12),%rax
  8041606620:	48 89 58 10          	mov    %rbx,0x10(%rax)
}
  8041606624:	48 83 c4 08          	add    $0x8,%rsp
  8041606628:	5b                   	pop    %rbx
  8041606629:	41 5c                	pop    %r12
  804160662b:	41 5d                	pop    %r13
  804160662d:	41 5e                	pop    %r14
  804160662f:	41 5f                	pop    %r15
  8041606631:	5d                   	pop    %rbp
  8041606632:	c3                   	ret    

0000008041606633 <propagate_pml4>:
    if (!current_space) return;
  8041606633:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  804160663a:	00 00 00 
  804160663d:	48 83 38 00          	cmpq   $0x0,(%rax)
  8041606641:	0f 84 87 00 00 00    	je     80416066ce <propagate_pml4+0x9b>
propagate_pml4(struct AddressSpace *spc) {
  8041606647:	55                   	push   %rbp
  8041606648:	48 89 e5             	mov    %rsp,%rbp
  804160664b:	41 56                	push   %r14
  804160664d:	41 55                	push   %r13
  804160664f:	41 54                	push   %r12
  8041606651:	53                   	push   %rbx
  8041606652:	49 89 fd             	mov    %rdi,%r13
    if (spc != &kspace) propagate_one_pml4(&kspace, spc);
  8041606655:	48 b8 b0 00 40 42 80 	movabs $0x80424000b0,%rax
  804160665c:	00 00 00 
  804160665f:	48 39 c7             	cmp    %rax,%rdi
  8041606662:	74 12                	je     8041606676 <propagate_pml4+0x43>
  8041606664:	48 89 fe             	mov    %rdi,%rsi
  8041606667:	48 89 c7             	mov    %rax,%rdi
  804160666a:	48 b8 0e 65 60 41 80 	movabs $0x804160650e,%rax
  8041606671:	00 00 00 
  8041606674:	ff d0                	call   *%rax
propagate_pml4(struct AddressSpace *spc) {
  8041606676:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (envs[i].env_status != ENV_FREE && &envs[i].address_space != spc)
  804160667b:	49 bc 48 44 40 42 80 	movabs $0x8042404448,%r12
  8041606682:	00 00 00 
            propagate_one_pml4(&envs[i].address_space, spc);
  8041606685:	49 be 0e 65 60 41 80 	movabs $0x804160650e,%r14
  804160668c:	00 00 00 
  804160668f:	eb 10                	jmp    80416066a1 <propagate_pml4+0x6e>
    for (size_t i = 0; i < NENV; i++) {
  8041606691:	48 81 c3 30 01 00 00 	add    $0x130,%rbx
  8041606698:	48 81 fb 00 c0 04 00 	cmp    $0x4c000,%rbx
  804160669f:	74 24                	je     80416066c5 <propagate_pml4+0x92>
        if (envs[i].env_status != ENV_FREE && &envs[i].address_space != spc)
  80416066a1:	48 89 df             	mov    %rbx,%rdi
  80416066a4:	49 03 3c 24          	add    (%r12),%rdi
  80416066a8:	83 bf d4 00 00 00 00 	cmpl   $0x0,0xd4(%rdi)
  80416066af:	74 e0                	je     8041606691 <propagate_pml4+0x5e>
  80416066b1:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  80416066b8:	4c 39 ef             	cmp    %r13,%rdi
  80416066bb:	74 d4                	je     8041606691 <propagate_pml4+0x5e>
            propagate_one_pml4(&envs[i].address_space, spc);
  80416066bd:	4c 89 ee             	mov    %r13,%rsi
  80416066c0:	41 ff d6             	call   *%r14
  80416066c3:	eb cc                	jmp    8041606691 <propagate_pml4+0x5e>
}
  80416066c5:	5b                   	pop    %rbx
  80416066c6:	41 5c                	pop    %r12
  80416066c8:	41 5d                	pop    %r13
  80416066ca:	41 5e                	pop    %r14
  80416066cc:	5d                   	pop    %rbp
  80416066cd:	c3                   	ret    
  80416066ce:	c3                   	ret    

00000080416066cf <remove_pt>:
remove_pt(pte_t *pt, pte_t base, size_t step, uintptr_t i0, uintptr_t i1) {
  80416066cf:	55                   	push   %rbp
  80416066d0:	48 89 e5             	mov    %rsp,%rbp
  80416066d3:	41 57                	push   %r15
  80416066d5:	41 56                	push   %r14
  80416066d7:	41 55                	push   %r13
  80416066d9:	41 54                	push   %r12
  80416066db:	53                   	push   %rbx
  80416066dc:	48 83 ec 28          	sub    $0x28,%rsp
  80416066e0:	49 89 fd             	mov    %rdi,%r13
  80416066e3:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  80416066e7:	49 89 d7             	mov    %rdx,%r15
  80416066ea:	48 89 cb             	mov    %rcx,%rbx
  80416066ed:	4d 89 c6             	mov    %r8,%r14
    assert(step == 1 * GB || step == 2 * MB || step == 4 * KB || step == 512 * GB);
  80416066f0:	48 81 fa 00 00 00 40 	cmp    $0x40000000,%rdx
  80416066f7:	0f 95 c2             	setne  %dl
  80416066fa:	49 81 ff 00 00 20 00 	cmp    $0x200000,%r15
  8041606701:	0f 95 c0             	setne  %al
  8041606704:	20 c2                	and    %al,%dl
  8041606706:	88 55 cf             	mov    %dl,-0x31(%rbp)
  8041606709:	75 23                	jne    804160672e <remove_pt+0x5f>
            remove_pt(pt2, base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  804160670b:	4c 89 f8             	mov    %r15,%rax
  804160670e:	48 c1 e8 09          	shr    $0x9,%rax
  8041606712:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    for (size_t i = i0; i < i1; i++) {
  8041606716:	4c 39 f3             	cmp    %r14,%rbx
  8041606719:	0f 82 d5 00 00 00    	jb     80416067f4 <remove_pt+0x125>
}
  804160671f:	48 83 c4 28          	add    $0x28,%rsp
  8041606723:	5b                   	pop    %rbx
  8041606724:	41 5c                	pop    %r12
  8041606726:	41 5d                	pop    %r13
  8041606728:	41 5e                	pop    %r14
  804160672a:	41 5f                	pop    %r15
  804160672c:	5d                   	pop    %rbp
  804160672d:	c3                   	ret    
    assert(step == 1 * GB || step == 2 * MB || step == 4 * KB || step == 512 * GB);
  804160672e:	49 81 ff 00 10 00 00 	cmp    $0x1000,%r15
  8041606735:	74 d4                	je     804160670b <remove_pt+0x3c>
  8041606737:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  804160673e:	00 00 00 
  8041606741:	49 39 c7             	cmp    %rax,%r15
  8041606744:	74 c5                	je     804160670b <remove_pt+0x3c>
  8041606746:	48 b9 98 24 61 41 80 	movabs $0x8041612498,%rcx
  804160674d:	00 00 00 
  8041606750:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606757:	00 00 00 
  804160675a:	be e2 01 00 00       	mov    $0x1e2,%esi
  804160675f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606766:	00 00 00 
  8041606769:	b8 00 00 00 00       	mov    $0x0,%eax
  804160676e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606775:	00 00 00 
  8041606778:	41 ff d0             	call   *%r8
        assert(!(pt[i] & PTE_PS) || (step == 1 * GB || step == 2 * MB));
  804160677b:	48 b9 e0 24 61 41 80 	movabs $0x80416124e0,%rcx
  8041606782:	00 00 00 
  8041606785:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160678c:	00 00 00 
  804160678f:	be e5 01 00 00       	mov    $0x1e5,%esi
  8041606794:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160679b:	00 00 00 
  804160679e:	b8 00 00 00 00       	mov    $0x0,%eax
  80416067a3:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416067aa:	00 00 00 
  80416067ad:	41 ff d0             	call   *%r8
  80416067b0:	4c 89 e1             	mov    %r12,%rcx
  80416067b3:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  80416067ba:	00 00 00 
  80416067bd:	be e8 01 00 00       	mov    $0x1e8,%esi
  80416067c2:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416067c9:	00 00 00 
  80416067cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80416067d1:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  80416067d8:	00 00 00 
  80416067db:	41 ff d1             	call   *%r9
        pt[i] = 0;
  80416067de:	49 c7 44 dd 00 00 00 	movq   $0x0,0x0(%r13,%rbx,8)
  80416067e5:	00 00 
    for (size_t i = i0; i < i1; i++) {
  80416067e7:	48 83 c3 01          	add    $0x1,%rbx
  80416067eb:	49 39 de             	cmp    %rbx,%r14
  80416067ee:	0f 86 2b ff ff ff    	jbe    804160671f <remove_pt+0x50>
        if (!(pt[i] & PTE_P)) continue;
  80416067f4:	4d 8b 64 dd 00       	mov    0x0(%r13,%rbx,8),%r12
  80416067f9:	41 f6 c4 01          	test   $0x1,%r12b
  80416067fd:	74 e8                	je     80416067e7 <remove_pt+0x118>
        assert(!(pt[i] & PTE_PS) || (step == 1 * GB || step == 2 * MB));
  80416067ff:	4c 89 e0             	mov    %r12,%rax
  8041606802:	25 80 00 00 00       	and    $0x80,%eax
  8041606807:	74 0a                	je     8041606813 <remove_pt+0x144>
  8041606809:	80 7d cf 00          	cmpb   $0x0,-0x31(%rbp)
  804160680d:	0f 85 68 ff ff ff    	jne    804160677b <remove_pt+0xac>
        if (!(pt[i] & PTE_PS) && step > 4 * KB) {
  8041606813:	48 85 c0             	test   %rax,%rax
  8041606816:	75 c6                	jne    80416067de <remove_pt+0x10f>
  8041606818:	49 81 ff 00 10 00 00 	cmp    $0x1000,%r15
  804160681f:	76 bd                	jbe    80416067de <remove_pt+0x10f>
            pte_t *pt2 = KADDR(PTE_ADDR(pt[i]));
  8041606821:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8041606828:	ff ff 7f 
  804160682b:	49 21 c4             	and    %rax,%r12
    if (pa > max_memory_map_addr)
  804160682e:	48 b8 c8 00 40 42 80 	movabs $0x80424000c8,%rax
  8041606835:	00 00 00 
  8041606838:	4c 8b 00             	mov    (%rax),%r8
  804160683b:	4d 39 c4             	cmp    %r8,%r12
  804160683e:	0f 87 6c ff ff ff    	ja     80416067b0 <remove_pt+0xe1>
    return (void *)(pa + KERN_BASE_ADDR);
  8041606844:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804160684b:	00 00 00 
  804160684e:	49 8d 3c 04          	lea    (%r12,%rax,1),%rdi
            remove_pt(pt2, base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  8041606852:	41 b8 00 02 00 00    	mov    $0x200,%r8d
  8041606858:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160685d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8041606861:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8041606865:	48 b8 cf 66 60 41 80 	movabs $0x80416066cf,%rax
  804160686c:	00 00 00 
  804160686f:	ff d0                	call   *%rax
            page_unref(page_lookup(NULL, (uintptr_t)PADDR(pt2), 0, PARTIAL_NODE, 0));
  8041606871:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8041606877:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804160687c:	ba 00 00 00 00       	mov    $0x0,%edx
  8041606881:	4c 89 e6             	mov    %r12,%rsi
  8041606884:	bf 00 00 00 00       	mov    $0x0,%edi
  8041606889:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  8041606890:	00 00 00 
  8041606893:	ff d0                	call   *%rax
  8041606895:	48 89 c7             	mov    %rax,%rdi
  8041606898:	48 b8 b1 48 60 41 80 	movabs $0x80416048b1,%rax
  804160689f:	00 00 00 
  80416068a2:	ff d0                	call   *%rax
  80416068a4:	e9 35 ff ff ff       	jmp    80416067de <remove_pt+0x10f>

00000080416068a9 <attach_region>:
attach_region(uintptr_t start, uintptr_t end, enum PageState type) {
  80416068a9:	55                   	push   %rbp
  80416068aa:	48 89 e5             	mov    %rsp,%rbp
  80416068ad:	41 57                	push   %r15
  80416068af:	41 56                	push   %r14
  80416068b1:	41 55                	push   %r13
  80416068b3:	41 54                	push   %r12
  80416068b5:	53                   	push   %rbx
  80416068b6:	48 83 ec 18          	sub    $0x18,%rsp
  80416068ba:	89 55 cc             	mov    %edx,-0x34(%rbp)
    start = ROUNDDOWN(start, CLASS_SIZE(0));
  80416068bd:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
  80416068c4:	48 89 fb             	mov    %rdi,%rbx
    end = ROUNDUP(end, CLASS_SIZE(0));
  80416068c7:	4c 8d a6 ff 0f 00 00 	lea    0xfff(%rsi),%r12
  80416068ce:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
            if (start + CLASS_SIZE(class) < end && !(start & CLASS_MASK(class))) {
  80416068d5:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  80416068db:	49 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%r15
    while (start < end) {
  80416068e2:	49 39 fc             	cmp    %rdi,%r12
  80416068e5:	77 71                	ja     8041606958 <attach_region+0xaf>
}
  80416068e7:	48 83 c4 18          	add    $0x18,%rsp
  80416068eb:	5b                   	pop    %rbx
  80416068ec:	41 5c                	pop    %r12
  80416068ee:	41 5d                	pop    %r13
  80416068f0:	41 5e                	pop    %r14
  80416068f2:	41 5f                	pop    %r15
  80416068f4:	5d                   	pop    %rbp
  80416068f5:	c3                   	ret    
        for (int class = 0; class < MAX_CLASS; ++class) {
  80416068f6:	83 c0 01             	add    $0x1,%eax
  80416068f9:	83 f8 30             	cmp    $0x30,%eax
  80416068fc:	74 28                	je     8041606926 <attach_region+0x7d>
            if (start + CLASS_SIZE(class) < end && !(start & CLASS_MASK(class))) {
  80416068fe:	8d 48 0c             	lea    0xc(%rax),%ecx
  8041606901:	4c 89 ea             	mov    %r13,%rdx
  8041606904:	48 d3 e2             	shl    %cl,%rdx
  8041606907:	48 01 da             	add    %rbx,%rdx
  804160690a:	4c 39 e2             	cmp    %r12,%rdx
  804160690d:	73 e7                	jae    80416068f6 <attach_region+0x4d>
  804160690f:	4c 89 fa             	mov    %r15,%rdx
  8041606912:	48 d3 e2             	shl    %cl,%rdx
  8041606915:	48 f7 d2             	not    %rdx
  8041606918:	48 85 da             	test   %rbx,%rdx
  804160691b:	75 d9                	jne    80416068f6 <attach_region+0x4d>
                max_class = MAX(max_class, class); 
  804160691d:	41 39 c6             	cmp    %eax,%r14d
  8041606920:	44 0f 4c f0          	cmovl  %eax,%r14d
  8041606924:	eb d0                	jmp    80416068f6 <attach_region+0x4d>
        page_lookup(NULL, start, max_class, type, 1);
  8041606926:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804160692c:	8b 4d cc             	mov    -0x34(%rbp),%ecx
  804160692f:	44 89 f2             	mov    %r14d,%edx
  8041606932:	48 89 de             	mov    %rbx,%rsi
  8041606935:	bf 00 00 00 00       	mov    $0x0,%edi
  804160693a:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  8041606941:	00 00 00 
  8041606944:	ff d0                	call   *%rax
        start += CLASS_SIZE(max_class);
  8041606946:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
  804160694a:	4c 89 e8             	mov    %r13,%rax
  804160694d:	48 d3 e0             	shl    %cl,%rax
  8041606950:	48 01 c3             	add    %rax,%rbx
    while (start < end) {
  8041606953:	49 39 dc             	cmp    %rbx,%r12
  8041606956:	76 8f                	jbe    80416068e7 <attach_region+0x3e>
        for (int class = 0; class < MAX_CLASS; ++class) {
  8041606958:	b8 00 00 00 00       	mov    $0x0,%eax
        int max_class = 0;
  804160695d:	41 be 00 00 00 00    	mov    $0x0,%r14d
  8041606963:	eb 99                	jmp    80416068fe <attach_region+0x55>

0000008041606965 <alloc_virtual_child>:
alloc_virtual_child(struct Page *parent, struct Page **dst) {
  8041606965:	55                   	push   %rbp
  8041606966:	48 89 e5             	mov    %rsp,%rbp
  8041606969:	41 54                	push   %r12
  804160696b:	53                   	push   %rbx
  804160696c:	48 89 fb             	mov    %rdi,%rbx
    assert_virtual(parent);
  804160696f:	8b 7f 28             	mov    0x28(%rdi),%edi
  8041606972:	89 f8                	mov    %edi,%eax
  8041606974:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041606979:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  804160697e:	0f 87 93 00 00 00    	ja     8041606a17 <alloc_virtual_child+0xb2>
  8041606984:	49 89 f4             	mov    %rsi,%r12
    assert(parent->phy && parent->phy->left && parent->phy->right);
  8041606987:	48 8b 43 30          	mov    0x30(%rbx),%rax
  804160698b:	48 85 c0             	test   %rax,%rax
  804160698e:	0f 84 b8 00 00 00    	je     8041606a4c <alloc_virtual_child+0xe7>
  8041606994:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  8041606999:	0f 84 ad 00 00 00    	je     8041606a4c <alloc_virtual_child+0xe7>
  804160699f:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  80416069a4:	0f 84 a2 00 00 00    	je     8041606a4c <alloc_virtual_child+0xe7>
    if ((*dst = alloc_descriptor(parent->state))) {
  80416069aa:	48 b8 77 57 60 41 80 	movabs $0x8041605777,%rax
  80416069b1:	00 00 00 
  80416069b4:	ff d0                	call   *%rax
  80416069b6:	49 89 04 24          	mov    %rax,(%r12)
  80416069ba:	48 85 c0             	test   %rax,%rax
  80416069bd:	74 53                	je     8041606a12 <alloc_virtual_child+0xad>
        (*dst)->parent = parent;
  80416069bf:	48 89 58 20          	mov    %rbx,0x20(%rax)
        (*dst)->phy = dst == &parent->left ? parent->phy->left : parent->phy->right;
  80416069c3:	48 8d 43 10          	lea    0x10(%rbx),%rax
  80416069c7:	49 39 c4             	cmp    %rax,%r12
  80416069ca:	0f 84 b1 00 00 00    	je     8041606a81 <alloc_virtual_child+0x11c>
  80416069d0:	48 8b 43 30          	mov    0x30(%rbx),%rax
  80416069d4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80416069d8:	49 8b 04 24          	mov    (%r12),%rax
  80416069dc:	48 89 50 30          	mov    %rdx,0x30(%rax)
        page_ref((*dst)->phy);
  80416069e0:	49 8b 04 24          	mov    (%r12),%rax
  80416069e4:	48 8b 78 30          	mov    0x30(%rax),%rdi
  80416069e8:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  80416069ef:	00 00 00 
  80416069f2:	ff d0                	call   *%rax
        list_append((struct List *)(*dst)->phy, (struct List *)(*dst));
  80416069f4:	49 8b 04 24          	mov    (%r12),%rax
  80416069f8:	48 8b 50 30          	mov    0x30(%rax),%rdx
    list->next->prev = new;
  80416069fc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8041606a00:	48 89 01             	mov    %rax,(%rcx)
    new->next = list->next;
  8041606a03:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8041606a07:	48 89 48 08          	mov    %rcx,0x8(%rax)
    list->next = new;
  8041606a0b:	48 89 42 08          	mov    %rax,0x8(%rdx)
    new->prev = list;
  8041606a0f:	48 89 10             	mov    %rdx,(%rax)
}
  8041606a12:	5b                   	pop    %rbx
  8041606a13:	41 5c                	pop    %r12
  8041606a15:	5d                   	pop    %rbp
  8041606a16:	c3                   	ret    
    assert_virtual(parent);
  8041606a17:	48 b9 18 25 61 41 80 	movabs $0x8041612518,%rcx
  8041606a1e:	00 00 00 
  8041606a21:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606a28:	00 00 00 
  8041606a2b:	be 52 01 00 00       	mov    $0x152,%esi
  8041606a30:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606a37:	00 00 00 
  8041606a3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606a3f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606a46:	00 00 00 
  8041606a49:	41 ff d0             	call   *%r8
    assert(parent->phy && parent->phy->left && parent->phy->right);
  8041606a4c:	48 b9 50 25 61 41 80 	movabs $0x8041612550,%rcx
  8041606a53:	00 00 00 
  8041606a56:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606a5d:	00 00 00 
  8041606a60:	be 53 01 00 00       	mov    $0x153,%esi
  8041606a65:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606a6c:	00 00 00 
  8041606a6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606a74:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606a7b:	00 00 00 
  8041606a7e:	41 ff d0             	call   *%r8
        (*dst)->phy = dst == &parent->left ? parent->phy->left : parent->phy->right;
  8041606a81:	48 8b 43 30          	mov    0x30(%rbx),%rax
  8041606a85:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8041606a89:	e9 4a ff ff ff       	jmp    80416069d8 <alloc_virtual_child+0x73>

0000008041606a8e <page_lookup_virtual>:
page_lookup_virtual(struct Page *node, uintptr_t addr, int class, int alloc) {
  8041606a8e:	55                   	push   %rbp
  8041606a8f:	48 89 e5             	mov    %rsp,%rbp
  8041606a92:	41 57                	push   %r15
  8041606a94:	41 56                	push   %r14
  8041606a96:	41 55                	push   %r13
  8041606a98:	41 54                	push   %r12
  8041606a9a:	53                   	push   %rbx
  8041606a9b:	48 83 ec 18          	sub    $0x18,%rsp
  8041606a9f:	89 4d cc             	mov    %ecx,-0x34(%rbp)
    assert(class >= 0);
  8041606aa2:	85 d2                	test   %edx,%edx
  8041606aa4:	78 31                	js     8041606ad7 <page_lookup_virtual+0x49>
  8041606aa6:	48 89 fb             	mov    %rdi,%rbx
  8041606aa9:	49 89 f7             	mov    %rsi,%r15
    assert_virtual(node);
  8041606aac:	8b 47 28             	mov    0x28(%rdi),%eax
  8041606aaf:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041606ab4:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8041606ab9:	77 59                	ja     8041606b14 <page_lookup_virtual+0x86>
    while (nclass > class) {
  8041606abb:	83 fa 2f             	cmp    $0x2f,%edx
  8041606abe:	7f 4c                	jg     8041606b0c <page_lookup_virtual+0x7e>
  8041606ac0:	41 bc 31 00 00 00    	mov    $0x31,%r12d
  8041606ac6:	41 29 d4             	sub    %edx,%r12d
  8041606ac9:	45 01 e4             	add    %r12d,%r12d
    int nclass = MAX_CLASS;
  8041606acc:	41 bd 30 00 00 00    	mov    $0x30,%r13d
  8041606ad2:	e9 94 00 00 00       	jmp    8041606b6b <page_lookup_virtual+0xdd>
    assert(class >= 0);
  8041606ad7:	48 b9 87 1c 61 41 80 	movabs $0x8041611c87,%rcx
  8041606ade:	00 00 00 
  8041606ae1:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606ae8:	00 00 00 
  8041606aeb:	be 79 01 00 00       	mov    $0x179,%esi
  8041606af0:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606af7:	00 00 00 
  8041606afa:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606aff:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606b06:	00 00 00 
  8041606b09:	41 ff d0             	call   *%r8
    while (nclass > class) {
  8041606b0c:	48 89 f8             	mov    %rdi,%rax
  8041606b0f:	e9 de 02 00 00       	jmp    8041606df2 <page_lookup_virtual+0x364>
    assert_virtual(node);
  8041606b14:	48 b9 40 1f 61 41 80 	movabs $0x8041611f40,%rcx
  8041606b1b:	00 00 00 
  8041606b1e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606b25:	00 00 00 
  8041606b28:	be 7a 01 00 00       	mov    $0x17a,%esi
  8041606b2d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606b34:	00 00 00 
  8041606b37:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606b3c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606b43:	00 00 00 
  8041606b46:	41 ff d0             	call   *%r8
        struct Page **next = right ? &node->right : &node->left;
  8041606b49:	4c 8d 73 10          	lea    0x10(%rbx),%r14
  8041606b4d:	48 8b 43 10          	mov    0x10(%rbx),%rax
        if (!*next) {
  8041606b51:	48 85 c0             	test   %rax,%rax
  8041606b54:	74 30                	je     8041606b86 <page_lookup_virtual+0xf8>
        node = *next;
  8041606b56:	49 8b 1e             	mov    (%r14),%rbx
        nclass--;
  8041606b59:	41 83 ed 01          	sub    $0x1,%r13d
    while (nclass > class) {
  8041606b5d:	41 83 ec 02          	sub    $0x2,%r12d
  8041606b61:	41 83 fc 02          	cmp    $0x2,%r12d
  8041606b65:	0f 84 84 02 00 00    	je     8041606def <page_lookup_virtual+0x361>
        bool right = addr & CLASS_SIZE(nclass - 1);
  8041606b6b:	41 8d 4d 0b          	lea    0xb(%r13),%ecx
  8041606b6f:	b8 01 00 00 00       	mov    $0x1,%eax
  8041606b74:	48 d3 e0             	shl    %cl,%rax
        struct Page **next = right ? &node->right : &node->left;
  8041606b77:	4c 85 f8             	test   %r15,%rax
  8041606b7a:	74 cd                	je     8041606b49 <page_lookup_virtual+0xbb>
  8041606b7c:	4c 8d 73 18          	lea    0x18(%rbx),%r14
  8041606b80:	48 8b 43 18          	mov    0x18(%rbx),%rax
  8041606b84:	eb cb                	jmp    8041606b51 <page_lookup_virtual+0xc3>
            if (!alloc) break;
  8041606b86:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8041606b89:	85 c0                	test   %eax,%eax
  8041606b8b:	0f 84 70 02 00 00    	je     8041606e01 <page_lookup_virtual+0x373>
            if (!node->phy && alloc == LOOKUP_SPLIT) break;
  8041606b91:	48 83 7b 30 00       	cmpq   $0x0,0x30(%rbx)
  8041606b96:	75 09                	jne    8041606ba1 <page_lookup_virtual+0x113>
  8041606b98:	83 f8 02             	cmp    $0x2,%eax
  8041606b9b:	0f 84 65 02 00 00    	je     8041606e06 <page_lookup_virtual+0x378>
            ensure_free_desc((nclass - class + 1) * 2);
  8041606ba1:	49 63 fc             	movslq %r12d,%rdi
  8041606ba4:	48 b8 89 56 60 41 80 	movabs $0x8041605689,%rax
  8041606bab:	00 00 00 
  8041606bae:	ff d0                	call   *%rax
            if (node->phy) {
  8041606bb0:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
  8041606bb4:	48 85 ff             	test   %rdi,%rdi
  8041606bb7:	0f 84 d7 01 00 00    	je     8041606d94 <page_lookup_virtual+0x306>
                assert(nclass == node->phy->class);
  8041606bbd:	0f b7 57 34          	movzwl 0x34(%rdi),%edx
  8041606bc1:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  8041606bc7:	44 39 ea             	cmp    %r13d,%edx
  8041606bca:	0f 85 25 01 00 00    	jne    8041606cf5 <page_lookup_virtual+0x267>
                assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8041606bd0:	8b 43 28             	mov    0x28(%rbx),%eax
  8041606bd3:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041606bd8:	3d 00 00 10 00       	cmp    $0x100000,%eax
  8041606bdd:	0f 85 47 01 00 00    	jne    8041606d2a <page_lookup_virtual+0x29c>
                struct Page *pleft = page_lookup(node->phy, page2pa(node->phy), node->phy->class - 1, PARTIAL_NODE, 1);
  8041606be3:	83 ea 01             	sub    $0x1,%edx
    return page->addr << CLASS_BASE;
  8041606be6:	48 be ff ff ff ff ff 	movabs $0xfffffffffffff,%rsi
  8041606bed:	ff 0f 00 
  8041606bf0:	48 23 77 38          	and    0x38(%rdi),%rsi
  8041606bf4:	48 c1 e6 0c          	shl    $0xc,%rsi
  8041606bf8:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8041606bff:	ff 0f 00 
  8041606c02:	48 21 c6             	and    %rax,%rsi
  8041606c05:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8041606c0b:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8041606c10:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  8041606c17:	00 00 00 
  8041606c1a:	ff d0                	call   *%rax
                if (!pleft) return NULL;
  8041606c1c:	48 85 c0             	test   %rax,%rax
  8041606c1f:	0f 84 cd 01 00 00    	je     8041606df2 <page_lookup_virtual+0x364>
                assert(node->phy->left && node->phy->right);
  8041606c25:	48 8b 43 30          	mov    0x30(%rbx),%rax
  8041606c29:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  8041606c2e:	0f 84 2b 01 00 00    	je     8041606d5f <page_lookup_virtual+0x2d1>
  8041606c34:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  8041606c39:	0f 84 20 01 00 00    	je     8041606d5f <page_lookup_virtual+0x2d1>
                alloc_virtual_child(node, &node->left);
  8041606c3f:	48 8d 73 10          	lea    0x10(%rbx),%rsi
  8041606c43:	48 89 df             	mov    %rbx,%rdi
  8041606c46:	48 b8 65 69 60 41 80 	movabs $0x8041606965,%rax
  8041606c4d:	00 00 00 
  8041606c50:	ff d0                	call   *%rax
                if (!node->left) return NULL;
  8041606c52:	48 8b 43 10          	mov    0x10(%rbx),%rax
  8041606c56:	48 85 c0             	test   %rax,%rax
  8041606c59:	0f 84 93 01 00 00    	je     8041606df2 <page_lookup_virtual+0x364>
                alloc_virtual_child(node, &node->right);
  8041606c5f:	48 8d 73 18          	lea    0x18(%rbx),%rsi
  8041606c63:	48 89 df             	mov    %rbx,%rdi
  8041606c66:	48 b8 65 69 60 41 80 	movabs $0x8041606965,%rax
  8041606c6d:	00 00 00 
  8041606c70:	ff d0                	call   *%rax
                if (!node->right) return NULL;
  8041606c72:	48 8b 43 18          	mov    0x18(%rbx),%rax
  8041606c76:	48 85 c0             	test   %rax,%rax
  8041606c79:	0f 84 73 01 00 00    	je     8041606df2 <page_lookup_virtual+0x364>
    list->prev->next = list->next;
  8041606c7f:	48 8b 13             	mov    (%rbx),%rdx
  8041606c82:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8041606c86:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list->next->prev = list->prev;
  8041606c8a:	48 8b 13             	mov    (%rbx),%rdx
  8041606c8d:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8041606c90:	48 89 1b             	mov    %rbx,(%rbx)
  8041606c93:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
                page_unref(node->phy);
  8041606c97:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
  8041606c9b:	48 b8 b1 48 60 41 80 	movabs $0x80416048b1,%rax
  8041606ca2:	00 00 00 
  8041606ca5:	ff d0                	call   *%rax
                node->phy = NULL;
  8041606ca7:	48 c7 43 30 00 00 00 	movq   $0x0,0x30(%rbx)
  8041606cae:	00 
                node->state = INTERMEDIATE_NODE;
  8041606caf:	c7 43 28 00 00 20 00 	movl   $0x200000,0x28(%rbx)
            assert(*next);
  8041606cb6:	49 83 3e 00          	cmpq   $0x0,(%r14)
  8041606cba:	0f 85 96 fe ff ff    	jne    8041606b56 <page_lookup_virtual+0xc8>
  8041606cc0:	48 b9 88 1d 61 41 80 	movabs $0x8041611d88,%rcx
  8041606cc7:	00 00 00 
  8041606cca:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606cd1:	00 00 00 
  8041606cd4:	be a2 01 00 00       	mov    $0x1a2,%esi
  8041606cd9:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606ce0:	00 00 00 
  8041606ce3:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606ce8:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606cef:	00 00 00 
  8041606cf2:	41 ff d0             	call   *%r8
                assert(nclass == node->phy->class);
  8041606cf5:	48 b9 6d 1d 61 41 80 	movabs $0x8041611d6d,%rcx
  8041606cfc:	00 00 00 
  8041606cff:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606d06:	00 00 00 
  8041606d09:	be 8c 01 00 00       	mov    $0x18c,%esi
  8041606d0e:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606d15:	00 00 00 
  8041606d18:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606d1d:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606d24:	00 00 00 
  8041606d27:	41 ff d0             	call   *%r8
                assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8041606d2a:	48 b9 70 1f 61 41 80 	movabs $0x8041611f70,%rcx
  8041606d31:	00 00 00 
  8041606d34:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606d3b:	00 00 00 
  8041606d3e:	be 8d 01 00 00       	mov    $0x18d,%esi
  8041606d43:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606d4a:	00 00 00 
  8041606d4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606d52:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606d59:	00 00 00 
  8041606d5c:	41 ff d0             	call   *%r8
                assert(node->phy->left && node->phy->right);
  8041606d5f:	48 b9 88 25 61 41 80 	movabs $0x8041612588,%rcx
  8041606d66:	00 00 00 
  8041606d69:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606d70:	00 00 00 
  8041606d73:	be 92 01 00 00       	mov    $0x192,%esi
  8041606d78:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606d7f:	00 00 00 
  8041606d82:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606d87:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606d8e:	00 00 00 
  8041606d91:	41 ff d0             	call   *%r8
                assert(node->state == INTERMEDIATE_NODE);
  8041606d94:	81 7b 28 00 00 20 00 	cmpl   $0x200000,0x28(%rbx)
  8041606d9b:	75 1d                	jne    8041606dba <page_lookup_virtual+0x32c>
                *next = alloc_descriptor(INTERMEDIATE_NODE);
  8041606d9d:	bf 00 00 20 00       	mov    $0x200000,%edi
  8041606da2:	48 b8 77 57 60 41 80 	movabs $0x8041605777,%rax
  8041606da9:	00 00 00 
  8041606dac:	ff d0                	call   *%rax
  8041606dae:	49 89 06             	mov    %rax,(%r14)
                (*next)->parent = node;
  8041606db1:	48 89 58 20          	mov    %rbx,0x20(%rax)
  8041606db5:	e9 fc fe ff ff       	jmp    8041606cb6 <page_lookup_virtual+0x228>
                assert(node->state == INTERMEDIATE_NODE);
  8041606dba:	48 b9 b0 25 61 41 80 	movabs $0x80416125b0,%rcx
  8041606dc1:	00 00 00 
  8041606dc4:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606dcb:	00 00 00 
  8041606dce:	be 9e 01 00 00       	mov    $0x19e,%esi
  8041606dd3:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606dda:	00 00 00 
  8041606ddd:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606de2:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606de9:	00 00 00 
  8041606dec:	41 ff d0             	call   *%r8
        node = *next;
  8041606def:	48 89 d8             	mov    %rbx,%rax
}
  8041606df2:	48 83 c4 18          	add    $0x18,%rsp
  8041606df6:	5b                   	pop    %rbx
  8041606df7:	41 5c                	pop    %r12
  8041606df9:	41 5d                	pop    %r13
  8041606dfb:	41 5e                	pop    %r14
  8041606dfd:	41 5f                	pop    %r15
  8041606dff:	5d                   	pop    %rbp
  8041606e00:	c3                   	ret    
  8041606e01:	48 89 d8             	mov    %rbx,%rax
  8041606e04:	eb ec                	jmp    8041606df2 <page_lookup_virtual+0x364>
  8041606e06:	48 89 d8             	mov    %rbx,%rax
  8041606e09:	eb e7                	jmp    8041606df2 <page_lookup_virtual+0x364>

0000008041606e0b <unmap_page>:
unmap_page(struct AddressSpace *spc, uintptr_t addr, int class) {
  8041606e0b:	55                   	push   %rbp
  8041606e0c:	48 89 e5             	mov    %rsp,%rbp
  8041606e0f:	41 57                	push   %r15
  8041606e11:	41 56                	push   %r14
  8041606e13:	41 55                	push   %r13
  8041606e15:	41 54                	push   %r12
  8041606e17:	53                   	push   %rbx
  8041606e18:	48 83 ec 28          	sub    $0x28,%rsp
    assert(!(addr & CLASS_MASK(class)));
  8041606e1c:	44 8d 7a 0c          	lea    0xc(%rdx),%r15d
  8041606e20:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8041606e27:	44 89 f9             	mov    %r15d,%ecx
  8041606e2a:	48 d3 e0             	shl    %cl,%rax
  8041606e2d:	48 f7 d0             	not    %rax
  8041606e30:	48 85 f0             	test   %rsi,%rax
  8041606e33:	75 7c                	jne    8041606eb1 <unmap_page+0xa6>
  8041606e35:	49 89 fe             	mov    %rdi,%r14
  8041606e38:	48 89 f3             	mov    %rsi,%rbx
  8041606e3b:	41 89 d5             	mov    %edx,%r13d
    struct Page *node = page_lookup_virtual(spc->root, addr, class, LOOKUP_ALLOC);
  8041606e3e:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8041606e42:	b9 01 00 00 00       	mov    $0x1,%ecx
  8041606e47:	48 b8 8e 6a 60 41 80 	movabs $0x8041606a8e,%rax
  8041606e4e:	00 00 00 
  8041606e51:	ff d0                	call   *%rax
  8041606e53:	49 89 c4             	mov    %rax,%r12
    if (node) unmap_page_remove(node);
  8041606e56:	48 85 c0             	test   %rax,%rax
  8041606e59:	74 0f                	je     8041606e6a <unmap_page+0x5f>
  8041606e5b:	48 89 c7             	mov    %rax,%rdi
  8041606e5e:	48 b8 58 4b 60 41 80 	movabs $0x8041604b58,%rax
  8041606e65:	00 00 00 
  8041606e68:	ff d0                	call   *%rax
    if (node == spc->root)
  8041606e6a:	4d 39 66 10          	cmp    %r12,0x10(%r14)
  8041606e6e:	74 76                	je     8041606ee6 <unmap_page+0xdb>
    uintptr_t end = addr + CLASS_SIZE(class);
  8041606e70:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  8041606e76:	44 89 f9             	mov    %r15d,%ecx
  8041606e79:	49 d3 e4             	shl    %cl,%r12
  8041606e7c:	49 01 dc             	add    %rbx,%r12
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  8041606e7f:	48 89 d9             	mov    %rbx,%rcx
  8041606e82:	48 c1 e9 27          	shr    $0x27,%rcx
  8041606e86:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
    if (class >= 27) {
  8041606e8c:	41 83 fd 1a          	cmp    $0x1a,%r13d
  8041606e90:	7f 6e                	jg     8041606f00 <unmap_page+0xf5>
    if (!(spc->pml4[pml4i0] & PTE_P)) return;
  8041606e92:	49 8b 06             	mov    (%r14),%rax
  8041606e95:	48 8b 0c c8          	mov    (%rax,%rcx,8),%rcx
  8041606e99:	f6 c1 01             	test   $0x1,%cl
  8041606e9c:	0f 85 a9 00 00 00    	jne    8041606f4b <unmap_page+0x140>
}
  8041606ea2:	48 83 c4 28          	add    $0x28,%rsp
  8041606ea6:	5b                   	pop    %rbx
  8041606ea7:	41 5c                	pop    %r12
  8041606ea9:	41 5d                	pop    %r13
  8041606eab:	41 5e                	pop    %r14
  8041606ead:	41 5f                	pop    %r15
  8041606eaf:	5d                   	pop    %rbp
  8041606eb0:	c3                   	ret    
    assert(!(addr & CLASS_MASK(class)));
  8041606eb1:	48 b9 02 1d 61 41 80 	movabs $0x8041611d02,%rcx
  8041606eb8:	00 00 00 
  8041606ebb:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041606ec2:	00 00 00 
  8041606ec5:	be 49 03 00 00       	mov    $0x349,%esi
  8041606eca:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041606ed1:	00 00 00 
  8041606ed4:	b8 00 00 00 00       	mov    $0x0,%eax
  8041606ed9:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041606ee0:	00 00 00 
  8041606ee3:	41 ff d0             	call   *%r8
        spc->root = alloc_descriptor(INTERMEDIATE_NODE);
  8041606ee6:	bf 00 00 20 00       	mov    $0x200000,%edi
  8041606eeb:	48 b8 77 57 60 41 80 	movabs $0x8041605777,%rax
  8041606ef2:	00 00 00 
  8041606ef5:	ff d0                	call   *%rax
  8041606ef7:	49 89 46 10          	mov    %rax,0x10(%r14)
  8041606efb:	e9 70 ff ff ff       	jmp    8041606e70 <unmap_page+0x65>
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  8041606f00:	4d 89 e5             	mov    %r12,%r13
  8041606f03:	49 c1 ed 27          	shr    $0x27,%r13
  8041606f07:	41 81 e5 ff 01 00 00 	and    $0x1ff,%r13d
        remove_pt(spc->pml4, addr, 512 * GB, pml4i0, pml4i1);
  8041606f0e:	4d 89 e8             	mov    %r13,%r8
  8041606f11:	48 ba 00 00 00 00 80 	movabs $0x8000000000,%rdx
  8041606f18:	00 00 00 
  8041606f1b:	48 89 de             	mov    %rbx,%rsi
  8041606f1e:	49 8b 3e             	mov    (%r14),%rdi
  8041606f21:	48 b8 cf 66 60 41 80 	movabs $0x80416066cf,%rax
  8041606f28:	00 00 00 
  8041606f2b:	ff d0                	call   *%rax
        if (pml4i1 - 1 >= NUSERPML4) propagate_pml4(spc);
  8041606f2d:	49 83 fd 01          	cmp    $0x1,%r13
  8041606f31:	0f 84 e4 03 00 00    	je     804160731b <unmap_page+0x510>
  8041606f37:	4c 89 f7             	mov    %r14,%rdi
  8041606f3a:	48 b8 33 66 60 41 80 	movabs $0x8041606633,%rax
  8041606f41:	00 00 00 
  8041606f44:	ff d0                	call   *%rax
  8041606f46:	e9 d0 03 00 00       	jmp    804160731b <unmap_page+0x510>
    pdpe_t *pdp = KADDR(PTE_ADDR(spc->pml4[pml4i0]));
  8041606f4b:	48 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdi
  8041606f52:	ff ff 7f 
  8041606f55:	48 21 f9             	and    %rdi,%rcx
    if (pa > max_memory_map_addr)
  8041606f58:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041606f5f:	00 00 00 
  8041606f62:	48 39 c1             	cmp    %rax,%rcx
  8041606f65:	0f 87 a9 00 00 00    	ja     8041607014 <unmap_page+0x209>
    return (void *)(pa + KERN_BASE_ADDR);
  8041606f6b:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  8041606f72:	00 00 00 
  8041606f75:	48 01 cf             	add    %rcx,%rdi
    size_t pdpi0 = PDP_INDEX(addr), pdpi1 = PDP_INDEX(end);
  8041606f78:	48 89 d9             	mov    %rbx,%rcx
  8041606f7b:	48 c1 e9 1e          	shr    $0x1e,%rcx
  8041606f7f:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
  8041606f85:	4d 89 e0             	mov    %r12,%r8
  8041606f88:	49 c1 e8 1e          	shr    $0x1e,%r8
  8041606f8c:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
    if (pdpi0 > pdpi1) pdpi1 = PDP_ENTRY_COUNT;
  8041606f93:	4c 39 c1             	cmp    %r8,%rcx
  8041606f96:	b8 00 02 00 00       	mov    $0x200,%eax
  8041606f9b:	4c 0f 47 c0          	cmova  %rax,%r8
    if (class >= 18) {
  8041606f9f:	41 83 fd 11          	cmp    $0x11,%r13d
  8041606fa3:	0f 8f 99 00 00 00    	jg     8041607042 <unmap_page+0x237>
    if (!(pdp[pdpi0] & PTE_P))
  8041606fa9:	4c 8d 3c cf          	lea    (%rdi,%rcx,8),%r15
  8041606fad:	49 8b 07             	mov    (%r15),%rax
  8041606fb0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8041606fb4:	a8 01                	test   $0x1,%al
  8041606fb6:	0f 84 e6 fe ff ff    	je     8041606ea2 <unmap_page+0x97>
    else if (pdp[pdpi0] & PTE_PS) {
  8041606fbc:	a8 80                	test   $0x80,%al
  8041606fbe:	0f 84 ea 01 00 00    	je     80416071ae <unmap_page+0x3a3>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8041606fc4:	25 81 00 00 00       	and    $0x81,%eax
  8041606fc9:	48 83 f8 01          	cmp    $0x1,%rax
  8041606fcd:	0f 85 88 00 00 00    	jne    804160705b <unmap_page+0x250>
        pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  8041606fd3:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8041606fda:	ff ff 7f 
  8041606fdd:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8041606fe0:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041606fe7:	00 00 00 
  8041606fea:	48 39 c1             	cmp    %rax,%rcx
  8041606fed:	0f 87 6c 01 00 00    	ja     804160715f <unmap_page+0x354>
    return (void *)(pa + KERN_BASE_ADDR);
  8041606ff3:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8041606ffa:	00 00 00 
  8041606ffd:	48 01 c1             	add    %rax,%rcx
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  8041607000:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8041607004:	40 80 ce 80          	or     $0x80,%sil
    for (size_t i = i0; i < i1; i++, base += step) {
  8041607008:	48 8d 86 00 00 00 40 	lea    0x40000000(%rsi),%rax
  804160700f:	e9 96 05 00 00       	jmp    80416075aa <unmap_page+0x79f>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607014:	49 89 c0             	mov    %rax,%r8
  8041607017:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160701e:	00 00 00 
  8041607021:	be 5c 03 00 00       	mov    $0x35c,%esi
  8041607026:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160702d:	00 00 00 
  8041607030:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607035:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160703c:	00 00 00 
  804160703f:	41 ff d1             	call   *%r9
        remove_pt(pdp, addr, 1 * GB, pdpi0, pdpi1);
  8041607042:	ba 00 00 00 40       	mov    $0x40000000,%edx
  8041607047:	48 89 de             	mov    %rbx,%rsi
  804160704a:	48 b8 cf 66 60 41 80 	movabs $0x80416066cf,%rax
  8041607051:	00 00 00 
  8041607054:	ff d0                	call   *%rax
        goto finish;
  8041607056:	e9 c0 02 00 00       	jmp    804160731b <unmap_page+0x510>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  804160705b:	be 00 00 04 00       	mov    $0x40000,%esi
  8041607060:	bf 00 00 00 00       	mov    $0x0,%edi
  8041607065:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  804160706c:	00 00 00 
  804160706f:	ff d0                	call   *%rax
  8041607071:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (!page) return -E_NO_MEM;
  8041607075:	48 85 c0             	test   %rax,%rax
  8041607078:	0f 84 96 05 00 00    	je     8041607614 <unmap_page+0x809>
        assert(!page->refc);
  804160707e:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041607082:	75 78                	jne    80416070fc <unmap_page+0x2f1>
        page_ref(page);
  8041607084:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8041607088:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  804160708f:	00 00 00 
  8041607092:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041607094:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  804160709b:	ff 0f 00 
  804160709e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80416070a2:	48 89 d0             	mov    %rdx,%rax
  80416070a5:	48 23 46 38          	and    0x38(%rsi),%rax
  80416070a9:	48 c1 e0 0c          	shl    $0xc,%rax
  80416070ad:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  80416070b0:	48 83 c8 07          	or     $0x7,%rax
  80416070b4:	49 89 07             	mov    %rax,(%r15)
  80416070b7:	48 89 d1             	mov    %rdx,%rcx
  80416070ba:	48 23 4e 38          	and    0x38(%rsi),%rcx
  80416070be:	48 c1 e1 0c          	shl    $0xc,%rcx
  80416070c2:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  80416070c5:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  80416070cc:	00 00 00 
  80416070cf:	48 39 c1             	cmp    %rax,%rcx
  80416070d2:	77 5d                	ja     8041607131 <unmap_page+0x326>
    return (void *)(pa + KERN_BASE_ADDR);
  80416070d4:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  80416070db:	00 00 00 
  80416070de:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  80416070e1:	ba 00 10 00 00       	mov    $0x1000,%edx
  80416070e6:	be 00 00 00 00       	mov    $0x0,%esi
  80416070eb:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  80416070f2:	00 00 00 
  80416070f5:	ff d0                	call   *%rax
  80416070f7:	e9 d7 fe ff ff       	jmp    8041606fd3 <unmap_page+0x1c8>
        assert(!page->refc);
  80416070fc:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041607103:	00 00 00 
  8041607106:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160710d:	00 00 00 
  8041607110:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041607115:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160711c:	00 00 00 
  804160711f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607124:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160712b:	00 00 00 
  804160712e:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607131:	49 89 c0             	mov    %rax,%r8
  8041607134:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160713b:	00 00 00 
  804160713e:	be db 02 00 00       	mov    $0x2db,%esi
  8041607143:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160714a:	00 00 00 
  804160714d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607152:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607159:	00 00 00 
  804160715c:	41 ff d1             	call   *%r9
  804160715f:	49 89 c0             	mov    %rax,%r8
  8041607162:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607169:	00 00 00 
  804160716c:	be 75 03 00 00       	mov    $0x375,%esi
  8041607171:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607178:	00 00 00 
  804160717b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607180:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607187:	00 00 00 
  804160718a:	41 ff d1             	call   *%r9
        inval_start = ROUNDDOWN(inval_start, 1 * GB);
  804160718d:	48 89 d8             	mov    %rbx,%rax
  8041607190:	48 25 00 00 00 c0    	and    $0xffffffffc0000000,%rax
  8041607196:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        inval_end = ROUNDUP(inval_end, 1 * GB);
  804160719a:	49 8d 84 24 ff ff ff 	lea    0x3fffffff(%r12),%rax
  80416071a1:	3f 
  80416071a2:	48 25 00 00 00 c0    	and    $0xffffffffc0000000,%rax
  80416071a8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        assert(!res);
  80416071ac:	eb 08                	jmp    80416071b6 <unmap_page+0x3ab>
    uintptr_t inval_start = addr, inval_end = end;
  80416071ae:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
  80416071b2:	48 89 5d c0          	mov    %rbx,-0x40(%rbp)
    pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  80416071b6:	48 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdi
  80416071bd:	ff ff 7f 
  80416071c0:	49 23 3f             	and    (%r15),%rdi
    if (pa > max_memory_map_addr)
  80416071c3:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  80416071ca:	00 00 00 
  80416071cd:	48 39 c7             	cmp    %rax,%rdi
  80416071d0:	0f 87 93 01 00 00    	ja     8041607369 <unmap_page+0x55e>
    return (void *)(pa + KERN_BASE_ADDR);
  80416071d6:	48 b9 00 00 00 40 80 	movabs $0x8040000000,%rcx
  80416071dd:	00 00 00 
  80416071e0:	48 01 cf             	add    %rcx,%rdi
    size_t pdi0 = PD_INDEX(addr), pdi1 = PD_INDEX(end);
  80416071e3:	48 89 d9             	mov    %rbx,%rcx
  80416071e6:	48 c1 e9 15          	shr    $0x15,%rcx
  80416071ea:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
  80416071f0:	4d 89 e0             	mov    %r12,%r8
  80416071f3:	49 c1 e8 15          	shr    $0x15,%r8
  80416071f7:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
    if (pdi0 > pdi1) pdi1 = PD_ENTRY_COUNT;
  80416071fe:	4c 39 c1             	cmp    %r8,%rcx
  8041607201:	b8 00 02 00 00       	mov    $0x200,%eax
  8041607206:	4c 0f 47 c0          	cmova  %rax,%r8
    if (class >= 9) {
  804160720a:	41 83 fd 08          	cmp    $0x8,%r13d
  804160720e:	0f 8f 86 01 00 00    	jg     804160739a <unmap_page+0x58f>
    if (!(pd[pdi0] & PTE_P))
  8041607214:	4c 8d 3c cf          	lea    (%rdi,%rcx,8),%r15
  8041607218:	49 8b 07             	mov    (%r15),%rax
  804160721b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  804160721f:	a8 01                	test   $0x1,%al
  8041607221:	0f 84 7b fc ff ff    	je     8041606ea2 <unmap_page+0x97>
    else if (pd[pdi0] & PTE_PS) {
  8041607227:	a8 80                	test   $0x80,%al
  8041607229:	74 77                	je     80416072a2 <unmap_page+0x497>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  804160722b:	25 81 00 00 00       	and    $0x81,%eax
  8041607230:	48 83 f8 01          	cmp    $0x1,%rax
  8041607234:	0f 85 81 01 00 00    	jne    80416073bb <unmap_page+0x5b0>
        pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  804160723a:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8041607241:	ff ff 7f 
  8041607244:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8041607247:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160724e:	00 00 00 
  8041607251:	48 39 c1             	cmp    %rax,%rcx
  8041607254:	0f 87 65 02 00 00    	ja     80416074bf <unmap_page+0x6b4>
    return (void *)(pa + KERN_BASE_ADDR);
  804160725a:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8041607261:	00 00 00 
  8041607264:	48 01 c1             	add    %rax,%rcx
        res = alloc_fill_pt(pt, old & ~PTE_PS, 4 * KB, 0, PT_ENTRY_COUNT);
  8041607267:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804160726b:	24 7f                	and    $0x7f,%al
    for (size_t i = i0; i < i1; i++, base += step) {
  804160726d:	48 8d 90 00 00 20 00 	lea    0x200000(%rax),%rdx
            dst[i] = base;
  8041607274:	48 89 01             	mov    %rax,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8041607277:	48 05 00 10 00 00    	add    $0x1000,%rax
  804160727d:	48 83 c1 08          	add    $0x8,%rcx
  8041607281:	48 39 c2             	cmp    %rax,%rdx
  8041607284:	75 ee                	jne    8041607274 <unmap_page+0x469>
        inval_start = ROUNDDOWN(inval_start, 2 * MB);
  8041607286:	48 81 65 c0 00 00 e0 	andq   $0xffffffffffe00000,-0x40(%rbp)
  804160728d:	ff 
        inval_end = ROUNDUP(inval_end, 2 * MB);
  804160728e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8041607292:	48 05 ff ff 1f 00    	add    $0x1fffff,%rax
  8041607298:	48 25 00 00 e0 ff    	and    $0xffffffffffe00000,%rax
  804160729e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  80416072a2:	48 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdi
  80416072a9:	ff ff 7f 
  80416072ac:	49 23 3f             	and    (%r15),%rdi
    if (pa > max_memory_map_addr)
  80416072af:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  80416072b6:	00 00 00 
  80416072b9:	48 39 c7             	cmp    %rax,%rdi
  80416072bc:	0f 87 2b 02 00 00    	ja     80416074ed <unmap_page+0x6e2>
    return (void *)(pa + KERN_BASE_ADDR);
  80416072c2:	48 b9 00 00 00 40 80 	movabs $0x8040000000,%rcx
  80416072c9:	00 00 00 
  80416072cc:	48 01 cf             	add    %rcx,%rdi
    size_t pti0 = PT_INDEX(addr), pti1 = PT_INDEX(end);
  80416072cf:	48 89 d9             	mov    %rbx,%rcx
  80416072d2:	48 c1 e9 0c          	shr    $0xc,%rcx
  80416072d6:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
  80416072dc:	4d 89 e0             	mov    %r12,%r8
  80416072df:	49 c1 e8 0c          	shr    $0xc,%r8
  80416072e3:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
    if (pti0 > pti1) pti1 = PT_ENTRY_COUNT;
  80416072ea:	4c 39 c1             	cmp    %r8,%rcx
  80416072ed:	b8 00 02 00 00       	mov    $0x200,%eax
  80416072f2:	4c 0f 47 c0          	cmova  %rax,%r8
    if (class >= 0) {
  80416072f6:	45 85 ed             	test   %r13d,%r13d
  80416072f9:	0f 88 1f 02 00 00    	js     804160751e <unmap_page+0x713>
        remove_pt(pt, addr, 4 * KB, pti0, pti1);
  80416072ff:	ba 00 10 00 00       	mov    $0x1000,%edx
  8041607304:	48 89 de             	mov    %rbx,%rsi
  8041607307:	48 b8 cf 66 60 41 80 	movabs $0x80416066cf,%rax
  804160730e:	00 00 00 
  8041607311:	ff d0                	call   *%rax
        goto finish;
  8041607313:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  8041607317:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
    if (current_space == spc || !current_space) {
  804160731b:	48 a1 a0 00 40 42 80 	movabs 0x80424000a0,%rax
  8041607322:	00 00 00 
  8041607325:	48 85 c0             	test   %rax,%rax
  8041607328:	74 09                	je     8041607333 <unmap_page+0x528>
  804160732a:	49 39 c6             	cmp    %rax,%r14
  804160732d:	0f 85 6f fb ff ff    	jne    8041606ea2 <unmap_page+0x97>
        if (start - end > 512 * GB)
  8041607333:	48 89 da             	mov    %rbx,%rdx
  8041607336:	4c 29 e2             	sub    %r12,%rdx
  8041607339:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  8041607340:	00 00 00 
  8041607343:	48 39 c2             	cmp    %rax,%rdx
  8041607346:	0f 87 07 02 00 00    	ja     8041607553 <unmap_page+0x748>
            while (start < end) {
  804160734c:	4c 39 e3             	cmp    %r12,%rbx
  804160734f:	0f 83 4d fb ff ff    	jae    8041606ea2 <unmap_page+0x97>
    asm volatile("invlpg (%0)" ::"r"(addr)
  8041607355:	0f 01 3b             	invlpg (%rbx)
                start += PAGE_SIZE;
  8041607358:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
            while (start < end) {
  804160735f:	49 39 dc             	cmp    %rbx,%r12
  8041607362:	77 f1                	ja     8041607355 <unmap_page+0x54a>
  8041607364:	e9 39 fb ff ff       	jmp    8041606ea2 <unmap_page+0x97>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607369:	49 89 c0             	mov    %rax,%r8
  804160736c:	48 89 f9             	mov    %rdi,%rcx
  804160736f:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607376:	00 00 00 
  8041607379:	be 7b 03 00 00       	mov    $0x37b,%esi
  804160737e:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607385:	00 00 00 
  8041607388:	b8 00 00 00 00       	mov    $0x0,%eax
  804160738d:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607394:	00 00 00 
  8041607397:	41 ff d1             	call   *%r9
        remove_pt(pd, addr, 2 * MB, pdi0, pdi1);
  804160739a:	ba 00 00 20 00       	mov    $0x200000,%edx
  804160739f:	48 89 de             	mov    %rbx,%rsi
  80416073a2:	48 b8 cf 66 60 41 80 	movabs $0x80416066cf,%rax
  80416073a9:	00 00 00 
  80416073ac:	ff d0                	call   *%rax
        goto finish;
  80416073ae:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  80416073b2:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  80416073b6:	e9 60 ff ff ff       	jmp    804160731b <unmap_page+0x510>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  80416073bb:	be 00 00 04 00       	mov    $0x40000,%esi
  80416073c0:	bf 00 00 00 00       	mov    $0x0,%edi
  80416073c5:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  80416073cc:	00 00 00 
  80416073cf:	ff d0                	call   *%rax
  80416073d1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        if (!page) return -E_NO_MEM;
  80416073d5:	48 85 c0             	test   %rax,%rax
  80416073d8:	0f 84 80 01 00 00    	je     804160755e <unmap_page+0x753>
        assert(!page->refc);
  80416073de:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  80416073e2:	75 78                	jne    804160745c <unmap_page+0x651>
        page_ref(page);
  80416073e4:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  80416073e8:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  80416073ef:	00 00 00 
  80416073f2:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  80416073f4:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  80416073fb:	ff 0f 00 
  80416073fe:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8041607402:	48 89 d0             	mov    %rdx,%rax
  8041607405:	48 23 46 38          	and    0x38(%rsi),%rax
  8041607409:	48 c1 e0 0c          	shl    $0xc,%rax
  804160740d:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8041607410:	48 83 c8 07          	or     $0x7,%rax
  8041607414:	49 89 07             	mov    %rax,(%r15)
  8041607417:	48 89 d1             	mov    %rdx,%rcx
  804160741a:	48 23 4e 38          	and    0x38(%rsi),%rcx
  804160741e:	48 c1 e1 0c          	shl    $0xc,%rcx
  8041607422:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8041607425:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160742c:	00 00 00 
  804160742f:	48 39 c1             	cmp    %rax,%rcx
  8041607432:	77 5d                	ja     8041607491 <unmap_page+0x686>
    return (void *)(pa + KERN_BASE_ADDR);
  8041607434:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  804160743b:	00 00 00 
  804160743e:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8041607441:	ba 00 10 00 00       	mov    $0x1000,%edx
  8041607446:	be 00 00 00 00       	mov    $0x0,%esi
  804160744b:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041607452:	00 00 00 
  8041607455:	ff d0                	call   *%rax
  8041607457:	e9 de fd ff ff       	jmp    804160723a <unmap_page+0x42f>
        assert(!page->refc);
  804160745c:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041607463:	00 00 00 
  8041607466:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160746d:	00 00 00 
  8041607470:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041607475:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160747c:	00 00 00 
  804160747f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607484:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160748b:	00 00 00 
  804160748e:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607491:	49 89 c0             	mov    %rax,%r8
  8041607494:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160749b:	00 00 00 
  804160749e:	be db 02 00 00       	mov    $0x2db,%esi
  80416074a3:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416074aa:	00 00 00 
  80416074ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80416074b2:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  80416074b9:	00 00 00 
  80416074bc:	41 ff d1             	call   *%r9
  80416074bf:	49 89 c0             	mov    %rax,%r8
  80416074c2:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  80416074c9:	00 00 00 
  80416074cc:	be 9e 03 00 00       	mov    $0x39e,%esi
  80416074d1:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416074d8:	00 00 00 
  80416074db:	b8 00 00 00 00       	mov    $0x0,%eax
  80416074e0:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  80416074e7:	00 00 00 
  80416074ea:	41 ff d1             	call   *%r9
  80416074ed:	49 89 c0             	mov    %rax,%r8
  80416074f0:	48 89 f9             	mov    %rdi,%rcx
  80416074f3:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  80416074fa:	00 00 00 
  80416074fd:	be a5 03 00 00       	mov    $0x3a5,%esi
  8041607502:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607509:	00 00 00 
  804160750c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607511:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607518:	00 00 00 
  804160751b:	41 ff d1             	call   *%r9
    assert(0);
  804160751e:	48 b9 90 1c 61 41 80 	movabs $0x8041611c90,%rcx
  8041607525:	00 00 00 
  8041607528:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160752f:	00 00 00 
  8041607532:	be b0 03 00 00       	mov    $0x3b0,%esi
  8041607537:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160753e:	00 00 00 
  8041607541:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607546:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160754d:	00 00 00 
  8041607550:	41 ff d0             	call   *%r8
    asm volatile("movq %%cr3,%0"
  8041607553:	0f 20 d8             	mov    %cr3,%rax
    asm volatile("movq %0,%%cr3" ::"r"(val));
  8041607556:	0f 22 d8             	mov    %rax,%cr3
}
  8041607559:	e9 44 f9 ff ff       	jmp    8041606ea2 <unmap_page+0x97>
        assert(!res);
  804160755e:	48 b9 8e 1d 61 41 80 	movabs $0x8041611d8e,%rcx
  8041607565:	00 00 00 
  8041607568:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160756f:	00 00 00 
  8041607572:	be 9d 03 00 00       	mov    $0x39d,%esi
  8041607577:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160757e:	00 00 00 
  8041607581:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607586:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160758d:	00 00 00 
  8041607590:	41 ff d0             	call   *%r8
            dst[i] = base;
  8041607593:	48 89 31             	mov    %rsi,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8041607596:	48 81 c6 00 00 20 00 	add    $0x200000,%rsi
  804160759d:	48 83 c1 08          	add    $0x8,%rcx
  80416075a1:	48 39 c6             	cmp    %rax,%rsi
  80416075a4:	0f 84 e3 fb ff ff    	je     804160718d <unmap_page+0x382>
            if ((PTE_ADDR(base) & (step - 1))) cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  80416075aa:	f7 c6 00 f0 1f 00    	test   $0x1ff000,%esi
  80416075b0:	74 e1                	je     8041607593 <unmap_page+0x788>
  80416075b2:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  80416075b9:	ff ff 7f 
  80416075bc:	48 21 c6             	and    %rax,%rsi
  80416075bf:	ba 00 00 20 00       	mov    $0x200000,%edx
  80416075c4:	48 bf 60 1d 61 41 80 	movabs $0x8041611d60,%rdi
  80416075cb:	00 00 00 
  80416075ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80416075d3:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  80416075da:	00 00 00 
  80416075dd:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  80416075df:	48 b9 78 24 61 41 80 	movabs $0x8041612478,%rcx
  80416075e6:	00 00 00 
  80416075e9:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416075f0:	00 00 00 
  80416075f3:	be 0f 03 00 00       	mov    $0x30f,%esi
  80416075f8:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416075ff:	00 00 00 
  8041607602:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607607:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160760e:	00 00 00 
  8041607611:	41 ff d0             	call   *%r8
        assert(!res);
  8041607614:	48 b9 8e 1d 61 41 80 	movabs $0x8041611d8e,%rcx
  804160761b:	00 00 00 
  804160761e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607625:	00 00 00 
  8041607628:	be 74 03 00 00       	mov    $0x374,%esi
  804160762d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607634:	00 00 00 
  8041607637:	b8 00 00 00 00       	mov    $0x0,%eax
  804160763c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607643:	00 00 00 
  8041607646:	41 ff d0             	call   *%r8

0000008041607649 <map_page>:
map_page(struct AddressSpace *spc, uintptr_t addr, struct Page *page, int flags) {
  8041607649:	55                   	push   %rbp
  804160764a:	48 89 e5             	mov    %rsp,%rbp
  804160764d:	41 57                	push   %r15
  804160764f:	41 56                	push   %r14
  8041607651:	41 55                	push   %r13
  8041607653:	41 54                	push   %r12
  8041607655:	53                   	push   %rbx
  8041607656:	48 83 ec 28          	sub    $0x28,%rsp
  804160765a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  804160765e:	89 c8                	mov    %ecx,%eax
  8041607660:	25 c0 00 00 00       	and    $0xc0,%eax
  8041607665:	3d c0 00 00 00       	cmp    $0xc0,%eax
  804160766a:	0f 84 57 02 00 00    	je     80416078c7 <map_page+0x27e>
  8041607670:	49 89 f5             	mov    %rsi,%r13
  8041607673:	49 89 d4             	mov    %rdx,%r12
  8041607676:	41 89 cf             	mov    %ecx,%r15d
    assert(page && spc);
  8041607679:	48 85 d2             	test   %rdx,%rdx
  804160767c:	0f 84 7a 02 00 00    	je     80416078fc <map_page+0x2b3>
  8041607682:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8041607687:	0f 84 6f 02 00 00    	je     80416078fc <map_page+0x2b3>
    assert_physical(page);
  804160768d:	8b 42 28             	mov    0x28(%rdx),%eax
  8041607690:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041607695:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  804160769a:	0f 86 91 02 00 00    	jbe    8041607931 <map_page+0x2e8>
    assert(!(addr & CLASS_MASK(page->class)));
  80416076a0:	0f b7 4a 34          	movzwl 0x34(%rdx),%ecx
  80416076a4:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  80416076aa:	83 c1 0c             	add    $0xc,%ecx
  80416076ad:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80416076b4:	48 d3 e0             	shl    %cl,%rax
  80416076b7:	48 f7 d0             	not    %rax
  80416076ba:	48 85 f0             	test   %rsi,%rax
  80416076bd:	0f 85 a3 02 00 00    	jne    8041607966 <map_page+0x31d>
    if (!(flags & ALLOC_WEAK)) {
  80416076c3:	41 f7 c7 00 00 02 00 	test   $0x20000,%r15d
  80416076ca:	0f 85 8d 00 00 00    	jne    804160775d <map_page+0x114>
        page_ref(page);
  80416076d0:	48 89 d7             	mov    %rdx,%rdi
  80416076d3:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  80416076da:	00 00 00 
  80416076dd:	ff d0                	call   *%rax
        unmap_page(spc, addr, page->class);
  80416076df:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  80416076e5:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  80416076eb:	4c 89 ee             	mov    %r13,%rsi
  80416076ee:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  80416076f2:	48 89 df             	mov    %rbx,%rdi
  80416076f5:	48 b8 0b 6e 60 41 80 	movabs $0x8041606e0b,%rax
  80416076fc:	00 00 00 
  80416076ff:	ff d0                	call   *%rax
        struct Page *mapping = page_lookup_virtual(spc->root, addr, page->class, LOOKUP_ALLOC);
  8041607701:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  8041607707:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  804160770d:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8041607711:	b9 01 00 00 00       	mov    $0x1,%ecx
  8041607716:	4c 89 ee             	mov    %r13,%rsi
  8041607719:	48 b8 8e 6a 60 41 80 	movabs $0x8041606a8e,%rax
  8041607720:	00 00 00 
  8041607723:	ff d0                	call   *%rax
        if (!mapping) return -E_NO_MEM;
  8041607725:	48 85 c0             	test   %rax,%rax
  8041607728:	0f 84 7a 0b 00 00    	je     80416082a8 <map_page+0xc5f>
        mapping->phy = page;
  804160772e:	4c 89 60 30          	mov    %r12,0x30(%rax)
        mapping->state = (PAGE_PROT(flags) & ~PROT_COMBINE) | MAPPING_NODE;
  8041607732:	44 89 fa             	mov    %r15d,%edx
  8041607735:	81 e2 ff fe 0f ff    	and    $0xff0ffeff,%edx
  804160773b:	81 ca 00 00 10 00    	or     $0x100000,%edx
  8041607741:	89 50 28             	mov    %edx,0x28(%rax)
    list->next->prev = new;
  8041607744:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  8041607749:	48 89 02             	mov    %rax,(%rdx)
    new->next = list->next;
  804160774c:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  8041607751:	48 89 50 08          	mov    %rdx,0x8(%rax)
    list->next = new;
  8041607755:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    new->prev = list;
  804160775a:	4c 89 20             	mov    %r12,(%rax)
    uintptr_t end = addr + CLASS_SIZE(page->class);
  804160775d:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  8041607763:	89 ce                	mov    %ecx,%esi
  8041607765:	66 81 e6 ff 0f       	and    $0xfff,%si
  804160776a:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041607770:	83 c1 0c             	add    $0xc,%ecx
  8041607773:	41 be 01 00 00 00    	mov    $0x1,%r14d
  8041607779:	49 d3 e6             	shl    %cl,%r14
  804160777c:	4d 01 ee             	add    %r13,%r14
    return page->addr << CLASS_BASE;
  804160777f:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041607786:	ff 0f 00 
  8041607789:	48 89 d0             	mov    %rdx,%rax
  804160778c:	49 23 44 24 38       	and    0x38(%r12),%rax
  8041607791:	48 c1 e0 0c          	shl    $0xc,%rax
  8041607795:	48 21 d0             	and    %rdx,%rax
    pte_t res = PTE_P | (flags & (PTE_AVAIL | PTE_PCD | PTE_PWT));
  8041607798:	44 89 fb             	mov    %r15d,%ebx
  804160779b:	81 e3 18 0e 00 00    	and    $0xe18,%ebx
    if (flags & PROT_W && !(flags & PROT_LAZY)) res |= PTE_W;
  80416077a1:	44 89 ff             	mov    %r15d,%edi
  80416077a4:	81 e7 82 00 00 00    	and    $0x82,%edi
    pte_t res = PTE_P | (flags & (PTE_AVAIL | PTE_PCD | PTE_PWT));
  80416077aa:	89 da                	mov    %ebx,%edx
  80416077ac:	83 ca 01             	or     $0x1,%edx
  80416077af:	83 cb 03             	or     $0x3,%ebx
  80416077b2:	83 ff 02             	cmp    $0x2,%edi
  80416077b5:	0f 45 da             	cmovne %edx,%ebx
  80416077b8:	48 63 db             	movslq %ebx,%rbx
    if (!(flags & PROT_X) && nx_supported) res |= PTE_NX;
  80416077bb:	41 f6 c7 01          	test   $0x1,%r15b
  80416077bf:	75 05                	jne    80416077c6 <map_page+0x17d>
  80416077c1:	48 0f ba eb 3f       	bts    $0x3f,%rbx
    if (flags & PROT_SHARE) res |= PTE_SHARE;
  80416077c6:	48 89 da             	mov    %rbx,%rdx
  80416077c9:	80 ce 04             	or     $0x4,%dh
  80416077cc:	41 f6 c7 40          	test   $0x40,%r15b
  80416077d0:	48 0f 45 da          	cmovne %rdx,%rbx
    if (flags & PROT_USER_) res |= PTE_U;
  80416077d4:	48 89 da             	mov    %rbx,%rdx
  80416077d7:	48 83 ca 04          	or     $0x4,%rdx
  80416077db:	41 f6 c7 20          	test   $0x20,%r15b
  80416077df:	48 0f 45 da          	cmovne %rdx,%rbx
    uintptr_t base = page2pa(page) | prot2pte(flags);
  80416077e3:	48 09 c3             	or     %rax,%rbx
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  80416077e6:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  80416077ed:	48 d3 e2             	shl    %cl,%rdx
  80416077f0:	48 f7 d2             	not    %rdx
  80416077f3:	48 85 c2             	test   %rax,%rdx
  80416077f6:	0f 85 9f 01 00 00    	jne    804160799b <map_page+0x352>
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  80416077fc:	4d 89 ef             	mov    %r13,%r15
  80416077ff:	49 c1 ef 27          	shr    $0x27,%r15
  8041607803:	41 81 e7 ff 01 00 00 	and    $0x1ff,%r15d
    if (page->class >= 27) {
  804160780a:	66 83 fe 1a          	cmp    $0x1a,%si
  804160780e:	0f 87 bc 01 00 00    	ja     80416079d0 <map_page+0x387>
    if (!(spc->pml4[pml4i0] & PTE_P)) {
  8041607814:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8041607818:	48 8b 00             	mov    (%rax),%rax
  804160781b:	4a 8d 04 f8          	lea    (%rax,%r15,8),%rax
  804160781f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8041607823:	48 8b 00             	mov    (%rax),%rax
  8041607826:	a8 01                	test   $0x1,%al
  8041607828:	0f 84 a0 02 00 00    	je     8041607ace <map_page+0x485>
    assert(!(spc->pml4[pml4i0] & PTE_PS)); /* There's (yet) no support for 512GB pages in x86 arch */
  804160782e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8041607832:	48 8b 00             	mov    (%rax),%rax
  8041607835:	4a 8b 0c f8          	mov    (%rax,%r15,8),%rcx
  8041607839:	f6 c1 80             	test   $0x80,%cl
  804160783c:	0f 85 bd 03 00 00    	jne    8041607bff <map_page+0x5b6>
    pdpe_t *pdp = KADDR(PTE_ADDR(spc->pml4[pml4i0]));
  8041607842:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8041607849:	ff ff 7f 
  804160784c:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  804160784f:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041607856:	00 00 00 
  8041607859:	48 39 c1             	cmp    %rax,%rcx
  804160785c:	0f 87 d2 03 00 00    	ja     8041607c34 <map_page+0x5eb>
    return (void *)(pa + KERN_BASE_ADDR);
  8041607862:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8041607869:	00 00 00 
  804160786c:	48 8d 34 01          	lea    (%rcx,%rax,1),%rsi
    size_t pdpi0 = PDP_INDEX(addr), pdpi1 = PDP_INDEX(end);
  8041607870:	4c 89 e8             	mov    %r13,%rax
  8041607873:	48 c1 e8 1e          	shr    $0x1e,%rax
  8041607877:	25 ff 01 00 00       	and    $0x1ff,%eax
  804160787c:	4c 89 f2             	mov    %r14,%rdx
  804160787f:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8041607883:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    if (pdpi0 > pdpi1) pdpi1 = PDP_ENTRY_COUNT;
  8041607889:	48 39 d0             	cmp    %rdx,%rax
  804160788c:	0f 87 d8 0d 00 00    	ja     804160866a <map_page+0x1021>
    if (page->class >= 18) return alloc_fill_pt(pdp, base, 1 * GB, pdpi0, pdpi1);
  8041607892:	41 0f b7 7c 24 34    	movzwl 0x34(%r12),%edi
  8041607898:	66 81 e7 ff 0f       	and    $0xfff,%di
  804160789d:	66 83 ff 11          	cmp    $0x11,%di
  80416078a1:	0f 86 d4 0d 00 00    	jbe    804160867b <map_page+0x1032>
    assert(i0 != i1);
  80416078a7:	48 39 d0             	cmp    %rdx,%rax
  80416078aa:	0f 84 b2 03 00 00    	je     8041607c62 <map_page+0x619>
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  80416078b0:	80 cb 80             	or     $0x80,%bl
    for (size_t i = i0; i < i1; i++, base += step) {
  80416078b3:	48 39 d0             	cmp    %rdx,%rax
  80416078b6:	0f 82 35 0e 00 00    	jb     80416086f1 <map_page+0x10a8>
    if (page->class >= 18) return alloc_fill_pt(pdp, base, 1 * GB, pdpi0, pdpi1);
  80416078bc:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  80416078c2:	e9 cf 09 00 00       	jmp    8041608296 <map_page+0xc4d>
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  80416078c7:	48 b9 d8 25 61 41 80 	movabs $0x80416125d8,%rcx
  80416078ce:	00 00 00 
  80416078d1:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416078d8:	00 00 00 
  80416078db:	be b8 03 00 00       	mov    $0x3b8,%esi
  80416078e0:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416078e7:	00 00 00 
  80416078ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80416078ef:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416078f6:	00 00 00 
  80416078f9:	41 ff d0             	call   *%r8
    assert(page && spc);
  80416078fc:	48 b9 93 1d 61 41 80 	movabs $0x8041611d93,%rcx
  8041607903:	00 00 00 
  8041607906:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160790d:	00 00 00 
  8041607910:	be b9 03 00 00       	mov    $0x3b9,%esi
  8041607915:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160791c:	00 00 00 
  804160791f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607924:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160792b:	00 00 00 
  804160792e:	41 ff d0             	call   *%r8
    assert_physical(page);
  8041607931:	48 b9 b8 1e 61 41 80 	movabs $0x8041611eb8,%rcx
  8041607938:	00 00 00 
  804160793b:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607942:	00 00 00 
  8041607945:	be ba 03 00 00       	mov    $0x3ba,%esi
  804160794a:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607951:	00 00 00 
  8041607954:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607959:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607960:	00 00 00 
  8041607963:	41 ff d0             	call   *%r8
    assert(!(addr & CLASS_MASK(page->class)));
  8041607966:	48 b9 08 26 61 41 80 	movabs $0x8041612608,%rcx
  804160796d:	00 00 00 
  8041607970:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607977:	00 00 00 
  804160797a:	be bb 03 00 00       	mov    $0x3bb,%esi
  804160797f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607986:	00 00 00 
  8041607989:	b8 00 00 00 00       	mov    $0x0,%eax
  804160798e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607995:	00 00 00 
  8041607998:	41 ff d0             	call   *%r8
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  804160799b:	48 b9 d8 1f 61 41 80 	movabs $0x8041611fd8,%rcx
  80416079a2:	00 00 00 
  80416079a5:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416079ac:	00 00 00 
  80416079af:	be d4 03 00 00       	mov    $0x3d4,%esi
  80416079b4:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416079bb:	00 00 00 
  80416079be:	b8 00 00 00 00       	mov    $0x0,%eax
  80416079c3:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416079ca:	00 00 00 
  80416079cd:	41 ff d0             	call   *%r8
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  80416079d0:	49 c1 ee 27          	shr    $0x27,%r14
  80416079d4:	41 81 e6 ff 01 00 00 	and    $0x1ff,%r14d
        int res = alloc_fill_pt(spc->pml4, base, 512 * GB, pml4i0, pml4i1);
  80416079db:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80416079df:	48 8b 00             	mov    (%rax),%rax
    assert(i0 != i1);
  80416079e2:	4d 39 f7             	cmp    %r14,%r15
  80416079e5:	74 1d                	je     8041607a04 <map_page+0x3bb>
    return 0;
  80416079e7:	41 bd 00 00 00 00    	mov    $0x0,%r13d
    for (size_t i = i0; i < i1; i++, base += step) {
  80416079ed:	0f 83 b0 00 00 00    	jae    8041607aa3 <map_page+0x45a>
  80416079f3:	4e 8d 24 f8          	lea    (%rax,%r15,8),%r12
  80416079f7:	4e 8d 3c f0          	lea    (%rax,%r14,8),%r15
    if (pa > max_memory_map_addr)
  80416079fb:	4c 89 75 c0          	mov    %r14,-0x40(%rbp)
  80416079ff:	e9 18 09 00 00       	jmp    804160831c <map_page+0xcd3>
    assert(i0 != i1);
  8041607a04:	48 b9 4b 1d 61 41 80 	movabs $0x8041611d4b,%rcx
  8041607a0b:	00 00 00 
  8041607a0e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607a15:	00 00 00 
  8041607a18:	be 01 03 00 00       	mov    $0x301,%esi
  8041607a1d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607a24:	00 00 00 
  8041607a27:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607a2c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607a33:	00 00 00 
  8041607a36:	41 ff d0             	call   *%r8
        assert(!page->refc);
  8041607a39:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041607a40:	00 00 00 
  8041607a43:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607a4a:	00 00 00 
  8041607a4d:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041607a52:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607a59:	00 00 00 
  8041607a5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607a61:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607a68:	00 00 00 
  8041607a6b:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607a6e:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607a75:	00 00 00 
  8041607a78:	be db 02 00 00       	mov    $0x2db,%esi
  8041607a7d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607a84:	00 00 00 
  8041607a87:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607a8c:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607a93:	00 00 00 
  8041607a96:	41 ff d1             	call   *%r9
    return 0;
  8041607a99:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
  8041607a9d:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        if (pml4i1 - 1 >= NUSERPML4) propagate_pml4(spc);
  8041607aa3:	49 83 fe 01          	cmp    $0x1,%r14
  8041607aa7:	0f 84 e9 07 00 00    	je     8041608296 <map_page+0xc4d>
  8041607aad:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041607ab1:	48 b8 33 66 60 41 80 	movabs $0x8041606633,%rax
  8041607ab8:	00 00 00 
  8041607abb:	ff d0                	call   *%rax
  8041607abd:	e9 d4 07 00 00       	jmp    8041608296 <map_page+0xc4d>
        if (!page) return -E_NO_MEM;
  8041607ac2:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
  8041607ac6:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  8041607acc:	eb d5                	jmp    8041607aa3 <map_page+0x45a>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8041607ace:	25 81 00 00 00       	and    $0x81,%eax
  8041607ad3:	48 83 f8 01          	cmp    $0x1,%rax
  8041607ad7:	75 1e                	jne    8041607af7 <map_page+0x4ae>
        if (pml4i0 >= NUSERPML4) propagate_pml4(spc);
  8041607ad9:	4d 85 ff             	test   %r15,%r15
  8041607adc:	0f 84 4c fd ff ff    	je     804160782e <map_page+0x1e5>
  8041607ae2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041607ae6:	48 b8 33 66 60 41 80 	movabs $0x8041606633,%rax
  8041607aed:	00 00 00 
  8041607af0:	ff d0                	call   *%rax
  8041607af2:	e9 37 fd ff ff       	jmp    804160782e <map_page+0x1e5>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8041607af7:	be 00 00 04 00       	mov    $0x40000,%esi
  8041607afc:	bf 00 00 00 00       	mov    $0x0,%edi
  8041607b01:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  8041607b08:	00 00 00 
  8041607b0b:	ff d0                	call   *%rax
  8041607b0d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (!page) return -E_NO_MEM;
  8041607b11:	48 85 c0             	test   %rax,%rax
  8041607b14:	0f 84 96 07 00 00    	je     80416082b0 <map_page+0xc67>
        assert(!page->refc);
  8041607b1a:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041607b1e:	75 7c                	jne    8041607b9c <map_page+0x553>
        page_ref(page);
  8041607b20:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8041607b24:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  8041607b2b:	00 00 00 
  8041607b2e:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041607b30:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041607b37:	ff 0f 00 
  8041607b3a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8041607b3e:	48 89 d0             	mov    %rdx,%rax
  8041607b41:	48 23 47 38          	and    0x38(%rdi),%rax
  8041607b45:	48 c1 e0 0c          	shl    $0xc,%rax
  8041607b49:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8041607b4c:	48 83 c8 07          	or     $0x7,%rax
  8041607b50:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8041607b54:	48 89 06             	mov    %rax,(%rsi)
  8041607b57:	48 89 d1             	mov    %rdx,%rcx
  8041607b5a:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8041607b5e:	48 c1 e1 0c          	shl    $0xc,%rcx
  8041607b62:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8041607b65:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041607b6c:	00 00 00 
  8041607b6f:	48 39 c1             	cmp    %rax,%rcx
  8041607b72:	77 5d                	ja     8041607bd1 <map_page+0x588>
    return (void *)(pa + KERN_BASE_ADDR);
  8041607b74:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  8041607b7b:	00 00 00 
  8041607b7e:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8041607b81:	ba 00 10 00 00       	mov    $0x1000,%edx
  8041607b86:	be 00 00 00 00       	mov    $0x0,%esi
  8041607b8b:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041607b92:	00 00 00 
  8041607b95:	ff d0                	call   *%rax
  8041607b97:	e9 3d ff ff ff       	jmp    8041607ad9 <map_page+0x490>
        assert(!page->refc);
  8041607b9c:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041607ba3:	00 00 00 
  8041607ba6:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607bad:	00 00 00 
  8041607bb0:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041607bb5:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607bbc:	00 00 00 
  8041607bbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607bc4:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607bcb:	00 00 00 
  8041607bce:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607bd1:	49 89 c0             	mov    %rax,%r8
  8041607bd4:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607bdb:	00 00 00 
  8041607bde:	be db 02 00 00       	mov    $0x2db,%esi
  8041607be3:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607bea:	00 00 00 
  8041607bed:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607bf2:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607bf9:	00 00 00 
  8041607bfc:	41 ff d1             	call   *%r9
    assert(!(spc->pml4[pml4i0] & PTE_PS)); /* There's (yet) no support for 512GB pages in x86 arch */
  8041607bff:	48 b9 9f 1d 61 41 80 	movabs $0x8041611d9f,%rcx
  8041607c06:	00 00 00 
  8041607c09:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607c10:	00 00 00 
  8041607c13:	be e3 03 00 00       	mov    $0x3e3,%esi
  8041607c18:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607c1f:	00 00 00 
  8041607c22:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607c27:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607c2e:	00 00 00 
  8041607c31:	41 ff d0             	call   *%r8
  8041607c34:	49 89 c0             	mov    %rax,%r8
  8041607c37:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607c3e:	00 00 00 
  8041607c41:	be e4 03 00 00       	mov    $0x3e4,%esi
  8041607c46:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607c4d:	00 00 00 
  8041607c50:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607c55:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607c5c:	00 00 00 
  8041607c5f:	41 ff d1             	call   *%r9
    assert(i0 != i1);
  8041607c62:	48 b9 4b 1d 61 41 80 	movabs $0x8041611d4b,%rcx
  8041607c69:	00 00 00 
  8041607c6c:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607c73:	00 00 00 
  8041607c76:	be 01 03 00 00       	mov    $0x301,%esi
  8041607c7b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607c82:	00 00 00 
  8041607c85:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607c8a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607c91:	00 00 00 
  8041607c94:	41 ff d0             	call   *%r8
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8041607c97:	25 81 00 00 00       	and    $0x81,%eax
  8041607c9c:	48 83 f8 01          	cmp    $0x1,%rax
  8041607ca0:	0f 84 e4 09 00 00    	je     804160868a <map_page+0x1041>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8041607ca6:	be 00 00 04 00       	mov    $0x40000,%esi
  8041607cab:	bf 00 00 00 00       	mov    $0x0,%edi
  8041607cb0:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  8041607cb7:	00 00 00 
  8041607cba:	ff d0                	call   *%rax
  8041607cbc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        if (!page) return -E_NO_MEM;
  8041607cc0:	48 85 c0             	test   %rax,%rax
  8041607cc3:	0f 84 ef 05 00 00    	je     80416082b8 <map_page+0xc6f>
        assert(!page->refc);
  8041607cc9:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041607ccd:	75 78                	jne    8041607d47 <map_page+0x6fe>
        page_ref(page);
  8041607ccf:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041607cd3:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  8041607cda:	00 00 00 
  8041607cdd:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041607cdf:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041607ce6:	ff 0f 00 
  8041607ce9:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041607ced:	48 89 d0             	mov    %rdx,%rax
  8041607cf0:	48 23 47 38          	and    0x38(%rdi),%rax
  8041607cf4:	48 c1 e0 0c          	shl    $0xc,%rax
  8041607cf8:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8041607cfb:	48 83 c8 07          	or     $0x7,%rax
  8041607cff:	49 89 07             	mov    %rax,(%r15)
  8041607d02:	48 89 d1             	mov    %rdx,%rcx
  8041607d05:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8041607d09:	48 c1 e1 0c          	shl    $0xc,%rcx
  8041607d0d:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8041607d10:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041607d17:	00 00 00 
  8041607d1a:	48 39 c1             	cmp    %rax,%rcx
  8041607d1d:	77 5d                	ja     8041607d7c <map_page+0x733>
    return (void *)(pa + KERN_BASE_ADDR);
  8041607d1f:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  8041607d26:	00 00 00 
  8041607d29:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8041607d2c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8041607d31:	be 00 00 00 00       	mov    $0x0,%esi
  8041607d36:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041607d3d:	00 00 00 
  8041607d40:	ff d0                	call   *%rax
  8041607d42:	e9 43 09 00 00       	jmp    804160868a <map_page+0x1041>
        assert(!page->refc);
  8041607d47:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041607d4e:	00 00 00 
  8041607d51:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607d58:	00 00 00 
  8041607d5b:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041607d60:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607d67:	00 00 00 
  8041607d6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607d6f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607d76:	00 00 00 
  8041607d79:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607d7c:	49 89 c0             	mov    %rax,%r8
  8041607d7f:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607d86:	00 00 00 
  8041607d89:	be db 02 00 00       	mov    $0x2db,%esi
  8041607d8e:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607d95:	00 00 00 
  8041607d98:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607d9d:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607da4:	00 00 00 
  8041607da7:	41 ff d1             	call   *%r9
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8041607daa:	be 00 00 04 00       	mov    $0x40000,%esi
  8041607daf:	bf 00 00 00 00       	mov    $0x0,%edi
  8041607db4:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  8041607dbb:	00 00 00 
  8041607dbe:	ff d0                	call   *%rax
  8041607dc0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (!page) return -E_NO_MEM;
  8041607dc4:	48 85 c0             	test   %rax,%rax
  8041607dc7:	0f 84 f3 04 00 00    	je     80416082c0 <map_page+0xc77>
        assert(!page->refc);
  8041607dcd:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041607dd1:	75 78                	jne    8041607e4b <map_page+0x802>
        page_ref(page);
  8041607dd3:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8041607dd7:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  8041607dde:	00 00 00 
  8041607de1:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041607de3:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041607dea:	ff 0f 00 
  8041607ded:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8041607df1:	48 89 d0             	mov    %rdx,%rax
  8041607df4:	48 23 47 38          	and    0x38(%rdi),%rax
  8041607df8:	48 c1 e0 0c          	shl    $0xc,%rax
  8041607dfc:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8041607dff:	48 83 c8 07          	or     $0x7,%rax
  8041607e03:	49 89 07             	mov    %rax,(%r15)
  8041607e06:	48 89 d1             	mov    %rdx,%rcx
  8041607e09:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8041607e0d:	48 c1 e1 0c          	shl    $0xc,%rcx
  8041607e11:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8041607e14:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041607e1b:	00 00 00 
  8041607e1e:	48 39 c1             	cmp    %rax,%rcx
  8041607e21:	77 5d                	ja     8041607e80 <map_page+0x837>
    return (void *)(pa + KERN_BASE_ADDR);
  8041607e23:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  8041607e2a:	00 00 00 
  8041607e2d:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8041607e30:	ba 00 10 00 00       	mov    $0x1000,%edx
  8041607e35:	be 00 00 00 00       	mov    $0x0,%esi
  8041607e3a:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041607e41:	00 00 00 
  8041607e44:	ff d0                	call   *%rax
  8041607e46:	e9 5d 08 00 00       	jmp    80416086a8 <map_page+0x105f>
        assert(!page->refc);
  8041607e4b:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041607e52:	00 00 00 
  8041607e55:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607e5c:	00 00 00 
  8041607e5f:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041607e64:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607e6b:	00 00 00 
  8041607e6e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607e73:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607e7a:	00 00 00 
  8041607e7d:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607e80:	49 89 c0             	mov    %rax,%r8
  8041607e83:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607e8a:	00 00 00 
  8041607e8d:	be db 02 00 00       	mov    $0x2db,%esi
  8041607e92:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607e99:	00 00 00 
  8041607e9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607ea1:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607ea8:	00 00 00 
  8041607eab:	41 ff d1             	call   *%r9
  8041607eae:	49 89 c0             	mov    %rax,%r8
  8041607eb1:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607eb8:	00 00 00 
  8041607ebb:	be f4 03 00 00       	mov    $0x3f4,%esi
  8041607ec0:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607ec7:	00 00 00 
  8041607eca:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607ecf:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607ed6:	00 00 00 
  8041607ed9:	41 ff d1             	call   *%r9
    pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  8041607edc:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8041607ee3:	ff ff 7f 
  8041607ee6:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8041607ee9:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041607ef0:	00 00 00 
  8041607ef3:	48 39 c1             	cmp    %rax,%rcx
  8041607ef6:	77 60                	ja     8041607f58 <map_page+0x90f>
    return (void *)(pa + KERN_BASE_ADDR);
  8041607ef8:	48 be 00 00 00 40 80 	movabs $0x8040000000,%rsi
  8041607eff:	00 00 00 
  8041607f02:	48 01 ce             	add    %rcx,%rsi
    size_t pdi0 = PD_INDEX(addr), pdi1 = PD_INDEX(end);
  8041607f05:	4c 89 e8             	mov    %r13,%rax
  8041607f08:	48 c1 e8 15          	shr    $0x15,%rax
  8041607f0c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8041607f11:	4c 89 f2             	mov    %r14,%rdx
  8041607f14:	48 c1 ea 15          	shr    $0x15,%rdx
  8041607f18:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    if (pdi0 > pdi1) pdi1 = PD_ENTRY_COUNT;
  8041607f1e:	48 39 d0             	cmp    %rdx,%rax
  8041607f21:	0f 87 d1 05 00 00    	ja     80416084f8 <map_page+0xeaf>
    if (page->class >= 9) return alloc_fill_pt(pd, base, 2 * MB, pdi0, pdi1);
  8041607f27:	41 0f b7 7c 24 34    	movzwl 0x34(%r12),%edi
  8041607f2d:	66 81 e7 ff 0f       	and    $0xfff,%di
  8041607f32:	66 83 ff 08          	cmp    $0x8,%di
  8041607f36:	0f 86 d1 05 00 00    	jbe    804160850d <map_page+0xec4>
    assert(i0 != i1);
  8041607f3c:	48 39 d0             	cmp    %rdx,%rax
  8041607f3f:	74 45                	je     8041607f86 <map_page+0x93d>
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  8041607f41:	80 cb 80             	or     $0x80,%bl
    for (size_t i = i0; i < i1; i++, base += step) {
  8041607f44:	48 39 d0             	cmp    %rdx,%rax
  8041607f47:	0f 82 c6 07 00 00    	jb     8041608713 <map_page+0x10ca>
    if (page->class >= 9) return alloc_fill_pt(pd, base, 2 * MB, pdi0, pdi1);
  8041607f4d:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  8041607f53:	e9 3e 03 00 00       	jmp    8041608296 <map_page+0xc4d>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041607f58:	49 89 c0             	mov    %rax,%r8
  8041607f5b:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041607f62:	00 00 00 
  8041607f65:	be f8 03 00 00       	mov    $0x3f8,%esi
  8041607f6a:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607f71:	00 00 00 
  8041607f74:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607f79:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041607f80:	00 00 00 
  8041607f83:	41 ff d1             	call   *%r9
    assert(i0 != i1);
  8041607f86:	48 b9 4b 1d 61 41 80 	movabs $0x8041611d4b,%rcx
  8041607f8d:	00 00 00 
  8041607f90:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041607f97:	00 00 00 
  8041607f9a:	be 01 03 00 00       	mov    $0x301,%esi
  8041607f9f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041607fa6:	00 00 00 
  8041607fa9:	b8 00 00 00 00       	mov    $0x0,%eax
  8041607fae:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041607fb5:	00 00 00 
  8041607fb8:	41 ff d0             	call   *%r8
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8041607fbb:	25 81 00 00 00       	and    $0x81,%eax
  8041607fc0:	48 83 f8 01          	cmp    $0x1,%rax
  8041607fc4:	0f 84 52 05 00 00    	je     804160851c <map_page+0xed3>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8041607fca:	be 00 00 04 00       	mov    $0x40000,%esi
  8041607fcf:	bf 00 00 00 00       	mov    $0x0,%edi
  8041607fd4:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  8041607fdb:	00 00 00 
  8041607fde:	ff d0                	call   *%rax
  8041607fe0:	49 89 c4             	mov    %rax,%r12
        if (!page) return -E_NO_MEM;
  8041607fe3:	48 85 c0             	test   %rax,%rax
  8041607fe6:	0f 84 dc 02 00 00    	je     80416082c8 <map_page+0xc7f>
        assert(!page->refc);
  8041607fec:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041607ff0:	75 75                	jne    8041608067 <map_page+0xa1e>
        page_ref(page);
  8041607ff2:	48 89 c7             	mov    %rax,%rdi
  8041607ff5:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  8041607ffc:	00 00 00 
  8041607fff:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041608001:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041608008:	ff 0f 00 
  804160800b:	48 89 d0             	mov    %rdx,%rax
  804160800e:	49 23 44 24 38       	and    0x38(%r12),%rax
  8041608013:	48 c1 e0 0c          	shl    $0xc,%rax
  8041608017:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  804160801a:	48 83 c8 07          	or     $0x7,%rax
  804160801e:	49 89 07             	mov    %rax,(%r15)
  8041608021:	48 89 d1             	mov    %rdx,%rcx
  8041608024:	49 23 4c 24 38       	and    0x38(%r12),%rcx
  8041608029:	48 c1 e1 0c          	shl    $0xc,%rcx
  804160802d:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8041608030:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041608037:	00 00 00 
  804160803a:	48 39 c1             	cmp    %rax,%rcx
  804160803d:	77 5d                	ja     804160809c <map_page+0xa53>
    return (void *)(pa + KERN_BASE_ADDR);
  804160803f:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  8041608046:	00 00 00 
  8041608049:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  804160804c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8041608051:	be 00 00 00 00       	mov    $0x0,%esi
  8041608056:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160805d:	00 00 00 
  8041608060:	ff d0                	call   *%rax
  8041608062:	e9 b5 04 00 00       	jmp    804160851c <map_page+0xed3>
        assert(!page->refc);
  8041608067:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  804160806e:	00 00 00 
  8041608071:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041608078:	00 00 00 
  804160807b:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041608080:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608087:	00 00 00 
  804160808a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160808f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041608096:	00 00 00 
  8041608099:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804160809c:	49 89 c0             	mov    %rax,%r8
  804160809f:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  80416080a6:	00 00 00 
  80416080a9:	be db 02 00 00       	mov    $0x2db,%esi
  80416080ae:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416080b5:	00 00 00 
  80416080b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80416080bd:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  80416080c4:	00 00 00 
  80416080c7:	41 ff d1             	call   *%r9
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  80416080ca:	be 00 00 04 00       	mov    $0x40000,%esi
  80416080cf:	bf 00 00 00 00       	mov    $0x0,%edi
  80416080d4:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  80416080db:	00 00 00 
  80416080de:	ff d0                	call   *%rax
  80416080e0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        if (!page) return -E_NO_MEM;
  80416080e4:	48 85 c0             	test   %rax,%rax
  80416080e7:	0f 84 e3 01 00 00    	je     80416082d0 <map_page+0xc87>
        assert(!page->refc);
  80416080ed:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  80416080f1:	75 78                	jne    804160816b <map_page+0xb22>
        page_ref(page);
  80416080f3:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  80416080f7:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  80416080fe:	00 00 00 
  8041608101:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041608103:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  804160810a:	ff 0f 00 
  804160810d:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041608111:	48 89 d0             	mov    %rdx,%rax
  8041608114:	48 23 47 38          	and    0x38(%rdi),%rax
  8041608118:	48 c1 e0 0c          	shl    $0xc,%rax
  804160811c:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  804160811f:	48 83 c8 07          	or     $0x7,%rax
  8041608123:	49 89 07             	mov    %rax,(%r15)
  8041608126:	48 89 d1             	mov    %rdx,%rcx
  8041608129:	48 23 4f 38          	and    0x38(%rdi),%rcx
  804160812d:	48 c1 e1 0c          	shl    $0xc,%rcx
  8041608131:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8041608134:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160813b:	00 00 00 
  804160813e:	48 39 c1             	cmp    %rax,%rcx
  8041608141:	77 5d                	ja     80416081a0 <map_page+0xb57>
    return (void *)(pa + KERN_BASE_ADDR);
  8041608143:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  804160814a:	00 00 00 
  804160814d:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8041608150:	ba 00 10 00 00       	mov    $0x1000,%edx
  8041608155:	be 00 00 00 00       	mov    $0x0,%esi
  804160815a:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041608161:	00 00 00 
  8041608164:	ff d0                	call   *%rax
  8041608166:	e9 cc 03 00 00       	jmp    8041608537 <map_page+0xeee>
        assert(!page->refc);
  804160816b:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  8041608172:	00 00 00 
  8041608175:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160817c:	00 00 00 
  804160817f:	be d4 02 00 00       	mov    $0x2d4,%esi
  8041608184:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160818b:	00 00 00 
  804160818e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608193:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160819a:	00 00 00 
  804160819d:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  80416081a0:	49 89 c0             	mov    %rax,%r8
  80416081a3:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  80416081aa:	00 00 00 
  80416081ad:	be db 02 00 00       	mov    $0x2db,%esi
  80416081b2:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416081b9:	00 00 00 
  80416081bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80416081c1:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  80416081c8:	00 00 00 
  80416081cb:	41 ff d1             	call   *%r9
  80416081ce:	49 89 c0             	mov    %rax,%r8
  80416081d1:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  80416081d8:	00 00 00 
  80416081db:	be 10 04 00 00       	mov    $0x410,%esi
  80416081e0:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416081e7:	00 00 00 
  80416081ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80416081ef:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  80416081f6:	00 00 00 
  80416081f9:	41 ff d1             	call   *%r9
  80416081fc:	49 89 c0             	mov    %rax,%r8
  80416081ff:	48 89 d1             	mov    %rdx,%rcx
  8041608202:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041608209:	00 00 00 
  804160820c:	be 13 04 00 00       	mov    $0x413,%esi
  8041608211:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608218:	00 00 00 
  804160821b:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608220:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041608227:	00 00 00 
  804160822a:	41 ff d1             	call   *%r9
    assert(i0 != i1);
  804160822d:	48 b9 4b 1d 61 41 80 	movabs $0x8041611d4b,%rcx
  8041608234:	00 00 00 
  8041608237:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160823e:	00 00 00 
  8041608241:	be 01 03 00 00       	mov    $0x301,%esi
  8041608246:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160824d:	00 00 00 
  8041608250:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608255:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160825c:	00 00 00 
  804160825f:	41 ff d0             	call   *%r8
    if (pti0 > pti1) pti1 = PT_ENTRY_COUNT;
  8041608262:	41 be 00 02 00 00    	mov    $0x200,%r14d
  8041608268:	48 b9 00 00 00 40 80 	movabs $0x8040000000,%rcx
  804160826f:	00 00 00 
  8041608272:	4a 8d 0c e9          	lea    (%rcx,%r13,8),%rcx
  8041608276:	48 01 d1             	add    %rdx,%rcx
  8041608279:	4a 8d 04 f0          	lea    (%rax,%r14,8),%rax
            dst[i] = base;
  804160827d:	48 89 19             	mov    %rbx,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8041608280:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
  8041608287:	48 83 c1 08          	add    $0x8,%rcx
  804160828b:	48 39 c8             	cmp    %rcx,%rax
  804160828e:	75 ed                	jne    804160827d <map_page+0xc34>
    if (page->class >= 0) return alloc_fill_pt(pt, base, 4 * KB, pti0, pti1);
  8041608290:	41 bd 00 00 00 00    	mov    $0x0,%r13d
}
  8041608296:	44 89 e8             	mov    %r13d,%eax
  8041608299:	48 83 c4 28          	add    $0x28,%rsp
  804160829d:	5b                   	pop    %rbx
  804160829e:	41 5c                	pop    %r12
  80416082a0:	41 5d                	pop    %r13
  80416082a2:	41 5e                	pop    %r14
  80416082a4:	41 5f                	pop    %r15
  80416082a6:	5d                   	pop    %rbp
  80416082a7:	c3                   	ret    
        if (!mapping) return -E_NO_MEM;
  80416082a8:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80416082ae:	eb e6                	jmp    8041608296 <map_page+0xc4d>
        if (alloc_pt(spc->pml4 + pml4i0) < 0) return -E_NO_MEM;
  80416082b0:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80416082b6:	eb de                	jmp    8041608296 <map_page+0xc4d>
    if (!(pdp[pdpi0] & PTE_P) && alloc_pt(pdp + pdpi0) < 0) return -E_NO_MEM;
  80416082b8:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80416082be:	eb d6                	jmp    8041608296 <map_page+0xc4d>
        if (alloc_pt(pdp + pdpi0) < 0) return -E_NO_MEM;
  80416082c0:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80416082c6:	eb ce                	jmp    8041608296 <map_page+0xc4d>
    if (!(pd[pdi0] & PTE_P) && alloc_pt(pd + pdi0) < 0) return -E_NO_MEM;
  80416082c8:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80416082ce:	eb c6                	jmp    8041608296 <map_page+0xc4d>
        if (alloc_pt(pd + pdi0) < 0) return -E_NO_MEM;
  80416082d0:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80416082d6:	eb be                	jmp    8041608296 <map_page+0xc4d>
            res = alloc_fill_pt(dst + i, base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  80416082d8:	41 b8 00 02 00 00    	mov    $0x200,%r8d
  80416082de:	b9 00 00 00 00       	mov    $0x0,%ecx
  80416082e3:	ba 00 00 00 40       	mov    $0x40000000,%edx
  80416082e8:	48 89 de             	mov    %rbx,%rsi
  80416082eb:	4c 89 f7             	mov    %r14,%rdi
  80416082ee:	48 b8 7f 62 60 41 80 	movabs $0x804160627f,%rax
  80416082f5:	00 00 00 
  80416082f8:	ff d0                	call   *%rax
            if (res < 0) return res;
  80416082fa:	85 c0                	test   %eax,%eax
  80416082fc:	0f 88 da 00 00 00    	js     80416083dc <map_page+0xd93>
    for (size_t i = i0; i < i1; i++, base += step) {
  8041608302:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  8041608309:	00 00 00 
  804160830c:	48 01 c3             	add    %rax,%rbx
  804160830f:	49 83 c4 08          	add    $0x8,%r12
  8041608313:	4d 39 fc             	cmp    %r15,%r12
  8041608316:	0f 84 7d f7 ff ff    	je     8041607a99 <map_page+0x450>
            int res = alloc_pt(dst + i);
  804160831c:	4d 89 e6             	mov    %r12,%r14
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  804160831f:	49 8b 04 24          	mov    (%r12),%rax
  8041608323:	25 81 00 00 00       	and    $0x81,%eax
  8041608328:	48 83 f8 01          	cmp    $0x1,%rax
  804160832c:	74 aa                	je     80416082d8 <map_page+0xc8f>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  804160832e:	be 00 00 04 00       	mov    $0x40000,%esi
  8041608333:	bf 00 00 00 00       	mov    $0x0,%edi
  8041608338:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  804160833f:	00 00 00 
  8041608342:	ff d0                	call   *%rax
  8041608344:	49 89 c5             	mov    %rax,%r13
        if (!page) return -E_NO_MEM;
  8041608347:	48 85 c0             	test   %rax,%rax
  804160834a:	0f 84 72 f7 ff ff    	je     8041607ac2 <map_page+0x479>
        assert(!page->refc);
  8041608350:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8041608354:	0f 85 df f6 ff ff    	jne    8041607a39 <map_page+0x3f0>
        page_ref(page);
  804160835a:	48 89 c7             	mov    %rax,%rdi
  804160835d:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  8041608364:	00 00 00 
  8041608367:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8041608369:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8041608370:	ff 0f 00 
  8041608373:	49 23 45 38          	and    0x38(%r13),%rax
  8041608377:	48 c1 e0 0c          	shl    $0xc,%rax
  804160837b:	48 bf ff ff ff ff ff 	movabs $0xfffffffffffff,%rdi
  8041608382:	ff 0f 00 
  8041608385:	48 21 f8             	and    %rdi,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8041608388:	48 83 c8 07          	or     $0x7,%rax
  804160838c:	49 89 04 24          	mov    %rax,(%r12)
  8041608390:	48 89 f9             	mov    %rdi,%rcx
  8041608393:	49 23 4d 38          	and    0x38(%r13),%rcx
  8041608397:	48 c1 e1 0c          	shl    $0xc,%rcx
  804160839b:	48 21 f9             	and    %rdi,%rcx
    if (pa > max_memory_map_addr)
  804160839e:	48 b8 c8 00 40 42 80 	movabs $0x80424000c8,%rax
  80416083a5:	00 00 00 
  80416083a8:	4c 8b 00             	mov    (%rax),%r8
  80416083ab:	4c 39 c1             	cmp    %r8,%rcx
  80416083ae:	0f 87 ba f6 ff ff    	ja     8041607a6e <map_page+0x425>
    return (void *)(pa + KERN_BASE_ADDR);
  80416083b4:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  80416083bb:	00 00 00 
  80416083be:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  80416083c1:	ba 00 10 00 00       	mov    $0x1000,%edx
  80416083c6:	be 00 00 00 00       	mov    $0x0,%esi
  80416083cb:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  80416083d2:	00 00 00 
  80416083d5:	ff d0                	call   *%rax
  80416083d7:	e9 fc fe ff ff       	jmp    80416082d8 <map_page+0xc8f>
  80416083dc:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
  80416083e0:	41 89 c5             	mov    %eax,%r13d
  80416083e3:	e9 bb f6 ff ff       	jmp    8041607aa3 <map_page+0x45a>
            dst[i] = base;
  80416083e8:	48 89 19             	mov    %rbx,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  80416083eb:	48 81 c3 00 00 00 40 	add    $0x40000000,%rbx
  80416083f2:	48 83 c1 08          	add    $0x8,%rcx
  80416083f6:	48 39 c1             	cmp    %rax,%rcx
  80416083f9:	74 6a                	je     8041608465 <map_page+0xe1c>
            if ((PTE_ADDR(base) & (step - 1))) cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  80416083fb:	f7 c3 00 f0 ff 3f    	test   $0x3ffff000,%ebx
  8041608401:	74 e5                	je     80416083e8 <map_page+0xd9f>
  8041608403:	48 be 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rsi
  804160840a:	ff ff 7f 
  804160840d:	48 21 de             	and    %rbx,%rsi
  8041608410:	ba 00 00 00 40       	mov    $0x40000000,%edx
  8041608415:	48 bf 60 1d 61 41 80 	movabs $0x8041611d60,%rdi
  804160841c:	00 00 00 
  804160841f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608424:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  804160842b:	00 00 00 
  804160842e:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  8041608430:	48 b9 78 24 61 41 80 	movabs $0x8041612478,%rcx
  8041608437:	00 00 00 
  804160843a:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041608441:	00 00 00 
  8041608444:	be 0f 03 00 00       	mov    $0x30f,%esi
  8041608449:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608450:	00 00 00 
  8041608453:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608458:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160845f:	00 00 00 
  8041608462:	41 ff d0             	call   *%r8
    if (page->class >= 18) return alloc_fill_pt(pdp, base, 1 * GB, pdpi0, pdpi1);
  8041608465:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  804160846b:	e9 26 fe ff ff       	jmp    8041608296 <map_page+0xc4d>
            dst[i] = base;
  8041608470:	48 89 19             	mov    %rbx,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8041608473:	48 81 c3 00 00 20 00 	add    $0x200000,%rbx
  804160847a:	48 83 c1 08          	add    $0x8,%rcx
  804160847e:	48 39 c1             	cmp    %rax,%rcx
  8041608481:	74 6a                	je     80416084ed <map_page+0xea4>
            if ((PTE_ADDR(base) & (step - 1))) cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  8041608483:	f7 c3 00 f0 1f 00    	test   $0x1ff000,%ebx
  8041608489:	74 e5                	je     8041608470 <map_page+0xe27>
  804160848b:	48 be 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rsi
  8041608492:	ff ff 7f 
  8041608495:	48 21 de             	and    %rbx,%rsi
  8041608498:	ba 00 00 20 00       	mov    $0x200000,%edx
  804160849d:	48 bf 60 1d 61 41 80 	movabs $0x8041611d60,%rdi
  80416084a4:	00 00 00 
  80416084a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80416084ac:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  80416084b3:	00 00 00 
  80416084b6:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  80416084b8:	48 b9 78 24 61 41 80 	movabs $0x8041612478,%rcx
  80416084bf:	00 00 00 
  80416084c2:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416084c9:	00 00 00 
  80416084cc:	be 0f 03 00 00       	mov    $0x30f,%esi
  80416084d1:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416084d8:	00 00 00 
  80416084db:	b8 00 00 00 00       	mov    $0x0,%eax
  80416084e0:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416084e7:	00 00 00 
  80416084ea:	41 ff d0             	call   *%r8
    if (page->class >= 9) return alloc_fill_pt(pd, base, 2 * MB, pdi0, pdi1);
  80416084ed:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  80416084f3:	e9 9e fd ff ff       	jmp    8041608296 <map_page+0xc4d>
  80416084f8:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  80416084fe:	66 81 e2 ff 0f       	and    $0xfff,%dx
  8041608503:	66 83 fa 08          	cmp    $0x8,%dx
  8041608507:	0f 87 fe 01 00 00    	ja     804160870b <map_page+0x10c2>
    if (!(pd[pdi0] & PTE_P) && alloc_pt(pd + pdi0) < 0) return -E_NO_MEM;
  804160850d:	4c 8d 3c c6          	lea    (%rsi,%rax,8),%r15
  8041608511:	49 8b 07             	mov    (%r15),%rax
  8041608514:	a8 01                	test   $0x1,%al
  8041608516:	0f 84 9f fa ff ff    	je     8041607fbb <map_page+0x972>
    else if (pd[pdi0] & PTE_PS) {
  804160851c:	4d 8b 27             	mov    (%r15),%r12
  804160851f:	41 f6 c4 80          	test   $0x80,%r12b
  8041608523:	74 5e                	je     8041608583 <map_page+0xf3a>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8041608525:	4c 89 e0             	mov    %r12,%rax
  8041608528:	25 81 00 00 00       	and    $0x81,%eax
  804160852d:	48 83 f8 01          	cmp    $0x1,%rax
  8041608531:	0f 85 93 fb ff ff    	jne    80416080ca <map_page+0xa81>
        pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  8041608537:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  804160853e:	ff ff 7f 
  8041608541:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8041608544:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160854b:	00 00 00 
  804160854e:	48 39 c1             	cmp    %rax,%rcx
  8041608551:	0f 87 77 fc ff ff    	ja     80416081ce <map_page+0xb85>
    return (void *)(pa + KERN_BASE_ADDR);
  8041608557:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804160855e:	00 00 00 
  8041608561:	48 01 c1             	add    %rax,%rcx
        if (alloc_fill_pt(pt, old & ~PTE_PS, 4 * KB, 0, PT_ENTRY_COUNT) < 0) return -E_NO_MEM;
  8041608564:	41 80 e4 7f          	and    $0x7f,%r12b
    for (size_t i = i0; i < i1; i++, base += step) {
  8041608568:	49 8d 84 24 00 00 20 	lea    0x200000(%r12),%rax
  804160856f:	00 
            dst[i] = base;
  8041608570:	4c 89 21             	mov    %r12,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8041608573:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
  804160857a:	48 83 c1 08          	add    $0x8,%rcx
  804160857e:	4c 39 e0             	cmp    %r12,%rax
  8041608581:	75 ed                	jne    8041608570 <map_page+0xf27>
    pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  8041608583:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  804160858a:	ff ff 7f 
  804160858d:	48 89 ca             	mov    %rcx,%rdx
  8041608590:	49 23 17             	and    (%r15),%rdx
    if (pa > max_memory_map_addr)
  8041608593:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160859a:	00 00 00 
  804160859d:	48 39 c2             	cmp    %rax,%rdx
  80416085a0:	0f 87 56 fc ff ff    	ja     80416081fc <map_page+0xbb3>
    return (void *)(pa + KERN_BASE_ADDR);
  80416085a6:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80416085ad:	00 00 00 
  80416085b0:	48 01 d0             	add    %rdx,%rax
    size_t pti0 = PT_INDEX(addr), pti1 = PT_INDEX(end);
  80416085b3:	49 c1 ed 0c          	shr    $0xc,%r13
  80416085b7:	41 81 e5 ff 01 00 00 	and    $0x1ff,%r13d
  80416085be:	49 c1 ee 0c          	shr    $0xc,%r14
  80416085c2:	41 81 e6 ff 01 00 00 	and    $0x1ff,%r14d
    if (pti0 > pti1) pti1 = PT_ENTRY_COUNT;
  80416085c9:	4d 39 f5             	cmp    %r14,%r13
  80416085cc:	0f 87 90 fc ff ff    	ja     8041608262 <map_page+0xc19>
    assert(i0 != i1);
  80416085d2:	0f 84 55 fc ff ff    	je     804160822d <map_page+0xbe4>
    for (size_t i = i0; i < i1; i++, base += step) {
  80416085d8:	0f 82 8a fc ff ff    	jb     8041608268 <map_page+0xc1f>
    if (page->class >= 0) return alloc_fill_pt(pt, base, 4 * KB, pti0, pti1);
  80416085de:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  80416085e4:	e9 ad fc ff ff       	jmp    8041608296 <map_page+0xc4d>
            dst[i] = base;
  80416085e9:	48 89 31             	mov    %rsi,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  80416085ec:	48 81 c6 00 00 20 00 	add    $0x200000,%rsi
  80416085f3:	48 83 c1 08          	add    $0x8,%rcx
  80416085f7:	48 39 c6             	cmp    %rax,%rsi
  80416085fa:	0f 84 dc f8 ff ff    	je     8041607edc <map_page+0x893>
            if ((PTE_ADDR(base) & (step - 1))) cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  8041608600:	f7 c6 00 f0 1f 00    	test   $0x1ff000,%esi
  8041608606:	74 e1                	je     80416085e9 <map_page+0xfa0>
  8041608608:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  804160860f:	ff ff 7f 
  8041608612:	48 21 c6             	and    %rax,%rsi
  8041608615:	ba 00 00 20 00       	mov    $0x200000,%edx
  804160861a:	48 bf 60 1d 61 41 80 	movabs $0x8041611d60,%rdi
  8041608621:	00 00 00 
  8041608624:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608629:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  8041608630:	00 00 00 
  8041608633:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  8041608635:	48 b9 78 24 61 41 80 	movabs $0x8041612478,%rcx
  804160863c:	00 00 00 
  804160863f:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041608646:	00 00 00 
  8041608649:	be 0f 03 00 00       	mov    $0x30f,%esi
  804160864e:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608655:	00 00 00 
  8041608658:	b8 00 00 00 00       	mov    $0x0,%eax
  804160865d:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041608664:	00 00 00 
  8041608667:	41 ff d0             	call   *%r8
    if (page->class >= 18) return alloc_fill_pt(pdp, base, 1 * GB, pdpi0, pdpi1);
  804160866a:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  8041608670:	66 81 e2 ff 0f       	and    $0xfff,%dx
  8041608675:	66 83 fa 11          	cmp    $0x11,%dx
  8041608679:	77 6e                	ja     80416086e9 <map_page+0x10a0>
    if (!(pdp[pdpi0] & PTE_P) && alloc_pt(pdp + pdpi0) < 0) return -E_NO_MEM;
  804160867b:	4c 8d 3c c6          	lea    (%rsi,%rax,8),%r15
  804160867f:	49 8b 07             	mov    (%r15),%rax
  8041608682:	a8 01                	test   $0x1,%al
  8041608684:	0f 84 0d f6 ff ff    	je     8041607c97 <map_page+0x64e>
    else if (pdp[pdpi0] & PTE_PS) {
  804160868a:	49 8b 07             	mov    (%r15),%rax
  804160868d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8041608691:	a8 80                	test   $0x80,%al
  8041608693:	0f 84 43 f8 ff ff    	je     8041607edc <map_page+0x893>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8041608699:	25 81 00 00 00       	and    $0x81,%eax
  804160869e:	48 83 f8 01          	cmp    $0x1,%rax
  80416086a2:	0f 85 02 f7 ff ff    	jne    8041607daa <map_page+0x761>
        pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  80416086a8:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  80416086af:	ff ff 7f 
  80416086b2:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  80416086b5:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  80416086bc:	00 00 00 
  80416086bf:	48 39 c1             	cmp    %rax,%rcx
  80416086c2:	0f 87 e6 f7 ff ff    	ja     8041607eae <map_page+0x865>
    return (void *)(pa + KERN_BASE_ADDR);
  80416086c8:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80416086cf:	00 00 00 
  80416086d2:	48 01 c1             	add    %rax,%rcx
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  80416086d5:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80416086d9:	40 80 ce 80          	or     $0x80,%sil
    for (size_t i = i0; i < i1; i++, base += step) {
  80416086dd:	48 8d 86 00 00 00 40 	lea    0x40000000(%rsi),%rax
  80416086e4:	e9 17 ff ff ff       	jmp    8041608600 <map_page+0xfb7>
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  80416086e9:	80 cb 80             	or     $0x80,%bl
    if (pdpi0 > pdpi1) pdpi1 = PDP_ENTRY_COUNT;
  80416086ec:	ba 00 02 00 00       	mov    $0x200,%edx
  80416086f1:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  80416086f8:	00 00 00 
  80416086fb:	48 8d 04 c7          	lea    (%rdi,%rax,8),%rax
  80416086ff:	48 01 c1             	add    %rax,%rcx
  8041608702:	48 8d 04 d6          	lea    (%rsi,%rdx,8),%rax
  8041608706:	e9 f0 fc ff ff       	jmp    80416083fb <map_page+0xdb2>
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  804160870b:	80 cb 80             	or     $0x80,%bl
    if (pdi0 > pdi1) pdi1 = PD_ENTRY_COUNT;
  804160870e:	ba 00 02 00 00       	mov    $0x200,%edx
  8041608713:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  804160871a:	00 00 00 
  804160871d:	48 8d 04 c7          	lea    (%rdi,%rax,8),%rax
  8041608721:	48 01 c1             	add    %rax,%rcx
  8041608724:	48 8d 04 d6          	lea    (%rsi,%rdx,8),%rax
  8041608728:	e9 56 fd ff ff       	jmp    8041608483 <map_page+0xe3a>

000000804160872d <map_physical_region>:
    return res;
}


static int
map_physical_region(struct AddressSpace *dst, uintptr_t dstart, uintptr_t pstart, size_t size, int flags) {
  804160872d:	55                   	push   %rbp
  804160872e:	48 89 e5             	mov    %rsp,%rbp
  8041608731:	41 57                	push   %r15
  8041608733:	41 56                	push   %r14
  8041608735:	41 55                	push   %r13
  8041608737:	41 54                	push   %r12
  8041608739:	53                   	push   %rbx
  804160873a:	48 83 ec 38          	sub    $0x38,%rsp
  804160873e:	49 89 fd             	mov    %rdi,%r13
  8041608741:	44 89 45 c4          	mov    %r8d,-0x3c(%rbp)
    if (trace_memory) cprintf("Mapping physical region [%08lX, %08lX] to [%08lX, %08lX] (flags=%x)\n",
                              pstart, pstart + (long)size - 1, dstart, dstart + (long)size - 1, flags);
    assert(dstart > MAX_USER_ADDRESS || dst == &kspace);
  8041608745:	48 b8 b0 00 40 42 80 	movabs $0x80424000b0,%rax
  804160874c:	00 00 00 
  804160874f:	48 39 c7             	cmp    %rax,%rdi
  8041608752:	74 13                	je     8041608767 <map_physical_region+0x3a>
  8041608754:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  804160875b:	00 00 00 
  804160875e:	48 39 c6             	cmp    %rax,%rsi
  8041608761:	0f 86 92 00 00 00    	jbe    80416087f9 <map_physical_region+0xcc>

    int class = 0, res;

    uintptr_t start = ROUNDDOWN(dstart, CLASS_SIZE(0));
  8041608767:	49 89 f6             	mov    %rsi,%r14
  804160876a:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
    uintptr_t end = ROUNDUP(dstart + size, CLASS_SIZE(0));
  8041608771:	48 8d 84 0e ff 0f 00 	lea    0xfff(%rsi,%rcx,1),%rax
  8041608778:	00 
  8041608779:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804160877f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    pstart = ROUNDDOWN(pstart, CLASS_SIZE(0));
  8041608783:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  804160878a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    assert(!((addr1 | addr2) & CLASS_MASK(0)));
  804160878e:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
  8041608794:	0f 85 94 00 00 00    	jne    804160882e <map_physical_region+0x101>
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  804160879a:	48 31 d6             	xor    %rdx,%rsi
    int res = 0;
  804160879d:	b8 00 00 00 00       	mov    $0x0,%eax
    int class = 0, res;
  80416087a2:	41 bf 00 00 00 00    	mov    $0x0,%r15d
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  80416087a8:	f7 c6 00 10 00 00    	test   $0x1000,%esi
  80416087ae:	0f 85 77 01 00 00    	jne    804160892b <map_physical_region+0x1fe>
  80416087b4:	89 c2                	mov    %eax,%edx
  80416087b6:	83 c0 01             	add    $0x1,%eax
  80416087b9:	8d 4a 0d             	lea    0xd(%rdx),%ecx
  80416087bc:	48 0f a3 ce          	bt     %rcx,%rsi
  80416087c0:	72 05                	jb     80416087c7 <map_physical_region+0x9a>
  80416087c2:	83 f8 2f             	cmp    $0x2f,%eax
  80416087c5:	7e ed                	jle    80416087b4 <map_physical_region+0x87>
        platform_asan_unpoison((void *)start, size);
    }
#endif

    int max_class = addr_common_class(dstart, pstart);
    for (; class < max_class && start + CLASS_SIZE(class) <= end; class ++) {
  80416087c7:	85 c0                	test   %eax,%eax
  80416087c9:	0f 8e b0 01 00 00    	jle    804160897f <map_physical_region+0x252>
  80416087cf:	4d 8d a6 00 10 00 00 	lea    0x1000(%r14),%r12
  80416087d6:	4c 39 65 c8          	cmp    %r12,-0x38(%rbp)
  80416087da:	0f 82 a7 01 00 00    	jb     8041608987 <map_physical_region+0x25a>
  80416087e0:	b8 00 10 00 00       	mov    $0x1000,%eax
    int class = 0, res;
  80416087e5:	bb 00 00 00 00       	mov    $0x0,%ebx
  80416087ea:	41 89 d7             	mov    %edx,%r15d
  80416087ed:	4c 89 6d b0          	mov    %r13,-0x50(%rbp)
  80416087f1:	49 89 c5             	mov    %rax,%r13
  80416087f4:	e9 cb 00 00 00       	jmp    80416088c4 <map_physical_region+0x197>
    assert(dstart > MAX_USER_ADDRESS || dst == &kspace);
  80416087f9:	48 b9 30 26 61 41 80 	movabs $0x8041612630,%rcx
  8041608800:	00 00 00 
  8041608803:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160880a:	00 00 00 
  804160880d:	be 97 04 00 00       	mov    $0x497,%esi
  8041608812:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608819:	00 00 00 
  804160881c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608821:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041608828:	00 00 00 
  804160882b:	41 ff d0             	call   *%r8
    assert(!((addr1 | addr2) & CLASS_MASK(0)));
  804160882e:	48 b9 60 26 61 41 80 	movabs $0x8041612660,%rcx
  8041608835:	00 00 00 
  8041608838:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160883f:	00 00 00 
  8041608842:	be 8c 04 00 00       	mov    $0x48c,%esi
  8041608847:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160884e:	00 00 00 
  8041608851:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608856:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160885d:	00 00 00 
  8041608860:	41 ff d0             	call   *%r8
        if (start & CLASS_SIZE(class)) {
            struct Page *page = page_lookup(NULL, pstart, class, PARTIAL_NODE, 1);
            assert(page);
  8041608863:	48 b9 66 1c 61 41 80 	movabs $0x8041611c66,%rcx
  804160886a:	00 00 00 
  804160886d:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041608874:	00 00 00 
  8041608877:	be aa 04 00 00       	mov    $0x4aa,%esi
  804160887c:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608883:	00 00 00 
  8041608886:	b8 00 00 00 00       	mov    $0x0,%eax
  804160888b:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041608892:	00 00 00 
  8041608895:	41 ff d0             	call   *%r8
            if ((res = map_page(dst, start, page, flags)) < 0) return res;
            start += CLASS_SIZE(class);
            pstart += CLASS_SIZE(class);
  8041608898:	4c 01 6d b8          	add    %r13,-0x48(%rbp)
  804160889c:	4d 89 e6             	mov    %r12,%r14
    for (; class < max_class && start + CLASS_SIZE(class) <= end; class ++) {
  804160889f:	8d 43 01             	lea    0x1(%rbx),%eax
  80416088a2:	44 39 fb             	cmp    %r15d,%ebx
  80416088a5:	7d 7d                	jge    8041608924 <map_physical_region+0x1f7>
  80416088a7:	8d 4b 0d             	lea    0xd(%rbx),%ecx
  80416088aa:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  80416088b0:	49 d3 e5             	shl    %cl,%r13
  80416088b3:	4f 8d 64 35 00       	lea    0x0(%r13,%r14,1),%r12
  80416088b8:	4c 3b 65 c8          	cmp    -0x38(%rbp),%r12
  80416088bc:	0f 87 d7 00 00 00    	ja     8041608999 <map_physical_region+0x26c>
  80416088c2:	89 c3                	mov    %eax,%ebx
        if (start & CLASS_SIZE(class)) {
  80416088c4:	8d 43 0c             	lea    0xc(%rbx),%eax
  80416088c7:	49 0f a3 c6          	bt     %rax,%r14
  80416088cb:	73 d2                	jae    804160889f <map_physical_region+0x172>
            struct Page *page = page_lookup(NULL, pstart, class, PARTIAL_NODE, 1);
  80416088cd:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80416088d3:	b9 00 00 30 00       	mov    $0x300000,%ecx
  80416088d8:	89 da                	mov    %ebx,%edx
  80416088da:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80416088de:	bf 00 00 00 00       	mov    $0x0,%edi
  80416088e3:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  80416088ea:	00 00 00 
  80416088ed:	ff d0                	call   *%rax
  80416088ef:	48 89 c2             	mov    %rax,%rdx
            assert(page);
  80416088f2:	48 85 c0             	test   %rax,%rax
  80416088f5:	0f 84 68 ff ff ff    	je     8041608863 <map_physical_region+0x136>
            if ((res = map_page(dst, start, page, flags)) < 0) return res;
  80416088fb:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  80416088fe:	4c 89 f6             	mov    %r14,%rsi
  8041608901:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8041608905:	48 b8 49 76 60 41 80 	movabs $0x8041607649,%rax
  804160890c:	00 00 00 
  804160890f:	ff d0                	call   *%rax
  8041608911:	85 c0                	test   %eax,%eax
  8041608913:	79 83                	jns    8041608898 <map_physical_region+0x16b>
        }
    }


    return 0;
}
  8041608915:	48 83 c4 38          	add    $0x38,%rsp
  8041608919:	5b                   	pop    %rbx
  804160891a:	41 5c                	pop    %r12
  804160891c:	41 5d                	pop    %r13
  804160891e:	41 5e                	pop    %r14
  8041608920:	41 5f                	pop    %r15
  8041608922:	5d                   	pop    %rbp
  8041608923:	c3                   	ret    
  8041608924:	41 89 c7             	mov    %eax,%r15d
  8041608927:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
    for (; class >= 0 && start < end; class --) {
  804160892b:	45 85 ff             	test   %r15d,%r15d
  804160892e:	78 5f                	js     804160898f <map_physical_region+0x262>
  8041608930:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8041608934:	4c 39 f1             	cmp    %r14,%rcx
  8041608937:	76 56                	jbe    804160898f <map_physical_region+0x262>
            if ((res = map_page(dst, start, page, flags)) < 0) return res;
  8041608939:	49 bc 49 76 60 41 80 	movabs $0x8041607649,%r12
  8041608940:	00 00 00 
  8041608943:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041608947:	44 89 7d b8          	mov    %r15d,-0x48(%rbp)
  804160894b:	49 89 cf             	mov    %rcx,%r15
        while (start + CLASS_SIZE(class) <= end) {
  804160894e:	8b 75 b8             	mov    -0x48(%rbp),%esi
  8041608951:	8d 4e 0c             	lea    0xc(%rsi),%ecx
  8041608954:	be 01 00 00 00       	mov    $0x1,%esi
  8041608959:	48 d3 e6             	shl    %cl,%rsi
  804160895c:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
  8041608960:	4a 8d 0c 36          	lea    (%rsi,%r14,1),%rcx
  8041608964:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8041608968:	48 89 c3             	mov    %rax,%rbx
  804160896b:	4c 89 f6             	mov    %r14,%rsi
  804160896e:	48 29 c6             	sub    %rax,%rsi
  8041608971:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8041608975:	49 39 cf             	cmp    %rcx,%r15
  8041608978:	73 2c                	jae    80416089a6 <map_physical_region+0x279>
  804160897a:	e9 9a 00 00 00       	jmp    8041608a19 <map_physical_region+0x2ec>
    int class = 0, res;
  804160897f:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  8041608985:	eb a4                	jmp    804160892b <map_physical_region+0x1fe>
  8041608987:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  804160898d:	eb 9c                	jmp    804160892b <map_physical_region+0x1fe>
    return 0;
  804160898f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608994:	e9 7c ff ff ff       	jmp    8041608915 <map_physical_region+0x1e8>
  8041608999:	41 89 c7             	mov    %eax,%r15d
  804160899c:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
  80416089a0:	eb 89                	jmp    804160892b <map_physical_region+0x1fe>
  80416089a2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80416089a6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80416089aa:	4c 8d 34 18          	lea    (%rax,%rbx,1),%r14
            struct Page *page = page_lookup(NULL, pstart, class, PARTIAL_NODE, 1);
  80416089ae:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80416089b4:	b9 00 00 30 00       	mov    $0x300000,%ecx
  80416089b9:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80416089bc:	48 89 de             	mov    %rbx,%rsi
  80416089bf:	bf 00 00 00 00       	mov    $0x0,%edi
  80416089c4:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  80416089cb:	00 00 00 
  80416089ce:	ff d0                	call   *%rax
  80416089d0:	48 89 c2             	mov    %rax,%rdx
            assert(page);
  80416089d3:	48 85 c0             	test   %rax,%rax
  80416089d6:	74 5a                	je     8041608a32 <map_physical_region+0x305>
            if ((res = map_page(dst, start, page, flags)) < 0) return res;
  80416089d8:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  80416089db:	4c 89 f6             	mov    %r14,%rsi
  80416089de:	4c 89 ef             	mov    %r13,%rdi
  80416089e1:	41 ff d4             	call   *%r12
  80416089e4:	85 c0                	test   %eax,%eax
  80416089e6:	0f 88 29 ff ff ff    	js     8041608915 <map_physical_region+0x1e8>
            assert_virtual(dst->root);
  80416089ec:	49 8b 45 10          	mov    0x10(%r13),%rax
  80416089f0:	8b 40 28             	mov    0x28(%rax),%eax
  80416089f3:	25 00 00 f0 00       	and    $0xf00000,%eax
  80416089f8:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  80416089fd:	77 68                	ja     8041608a67 <map_physical_region+0x33a>
            pstart += CLASS_SIZE(class);
  80416089ff:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8041608a03:	48 01 fb             	add    %rdi,%rbx
        while (start + CLASS_SIZE(class) <= end) {
  8041608a06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8041608a0a:	48 01 f8             	add    %rdi,%rax
  8041608a0d:	49 39 c7             	cmp    %rax,%r15
  8041608a10:	73 90                	jae    80416089a2 <map_physical_region+0x275>
  8041608a12:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
            pstart += CLASS_SIZE(class);
  8041608a16:	48 89 d8             	mov    %rbx,%rax
    for (; class >= 0 && start < end; class --) {
  8041608a19:	83 6d b8 01          	subl   $0x1,-0x48(%rbp)
  8041608a1d:	78 09                	js     8041608a28 <map_physical_region+0x2fb>
  8041608a1f:	4d 39 f7             	cmp    %r14,%r15
  8041608a22:	0f 87 26 ff ff ff    	ja     804160894e <map_physical_region+0x221>
    return 0;
  8041608a28:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608a2d:	e9 e3 fe ff ff       	jmp    8041608915 <map_physical_region+0x1e8>
            assert(page);
  8041608a32:	48 b9 66 1c 61 41 80 	movabs $0x8041611c66,%rcx
  8041608a39:	00 00 00 
  8041608a3c:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041608a43:	00 00 00 
  8041608a46:	be b4 04 00 00       	mov    $0x4b4,%esi
  8041608a4b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608a52:	00 00 00 
  8041608a55:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608a5a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041608a61:	00 00 00 
  8041608a64:	41 ff d0             	call   *%r8
            assert_virtual(dst->root);
  8041608a67:	48 b9 88 26 61 41 80 	movabs $0x8041612688,%rcx
  8041608a6e:	00 00 00 
  8041608a71:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041608a78:	00 00 00 
  8041608a7b:	be b6 04 00 00       	mov    $0x4b6,%esi
  8041608a80:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608a87:	00 00 00 
  8041608a8a:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608a8f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041608a96:	00 00 00 
  8041608a99:	41 ff d0             	call   *%r8

0000008041608a9c <dump_virtual_tree>:
dump_virtual_tree(struct Page *node, int class) {
  8041608a9c:	55                   	push   %rbp
  8041608a9d:	48 89 e5             	mov    %rsp,%rbp
  8041608aa0:	41 54                	push   %r12
  8041608aa2:	53                   	push   %rbx
  8041608aa3:	48 89 fb             	mov    %rdi,%rbx
  8041608aa6:	41 89 f4             	mov    %esi,%r12d
    if ((node->state & NODE_TYPE_MASK) == MAPPING_NODE) {
  8041608aa9:	8b 47 28             	mov    0x28(%rdi),%eax
  8041608aac:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041608ab1:	3d 00 00 10 00       	cmp    $0x100000,%eax
  8041608ab6:	74 39                	je     8041608af1 <dump_virtual_tree+0x55>
    if (node->left) {
  8041608ab8:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8041608abc:	48 85 ff             	test   %rdi,%rdi
  8041608abf:	74 11                	je     8041608ad2 <dump_virtual_tree+0x36>
        dump_virtual_tree(node->left, class - 1);
  8041608ac1:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  8041608ac6:	48 b8 9c 8a 60 41 80 	movabs $0x8041608a9c,%rax
  8041608acd:	00 00 00 
  8041608ad0:	ff d0                	call   *%rax
    if (node->right) {
  8041608ad2:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8041608ad6:	48 85 ff             	test   %rdi,%rdi
  8041608ad9:	74 11                	je     8041608aec <dump_virtual_tree+0x50>
        dump_virtual_tree(node->right, class - 1); 
  8041608adb:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  8041608ae0:	48 b8 9c 8a 60 41 80 	movabs $0x8041608a9c,%rax
  8041608ae7:	00 00 00 
  8041608aea:	ff d0                	call   *%rax
}
  8041608aec:	5b                   	pop    %rbx
  8041608aed:	41 5c                	pop    %r12
  8041608aef:	5d                   	pop    %rbp
  8041608af0:	c3                   	ret    
       assert(node->phy->class == class); 
  8041608af1:	48 8b 57 30          	mov    0x30(%rdi),%rdx
  8041608af5:	0f b7 42 34          	movzwl 0x34(%rdx),%eax
  8041608af9:	25 ff 0f 00 00       	and    $0xfff,%eax
  8041608afe:	39 f0                	cmp    %esi,%eax
  8041608b00:	75 65                	jne    8041608b67 <dump_virtual_tree+0xcb>
                                        (long)PTE_ADDR(node->phy->addr), (long)(PTE_ADDR(node->phy->addr) + CLASS_MASK(class)), 
  8041608b02:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8041608b09:	ff 0f 00 
  8041608b0c:	48 23 42 38          	and    0x38(%rdx),%rax
  8041608b10:	8d 4e 0c             	lea    0xc(%rsi),%ecx
  8041608b13:	ba 01 00 00 00       	mov    $0x1,%edx
  8041608b18:	48 d3 e2             	shl    %cl,%rdx
  8041608b1b:	48 be 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rsi
  8041608b22:	ff ff 7f 
  8041608b25:	48 21 f0             	and    %rsi,%rax
                                        (long)node, (long)(node + CLASS_MASK(class)), 
  8041608b28:	be 40 00 00 00       	mov    $0x40,%esi
  8041608b2d:	48 d3 e6             	shl    %cl,%rsi
  8041608b30:	48 8d 74 37 c0       	lea    -0x40(%rdi,%rsi,1),%rsi
       cprintf("virt: [%08lX, %08lX] phys: [%08lX, %08lx] class: [%d]\n", 
  8041608b35:	45 89 e1             	mov    %r12d,%r9d
  8041608b38:	4c 8d 44 02 ff       	lea    -0x1(%rdx,%rax,1),%r8
  8041608b3d:	48 89 c1             	mov    %rax,%rcx
  8041608b40:	48 89 f2             	mov    %rsi,%rdx
  8041608b43:	48 89 fe             	mov    %rdi,%rsi
  8041608b46:	48 bf c0 26 61 41 80 	movabs $0x80416126c0,%rdi
  8041608b4d:	00 00 00 
  8041608b50:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608b55:	49 ba 99 c8 60 41 80 	movabs $0x804160c899,%r10
  8041608b5c:	00 00 00 
  8041608b5f:	41 ff d2             	call   *%r10
  8041608b62:	e9 51 ff ff ff       	jmp    8041608ab8 <dump_virtual_tree+0x1c>
       assert(node->phy->class == class); 
  8041608b67:	48 b9 bd 1d 61 41 80 	movabs $0x8041611dbd,%rcx
  8041608b6e:	00 00 00 
  8041608b71:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041608b78:	00 00 00 
  8041608b7b:	be 64 02 00 00       	mov    $0x264,%esi
  8041608b80:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608b87:	00 00 00 
  8041608b8a:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608b8f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041608b96:	00 00 00 
  8041608b99:	41 ff d0             	call   *%r8

0000008041608b9c <dump_memory_lists>:
dump_memory_lists(void) {
  8041608b9c:	55                   	push   %rbp
  8041608b9d:	48 89 e5             	mov    %rsp,%rbp
  8041608ba0:	41 57                	push   %r15
  8041608ba2:	41 56                	push   %r14
  8041608ba4:	41 55                	push   %r13
  8041608ba6:	41 54                	push   %r12
  8041608ba8:	53                   	push   %rbx
  8041608ba9:	48 83 ec 08          	sub    $0x8,%rsp
    for (int i = 0; i < MAX_CLASS; ++i) {
  8041608bad:	49 bd 40 41 40 42 80 	movabs $0x8042404140,%r13
  8041608bb4:	00 00 00 
    return page->addr << CLASS_BASE;
  8041608bb7:	49 bc ff ff ff ff ff 	movabs $0xfffffffffffff,%r12
  8041608bbe:	ff 0f 00 
                cprintf("pa: [%08lX, %08lX]  page_class: [%d] refc: [%d]\n", page2pa(page), 
  8041608bc1:	49 bf 99 c8 60 41 80 	movabs $0x804160c899,%r15
  8041608bc8:	00 00 00 
  8041608bcb:	eb 13                	jmp    8041608be0 <dump_memory_lists+0x44>
    for (int i = 0; i < MAX_CLASS; ++i) {
  8041608bcd:	49 83 c5 10          	add    $0x10,%r13
  8041608bd1:	48 b8 40 44 40 42 80 	movabs $0x8042404440,%rax
  8041608bd8:	00 00 00 
  8041608bdb:	49 39 c5             	cmp    %rax,%r13
  8041608bde:	74 56                	je     8041608c36 <dump_memory_lists+0x9a>
    return list->next == list;
  8041608be0:	4d 89 ee             	mov    %r13,%r14
  8041608be3:	49 8b 5d 08          	mov    0x8(%r13),%rbx
        if (!list_empty(begin)) {
  8041608be7:	4c 39 eb             	cmp    %r13,%rbx
  8041608bea:	74 e1                	je     8041608bcd <dump_memory_lists+0x31>
                                                             page->class, 
  8041608bec:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
                cprintf("pa: [%08lX, %08lX]  page_class: [%d] refc: [%d]\n", page2pa(page), 
  8041608bf0:	25 ff 0f 00 00       	and    $0xfff,%eax
  8041608bf5:	4c 89 e6             	mov    %r12,%rsi
  8041608bf8:	48 23 73 38          	and    0x38(%rbx),%rsi
  8041608bfc:	48 c1 e6 0c          	shl    $0xc,%rsi
  8041608c00:	4c 21 e6             	and    %r12,%rsi
                                                             page2pa(page) + (long)CLASS_MASK(page->class), 
  8041608c03:	8d 48 0c             	lea    0xc(%rax),%ecx
  8041608c06:	ba 01 00 00 00       	mov    $0x1,%edx
  8041608c0b:	48 d3 e2             	shl    %cl,%rdx
                cprintf("pa: [%08lX, %08lX]  page_class: [%d] refc: [%d]\n", page2pa(page), 
  8041608c0e:	48 8d 54 16 ff       	lea    -0x1(%rsi,%rdx,1),%rdx
  8041608c13:	44 8b 43 30          	mov    0x30(%rbx),%r8d
  8041608c17:	89 c1                	mov    %eax,%ecx
  8041608c19:	48 bf f8 26 61 41 80 	movabs $0x80416126f8,%rdi
  8041608c20:	00 00 00 
  8041608c23:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608c28:	41 ff d7             	call   *%r15
            for (struct List *temp = begin->next; temp != begin; temp = temp->next) {
  8041608c2b:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
  8041608c2f:	4c 39 f3             	cmp    %r14,%rbx
  8041608c32:	75 b8                	jne    8041608bec <dump_memory_lists+0x50>
  8041608c34:	eb 97                	jmp    8041608bcd <dump_memory_lists+0x31>
}
  8041608c36:	48 83 c4 08          	add    $0x8,%rsp
  8041608c3a:	5b                   	pop    %rbx
  8041608c3b:	41 5c                	pop    %r12
  8041608c3d:	41 5d                	pop    %r13
  8041608c3f:	41 5e                	pop    %r14
  8041608c41:	41 5f                	pop    %r15
  8041608c43:	5d                   	pop    %rbp
  8041608c44:	c3                   	ret    

0000008041608c45 <test_alloc_all>:
void test_alloc_all(int pclass, int flags) {
  8041608c45:	55                   	push   %rbp
  8041608c46:	48 89 e5             	mov    %rsp,%rbp
  8041608c49:	41 57                	push   %r15
  8041608c4b:	41 56                	push   %r14
  8041608c4d:	41 55                	push   %r13
  8041608c4f:	41 54                	push   %r12
  8041608c51:	53                   	push   %rbx
  8041608c52:	48 83 ec 08          	sub    $0x8,%rsp
  8041608c56:	41 89 fc             	mov    %edi,%r12d
  8041608c59:	89 f3                	mov    %esi,%ebx
    while ((p = alloc_page(pclass, flags))) {
  8041608c5b:	49 bd a2 5d 60 41 80 	movabs $0x8041605da2,%r13
  8041608c62:	00 00 00 
        if (last_alloc_actual_size < LAST_ALLOC_SIZE) {
  8041608c65:	49 be 00 00 40 42 80 	movabs $0x8042400000,%r14
  8041608c6c:	00 00 00 
           last_alloc[last_alloc_actual_size] = p;
  8041608c6f:	49 bf 20 00 40 42 80 	movabs $0x8042400020,%r15
  8041608c76:	00 00 00 
    while ((p = alloc_page(pclass, flags))) {
  8041608c79:	89 de                	mov    %ebx,%esi
  8041608c7b:	44 89 e7             	mov    %r12d,%edi
  8041608c7e:	41 ff d5             	call   *%r13
  8041608c81:	48 85 c0             	test   %rax,%rax
  8041608c84:	74 16                	je     8041608c9c <test_alloc_all+0x57>
        if (last_alloc_actual_size < LAST_ALLOC_SIZE) {
  8041608c86:	49 8b 16             	mov    (%r14),%rdx
  8041608c89:	48 83 fa 04          	cmp    $0x4,%rdx
  8041608c8d:	77 ea                	ja     8041608c79 <test_alloc_all+0x34>
           last_alloc[last_alloc_actual_size] = p;
  8041608c8f:	49 89 04 d7          	mov    %rax,(%r15,%rdx,8)
           last_alloc_actual_size++;
  8041608c93:	48 83 c2 01          	add    $0x1,%rdx
  8041608c97:	49 89 16             	mov    %rdx,(%r14)
  8041608c9a:	eb dd                	jmp    8041608c79 <test_alloc_all+0x34>
}
  8041608c9c:	48 83 c4 08          	add    $0x8,%rsp
  8041608ca0:	5b                   	pop    %rbx
  8041608ca1:	41 5c                	pop    %r12
  8041608ca3:	41 5d                	pop    %r13
  8041608ca5:	41 5e                	pop    %r14
  8041608ca7:	41 5f                	pop    %r15
  8041608ca9:	5d                   	pop    %rbp
  8041608caa:	c3                   	ret    

0000008041608cab <test_free_last_alloc>:
void test_free_last_alloc(void) {
  8041608cab:	55                   	push   %rbp
  8041608cac:	48 89 e5             	mov    %rsp,%rbp
  8041608caf:	41 57                	push   %r15
  8041608cb1:	41 56                	push   %r14
  8041608cb3:	41 55                	push   %r13
  8041608cb5:	41 54                	push   %r12
  8041608cb7:	53                   	push   %rbx
  8041608cb8:	48 83 ec 08          	sub    $0x8,%rsp
    for (int i = 0; i < last_alloc_actual_size; ++i) {
  8041608cbc:	48 b8 00 00 40 42 80 	movabs $0x8042400000,%rax
  8041608cc3:	00 00 00 
  8041608cc6:	48 83 38 00          	cmpq   $0x0,(%rax)
  8041608cca:	74 48                	je     8041608d14 <test_free_last_alloc+0x69>
  8041608ccc:	bb 00 00 00 00       	mov    $0x0,%ebx
       page_ref(last_alloc[i]);
  8041608cd1:	49 bf 20 00 40 42 80 	movabs $0x8042400020,%r15
  8041608cd8:	00 00 00 
  8041608cdb:	49 be d2 47 60 41 80 	movabs $0x80416047d2,%r14
  8041608ce2:	00 00 00 
       page_unref(last_alloc[i]);
  8041608ce5:	49 bd b1 48 60 41 80 	movabs $0x80416048b1,%r13
  8041608cec:	00 00 00 
       page_ref(last_alloc[i]);
  8041608cef:	4d 8d 24 df          	lea    (%r15,%rbx,8),%r12
  8041608cf3:	49 8b 3c 24          	mov    (%r12),%rdi
  8041608cf7:	41 ff d6             	call   *%r14
       page_unref(last_alloc[i]);
  8041608cfa:	49 8b 3c 24          	mov    (%r12),%rdi
  8041608cfe:	41 ff d5             	call   *%r13
    for (int i = 0; i < last_alloc_actual_size; ++i) {
  8041608d01:	48 83 c3 01          	add    $0x1,%rbx
  8041608d05:	48 b8 00 00 40 42 80 	movabs $0x8042400000,%rax
  8041608d0c:	00 00 00 
  8041608d0f:	48 39 18             	cmp    %rbx,(%rax)
  8041608d12:	77 db                	ja     8041608cef <test_free_last_alloc+0x44>
   last_alloc_actual_size = 0; 
  8041608d14:	48 b8 00 00 40 42 80 	movabs $0x8042400000,%rax
  8041608d1b:	00 00 00 
  8041608d1e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
}
  8041608d25:	48 83 c4 08          	add    $0x8,%rsp
  8041608d29:	5b                   	pop    %rbx
  8041608d2a:	41 5c                	pop    %r12
  8041608d2c:	41 5d                	pop    %r13
  8041608d2e:	41 5e                	pop    %r14
  8041608d30:	41 5f                	pop    %r15
  8041608d32:	5d                   	pop    %rbp
  8041608d33:	c3                   	ret    

0000008041608d34 <dump_page_table>:
dump_page_table(pte_t *pml4) {
  8041608d34:	55                   	push   %rbp
  8041608d35:	48 89 e5             	mov    %rsp,%rbp
  8041608d38:	41 57                	push   %r15
  8041608d3a:	41 56                	push   %r14
  8041608d3c:	41 55                	push   %r13
  8041608d3e:	41 54                	push   %r12
  8041608d40:	53                   	push   %rbx
  8041608d41:	48 83 ec 38          	sub    $0x38,%rsp
  8041608d45:	48 89 fb             	mov    %rdi,%rbx
    cprintf("Page table:\n");
  8041608d48:	48 bf d7 1d 61 41 80 	movabs $0x8041611dd7,%rdi
  8041608d4f:	00 00 00 
  8041608d52:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608d57:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041608d5e:	00 00 00 
  8041608d61:	ff d2                	call   *%rdx
    for (int pml4i = NUSERPML4; pml4i < PML4_ENTRY_COUNT; ++pml4i) {
  8041608d63:	48 8d 43 08          	lea    0x8(%rbx),%rax
  8041608d67:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8041608d6b:	48 8d 83 00 10 00 00 	lea    0x1000(%rbx),%rax
  8041608d72:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608d76:	49 bf 99 c8 60 41 80 	movabs $0x804160c899,%r15
  8041608d7d:	00 00 00 
  8041608d80:	e9 c9 02 00 00       	jmp    804160904e <dump_page_table+0x31a>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041608d85:	49 89 c0             	mov    %rax,%r8
  8041608d88:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041608d8f:	00 00 00 
  8041608d92:	be a9 02 00 00       	mov    $0x2a9,%esi
  8041608d97:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608d9e:	00 00 00 
  8041608da1:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608da6:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041608dad:	00 00 00 
  8041608db0:	41 ff d1             	call   *%r9
            pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi]));
  8041608db3:	4c 21 f0             	and    %r14,%rax
  8041608db6:	48 89 c1             	mov    %rax,%rcx
    if (pa > max_memory_map_addr)
  8041608db9:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041608dc0:	00 00 00 
  8041608dc3:	48 39 c1             	cmp    %rax,%rcx
  8041608dc6:	77 23                	ja     8041608deb <dump_page_table+0xb7>
    return (void *)(pa + KERN_BASE_ADDR);
  8041608dc8:	49 bd 00 00 00 40 80 	movabs $0x8040000000,%r13
  8041608dcf:	00 00 00 
  8041608dd2:	49 01 cd             	add    %rcx,%r13
            for (int pdi = 0; pdi < PD_ENTRY_COUNT; ++pdi) {
  8041608dd5:	48 b8 00 10 00 40 80 	movabs $0x8040001000,%rax
  8041608ddc:	00 00 00 
  8041608ddf:	48 01 c8             	add    %rcx,%rax
  8041608de2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8041608de6:	e9 38 01 00 00       	jmp    8041608f23 <dump_page_table+0x1ef>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041608deb:	49 89 c0             	mov    %rax,%r8
  8041608dee:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041608df5:	00 00 00 
  8041608df8:	be b5 02 00 00       	mov    $0x2b5,%esi
  8041608dfd:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608e04:	00 00 00 
  8041608e07:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608e0c:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041608e13:	00 00 00 
  8041608e16:	41 ff d1             	call   *%r9
                pte_t *pt = KADDR(PTE_ADDR(pd[pdi]));
  8041608e19:	4c 21 f2             	and    %r14,%rdx
    if (pa > max_memory_map_addr)
  8041608e1c:	48 b8 c8 00 40 42 80 	movabs $0x80424000c8,%rax
  8041608e23:	00 00 00 
  8041608e26:	4c 8b 00             	mov    (%rax),%r8
  8041608e29:	4c 39 c2             	cmp    %r8,%rdx
  8041608e2c:	77 1c                	ja     8041608e4a <dump_page_table+0x116>
    return (void *)(pa + KERN_BASE_ADDR);
  8041608e2e:	48 bb 00 00 00 40 80 	movabs $0x8040000000,%rbx
  8041608e35:	00 00 00 
  8041608e38:	48 01 d3             	add    %rdx,%rbx
                for (int pti = 0; pti < PT_ENTRY_COUNT; ++pti) {
  8041608e3b:	49 bc 00 10 00 40 80 	movabs $0x8040001000,%r12
  8041608e42:	00 00 00 
  8041608e45:	49 01 d4             	add    %rdx,%r12
  8041608e48:	eb 3b                	jmp    8041608e85 <dump_page_table+0x151>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8041608e4a:	48 89 d1             	mov    %rdx,%rcx
  8041608e4d:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  8041608e54:	00 00 00 
  8041608e57:	be bf 02 00 00       	mov    $0x2bf,%esi
  8041608e5c:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041608e63:	00 00 00 
  8041608e66:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608e6b:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  8041608e72:	00 00 00 
  8041608e75:	41 ff d1             	call   *%r9
  8041608e78:	48 83 c3 08          	add    $0x8,%rbx
  8041608e7c:	49 39 dc             	cmp    %rbx,%r12
  8041608e7f:	0f 84 90 00 00 00    	je     8041608f15 <dump_page_table+0x1e1>
                    if (!(pt[pti] & PTE_P)) {
  8041608e85:	48 8b 13             	mov    (%rbx),%rdx
  8041608e88:	f6 c2 01             	test   $0x1,%dl
  8041608e8b:	74 eb                	je     8041608e78 <dump_page_table+0x144>
            base & PTE_PS ? 'S' : '-',
  8041608e8d:	48 89 d0             	mov    %rdx,%rax
  8041608e90:	25 80 00 00 00       	and    $0x80,%eax
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608e95:	48 83 f8 01          	cmp    $0x1,%rax
  8041608e99:	19 c9                	sbb    %ecx,%ecx
  8041608e9b:	83 e1 da             	and    $0xffffffda,%ecx
  8041608e9e:	83 c1 53             	add    $0x53,%ecx
  8041608ea1:	48 89 d0             	mov    %rdx,%rax
  8041608ea4:	48 c1 f8 3f          	sar    $0x3f,%rax
  8041608ea8:	83 e0 d5             	and    $0xffffffd5,%eax
  8041608eab:	44 8d 40 58          	lea    0x58(%rax),%r8d
            base & PTE_W ? 'W' : '-',
  8041608eaf:	48 89 d0             	mov    %rdx,%rax
  8041608eb2:	83 e0 02             	and    $0x2,%eax
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608eb5:	48 83 f8 01          	cmp    $0x1,%rax
  8041608eb9:	19 c0                	sbb    %eax,%eax
  8041608ebb:	83 e0 d6             	and    $0xffffffd6,%eax
  8041608ebe:	83 c0 57             	add    $0x57,%eax
            base & PTE_U ? 'U' : '-',
  8041608ec1:	48 89 d6             	mov    %rdx,%rsi
  8041608ec4:	83 e6 04             	and    $0x4,%esi
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608ec7:	48 83 fe 01          	cmp    $0x1,%rsi
  8041608ecb:	19 f6                	sbb    %esi,%esi
  8041608ecd:	83 e6 d8             	and    $0xffffffd8,%esi
            PTE_ADDR(base) + (isz ? (step * isz - 1) : 0xFFF),
  8041608ed0:	4c 21 f2             	and    %r14,%rdx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608ed3:	48 8d ba ff 0f 00 00 	lea    0xfff(%rdx),%rdi
  8041608eda:	68 00 10 00 00       	push   $0x1000
  8041608edf:	51                   	push   %rcx
  8041608ee0:	41 50                	push   %r8
  8041608ee2:	50                   	push   %rax
  8041608ee3:	44 8d 4e 55          	lea    0x55(%rsi),%r9d
  8041608ee7:	41 b8 50 00 00 00    	mov    $0x50,%r8d
  8041608eed:	48 89 f9             	mov    %rdi,%rcx
  8041608ef0:	48 be e4 1d 61 41 80 	movabs $0x8041611de4,%rsi
  8041608ef7:	00 00 00 
  8041608efa:	48 bf 30 27 61 41 80 	movabs $0x8041612730,%rdi
  8041608f01:	00 00 00 
  8041608f04:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608f09:	41 ff d7             	call   *%r15
}
  8041608f0c:	48 83 c4 20          	add    $0x20,%rsp
  8041608f10:	e9 63 ff ff ff       	jmp    8041608e78 <dump_page_table+0x144>
            for (int pdi = 0; pdi < PD_ENTRY_COUNT; ++pdi) {
  8041608f15:	49 83 c5 08          	add    $0x8,%r13
  8041608f19:	4c 3b 6d c8          	cmp    -0x38(%rbp),%r13
  8041608f1d:	0f 84 85 00 00 00    	je     8041608fa8 <dump_page_table+0x274>
                if (!(pd[pdi] & PTE_P))
  8041608f23:	49 8b 55 00          	mov    0x0(%r13),%rdx
  8041608f27:	f6 c2 01             	test   $0x1,%dl
  8041608f2a:	74 e9                	je     8041608f15 <dump_page_table+0x1e1>
                if (pd[pdi] & PTE_PS) {
  8041608f2c:	f6 c2 80             	test   $0x80,%dl
  8041608f2f:	0f 84 e4 fe ff ff    	je     8041608e19 <dump_page_table+0xe5>
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608f35:	48 89 d0             	mov    %rdx,%rax
  8041608f38:	48 c1 f8 3f          	sar    $0x3f,%rax
  8041608f3c:	83 e0 d5             	and    $0xffffffd5,%eax
  8041608f3f:	8d 78 58             	lea    0x58(%rax),%edi
            base & PTE_W ? 'W' : '-',
  8041608f42:	48 89 d0             	mov    %rdx,%rax
  8041608f45:	83 e0 02             	and    $0x2,%eax
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608f48:	48 83 f8 01          	cmp    $0x1,%rax
  8041608f4c:	19 c0                	sbb    %eax,%eax
  8041608f4e:	83 e0 d6             	and    $0xffffffd6,%eax
  8041608f51:	83 c0 57             	add    $0x57,%eax
            base & PTE_U ? 'U' : '-',
  8041608f54:	48 89 d1             	mov    %rdx,%rcx
  8041608f57:	83 e1 04             	and    $0x4,%ecx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608f5a:	48 83 f9 01          	cmp    $0x1,%rcx
  8041608f5e:	19 c9                	sbb    %ecx,%ecx
  8041608f60:	83 e1 d8             	and    $0xffffffd8,%ecx
            PTE_ADDR(base) + (isz ? (step * isz - 1) : 0xFFF),
  8041608f63:	4c 21 f2             	and    %r14,%rdx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608f66:	48 8d b2 ff ff 1f 00 	lea    0x1fffff(%rdx),%rsi
  8041608f6d:	68 00 00 20 00       	push   $0x200000
  8041608f72:	6a 53                	push   $0x53
  8041608f74:	57                   	push   %rdi
  8041608f75:	50                   	push   %rax
  8041608f76:	44 8d 49 55          	lea    0x55(%rcx),%r9d
  8041608f7a:	41 b8 50 00 00 00    	mov    $0x50,%r8d
  8041608f80:	48 89 f1             	mov    %rsi,%rcx
  8041608f83:	48 be e9 1d 61 41 80 	movabs $0x8041611de9,%rsi
  8041608f8a:	00 00 00 
  8041608f8d:	48 bf 30 27 61 41 80 	movabs $0x8041612730,%rdi
  8041608f94:	00 00 00 
  8041608f97:	b8 00 00 00 00       	mov    $0x0,%eax
  8041608f9c:	41 ff d7             	call   *%r15
                  continue;
  8041608f9f:	48 83 c4 20          	add    $0x20,%rsp
  8041608fa3:	e9 6d ff ff ff       	jmp    8041608f15 <dump_page_table+0x1e1>
        for (int pdpi = 0; pdpi < PDP_ENTRY_COUNT; ++pdpi) {
  8041608fa8:	48 83 45 c0 08       	addq   $0x8,-0x40(%rbp)
  8041608fad:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8041608fb1:	48 3b 45 a8          	cmp    -0x58(%rbp),%rax
  8041608fb5:	0f 84 84 00 00 00    	je     804160903f <dump_page_table+0x30b>
            if (!(pdp[pdpi] & PTE_P))
  8041608fbb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8041608fbf:	48 8b 00             	mov    (%rax),%rax
  8041608fc2:	a8 01                	test   $0x1,%al
  8041608fc4:	74 e2                	je     8041608fa8 <dump_page_table+0x274>
            if (pdp[pdpi] & PTE_PS) {
  8041608fc6:	a8 80                	test   $0x80,%al
  8041608fc8:	0f 84 e5 fd ff ff    	je     8041608db3 <dump_page_table+0x7f>
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608fce:	48 99                	cqto   
  8041608fd0:	83 e2 d5             	and    $0xffffffd5,%edx
  8041608fd3:	8d 7a 58             	lea    0x58(%rdx),%edi
            base & PTE_W ? 'W' : '-',
  8041608fd6:	48 89 c2             	mov    %rax,%rdx
  8041608fd9:	83 e2 02             	and    $0x2,%edx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608fdc:	48 83 fa 01          	cmp    $0x1,%rdx
  8041608fe0:	19 c9                	sbb    %ecx,%ecx
  8041608fe2:	83 e1 d6             	and    $0xffffffd6,%ecx
  8041608fe5:	83 c1 57             	add    $0x57,%ecx
            base & PTE_U ? 'U' : '-',
  8041608fe8:	48 89 c2             	mov    %rax,%rdx
  8041608feb:	83 e2 04             	and    $0x4,%edx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608fee:	48 83 fa 01          	cmp    $0x1,%rdx
  8041608ff2:	19 f6                	sbb    %esi,%esi
  8041608ff4:	83 e6 d8             	and    $0xffffffd8,%esi
            PTE_ADDR(base) + (isz ? (step * isz - 1) : 0xFFF),
  8041608ff7:	4c 21 f0             	and    %r14,%rax
  8041608ffa:	48 89 c2             	mov    %rax,%rdx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8041608ffd:	48 8d 80 ff ff ff 3f 	lea    0x3fffffff(%rax),%rax
  8041609004:	68 00 00 00 40       	push   $0x40000000
  8041609009:	6a 53                	push   $0x53
  804160900b:	57                   	push   %rdi
  804160900c:	51                   	push   %rcx
  804160900d:	44 8d 4e 55          	lea    0x55(%rsi),%r9d
  8041609011:	41 b8 50 00 00 00    	mov    $0x50,%r8d
  8041609017:	48 89 c1             	mov    %rax,%rcx
  804160901a:	48 be ee 1d 61 41 80 	movabs $0x8041611dee,%rsi
  8041609021:	00 00 00 
  8041609024:	48 bf 30 27 61 41 80 	movabs $0x8041612730,%rdi
  804160902b:	00 00 00 
  804160902e:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609033:	41 ff d7             	call   *%r15
                continue;
  8041609036:	48 83 c4 20          	add    $0x20,%rsp
  804160903a:	e9 69 ff ff ff       	jmp    8041608fa8 <dump_page_table+0x274>
    for (int pml4i = NUSERPML4; pml4i < PML4_ENTRY_COUNT; ++pml4i) {
  804160903f:	48 83 45 b8 08       	addq   $0x8,-0x48(%rbp)
  8041609044:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041609048:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  804160904c:	74 5d                	je     80416090ab <dump_page_table+0x377>
        if (!(pml4[pml4i] & PTE_P))
  804160904e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041609052:	48 8b 08             	mov    (%rax),%rcx
  8041609055:	f6 c1 01             	test   $0x1,%cl
  8041609058:	74 e5                	je     804160903f <dump_page_table+0x30b>
        pdpe_t *pdp = KADDR(PTE_ADDR(pml4[pml4i]));
  804160905a:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8041609061:	ff ff 7f 
  8041609064:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  8041609067:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160906e:	00 00 00 
  8041609071:	48 39 c1             	cmp    %rax,%rcx
  8041609074:	0f 87 0b fd ff ff    	ja     8041608d85 <dump_page_table+0x51>
    return (void *)(pa + KERN_BASE_ADDR);
  804160907a:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8041609081:	00 00 00 
  8041609084:	48 01 c8             	add    %rcx,%rax
  8041609087:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        for (int pdpi = 0; pdpi < PDP_ENTRY_COUNT; ++pdpi) {
  804160908b:	48 b8 00 10 00 40 80 	movabs $0x8040001000,%rax
  8041609092:	00 00 00 
  8041609095:	48 01 c8             	add    %rcx,%rax
  8041609098:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi]));
  804160909c:	49 be 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%r14
  80416090a3:	ff ff 7f 
  80416090a6:	e9 10 ff ff ff       	jmp    8041608fbb <dump_page_table+0x287>
}
  80416090ab:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  80416090af:	5b                   	pop    %rbx
  80416090b0:	41 5c                	pop    %r12
  80416090b2:	41 5d                	pop    %r13
  80416090b4:	41 5e                	pop    %r14
  80416090b6:	41 5f                	pop    %r15
  80416090b8:	5d                   	pop    %rbp
  80416090b9:	c3                   	ret    

00000080416090ba <unmap_region>:
unmap_region(struct AddressSpace *dspace, uintptr_t dst, uintptr_t size) {
  80416090ba:	55                   	push   %rbp
  80416090bb:	48 89 e5             	mov    %rsp,%rbp
  80416090be:	41 57                	push   %r15
  80416090c0:	41 56                	push   %r14
  80416090c2:	41 55                	push   %r13
  80416090c4:	41 54                	push   %r12
  80416090c6:	53                   	push   %rbx
  80416090c7:	48 83 ec 18          	sub    $0x18,%rsp
  80416090cb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80416090cf:	48 89 f0             	mov    %rsi,%rax
    uintptr_t start = ROUNDDOWN(dst, 1ULL << CLASS_BASE);
  80416090d2:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
    uintptr_t end = ROUNDUP(dst + size, 1ULL << CLASS_BASE);
  80416090d9:	4c 8d b4 10 ff 0f 00 	lea    0xfff(%rax,%rdx,1),%r14
  80416090e0:	00 
  80416090e1:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
    for (; class < MAX_CLASS && start + CLASS_SIZE(class) <= end; class ++) {
  80416090e8:	4c 8d a6 00 10 00 00 	lea    0x1000(%rsi),%r12
  80416090ef:	4d 39 e6             	cmp    %r12,%r14
  80416090f2:	72 48                	jb     804160913c <unmap_region+0x82>
    int class = 0;
  80416090f4:	bb 00 00 00 00       	mov    $0x0,%ebx
            unmap_page(dspace, start, class);
  80416090f9:	49 bf 0b 6e 60 41 80 	movabs $0x8041606e0b,%r15
  8041609100:	00 00 00 
  8041609103:	eb 20                	jmp    8041609125 <unmap_region+0x6b>
    for (; class < MAX_CLASS && start + CLASS_SIZE(class) <= end; class ++) {
  8041609105:	44 8d 6b 01          	lea    0x1(%rbx),%r13d
  8041609109:	83 fb 2f             	cmp    $0x2f,%ebx
  804160910c:	74 34                	je     8041609142 <unmap_region+0x88>
  804160910e:	8d 4b 0d             	lea    0xd(%rbx),%ecx
  8041609111:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  8041609117:	49 d3 e4             	shl    %cl,%r12
  804160911a:	49 01 f4             	add    %rsi,%r12
  804160911d:	4d 39 f4             	cmp    %r14,%r12
  8041609120:	77 20                	ja     8041609142 <unmap_region+0x88>
  8041609122:	44 89 eb             	mov    %r13d,%ebx
        if (start & CLASS_SIZE(class)) {
  8041609125:	8d 43 0c             	lea    0xc(%rbx),%eax
  8041609128:	48 0f a3 c6          	bt     %rax,%rsi
  804160912c:	73 d7                	jae    8041609105 <unmap_region+0x4b>
            unmap_page(dspace, start, class);
  804160912e:	89 da                	mov    %ebx,%edx
  8041609130:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041609134:	41 ff d7             	call   *%r15
  8041609137:	4c 89 e6             	mov    %r12,%rsi
  804160913a:	eb c9                	jmp    8041609105 <unmap_region+0x4b>
    int class = 0;
  804160913c:	41 bd 00 00 00 00    	mov    $0x0,%r13d
    for (; class >= 0 && start < end; class --) {
  8041609142:	45 85 ed             	test   %r13d,%r13d
  8041609145:	78 0f                	js     8041609156 <unmap_region+0x9c>
            unmap_page(dspace, start, class);
  8041609147:	49 bc 0b 6e 60 41 80 	movabs $0x8041606e0b,%r12
  804160914e:	00 00 00 
    for (; class >= 0 && start < end; class --) {
  8041609151:	4c 39 f6             	cmp    %r14,%rsi
  8041609154:	72 1a                	jb     8041609170 <unmap_region+0xb6>
}
  8041609156:	48 83 c4 18          	add    $0x18,%rsp
  804160915a:	5b                   	pop    %rbx
  804160915b:	41 5c                	pop    %r12
  804160915d:	41 5d                	pop    %r13
  804160915f:	41 5e                	pop    %r14
  8041609161:	41 5f                	pop    %r15
  8041609163:	5d                   	pop    %rbp
  8041609164:	c3                   	ret    
    for (; class >= 0 && start < end; class --) {
  8041609165:	41 83 ed 01          	sub    $0x1,%r13d
  8041609169:	78 eb                	js     8041609156 <unmap_region+0x9c>
  804160916b:	4c 39 f6             	cmp    %r14,%rsi
  804160916e:	73 e6                	jae    8041609156 <unmap_region+0x9c>
        if (start + CLASS_SIZE(class) <= end) {
  8041609170:	41 8d 4d 0c          	lea    0xc(%r13),%ecx
  8041609174:	bb 01 00 00 00       	mov    $0x1,%ebx
  8041609179:	48 d3 e3             	shl    %cl,%rbx
  804160917c:	48 01 f3             	add    %rsi,%rbx
  804160917f:	4c 39 f3             	cmp    %r14,%rbx
  8041609182:	77 e1                	ja     8041609165 <unmap_region+0xab>
            unmap_page(dspace, start, class);
  8041609184:	44 89 ea             	mov    %r13d,%edx
  8041609187:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160918b:	41 ff d4             	call   *%r12
            start += CLASS_SIZE(class);
  804160918e:	48 89 de             	mov    %rbx,%rsi
  8041609191:	eb d2                	jmp    8041609165 <unmap_region+0xab>

0000008041609193 <region_maxref>:
region_maxref(struct AddressSpace *spc, uintptr_t addr, size_t size) {
  8041609193:	55                   	push   %rbp
  8041609194:	48 89 e5             	mov    %rsp,%rbp
  8041609197:	41 57                	push   %r15
  8041609199:	41 56                	push   %r14
  804160919b:	41 55                	push   %r13
  804160919d:	41 54                	push   %r12
  804160919f:	53                   	push   %rbx
  80416091a0:	48 83 ec 08          	sub    $0x8,%rsp
    uintptr_t start = ROUNDDOWN(addr, PAGE_SIZE);
  80416091a4:	48 89 f3             	mov    %rsi,%rbx
  80416091a7:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
    uintptr_t end = ROUNDUP(addr + size, PAGE_SIZE);
  80416091ae:	4c 8d ac 16 ff 0f 00 	lea    0xfff(%rsi,%rdx,1),%r13
  80416091b5:	00 
  80416091b6:	49 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%r13
    while (start < end) {
  80416091bd:	49 39 dd             	cmp    %rbx,%r13
  80416091c0:	0f 86 82 00 00 00    	jbe    8041609248 <region_maxref+0xb5>
  80416091c6:	49 89 fe             	mov    %rdi,%r14
    int res = 0;
  80416091c9:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        struct Page *page = page_lookup_virtual(spc->root, start, 0, LOOKUP_PRESERVE);
  80416091cf:	49 bf 8e 6a 60 41 80 	movabs $0x8041606a8e,%r15
  80416091d6:	00 00 00 
  80416091d9:	eb 19                	jmp    80416091f4 <region_maxref+0x61>
            res = MAX(res, page->phy->refc + (page->phy->left || page->phy->right));
  80416091db:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  80416091e0:	0f 95 c2             	setne  %dl
  80416091e3:	0f b6 d2             	movzbl %dl,%edx
  80416091e6:	eb 3d                	jmp    8041609225 <region_maxref+0x92>
            start += CLASS_SIZE(0);
  80416091e8:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
    while (start < end) {
  80416091ef:	4c 39 eb             	cmp    %r13,%rbx
  80416091f2:	73 5a                	jae    804160924e <region_maxref+0xbb>
        struct Page *page = page_lookup_virtual(spc->root, start, 0, LOOKUP_PRESERVE);
  80416091f4:	49 8b 7e 10          	mov    0x10(%r14),%rdi
  80416091f8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80416091fd:	ba 00 00 00 00       	mov    $0x0,%edx
  8041609202:	48 89 de             	mov    %rbx,%rsi
  8041609205:	41 ff d7             	call   *%r15
        if (page && page->phy) {
  8041609208:	48 85 c0             	test   %rax,%rax
  804160920b:	74 db                	je     80416091e8 <region_maxref+0x55>
  804160920d:	48 8b 40 30          	mov    0x30(%rax),%rax
  8041609211:	48 85 c0             	test   %rax,%rax
  8041609214:	74 d2                	je     80416091e8 <region_maxref+0x55>
            res = MAX(res, page->phy->refc + (page->phy->left || page->phy->right));
  8041609216:	8b 48 30             	mov    0x30(%rax),%ecx
  8041609219:	ba 01 00 00 00       	mov    $0x1,%edx
  804160921e:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  8041609223:	74 b6                	je     80416091db <region_maxref+0x48>
  8041609225:	01 ca                	add    %ecx,%edx
  8041609227:	44 39 e2             	cmp    %r12d,%edx
  804160922a:	44 0f 43 e2          	cmovae %edx,%r12d
            start += CLASS_SIZE(page->phy->class);
  804160922e:	0f b7 48 34          	movzwl 0x34(%rax),%ecx
  8041609232:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041609238:	83 c1 0c             	add    $0xc,%ecx
  804160923b:	b8 01 00 00 00       	mov    $0x1,%eax
  8041609240:	48 d3 e0             	shl    %cl,%rax
  8041609243:	48 01 c3             	add    %rax,%rbx
  8041609246:	eb a7                	jmp    80416091ef <region_maxref+0x5c>
    int res = 0;
  8041609248:	41 bc 00 00 00 00    	mov    $0x0,%r12d
}
  804160924e:	44 89 e0             	mov    %r12d,%eax
  8041609251:	48 83 c4 08          	add    $0x8,%rsp
  8041609255:	5b                   	pop    %rbx
  8041609256:	41 5c                	pop    %r12
  8041609258:	41 5d                	pop    %r13
  804160925a:	41 5e                	pop    %r14
  804160925c:	41 5f                	pop    %r15
  804160925e:	5d                   	pop    %rbp
  804160925f:	c3                   	ret    

0000008041609260 <alloc_composite_page>:

/* Allocate page (possibly physically discontiguous) and map it to address space */
int
alloc_composite_page(struct AddressSpace *spc, uintptr_t addr, int class, int flags) {
  8041609260:	55                   	push   %rbp
  8041609261:	48 89 e5             	mov    %rsp,%rbp
  8041609264:	41 57                	push   %r15
  8041609266:	41 56                	push   %r14
  8041609268:	41 55                	push   %r13
  804160926a:	41 54                	push   %r12
  804160926c:	53                   	push   %rbx
  804160926d:	48 83 ec 18          	sub    $0x18,%rsp
  8041609271:	41 89 ce             	mov    %ecx,%r14d
    int res = -E_NO_MEM;

    assert(!(addr & CLASS_MASK(class)));
  8041609274:	8d 4a 0c             	lea    0xc(%rdx),%ecx
  8041609277:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  804160927e:	48 d3 e0             	shl    %cl,%rax
  8041609281:	48 f7 d0             	not    %rax
  8041609284:	48 85 f0             	test   %rsi,%rax
  8041609287:	75 4b                	jne    80416092d4 <alloc_composite_page+0x74>
  8041609289:	49 89 ff             	mov    %rdi,%r15
  804160928c:	49 89 f5             	mov    %rsi,%r13
  804160928f:	89 d3                	mov    %edx,%ebx

    struct Page *page = alloc_page(class, flags);
  8041609291:	44 89 f6             	mov    %r14d,%esi
  8041609294:	89 d7                	mov    %edx,%edi
  8041609296:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  804160929d:	00 00 00 
  80416092a0:	ff d0                	call   *%rax
    if (page) {
  80416092a2:	48 85 c0             	test   %rax,%rax
  80416092a5:	74 62                	je     8041609309 <alloc_composite_page+0xa9>
        res = map_page(spc, addr, page, flags);
  80416092a7:	44 89 f1             	mov    %r14d,%ecx
  80416092aa:	48 89 c2             	mov    %rax,%rdx
  80416092ad:	4c 89 ee             	mov    %r13,%rsi
  80416092b0:	4c 89 ff             	mov    %r15,%rdi
  80416092b3:	48 b8 49 76 60 41 80 	movabs $0x8041607649,%rax
  80416092ba:	00 00 00 
  80416092bd:	ff d0                	call   *%rax
  80416092bf:	41 89 c4             	mov    %eax,%r12d
        if ((res = alloc_composite_page(spc, addr + CLASS_SIZE(class - 1), class - 1, flags)) < 0)
            unmap_page(spc, addr, class - 1);
    }

    return res;
}
  80416092c2:	44 89 e0             	mov    %r12d,%eax
  80416092c5:	48 83 c4 18          	add    $0x18,%rsp
  80416092c9:	5b                   	pop    %rbx
  80416092ca:	41 5c                	pop    %r12
  80416092cc:	41 5d                	pop    %r13
  80416092ce:	41 5e                	pop    %r14
  80416092d0:	41 5f                	pop    %r15
  80416092d2:	5d                   	pop    %rbp
  80416092d3:	c3                   	ret    
    assert(!(addr & CLASS_MASK(class)));
  80416092d4:	48 b9 02 1d 61 41 80 	movabs $0x8041611d02,%rcx
  80416092db:	00 00 00 
  80416092de:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416092e5:	00 00 00 
  80416092e8:	be c5 04 00 00       	mov    $0x4c5,%esi
  80416092ed:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416092f4:	00 00 00 
  80416092f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80416092fc:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609303:	00 00 00 
  8041609306:	41 ff d0             	call   *%r8
    } else if (class) {
  8041609309:	85 db                	test   %ebx,%ebx
  804160930b:	74 6c                	je     8041609379 <alloc_composite_page+0x119>
        if ((res = alloc_composite_page(spc, addr, class - 1, flags)) < 0) return res;
  804160930d:	8d 43 ff             	lea    -0x1(%rbx),%eax
  8041609310:	44 89 f1             	mov    %r14d,%ecx
  8041609313:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8041609316:	89 c2                	mov    %eax,%edx
  8041609318:	4c 89 ee             	mov    %r13,%rsi
  804160931b:	4c 89 ff             	mov    %r15,%rdi
  804160931e:	48 b8 60 92 60 41 80 	movabs $0x8041609260,%rax
  8041609325:	00 00 00 
  8041609328:	ff d0                	call   *%rax
  804160932a:	41 89 c4             	mov    %eax,%r12d
  804160932d:	85 c0                	test   %eax,%eax
  804160932f:	78 91                	js     80416092c2 <alloc_composite_page+0x62>
        if ((res = alloc_composite_page(spc, addr + CLASS_SIZE(class - 1), class - 1, flags)) < 0)
  8041609331:	8d 4b 0b             	lea    0xb(%rbx),%ecx
  8041609334:	be 01 00 00 00       	mov    $0x1,%esi
  8041609339:	48 d3 e6             	shl    %cl,%rsi
  804160933c:	4c 01 ee             	add    %r13,%rsi
  804160933f:	44 89 f1             	mov    %r14d,%ecx
  8041609342:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8041609345:	4c 89 ff             	mov    %r15,%rdi
  8041609348:	48 b8 60 92 60 41 80 	movabs $0x8041609260,%rax
  804160934f:	00 00 00 
  8041609352:	ff d0                	call   *%rax
  8041609354:	41 89 c4             	mov    %eax,%r12d
  8041609357:	85 c0                	test   %eax,%eax
  8041609359:	0f 89 63 ff ff ff    	jns    80416092c2 <alloc_composite_page+0x62>
            unmap_page(spc, addr, class - 1);
  804160935f:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8041609362:	4c 89 ee             	mov    %r13,%rsi
  8041609365:	4c 89 ff             	mov    %r15,%rdi
  8041609368:	48 b8 0b 6e 60 41 80 	movabs $0x8041606e0b,%rax
  804160936f:	00 00 00 
  8041609372:	ff d0                	call   *%rax
  8041609374:	e9 49 ff ff ff       	jmp    80416092c2 <alloc_composite_page+0x62>
    int res = -E_NO_MEM;
  8041609379:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
  804160937f:	e9 3e ff ff ff       	jmp    80416092c2 <alloc_composite_page+0x62>

0000008041609384 <release_address_space>:
    }
    return 0;
}

void
release_address_space(struct AddressSpace *space) {
  8041609384:	55                   	push   %rbp
  8041609385:	48 89 e5             	mov    %rsp,%rbp
  8041609388:	41 57                	push   %r15
  804160938a:	41 56                	push   %r14
  804160938c:	41 55                	push   %r13
  804160938e:	41 54                	push   %r12
  8041609390:	53                   	push   %rbx
  8041609391:	48 83 ec 18          	sub    $0x18,%rsp
  8041609395:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    /* NOTE: This function should not be called for kspace */

    /* Manually unref level 3 kernel page tables */
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  8041609399:	bb 01 00 00 00       	mov    $0x1,%ebx
        if (kspace.pml4[i] & PTE_P && i != UVPT_INDEX)
  804160939e:	49 bc b0 00 40 42 80 	movabs $0x80424000b0,%r12
  80416093a5:	00 00 00 
            page_unref(page_lookup(NULL, PTE_ADDR(kspace.pml4[i]), 0, PARTIAL_NODE, 0));
  80416093a8:	49 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%r15
  80416093af:	ff ff 7f 
  80416093b2:	49 be 03 59 60 41 80 	movabs $0x8041605903,%r14
  80416093b9:	00 00 00 
  80416093bc:	49 bd b1 48 60 41 80 	movabs $0x80416048b1,%r13
  80416093c3:	00 00 00 
  80416093c6:	eb 2e                	jmp    80416093f6 <release_address_space+0x72>
  80416093c8:	4c 21 fe             	and    %r15,%rsi
  80416093cb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80416093d1:	b9 00 00 30 00       	mov    $0x300000,%ecx
  80416093d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80416093db:	bf 00 00 00 00       	mov    $0x0,%edi
  80416093e0:	41 ff d6             	call   *%r14
  80416093e3:	48 89 c7             	mov    %rax,%rdi
  80416093e6:	41 ff d5             	call   *%r13
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  80416093e9:	48 83 c3 01          	add    $0x1,%rbx
  80416093ed:	48 81 fb 00 02 00 00 	cmp    $0x200,%rbx
  80416093f4:	74 16                	je     804160940c <release_address_space+0x88>
        if (kspace.pml4[i] & PTE_P && i != UVPT_INDEX)
  80416093f6:	49 8b 04 24          	mov    (%r12),%rax
  80416093fa:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  80416093fe:	40 f6 c6 01          	test   $0x1,%sil
  8041609402:	74 e5                	je     80416093e9 <release_address_space+0x65>
  8041609404:	48 83 fb 02          	cmp    $0x2,%rbx
  8041609408:	74 df                	je     80416093e9 <release_address_space+0x65>
  804160940a:	eb bc                	jmp    80416093c8 <release_address_space+0x44>
    /* Unmap all memory from the space
     * (kernel is cheating and does not store
     *  metadata for upper part of address space (privileged)
     *  in tree and only in page tables for user address spaces,
     *  so unmapping is safe) */
    unmap_page(space, 0, MAX_CLASS);
  804160940c:	ba 30 00 00 00       	mov    $0x30,%edx
  8041609411:	be 00 00 00 00       	mov    $0x0,%esi
  8041609416:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804160941a:	48 89 df             	mov    %rbx,%rdi
  804160941d:	48 b8 0b 6e 60 41 80 	movabs $0x8041606e0b,%rax
  8041609424:	00 00 00 
  8041609427:	ff d0                	call   *%rax

    /* Also unmap PML4 itself since it is never deallocated by page_uname*/
    page_unref(page_lookup(NULL, space->cr3, 0, PARTIAL_NODE, 0));
  8041609429:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  804160942d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8041609433:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8041609438:	ba 00 00 00 00       	mov    $0x0,%edx
  804160943d:	bf 00 00 00 00       	mov    $0x0,%edi
  8041609442:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  8041609449:	00 00 00 
  804160944c:	ff d0                	call   *%rax
  804160944e:	48 89 c7             	mov    %rax,%rdi
  8041609451:	48 b8 b1 48 60 41 80 	movabs $0x80416048b1,%rax
  8041609458:	00 00 00 
  804160945b:	ff d0                	call   *%rax

    /* Zero-out metadata */
    memset(space, 0, sizeof *space);
  804160945d:	ba 18 00 00 00       	mov    $0x18,%edx
  8041609462:	be 00 00 00 00       	mov    $0x0,%esi
  8041609467:	48 89 df             	mov    %rbx,%rdi
  804160946a:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041609471:	00 00 00 
  8041609474:	ff d0                	call   *%rax
}
  8041609476:	48 83 c4 18          	add    $0x18,%rsp
  804160947a:	5b                   	pop    %rbx
  804160947b:	41 5c                	pop    %r12
  804160947d:	41 5d                	pop    %r13
  804160947f:	41 5e                	pop    %r14
  8041609481:	41 5f                	pop    %r15
  8041609483:	5d                   	pop    %rbp
  8041609484:	c3                   	ret    

0000008041609485 <switch_address_space>:
 *
 * Returns old address space
 */
struct AddressSpace *
switch_address_space(struct AddressSpace *space) {
    assert(space);
  8041609485:	48 85 ff             	test   %rdi,%rdi
  8041609488:	74 2a                	je     80416094b4 <switch_address_space+0x2f>
    ///LAB 7: Your code here
    if (space == current_space)
  804160948a:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  8041609491:	00 00 00 
  8041609494:	48 8b 10             	mov    (%rax),%rdx
  8041609497:	48 39 fa             	cmp    %rdi,%rdx
  804160949a:	74 14                	je     80416094b0 <switch_address_space+0x2b>
        return current_space;
    struct AddressSpace *old_addr_space = current_space;
    current_space = space;
  804160949c:	48 89 f8             	mov    %rdi,%rax
  804160949f:	48 a3 a0 00 40 42 80 	movabs %rax,0x80424000a0
  80416094a6:	00 00 00 
    asm volatile("movq %0,%%cr3" ::"r"(val));
  80416094a9:	48 8b 47 08          	mov    0x8(%rdi),%rax
  80416094ad:	0f 22 d8             	mov    %rax,%cr3
    lcr3(space->cr3);
    return old_addr_space;
}
  80416094b0:	48 89 d0             	mov    %rdx,%rax
  80416094b3:	c3                   	ret    
switch_address_space(struct AddressSpace *space) {
  80416094b4:	55                   	push   %rbp
  80416094b5:	48 89 e5             	mov    %rsp,%rbp
    assert(space);
  80416094b8:	48 b9 fe 1d 61 41 80 	movabs $0x8041611dfe,%rcx
  80416094bf:	00 00 00 
  80416094c2:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416094c9:	00 00 00 
  80416094cc:	be e7 05 00 00       	mov    $0x5e7,%esi
  80416094d1:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416094d8:	00 00 00 
  80416094db:	b8 00 00 00 00       	mov    $0x0,%eax
  80416094e0:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416094e7:	00 00 00 
  80416094ea:	41 ff d0             	call   *%r8

00000080416094ed <force_alloc_page>:
force_alloc_page(struct AddressSpace *spc, uintptr_t va, int maxclass) {
  80416094ed:	55                   	push   %rbp
  80416094ee:	48 89 e5             	mov    %rsp,%rbp
  80416094f1:	41 57                	push   %r15
  80416094f3:	41 56                	push   %r14
  80416094f5:	41 55                	push   %r13
  80416094f7:	41 54                	push   %r12
  80416094f9:	53                   	push   %rbx
  80416094fa:	48 83 ec 18          	sub    $0x18,%rsp
    assert(current_space);
  80416094fe:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  8041609505:	00 00 00 
  8041609508:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160950c:	0f 84 74 01 00 00    	je     8041609686 <force_alloc_page+0x199>
  8041609512:	48 89 fb             	mov    %rdi,%rbx
  8041609515:	49 89 f6             	mov    %rsi,%r14
  8041609518:	41 89 d4             	mov    %edx,%r12d
    old = switch_address_space(spc = (va > MAX_USER_ADDRESS ? &kspace : spc));
  804160951b:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  8041609522:	00 00 00 
  8041609525:	48 39 c6             	cmp    %rax,%rsi
  8041609528:	48 b8 b0 00 40 42 80 	movabs $0x80424000b0,%rax
  804160952f:	00 00 00 
  8041609532:	48 0f 47 d8          	cmova  %rax,%rbx
  8041609536:	48 89 df             	mov    %rbx,%rdi
  8041609539:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  8041609540:	00 00 00 
  8041609543:	ff d0                	call   *%rax
  8041609545:	49 89 c7             	mov    %rax,%r15
    if (!(page = page_lookup_virtual(spc->root, va, maxclass, LOOKUP_SPLIT))) goto fault;
  8041609548:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  804160954c:	b9 02 00 00 00       	mov    $0x2,%ecx
  8041609551:	44 89 e2             	mov    %r12d,%edx
  8041609554:	4c 89 f6             	mov    %r14,%rsi
  8041609557:	48 b8 8e 6a 60 41 80 	movabs $0x8041606a8e,%rax
  804160955e:	00 00 00 
  8041609561:	ff d0                	call   *%rax
  8041609563:	48 85 c0             	test   %rax,%rax
  8041609566:	0f 84 04 03 00 00    	je     8041609870 <force_alloc_page+0x383>
    if (!(page = page_lookup_virtual(spc->root, va, 0, LOOKUP_PRESERVE))) goto fault;
  804160956c:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8041609570:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041609575:	ba 00 00 00 00       	mov    $0x0,%edx
  804160957a:	4c 89 f6             	mov    %r14,%rsi
  804160957d:	48 b8 8e 6a 60 41 80 	movabs $0x8041606a8e,%rax
  8041609584:	00 00 00 
  8041609587:	ff d0                	call   *%rax
  8041609589:	49 89 c5             	mov    %rax,%r13
  804160958c:	48 85 c0             	test   %rax,%rax
  804160958f:	0f 84 db 02 00 00    	je     8041609870 <force_alloc_page+0x383>
    if (!(page->state & PROT_LAZY)) goto fault;
  8041609595:	8b 40 28             	mov    0x28(%rax),%eax
  8041609598:	a8 80                	test   $0x80,%al
  804160959a:	0f 84 d0 02 00 00    	je     8041609870 <force_alloc_page+0x383>
    va &= ~CLASS_MASK(page->phy->class);
  80416095a0:	4d 8b 65 30          	mov    0x30(%r13),%r12
  80416095a4:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  80416095aa:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  80416095b0:	83 c1 0c             	add    $0xc,%ecx
  80416095b3:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
  80416095ba:	48 d3 e6             	shl    %cl,%rsi
  80416095bd:	49 21 f6             	and    %rsi,%r14
    if (PAGE_IS_UNIQ(page->phy)) {
  80416095c0:	41 83 7c 24 30 01    	cmpl   $0x1,0x30(%r12)
  80416095c6:	75 0c                	jne    80416095d4 <force_alloc_page+0xe7>
  80416095c8:	49 83 7c 24 10 00    	cmpq   $0x0,0x10(%r12)
  80416095ce:	0f 84 e7 00 00 00    	je     80416096bb <force_alloc_page+0x1ce>
        page_ref(phy);
  80416095d4:	4c 89 e7             	mov    %r12,%rdi
  80416095d7:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  80416095de:	00 00 00 
  80416095e1:	ff d0                	call   *%rax
        res = alloc_composite_page(spc, va, phy->class, page->state & PROT_ALL & ~PROT_LAZY);
  80416095e3:	41 8b 4d 28          	mov    0x28(%r13),%ecx
  80416095e7:	81 e1 7f 0f 00 00    	and    $0xf7f,%ecx
  80416095ed:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  80416095f3:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  80416095f9:	4c 89 f6             	mov    %r14,%rsi
  80416095fc:	48 89 df             	mov    %rbx,%rdi
  80416095ff:	48 b8 60 92 60 41 80 	movabs $0x8041609260,%rax
  8041609606:	00 00 00 
  8041609609:	ff d0                	call   *%rax
  804160960b:	41 89 c5             	mov    %eax,%r13d
        if (!res) memcpy_page(spc, va, phy);
  804160960e:	85 c0                	test   %eax,%eax
  8041609610:	0f 84 d2 00 00 00    	je     80416096e8 <force_alloc_page+0x1fb>
        page_unref(phy);
  8041609616:	4c 89 e7             	mov    %r12,%rdi
  8041609619:	48 b8 b1 48 60 41 80 	movabs $0x80416048b1,%rax
  8041609620:	00 00 00 
  8041609623:	ff d0                	call   *%rax
    switch_address_space(old);
  8041609625:	4c 89 ff             	mov    %r15,%rdi
  8041609628:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160962f:	00 00 00 
  8041609632:	ff d0                	call   *%rax
    if (res == -E_NO_MEM) {
  8041609634:	41 83 fd fc          	cmp    $0xfffffffc,%r13d
  8041609638:	0f 84 d4 01 00 00    	je     8041609812 <force_alloc_page+0x325>
        assert(!res || res == -E_FAULT);
  804160963e:	45 85 ed             	test   %r13d,%r13d
  8041609641:	0f 84 ed 01 00 00    	je     8041609834 <force_alloc_page+0x347>
  8041609647:	41 83 fd f9          	cmp    $0xfffffff9,%r13d
  804160964b:	0f 84 e3 01 00 00    	je     8041609834 <force_alloc_page+0x347>
  8041609651:	48 b9 04 1e 61 41 80 	movabs $0x8041611e04,%rcx
  8041609658:	00 00 00 
  804160965b:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609662:	00 00 00 
  8041609665:	be 08 05 00 00       	mov    $0x508,%esi
  804160966a:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609671:	00 00 00 
  8041609674:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609679:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609680:	00 00 00 
  8041609683:	41 ff d0             	call   *%r8
    assert(current_space);
  8041609686:	48 b9 f6 1d 61 41 80 	movabs $0x8041611df6,%rcx
  804160968d:	00 00 00 
  8041609690:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609697:	00 00 00 
  804160969a:	be e1 04 00 00       	mov    $0x4e1,%esi
  804160969f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416096a6:	00 00 00 
  80416096a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80416096ae:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416096b5:	00 00 00 
  80416096b8:	41 ff d0             	call   *%r8
    if (PAGE_IS_UNIQ(page->phy)) {
  80416096bb:	49 83 7c 24 18 00    	cmpq   $0x0,0x18(%r12)
  80416096c1:	0f 85 0d ff ff ff    	jne    80416095d4 <force_alloc_page+0xe7>
        res = map_page(spc, va, page->phy, page->state & ~PROT_LAZY);
  80416096c7:	24 7f                	and    $0x7f,%al
  80416096c9:	89 c1                	mov    %eax,%ecx
  80416096cb:	4c 89 e2             	mov    %r12,%rdx
  80416096ce:	4c 89 f6             	mov    %r14,%rsi
  80416096d1:	48 89 df             	mov    %rbx,%rdi
  80416096d4:	48 b8 49 76 60 41 80 	movabs $0x8041607649,%rax
  80416096db:	00 00 00 
  80416096de:	ff d0                	call   *%rax
  80416096e0:	41 89 c5             	mov    %eax,%r13d
  80416096e3:	e9 3d ff ff ff       	jmp    8041609625 <force_alloc_page+0x138>
    assert(current_space);
  80416096e8:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  80416096ef:	00 00 00 
  80416096f2:	48 83 38 00          	cmpq   $0x0,(%rax)
  80416096f6:	0f 84 b0 00 00 00    	je     80416097ac <force_alloc_page+0x2bf>
   struct AddressSpace *old = switch_address_space(dst);
  80416096fc:	48 89 df             	mov    %rbx,%rdi
  80416096ff:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  8041609706:	00 00 00 
  8041609709:	ff d0                	call   *%rax
  804160970b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    asm volatile("movq %%cr0,%0"
  804160970f:	0f 20 c0             	mov    %cr0,%rax
   if (old_cr0 & CR0_WP) 
  8041609712:	25 00 00 01 00       	and    $0x10000,%eax
  8041609717:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160971b:	74 0c                	je     8041609729 <force_alloc_page+0x23c>
  804160971d:	0f 20 c0             	mov    %cr0,%rax
}

inline static void
set_wp(bool wp) {
    uintptr_t old = rcr0();
    lcr0(wp ? old | CR0_WP : old & ~CR0_WP);
  8041609720:	48 25 ff ff fe ff    	and    $0xfffffffffffeffff,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  8041609726:	0f 22 c0             	mov    %rax,%cr0
   nosan_memcpy((void*)va, KADDR(page2pa(page)), CLASS_SIZE(page->class));
  8041609729:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  804160972f:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041609735:	83 c1 0c             	add    $0xc,%ecx
  8041609738:	ba 01 00 00 00       	mov    $0x1,%edx
  804160973d:	48 d3 e2             	shl    %cl,%rdx
    return page->addr << CLASS_BASE;
  8041609740:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8041609747:	ff 0f 00 
  804160974a:	48 89 c6             	mov    %rax,%rsi
  804160974d:	49 23 74 24 38       	and    0x38(%r12),%rsi
  8041609752:	48 c1 e6 0c          	shl    $0xc,%rsi
  8041609756:	48 21 c6             	and    %rax,%rsi
    if (pa > max_memory_map_addr)
  8041609759:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  8041609760:	00 00 00 
  8041609763:	48 39 c6             	cmp    %rax,%rsi
  8041609766:	77 79                	ja     80416097e1 <force_alloc_page+0x2f4>
    return (void *)(pa + KERN_BASE_ADDR);
  8041609768:	48 b9 00 00 00 40 80 	movabs $0x8040000000,%rcx
  804160976f:	00 00 00 
  8041609772:	48 01 ce             	add    %rcx,%rsi
  8041609775:	4c 89 f7             	mov    %r14,%rdi
  8041609778:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160977f:	00 00 00 
  8041609782:	ff d0                	call   *%rax
   if (old_cr0 & CR0_WP) 
  8041609784:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8041609789:	74 0c                	je     8041609797 <force_alloc_page+0x2aa>
    asm volatile("movq %%cr0,%0"
  804160978b:	0f 20 c0             	mov    %cr0,%rax
    lcr0(wp ? old | CR0_WP : old & ~CR0_WP);
  804160978e:	48 0d 00 00 01 00    	or     $0x10000,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  8041609794:	0f 22 c0             	mov    %rax,%cr0
   switch_address_space(old);
  8041609797:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160979b:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  80416097a2:	00 00 00 
  80416097a5:	ff d0                	call   *%rax
}
  80416097a7:	e9 6a fe ff ff       	jmp    8041609616 <force_alloc_page+0x129>
    assert(current_space);
  80416097ac:	48 b9 f6 1d 61 41 80 	movabs $0x8041611df6,%rcx
  80416097b3:	00 00 00 
  80416097b6:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  80416097bd:	00 00 00 
  80416097c0:	be 27 03 00 00       	mov    $0x327,%esi
  80416097c5:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416097cc:	00 00 00 
  80416097cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80416097d4:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416097db:	00 00 00 
  80416097de:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  80416097e1:	49 89 c0             	mov    %rax,%r8
  80416097e4:	48 89 f1             	mov    %rsi,%rcx
  80416097e7:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  80416097ee:	00 00 00 
  80416097f1:	be 2f 03 00 00       	mov    $0x32f,%esi
  80416097f6:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416097fd:	00 00 00 
  8041609800:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609805:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160980c:	00 00 00 
  804160980f:	41 ff d1             	call   *%r9
        if (spc != &kspace) {
  8041609812:	48 b8 b0 00 40 42 80 	movabs $0x80424000b0,%rax
  8041609819:	00 00 00 
  804160981c:	48 39 c3             	cmp    %rax,%rbx
  804160981f:	74 25                	je     8041609846 <force_alloc_page+0x359>
            struct Env *env = (void *)((uint8_t *)spc - offsetof(struct Env, address_space));
  8041609821:	48 8d bb 18 ff ff ff 	lea    -0xe8(%rbx),%rdi
            env_destroy(env);
  8041609828:	48 b8 5e c0 60 41 80 	movabs $0x804160c05e,%rax
  804160982f:	00 00 00 
  8041609832:	ff d0                	call   *%rax
}
  8041609834:	44 89 e8             	mov    %r13d,%eax
  8041609837:	48 83 c4 18          	add    $0x18,%rsp
  804160983b:	5b                   	pop    %rbx
  804160983c:	41 5c                	pop    %r12
  804160983e:	41 5d                	pop    %r13
  8041609840:	41 5e                	pop    %r14
  8041609842:	41 5f                	pop    %r15
  8041609844:	5d                   	pop    %rbp
  8041609845:	c3                   	ret    
            panic("Out of memory\n");
  8041609846:	48 ba da 1c 61 41 80 	movabs $0x8041611cda,%rdx
  804160984d:	00 00 00 
  8041609850:	be 06 05 00 00       	mov    $0x506,%esi
  8041609855:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160985c:	00 00 00 
  804160985f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609864:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160986b:	00 00 00 
  804160986e:	ff d1                	call   *%rcx
    switch_address_space(old);
  8041609870:	4c 89 ff             	mov    %r15,%rdi
  8041609873:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160987a:	00 00 00 
  804160987d:	ff d0                	call   *%rax
  804160987f:	41 bd f9 ff ff ff    	mov    $0xfffffff9,%r13d
  8041609885:	eb ad                	jmp    8041609834 <force_alloc_page+0x347>

0000008041609887 <do_map_page>:
do_map_page(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, struct Page *phy, int oldflags, int flags) {
  8041609887:	55                   	push   %rbp
  8041609888:	48 89 e5             	mov    %rsp,%rbp
  804160988b:	41 57                	push   %r15
  804160988d:	41 56                	push   %r14
  804160988f:	41 55                	push   %r13
  8041609891:	41 54                	push   %r12
  8041609893:	53                   	push   %rbx
  8041609894:	48 83 ec 28          	sub    $0x28,%rsp
  8041609898:	49 89 ff             	mov    %rdi,%r15
  804160989b:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804160989f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80416098a3:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80416098a7:	4d 89 c5             	mov    %r8,%r13
  80416098aa:	45 89 cc             	mov    %r9d,%r12d
  80416098ad:	8b 5d 10             	mov    0x10(%rbp),%ebx
    if (flags & PROT_COMBINE) {
  80416098b0:	f6 c7 01             	test   $0x1,%bh
  80416098b3:	74 13                	je     80416098c8 <do_map_page+0x41>
            flags &= oldflags;
  80416098b5:	89 da                	mov    %ebx,%edx
  80416098b7:	44 21 ca             	and    %r9d,%edx
  80416098ba:	44 89 c8             	mov    %r9d,%eax
  80416098bd:	0c 80                	or     $0x80,%al
  80416098bf:	21 c3                	and    %eax,%ebx
  80416098c1:	41 f6 c1 40          	test   $0x40,%r9b
  80416098c5:	0f 45 da             	cmovne %edx,%ebx
    assert(!(oldflags & PROT_LAZY) | !(oldflags & PROT_SHARE));
  80416098c8:	44 89 e0             	mov    %r12d,%eax
  80416098cb:	25 c0 00 00 00       	and    $0xc0,%eax
  80416098d0:	3d c0 00 00 00       	cmp    $0xc0,%eax
  80416098d5:	74 7f                	je     8041609956 <do_map_page+0xcf>
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  80416098d7:	89 d8                	mov    %ebx,%eax
  80416098d9:	25 c0 00 00 00       	and    $0xc0,%eax
  80416098de:	3d c0 00 00 00       	cmp    $0xc0,%eax
  80416098e3:	0f 84 a2 00 00 00    	je     804160998b <do_map_page+0x104>
    if (!(flags & PROT_LAZY) && ~oldflags &
  80416098e9:	f6 c3 80             	test   $0x80,%bl
  80416098ec:	0f 85 fa 01 00 00    	jne    8041609aec <do_map_page+0x265>
  80416098f2:	44 89 e0             	mov    %r12d,%eax
  80416098f5:	f7 d0                	not    %eax
                                        (PROT_R | PROT_W | PROT_X) & flags) return -E_INVAL;
  80416098f7:	21 d8                	and    %ebx,%eax
    if (!(flags & PROT_LAZY) && ~oldflags &
  80416098f9:	a8 07                	test   $0x7,%al
  80416098fb:	0f 85 e0 01 00 00    	jne    8041609ae1 <do_map_page+0x25a>
    if (!(flags & PROT_LAZY) && (oldflags & PROT_LAZY)) {
  8041609901:	41 f6 c4 80          	test   $0x80,%r12b
  8041609905:	0f 85 b5 00 00 00    	jne    80416099c0 <do_map_page+0x139>
    page_ref(phy);
  804160990b:	4c 89 ef             	mov    %r13,%rdi
  804160990e:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  8041609915:	00 00 00 
  8041609918:	ff d0                	call   *%rax
    res = map_page(dspace, dst, phy, flags);
  804160991a:	89 d9                	mov    %ebx,%ecx
  804160991c:	4c 89 ea             	mov    %r13,%rdx
  804160991f:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8041609923:	4c 89 ff             	mov    %r15,%rdi
  8041609926:	48 b8 49 76 60 41 80 	movabs $0x8041607649,%rax
  804160992d:	00 00 00 
  8041609930:	ff d0                	call   *%rax
  8041609932:	41 89 c6             	mov    %eax,%r14d
    page_unref(phy);
  8041609935:	4c 89 ef             	mov    %r13,%rdi
  8041609938:	48 b8 b1 48 60 41 80 	movabs $0x80416048b1,%rax
  804160993f:	00 00 00 
  8041609942:	ff d0                	call   *%rax
}
  8041609944:	44 89 f0             	mov    %r14d,%eax
  8041609947:	48 83 c4 28          	add    $0x28,%rsp
  804160994b:	5b                   	pop    %rbx
  804160994c:	41 5c                	pop    %r12
  804160994e:	41 5d                	pop    %r13
  8041609950:	41 5e                	pop    %r14
  8041609952:	41 5f                	pop    %r15
  8041609954:	5d                   	pop    %rbp
  8041609955:	c3                   	ret    
    assert(!(oldflags & PROT_LAZY) | !(oldflags & PROT_SHARE));
  8041609956:	48 b9 60 27 61 41 80 	movabs $0x8041612760,%rcx
  804160995d:	00 00 00 
  8041609960:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609967:	00 00 00 
  804160996a:	be 18 05 00 00       	mov    $0x518,%esi
  804160996f:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609976:	00 00 00 
  8041609979:	b8 00 00 00 00       	mov    $0x0,%eax
  804160997e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609985:	00 00 00 
  8041609988:	41 ff d0             	call   *%r8
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  804160998b:	48 b9 d8 25 61 41 80 	movabs $0x80416125d8,%rcx
  8041609992:	00 00 00 
  8041609995:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160999c:	00 00 00 
  804160999f:	be 19 05 00 00       	mov    $0x519,%esi
  80416099a4:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  80416099ab:	00 00 00 
  80416099ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80416099b3:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  80416099ba:	00 00 00 
  80416099bd:	41 ff d0             	call   *%r8
        int class = phy->class;
  80416099c0:	45 0f b7 65 34       	movzwl 0x34(%r13),%r12d
  80416099c5:	66 41 81 e4 ff 0f    	and    $0xfff,%r12w
        res = force_alloc_page(sspace, src, MAX_CLASS);
  80416099cb:	ba 30 00 00 00       	mov    $0x30,%edx
  80416099d0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80416099d4:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
  80416099d8:	4c 89 ef             	mov    %r13,%rdi
  80416099db:	48 b8 ed 94 60 41 80 	movabs $0x80416094ed,%rax
  80416099e2:	00 00 00 
  80416099e5:	ff d0                	call   *%rax
  80416099e7:	41 89 c6             	mov    %eax,%r14d
        if (res < 0 || (sspace == dspace && src == dst)) return res;
  80416099ea:	85 c0                	test   %eax,%eax
  80416099ec:	0f 88 52 ff ff ff    	js     8041609944 <do_map_page+0xbd>
  80416099f2:	4d 39 fd             	cmp    %r15,%r13
  80416099f5:	75 0e                	jne    8041609a05 <do_map_page+0x17e>
  80416099f7:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80416099fb:	48 39 75 c0          	cmp    %rsi,-0x40(%rbp)
  80416099ff:	0f 84 3f ff ff ff    	je     8041609944 <do_map_page+0xbd>
        int class = phy->class;
  8041609a05:	45 0f b7 e4          	movzwl %r12w,%r12d
        struct Page *newv = page_lookup_virtual(sspace->root, src, class, LOOKUP_PRESERVE);
  8041609a09:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8041609a0d:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8041609a11:	b9 00 00 00 00       	mov    $0x0,%ecx
  8041609a16:	44 89 e2             	mov    %r12d,%edx
  8041609a19:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8041609a1d:	48 b8 8e 6a 60 41 80 	movabs $0x8041606a8e,%rax
  8041609a24:	00 00 00 
  8041609a27:	ff d0                	call   *%rax
  8041609a29:	49 89 c5             	mov    %rax,%r13
        check_virtual_class(newv, class);
  8041609a2c:	44 89 e6             	mov    %r12d,%esi
  8041609a2f:	48 89 c7             	mov    %rax,%rdi
  8041609a32:	48 b8 e4 4c 60 41 80 	movabs $0x8041604ce4,%rax
  8041609a39:	00 00 00 
  8041609a3c:	ff d0                	call   *%rax
        assert(newv && newv->phy);
  8041609a3e:	4d 85 ed             	test   %r13,%r13
  8041609a41:	74 0d                	je     8041609a50 <do_map_page+0x1c9>
  8041609a43:	4d 8b 6d 30          	mov    0x30(%r13),%r13
  8041609a47:	4d 85 ed             	test   %r13,%r13
  8041609a4a:	0f 85 bb fe ff ff    	jne    804160990b <do_map_page+0x84>
  8041609a50:	48 b9 1c 1e 61 41 80 	movabs $0x8041611e1c,%rcx
  8041609a57:	00 00 00 
  8041609a5a:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609a61:	00 00 00 
  8041609a64:	be 37 05 00 00       	mov    $0x537,%esi
  8041609a69:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609a70:	00 00 00 
  8041609a73:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609a78:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609a7f:	00 00 00 
  8041609a82:	41 ff d0             	call   *%r8
    bool need_remap = (flags & PROT_LAZY) && (sspace != dspace || src != dst);
  8041609a85:	4c 39 7d b8          	cmp    %r15,-0x48(%rbp)
  8041609a89:	75 0e                	jne    8041609a99 <do_map_page+0x212>
  8041609a8b:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8041609a8f:	48 39 75 c0          	cmp    %rsi,-0x40(%rbp)
  8041609a93:	0f 84 81 fe ff ff    	je     804160991a <do_map_page+0x93>
    res = map_page(dspace, dst, phy, flags);
  8041609a99:	89 d9                	mov    %ebx,%ecx
  8041609a9b:	4c 89 ea             	mov    %r13,%rdx
  8041609a9e:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8041609aa2:	4c 89 ff             	mov    %r15,%rdi
  8041609aa5:	48 b8 49 76 60 41 80 	movabs $0x8041607649,%rax
  8041609aac:	00 00 00 
  8041609aaf:	ff d0                	call   *%rax
  8041609ab1:	41 89 c6             	mov    %eax,%r14d
    if (!res && need_remap) {
  8041609ab4:	85 c0                	test   %eax,%eax
  8041609ab6:	0f 85 79 fe ff ff    	jne    8041609935 <do_map_page+0xae>
        res = map_page(sspace, src, phy, oldflags | PROT_LAZY);
  8041609abc:	44 89 e1             	mov    %r12d,%ecx
  8041609abf:	80 c9 80             	or     $0x80,%cl
  8041609ac2:	4c 89 ea             	mov    %r13,%rdx
  8041609ac5:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8041609ac9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8041609acd:	48 b8 49 76 60 41 80 	movabs $0x8041607649,%rax
  8041609ad4:	00 00 00 
  8041609ad7:	ff d0                	call   *%rax
  8041609ad9:	41 89 c6             	mov    %eax,%r14d
  8041609adc:	e9 54 fe ff ff       	jmp    8041609935 <do_map_page+0xae>
                                        (PROT_R | PROT_W | PROT_X) & flags) return -E_INVAL;
  8041609ae1:	41 be fd ff ff ff    	mov    $0xfffffffd,%r14d
  8041609ae7:	e9 58 fe ff ff       	jmp    8041609944 <do_map_page+0xbd>
    page_ref(phy);
  8041609aec:	4c 89 ef             	mov    %r13,%rdi
  8041609aef:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  8041609af6:	00 00 00 
  8041609af9:	ff d0                	call   *%rax
    if (oldflags & PROT_SHARE && flags & PROT_LAZY)
  8041609afb:	41 f6 c4 40          	test   $0x40,%r12b
  8041609aff:	74 84                	je     8041609a85 <do_map_page+0x1fe>
        flags = (flags & ~PROT_LAZY) | PROT_SHARE;
  8041609b01:	80 e3 3f             	and    $0x3f,%bl
  8041609b04:	83 cb 40             	or     $0x40,%ebx
    bool need_remap = (flags & PROT_LAZY) && (sspace != dspace || src != dst);
  8041609b07:	e9 0e fe ff ff       	jmp    804160991a <do_map_page+0x93>

0000008041609b0c <do_map_subtree>:
do_map_subtree(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, struct Page *vpage, int class, int flags) {
  8041609b0c:	55                   	push   %rbp
  8041609b0d:	48 89 e5             	mov    %rsp,%rbp
  8041609b10:	41 57                	push   %r15
  8041609b12:	41 56                	push   %r14
  8041609b14:	41 55                	push   %r13
  8041609b16:	41 54                	push   %r12
  8041609b18:	53                   	push   %rbx
  8041609b19:	48 83 ec 18          	sub    $0x18,%rsp
  8041609b1d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8041609b21:	49 89 f5             	mov    %rsi,%r13
  8041609b24:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8041609b28:	49 89 ce             	mov    %rcx,%r14
  8041609b2b:	4c 89 c3             	mov    %r8,%rbx
  8041609b2e:	45 89 cc             	mov    %r9d,%r12d
    check_virtual_class(vpage, class);
  8041609b31:	44 89 ce             	mov    %r9d,%esi
  8041609b34:	4c 89 c7             	mov    %r8,%rdi
  8041609b37:	48 b8 e4 4c 60 41 80 	movabs $0x8041604ce4,%rax
  8041609b3e:	00 00 00 
  8041609b41:	ff d0                	call   *%rax
    while (!res && vpage) {
  8041609b43:	48 85 db             	test   %rbx,%rbx
  8041609b46:	0f 84 93 01 00 00    	je     8041609cdf <do_map_subtree+0x1d3>
        assert(class >= 0);
  8041609b4c:	45 85 e4             	test   %r12d,%r12d
  8041609b4f:	78 13                	js     8041609b64 <do_map_subtree+0x58>
  8041609b51:	41 83 ec 01          	sub    $0x1,%r12d
        if (vpage->left && (res = do_map_subtree(dspace, dst,
  8041609b55:	49 bf 0c 9b 60 41 80 	movabs $0x8041609b0c,%r15
  8041609b5c:	00 00 00 
  8041609b5f:	e9 2d 01 00 00       	jmp    8041609c91 <do_map_subtree+0x185>
        assert(class >= 0);
  8041609b64:	48 b9 87 1c 61 41 80 	movabs $0x8041611c87,%rcx
  8041609b6b:	00 00 00 
  8041609b6e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609b75:	00 00 00 
  8041609b78:	be 53 05 00 00       	mov    $0x553,%esi
  8041609b7d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609b84:	00 00 00 
  8041609b87:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609b8c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609b93:	00 00 00 
  8041609b96:	41 ff d0             	call   *%r8
            assert((vpage->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8041609b99:	44 8b 4b 28          	mov    0x28(%rbx),%r9d
  8041609b9d:	44 89 c8             	mov    %r9d,%eax
  8041609ba0:	25 00 00 f0 00       	and    $0xf00000,%eax
  8041609ba5:	3d 00 00 10 00       	cmp    $0x100000,%eax
  8041609baa:	75 40                	jne    8041609bec <do_map_subtree+0xe0>
            return do_map_page(dspace, dst, sspace, src,
  8041609bac:	48 83 ec 08          	sub    $0x8,%rsp
  8041609bb0:	8b 45 10             	mov    0x10(%rbp),%eax
  8041609bb3:	50                   	push   %rax
  8041609bb4:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
  8041609bbb:	4c 89 f1             	mov    %r14,%rcx
  8041609bbe:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8041609bc2:	4c 89 ee             	mov    %r13,%rsi
  8041609bc5:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041609bc9:	48 b8 87 98 60 41 80 	movabs $0x8041609887,%rax
  8041609bd0:	00 00 00 
  8041609bd3:	ff d0                	call   *%rax
  8041609bd5:	89 c2                	mov    %eax,%edx
  8041609bd7:	48 83 c4 10          	add    $0x10,%rsp
}
  8041609bdb:	89 d0                	mov    %edx,%eax
  8041609bdd:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  8041609be1:	5b                   	pop    %rbx
  8041609be2:	41 5c                	pop    %r12
  8041609be4:	41 5d                	pop    %r13
  8041609be6:	41 5e                	pop    %r14
  8041609be8:	41 5f                	pop    %r15
  8041609bea:	5d                   	pop    %rbp
  8041609beb:	c3                   	ret    
            assert((vpage->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8041609bec:	48 b9 98 27 61 41 80 	movabs $0x8041612798,%rcx
  8041609bf3:	00 00 00 
  8041609bf6:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609bfd:	00 00 00 
  8041609c00:	be 55 05 00 00       	mov    $0x555,%esi
  8041609c05:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609c0c:	00 00 00 
  8041609c0f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609c14:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609c1b:	00 00 00 
  8041609c1e:	41 ff d0             	call   *%r8
        assert(vpage->state == INTERMEDIATE_NODE);
  8041609c21:	48 b9 c8 27 61 41 80 	movabs $0x80416127c8,%rcx
  8041609c28:	00 00 00 
  8041609c2b:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609c32:	00 00 00 
  8041609c35:	be 59 05 00 00       	mov    $0x559,%esi
  8041609c3a:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609c41:	00 00 00 
  8041609c44:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609c49:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609c50:	00 00 00 
  8041609c53:	41 ff d0             	call   *%r8
  8041609c56:	ba 00 00 00 00       	mov    $0x0,%edx
        dst += CLASS_SIZE(class - 1);
  8041609c5b:	41 8d 4c 24 0c       	lea    0xc(%r12),%ecx
  8041609c60:	b8 01 00 00 00       	mov    $0x1,%eax
  8041609c65:	48 d3 e0             	shl    %cl,%rax
  8041609c68:	49 01 c5             	add    %rax,%r13
        src += CLASS_SIZE(class - 1);
  8041609c6b:	49 01 c6             	add    %rax,%r14
        vpage = vpage->right;
  8041609c6e:	48 8b 5b 18          	mov    0x18(%rbx),%rbx
    while (!res && vpage) {
  8041609c72:	85 d2                	test   %edx,%edx
  8041609c74:	0f 85 61 ff ff ff    	jne    8041609bdb <do_map_subtree+0xcf>
  8041609c7a:	48 85 db             	test   %rbx,%rbx
  8041609c7d:	0f 84 58 ff ff ff    	je     8041609bdb <do_map_subtree+0xcf>
        assert(class >= 0);
  8041609c83:	41 83 ec 01          	sub    $0x1,%r12d
  8041609c87:	41 83 fc fe          	cmp    $0xfffffffe,%r12d
  8041609c8b:	0f 84 d3 fe ff ff    	je     8041609b64 <do_map_subtree+0x58>
        if (vpage->phy) {
  8041609c91:	4c 8b 43 30          	mov    0x30(%rbx),%r8
  8041609c95:	4d 85 c0             	test   %r8,%r8
  8041609c98:	0f 85 fb fe ff ff    	jne    8041609b99 <do_map_subtree+0x8d>
        assert(vpage->state == INTERMEDIATE_NODE);
  8041609c9e:	81 7b 28 00 00 20 00 	cmpl   $0x200000,0x28(%rbx)
  8041609ca5:	0f 85 76 ff ff ff    	jne    8041609c21 <do_map_subtree+0x115>
        if (vpage->left && (res = do_map_subtree(dspace, dst,
  8041609cab:	4c 8b 43 10          	mov    0x10(%rbx),%r8
  8041609caf:	4d 85 c0             	test   %r8,%r8
  8041609cb2:	74 a2                	je     8041609c56 <do_map_subtree+0x14a>
  8041609cb4:	48 83 ec 08          	sub    $0x8,%rsp
  8041609cb8:	8b 45 10             	mov    0x10(%rbp),%eax
  8041609cbb:	50                   	push   %rax
  8041609cbc:	45 89 e1             	mov    %r12d,%r9d
  8041609cbf:	4c 89 f1             	mov    %r14,%rcx
  8041609cc2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8041609cc6:	4c 89 ee             	mov    %r13,%rsi
  8041609cc9:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8041609ccd:	41 ff d7             	call   *%r15
  8041609cd0:	89 c2                	mov    %eax,%edx
  8041609cd2:	48 83 c4 10          	add    $0x10,%rsp
  8041609cd6:	85 c0                	test   %eax,%eax
  8041609cd8:	79 81                	jns    8041609c5b <do_map_subtree+0x14f>
  8041609cda:	e9 fc fe ff ff       	jmp    8041609bdb <do_map_subtree+0xcf>
    int res = 0;
  8041609cdf:	ba 00 00 00 00       	mov    $0x0,%edx
  8041609ce4:	e9 f2 fe ff ff       	jmp    8041609bdb <do_map_subtree+0xcf>

0000008041609ce9 <do_map_region_one_page>:
do_map_region_one_page(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, int class, int flags) {
  8041609ce9:	55                   	push   %rbp
  8041609cea:	48 89 e5             	mov    %rsp,%rbp
  8041609ced:	41 57                	push   %r15
  8041609cef:	41 56                	push   %r14
  8041609cf1:	41 55                	push   %r13
  8041609cf3:	41 54                	push   %r12
  8041609cf5:	53                   	push   %rbx
  8041609cf6:	48 83 ec 28          	sub    $0x28,%rsp
  8041609cfa:	49 89 fd             	mov    %rdi,%r13
  8041609cfd:	48 89 f3             	mov    %rsi,%rbx
  8041609d00:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8041609d04:	49 89 cc             	mov    %rcx,%r12
  8041609d07:	45 89 c6             	mov    %r8d,%r14d
  8041609d0a:	45 89 cf             	mov    %r9d,%r15d
    if (dspace == sspace && src != dst) assert(ABSDIFF(dst, src) >= CLASS_SIZE(class));
  8041609d0d:	48 39 d7             	cmp    %rdx,%rdi
  8041609d10:	75 28                	jne    8041609d3a <do_map_region_one_page+0x51>
  8041609d12:	48 39 f1             	cmp    %rsi,%rcx
  8041609d15:	74 23                	je     8041609d3a <do_map_region_one_page+0x51>
  8041609d17:	48 89 f2             	mov    %rsi,%rdx
  8041609d1a:	48 29 ca             	sub    %rcx,%rdx
  8041609d1d:	48 89 c8             	mov    %rcx,%rax
  8041609d20:	48 29 f0             	sub    %rsi,%rax
  8041609d23:	48 39 f1             	cmp    %rsi,%rcx
  8041609d26:	48 0f 42 c2          	cmovb  %rdx,%rax
  8041609d2a:	41 8d 48 0c          	lea    0xc(%r8),%ecx
  8041609d2e:	48 d3 e8             	shr    %cl,%rax
  8041609d31:	48 85 c0             	test   %rax,%rax
  8041609d34:	0f 84 13 01 00 00    	je     8041609e4d <do_map_region_one_page+0x164>
    if (flags & (ALLOC_ONE | ALLOC_ZERO)) {
  8041609d3a:	41 f7 c7 00 00 30 00 	test   $0x300000,%r15d
  8041609d41:	0f 84 81 02 00 00    	je     8041609fc8 <do_map_region_one_page+0x2df>
        if (flags & PROT_SHARE) {
  8041609d47:	45 89 fc             	mov    %r15d,%r12d
  8041609d4a:	41 83 e4 40          	and    $0x40,%r12d
  8041609d4e:	0f 85 29 01 00 00    	jne    8041609e7d <do_map_region_one_page+0x194>
            struct Page *cpage = flags & ALLOC_ONE ? one_page : zero_page;
  8041609d54:	48 a1 00 41 40 42 80 	movabs 0x8042404100,%rax
  8041609d5b:	00 00 00 
  8041609d5e:	41 f7 c7 00 00 20 00 	test   $0x200000,%r15d
  8041609d65:	74 0a                	je     8041609d71 <do_map_region_one_page+0x88>
  8041609d67:	48 a1 f8 40 40 42 80 	movabs 0x80424040f8,%rax
  8041609d6e:	00 00 00 
            cpage = page_lookup(cpage, page2pa(cpage), MIN(class, MAX_ALLOCATION_CLASS), PARTIAL_NODE, 1);
  8041609d71:	41 83 fe 09          	cmp    $0x9,%r14d
  8041609d75:	b9 09 00 00 00       	mov    $0x9,%ecx
  8041609d7a:	89 cf                	mov    %ecx,%edi
  8041609d7c:	41 0f 4e fe          	cmovle %r14d,%edi
    return page->addr << CLASS_BASE;
  8041609d80:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8041609d87:	ff 0f 00 
  8041609d8a:	48 89 d6             	mov    %rdx,%rsi
  8041609d8d:	48 23 70 38          	and    0x38(%rax),%rsi
  8041609d91:	48 c1 e6 0c          	shl    $0xc,%rsi
  8041609d95:	48 21 d6             	and    %rdx,%rsi
  8041609d98:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8041609d9e:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8041609da3:	89 7d c0             	mov    %edi,-0x40(%rbp)
  8041609da6:	89 fa                	mov    %edi,%edx
  8041609da8:	48 89 c7             	mov    %rax,%rdi
  8041609dab:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  8041609db2:	00 00 00 
  8041609db5:	ff d0                	call   *%rax
  8041609db7:	48 89 c6             	mov    %rax,%rsi
  8041609dba:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (!cpage) return -E_NO_MEM;
  8041609dbe:	48 85 c0             	test   %rax,%rax
  8041609dc1:	0f 84 24 03 00 00    	je     804160a0eb <do_map_region_one_page+0x402>
            size_t size_inc = CLASS_SIZE(MIN(class, MAX_ALLOCATION_CLASS));
  8041609dc7:	8b 4d c0             	mov    -0x40(%rbp),%ecx
  8041609dca:	83 c1 0c             	add    $0xc,%ecx
  8041609dcd:	b8 01 00 00 00       	mov    $0x1,%eax
  8041609dd2:	48 89 c7             	mov    %rax,%rdi
  8041609dd5:	48 d3 e7             	shl    %cl,%rdi
  8041609dd8:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
            uintptr_t end = dst + CLASS_SIZE(class);
  8041609ddc:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
  8041609de0:	49 89 c6             	mov    %rax,%r14
  8041609de3:	49 d3 e6             	shl    %cl,%r14
  8041609de6:	49 01 de             	add    %rbx,%r14
            assert(CLASS_SIZE(cpage->class) == size_inc);
  8041609de9:	0f b7 4e 34          	movzwl 0x34(%rsi),%ecx
  8041609ded:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8041609df3:	83 c1 0c             	add    $0xc,%ecx
  8041609df6:	48 d3 e0             	shl    %cl,%rax
  8041609df9:	48 39 f8             	cmp    %rdi,%rax
  8041609dfc:	0f 85 91 01 00 00    	jne    8041609f93 <do_map_region_one_page+0x2aa>
                res = map_page(dspace, dst, cpage, (flags & PROT_ALL & ~PROT_COMBINE) | PROT_LAZY);
  8041609e02:	41 81 e7 7f 0e 00 00 	and    $0xe7f,%r15d
  8041609e09:	41 80 cf 80          	or     $0x80,%r15b
  8041609e0d:	44 89 7d bc          	mov    %r15d,-0x44(%rbp)
  8041609e11:	49 bf 49 76 60 41 80 	movabs $0x8041607649,%r15
  8041609e18:	00 00 00 
            while (dst < end && !res) {
  8041609e1b:	4c 39 f3             	cmp    %r14,%rbx
  8041609e1e:	0f 83 2b 02 00 00    	jae    804160a04f <do_map_region_one_page+0x366>
                res = map_page(dspace, dst, cpage, (flags & PROT_ALL & ~PROT_COMBINE) | PROT_LAZY);
  8041609e24:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  8041609e27:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8041609e2b:	48 89 de             	mov    %rbx,%rsi
  8041609e2e:	4c 89 ef             	mov    %r13,%rdi
  8041609e31:	41 ff d7             	call   *%r15
  8041609e34:	41 89 c4             	mov    %eax,%r12d
                dst += size_inc;
  8041609e37:	48 03 5d c0          	add    -0x40(%rbp),%rbx
            while (dst < end && !res) {
  8041609e3b:	49 39 de             	cmp    %rbx,%r14
  8041609e3e:	0f 86 0b 02 00 00    	jbe    804160a04f <do_map_region_one_page+0x366>
  8041609e44:	85 c0                	test   %eax,%eax
  8041609e46:	74 dc                	je     8041609e24 <do_map_region_one_page+0x13b>
  8041609e48:	e9 02 02 00 00       	jmp    804160a04f <do_map_region_one_page+0x366>
    if (dspace == sspace && src != dst) assert(ABSDIFF(dst, src) >= CLASS_SIZE(class));
  8041609e4d:	48 b9 f0 27 61 41 80 	movabs $0x80416127f0,%rcx
  8041609e54:	00 00 00 
  8041609e57:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609e5e:	00 00 00 
  8041609e61:	be 6a 05 00 00       	mov    $0x56a,%esi
  8041609e66:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609e6d:	00 00 00 
  8041609e70:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609e77:	00 00 00 
  8041609e7a:	41 ff d0             	call   *%r8
            res = alloc_composite_page(dspace, dst, class, flags & PROT_ALL & ~(PROT_LAZY | PROT_COMBINE));
  8041609e7d:	44 89 f9             	mov    %r15d,%ecx
  8041609e80:	81 e1 7f 0e 00 00    	and    $0xe7f,%ecx
  8041609e86:	44 89 f2             	mov    %r14d,%edx
  8041609e89:	48 89 de             	mov    %rbx,%rsi
  8041609e8c:	4c 89 ef             	mov    %r13,%rdi
  8041609e8f:	48 b8 60 92 60 41 80 	movabs $0x8041609260,%rax
  8041609e96:	00 00 00 
  8041609e99:	ff d0                	call   *%rax
  8041609e9b:	41 89 c4             	mov    %eax,%r12d
            if (!res) {
  8041609e9e:	85 c0                	test   %eax,%eax
  8041609ea0:	0f 85 a9 01 00 00    	jne    804160a04f <do_map_region_one_page+0x366>
                assert(current_space);
  8041609ea6:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  8041609ead:	00 00 00 
  8041609eb0:	48 83 38 00          	cmpq   $0x0,(%rax)
  8041609eb4:	74 73                	je     8041609f29 <do_map_region_one_page+0x240>
                assert(dspace);
  8041609eb6:	4d 85 ed             	test   %r13,%r13
  8041609eb9:	0f 84 9f 00 00 00    	je     8041609f5e <do_map_region_one_page+0x275>
                struct AddressSpace *old = switch_address_space(dspace);
  8041609ebf:	4c 89 ef             	mov    %r13,%rdi
  8041609ec2:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  8041609ec9:	00 00 00 
  8041609ecc:	ff d0                	call   *%rax
  8041609ece:	49 89 c5             	mov    %rax,%r13
    asm volatile("movq %%cr0,%0"
  8041609ed1:	0f 20 c0             	mov    %cr0,%rax
    lcr0(wp ? old | CR0_WP : old & ~CR0_WP);
  8041609ed4:	48 25 ff ff fe ff    	and    $0xfffffffffffeffff,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  8041609eda:	0f 22 c0             	mov    %rax,%cr0
                nosan_memset((void *)dst, flags & ALLOC_ONE ? 0xFF : 0x00, CLASS_SIZE(class));
  8041609edd:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
  8041609ee1:	ba 01 00 00 00       	mov    $0x1,%edx
  8041609ee6:	48 d3 e2             	shl    %cl,%rdx
  8041609ee9:	44 89 fe             	mov    %r15d,%esi
  8041609eec:	81 e6 00 00 20 00    	and    $0x200000,%esi
  8041609ef2:	b8 ff 00 00 00       	mov    $0xff,%eax
  8041609ef7:	0f 45 f0             	cmovne %eax,%esi
  8041609efa:	48 89 df             	mov    %rbx,%rdi
  8041609efd:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  8041609f04:	00 00 00 
  8041609f07:	ff d0                	call   *%rax
    asm volatile("movq %%cr0,%0"
  8041609f09:	0f 20 c0             	mov    %cr0,%rax
  8041609f0c:	48 0d 00 00 01 00    	or     $0x10000,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  8041609f12:	0f 22 c0             	mov    %rax,%cr0
                switch_address_space(old);
  8041609f15:	4c 89 ef             	mov    %r13,%rdi
  8041609f18:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  8041609f1f:	00 00 00 
  8041609f22:	ff d0                	call   *%rax
  8041609f24:	e9 26 01 00 00       	jmp    804160a04f <do_map_region_one_page+0x366>
                assert(current_space);
  8041609f29:	48 b9 f6 1d 61 41 80 	movabs $0x8041611df6,%rcx
  8041609f30:	00 00 00 
  8041609f33:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609f3a:	00 00 00 
  8041609f3d:	be 73 05 00 00       	mov    $0x573,%esi
  8041609f42:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609f49:	00 00 00 
  8041609f4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609f51:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609f58:	00 00 00 
  8041609f5b:	41 ff d0             	call   *%r8
                assert(dspace);
  8041609f5e:	48 b9 2e 1e 61 41 80 	movabs $0x8041611e2e,%rcx
  8041609f65:	00 00 00 
  8041609f68:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609f6f:	00 00 00 
  8041609f72:	be 74 05 00 00       	mov    $0x574,%esi
  8041609f77:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609f7e:	00 00 00 
  8041609f81:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609f86:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609f8d:	00 00 00 
  8041609f90:	41 ff d0             	call   *%r8
            assert(CLASS_SIZE(cpage->class) == size_inc);
  8041609f93:	48 b9 18 28 61 41 80 	movabs $0x8041612818,%rcx
  8041609f9a:	00 00 00 
  8041609f9d:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  8041609fa4:	00 00 00 
  8041609fa7:	be 87 05 00 00       	mov    $0x587,%esi
  8041609fac:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  8041609fb3:	00 00 00 
  8041609fb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8041609fbb:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  8041609fc2:	00 00 00 
  8041609fc5:	41 ff d0             	call   *%r8
        struct Page *page1 = page_lookup_virtual(sspace->root, src, class, LOOKUP_ALLOC);
  8041609fc8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8041609fcc:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8041609fd0:	b9 01 00 00 00       	mov    $0x1,%ecx
  8041609fd5:	44 89 f2             	mov    %r14d,%edx
  8041609fd8:	4c 89 e6             	mov    %r12,%rsi
  8041609fdb:	48 b8 8e 6a 60 41 80 	movabs $0x8041606a8e,%rax
  8041609fe2:	00 00 00 
  8041609fe5:	ff d0                	call   *%rax
  8041609fe7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        assert(page1);
  8041609feb:	48 85 c0             	test   %rax,%rax
  8041609fee:	74 71                	je     804160a061 <do_map_region_one_page+0x378>
        if (page1->phy && page1->phy->class > class) {
  8041609ff0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8041609ff4:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8041609ff8:	48 85 ff             	test   %rdi,%rdi
  8041609ffb:	74 12                	je     804160a00f <do_map_region_one_page+0x326>
  8041609ffd:	0f b7 47 34          	movzwl 0x34(%rdi),%eax
  804160a001:	25 ff 0f 00 00       	and    $0xfff,%eax
  804160a006:	44 39 f0             	cmp    %r14d,%eax
  804160a009:	0f 8f 82 00 00 00    	jg     804160a091 <do_map_region_one_page+0x3a8>
            check_virtual_class(page1, class);
  804160a00f:	44 89 f6             	mov    %r14d,%esi
  804160a012:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804160a016:	48 b8 e4 4c 60 41 80 	movabs $0x8041604ce4,%rax
  804160a01d:	00 00 00 
  804160a020:	ff d0                	call   *%rax
            return do_map_subtree(dspace, dst, sspace, src, page1, class, flags);
  804160a022:	48 83 ec 08          	sub    $0x8,%rsp
  804160a026:	41 57                	push   %r15
  804160a028:	45 89 f1             	mov    %r14d,%r9d
  804160a02b:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  804160a02f:	4c 89 e1             	mov    %r12,%rcx
  804160a032:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804160a036:	48 89 de             	mov    %rbx,%rsi
  804160a039:	4c 89 ef             	mov    %r13,%rdi
  804160a03c:	48 b8 0c 9b 60 41 80 	movabs $0x8041609b0c,%rax
  804160a043:	00 00 00 
  804160a046:	ff d0                	call   *%rax
  804160a048:	41 89 c4             	mov    %eax,%r12d
  804160a04b:	48 83 c4 10          	add    $0x10,%rsp
}
  804160a04f:	44 89 e0             	mov    %r12d,%eax
  804160a052:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  804160a056:	5b                   	pop    %rbx
  804160a057:	41 5c                	pop    %r12
  804160a059:	41 5d                	pop    %r13
  804160a05b:	41 5e                	pop    %r14
  804160a05d:	41 5f                	pop    %r15
  804160a05f:	5d                   	pop    %rbp
  804160a060:	c3                   	ret    
        assert(page1);
  804160a061:	48 b9 35 1e 61 41 80 	movabs $0x8041611e35,%rcx
  804160a068:	00 00 00 
  804160a06b:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160a072:	00 00 00 
  804160a075:	be 90 05 00 00       	mov    $0x590,%esi
  804160a07a:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a081:	00 00 00 
  804160a084:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a08b:	00 00 00 
  804160a08e:	41 ff d0             	call   *%r8
            struct Page *page = page_lookup(page1->phy, src, class, PARTIAL_NODE, 1);
  804160a091:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804160a097:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804160a09c:	44 89 f2             	mov    %r14d,%edx
  804160a09f:	4c 89 e6             	mov    %r12,%rsi
  804160a0a2:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  804160a0a9:	00 00 00 
  804160a0ac:	ff d0                	call   *%rax
  804160a0ae:	49 89 c0             	mov    %rax,%r8
            return do_map_page(dspace, dst, sspace, src, page, page1->state & PROT_ALL, flags);
  804160a0b1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804160a0b5:	44 8b 48 28          	mov    0x28(%rax),%r9d
  804160a0b9:	48 83 ec 08          	sub    $0x8,%rsp
  804160a0bd:	41 57                	push   %r15
  804160a0bf:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
  804160a0c6:	4c 89 e1             	mov    %r12,%rcx
  804160a0c9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804160a0cd:	48 89 de             	mov    %rbx,%rsi
  804160a0d0:	4c 89 ef             	mov    %r13,%rdi
  804160a0d3:	48 b8 87 98 60 41 80 	movabs $0x8041609887,%rax
  804160a0da:	00 00 00 
  804160a0dd:	ff d0                	call   *%rax
  804160a0df:	41 89 c4             	mov    %eax,%r12d
  804160a0e2:	48 83 c4 10          	add    $0x10,%rsp
  804160a0e6:	e9 64 ff ff ff       	jmp    804160a04f <do_map_region_one_page+0x366>
            if (!cpage) return -E_NO_MEM;
  804160a0eb:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
  804160a0f1:	e9 59 ff ff ff       	jmp    804160a04f <do_map_region_one_page+0x366>

000000804160a0f6 <map_region>:
map_region(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, uintptr_t size, int flags) {
  804160a0f6:	55                   	push   %rbp
  804160a0f7:	48 89 e5             	mov    %rsp,%rbp
  804160a0fa:	41 57                	push   %r15
  804160a0fc:	41 56                	push   %r14
  804160a0fe:	41 55                	push   %r13
  804160a100:	41 54                	push   %r12
  804160a102:	53                   	push   %rbx
  804160a103:	48 83 ec 38          	sub    $0x38,%rsp
  804160a107:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  804160a10b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  804160a10f:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  804160a113:	44 89 4d b4          	mov    %r9d,-0x4c(%rbp)
    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) return -E_INVAL;
  804160a117:	f7 c1 ff 0f 00 00    	test   $0xfff,%ecx
  804160a11d:	0f 85 73 02 00 00    	jne    804160a396 <map_region+0x2a0>
  804160a123:	49 89 f4             	mov    %rsi,%r12
  804160a126:	48 85 d2             	test   %rdx,%rdx
  804160a129:	0f 84 d1 00 00 00    	je     804160a200 <map_region+0x10a>
    if (dst & CLASS_MASK(0) || !dspace) return -E_INVAL;
  804160a12f:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804160a133:	48 85 ff             	test   %rdi,%rdi
  804160a136:	0f 84 61 02 00 00    	je     804160a39d <map_region+0x2a7>
    if (size & CLASS_MASK(0) || !size) return -E_INVAL;
  804160a13c:	4c 89 e0             	mov    %r12,%rax
  804160a13f:	4c 09 c0             	or     %r8,%rax
  804160a142:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804160a147:	0f 85 57 02 00 00    	jne    804160a3a4 <map_region+0x2ae>
  804160a14d:	4d 85 c0             	test   %r8,%r8
  804160a150:	0f 84 4e 02 00 00    	je     804160a3a4 <map_region+0x2ae>
    assert(sspace != dspace || dst <= src || ABSDIFF(src, dst) >= size);
  804160a156:	48 39 7d b8          	cmp    %rdi,-0x48(%rbp)
  804160a15a:	75 25                	jne    804160a181 <map_region+0x8b>
  804160a15c:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160a160:	4c 39 e7             	cmp    %r12,%rdi
  804160a163:	73 1c                	jae    804160a181 <map_region+0x8b>
  804160a165:	48 89 fa             	mov    %rdi,%rdx
  804160a168:	4c 29 e2             	sub    %r12,%rdx
  804160a16b:	4c 89 e0             	mov    %r12,%rax
  804160a16e:	48 29 f8             	sub    %rdi,%rax
  804160a171:	4c 39 e7             	cmp    %r12,%rdi
  804160a174:	48 0f 47 c2          	cmova  %rdx,%rax
  804160a178:	4c 39 c0             	cmp    %r8,%rax
  804160a17b:	0f 82 96 00 00 00    	jb     804160a217 <map_region+0x121>
    uintptr_t end = dst + size;
  804160a181:	4b 8d 04 04          	lea    (%r12,%r8,1),%rax
  804160a185:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    assert(!((addr1 | addr2) & CLASS_MASK(0)));
  804160a189:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804160a18d:	48 89 d0             	mov    %rdx,%rax
  804160a190:	4c 09 e0             	or     %r12,%rax
  804160a193:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804160a198:	0f 85 ae 00 00 00    	jne    804160a24c <map_region+0x156>
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  804160a19e:	4c 31 e2             	xor    %r12,%rdx
  804160a1a1:	48 89 d1             	mov    %rdx,%rcx
    int res = 0;
  804160a1a4:	b8 00 00 00 00       	mov    $0x0,%eax
    int max_class = addr_common_class(src, dst), class = 0, res;
  804160a1a9:	41 bd 00 00 00 00    	mov    $0x0,%r13d
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  804160a1af:	f6 c6 10             	test   $0x10,%dh
  804160a1b2:	0f 85 29 01 00 00    	jne    804160a2e1 <map_region+0x1eb>
  804160a1b8:	41 89 c6             	mov    %eax,%r14d
  804160a1bb:	83 c0 01             	add    $0x1,%eax
  804160a1be:	41 8d 56 0d          	lea    0xd(%r14),%edx
  804160a1c2:	48 0f a3 d1          	bt     %rdx,%rcx
  804160a1c6:	72 05                	jb     804160a1cd <map_region+0xd7>
  804160a1c8:	83 f8 2f             	cmp    $0x2f,%eax
  804160a1cb:	7e eb                	jle    804160a1b8 <map_region+0xc2>
    for (; class < max_class && dst + CLASS_SIZE(class) <= end; class ++) {
  804160a1cd:	85 c0                	test   %eax,%eax
  804160a1cf:	0f 8e 41 01 00 00    	jle    804160a316 <map_region+0x220>
  804160a1d5:	4d 8d bc 24 00 10 00 	lea    0x1000(%r12),%r15
  804160a1dc:	00 
  804160a1dd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804160a1e1:	4c 39 f8             	cmp    %r15,%rax
  804160a1e4:	0f 82 34 01 00 00    	jb     804160a31e <map_region+0x228>
    int max_class = addr_common_class(src, dst), class = 0, res;
  804160a1ea:	bb 00 00 00 00       	mov    $0x0,%ebx
    for (; class < max_class && dst + CLASS_SIZE(class) <= end; class ++) {
  804160a1ef:	41 bd 00 10 00 00    	mov    $0x1000,%r13d
  804160a1f5:	4c 89 e6             	mov    %r12,%rsi
  804160a1f8:	49 89 c4             	mov    %rax,%r12
  804160a1fb:	e9 a5 00 00 00       	jmp    804160a2a5 <map_region+0x1af>
    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) return -E_INVAL;
  804160a200:	41 f7 c1 00 00 30 00 	test   $0x300000,%r9d
  804160a207:	0f 85 22 ff ff ff    	jne    804160a12f <map_region+0x39>
  804160a20d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160a212:	e9 14 01 00 00       	jmp    804160a32b <map_region+0x235>
    assert(sspace != dspace || dst <= src || ABSDIFF(src, dst) >= size);
  804160a217:	48 b9 40 28 61 41 80 	movabs $0x8041612840,%rcx
  804160a21e:	00 00 00 
  804160a221:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160a228:	00 00 00 
  804160a22b:	be a8 05 00 00       	mov    $0x5a8,%esi
  804160a230:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a237:	00 00 00 
  804160a23a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a23f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a246:	00 00 00 
  804160a249:	41 ff d0             	call   *%r8
    assert(!((addr1 | addr2) & CLASS_MASK(0)));
  804160a24c:	48 b9 60 26 61 41 80 	movabs $0x8041612660,%rcx
  804160a253:	00 00 00 
  804160a256:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160a25d:	00 00 00 
  804160a260:	be 8c 04 00 00       	mov    $0x48c,%esi
  804160a265:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a26c:	00 00 00 
  804160a26f:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a274:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a27b:	00 00 00 
  804160a27e:	41 ff d0             	call   *%r8
    for (; class < max_class && dst + CLASS_SIZE(class) <= end; class ++) {
  804160a281:	8d 43 01             	lea    0x1(%rbx),%eax
  804160a284:	44 39 f3             	cmp    %r14d,%ebx
  804160a287:	7d 52                	jge    804160a2db <map_region+0x1e5>
  804160a289:	8d 4b 0d             	lea    0xd(%rbx),%ecx
  804160a28c:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  804160a292:	49 d3 e5             	shl    %cl,%r13
  804160a295:	4d 8d 7c 35 00       	lea    0x0(%r13,%rsi,1),%r15
  804160a29a:	4d 39 e7             	cmp    %r12,%r15
  804160a29d:	0f 87 97 00 00 00    	ja     804160a33a <map_region+0x244>
  804160a2a3:	89 c3                	mov    %eax,%ebx
        if (dst & CLASS_SIZE(class)) {
  804160a2a5:	8d 43 0c             	lea    0xc(%rbx),%eax
  804160a2a8:	48 0f a3 c6          	bt     %rax,%rsi
  804160a2ac:	73 d3                	jae    804160a281 <map_region+0x18b>
            res = do_map_region_one_page(dspace, dst, sspace, src, class, flags);
  804160a2ae:	44 8b 4d b4          	mov    -0x4c(%rbp),%r9d
  804160a2b2:	41 89 d8             	mov    %ebx,%r8d
  804160a2b5:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804160a2b9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804160a2bd:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804160a2c1:	49 ba e9 9c 60 41 80 	movabs $0x8041609ce9,%r10
  804160a2c8:	00 00 00 
  804160a2cb:	41 ff d2             	call   *%r10
            if (res < 0) return res;
  804160a2ce:	85 c0                	test   %eax,%eax
  804160a2d0:	78 59                	js     804160a32b <map_region+0x235>
            src += CLASS_SIZE(class);
  804160a2d2:	4c 01 6d c8          	add    %r13,-0x38(%rbp)
  804160a2d6:	4c 89 fe             	mov    %r15,%rsi
  804160a2d9:	eb a6                	jmp    804160a281 <map_region+0x18b>
  804160a2db:	41 89 c5             	mov    %eax,%r13d
  804160a2de:	49 89 f4             	mov    %rsi,%r12
    for (; class >= 0 && dst < end; class --) {
  804160a2e1:	45 85 ed             	test   %r13d,%r13d
  804160a2e4:	78 40                	js     804160a326 <map_region+0x230>
            res = do_map_region_one_page(dspace, dst, sspace, src, class, flags);
  804160a2e6:	49 bf e9 9c 60 41 80 	movabs $0x8041609ce9,%r15
  804160a2ed:	00 00 00 
    for (; class >= 0 && dst < end; class --) {
  804160a2f0:	4c 39 65 a8          	cmp    %r12,-0x58(%rbp)
  804160a2f4:	76 30                	jbe    804160a326 <map_region+0x230>
        while (dst + CLASS_SIZE(class) <= end) {
  804160a2f6:	41 8d 4d 0c          	lea    0xc(%r13),%ecx
  804160a2fa:	b8 01 00 00 00       	mov    $0x1,%eax
  804160a2ff:	48 d3 e0             	shl    %cl,%rax
  804160a302:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  804160a306:	4e 8d 34 20          	lea    (%rax,%r12,1),%r14
  804160a30a:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804160a30e:	4c 39 75 a8          	cmp    %r14,-0x58(%rbp)
  804160a312:	73 31                	jae    804160a345 <map_region+0x24f>
  804160a314:	eb 69                	jmp    804160a37f <map_region+0x289>
    int max_class = addr_common_class(src, dst), class = 0, res;
  804160a316:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  804160a31c:	eb c3                	jmp    804160a2e1 <map_region+0x1eb>
  804160a31e:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  804160a324:	eb bb                	jmp    804160a2e1 <map_region+0x1eb>
    return 0;
  804160a326:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804160a32b:	48 83 c4 38          	add    $0x38,%rsp
  804160a32f:	5b                   	pop    %rbx
  804160a330:	41 5c                	pop    %r12
  804160a332:	41 5d                	pop    %r13
  804160a334:	41 5e                	pop    %r14
  804160a336:	41 5f                	pop    %r15
  804160a338:	5d                   	pop    %rbp
  804160a339:	c3                   	ret    
  804160a33a:	41 89 c5             	mov    %eax,%r13d
  804160a33d:	49 89 f4             	mov    %rsi,%r12
  804160a340:	eb 9f                	jmp    804160a2e1 <map_region+0x1eb>
  804160a342:	49 89 c6             	mov    %rax,%r14
            res = do_map_region_one_page(dspace, dst, sspace, src, class, flags);
  804160a345:	4c 89 e6             	mov    %r12,%rsi
  804160a348:	48 2b 75 c8          	sub    -0x38(%rbp),%rsi
  804160a34c:	48 01 de             	add    %rbx,%rsi
  804160a34f:	44 8b 4d b4          	mov    -0x4c(%rbp),%r9d
  804160a353:	45 89 e8             	mov    %r13d,%r8d
  804160a356:	48 89 d9             	mov    %rbx,%rcx
  804160a359:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804160a35d:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804160a361:	41 ff d7             	call   *%r15
            if (res < 0) return res;
  804160a364:	85 c0                	test   %eax,%eax
  804160a366:	78 c3                	js     804160a32b <map_region+0x235>
            src += CLASS_SIZE(class);
  804160a368:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804160a36c:	48 01 c3             	add    %rax,%rbx
        while (dst + CLASS_SIZE(class) <= end) {
  804160a36f:	4c 01 f0             	add    %r14,%rax
  804160a372:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  804160a376:	73 ca                	jae    804160a342 <map_region+0x24c>
            src += CLASS_SIZE(class);
  804160a378:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
  804160a37c:	4d 89 f4             	mov    %r14,%r12
    for (; class >= 0 && dst < end; class --) {
  804160a37f:	41 83 ed 01          	sub    $0x1,%r13d
  804160a383:	78 0a                	js     804160a38f <map_region+0x299>
  804160a385:	4c 39 65 a8          	cmp    %r12,-0x58(%rbp)
  804160a389:	0f 87 67 ff ff ff    	ja     804160a2f6 <map_region+0x200>
    return 0;
  804160a38f:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a394:	eb 95                	jmp    804160a32b <map_region+0x235>
    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) return -E_INVAL;
  804160a396:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160a39b:	eb 8e                	jmp    804160a32b <map_region+0x235>
    if (dst & CLASS_MASK(0) || !dspace) return -E_INVAL;
  804160a39d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160a3a2:	eb 87                	jmp    804160a32b <map_region+0x235>
    if (size & CLASS_MASK(0) || !size) return -E_INVAL;
  804160a3a4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160a3a9:	eb 80                	jmp    804160a32b <map_region+0x235>

000000804160a3ab <init_address_space>:

int
init_address_space(struct AddressSpace *space) {
  804160a3ab:	55                   	push   %rbp
  804160a3ac:	48 89 e5             	mov    %rsp,%rbp
  804160a3af:	41 54                	push   %r12
  804160a3b1:	53                   	push   %rbx
  804160a3b2:	48 89 fb             	mov    %rdi,%rbx
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  804160a3b5:	be 00 00 04 00       	mov    $0x40000,%esi
  804160a3ba:	bf 00 00 00 00       	mov    $0x0,%edi
  804160a3bf:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  804160a3c6:	00 00 00 
  804160a3c9:	ff d0                	call   *%rax
        if (!page) return -E_NO_MEM;
  804160a3cb:	48 85 c0             	test   %rax,%rax
  804160a3ce:	0f 84 81 01 00 00    	je     804160a555 <init_address_space+0x1aa>
  804160a3d4:	49 89 c4             	mov    %rax,%r12
        assert(!page->refc);
  804160a3d7:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  804160a3db:	0f 85 e0 00 00 00    	jne    804160a4c1 <init_address_space+0x116>
        page_ref(page);
  804160a3e1:	48 89 c7             	mov    %rax,%rdi
  804160a3e4:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  804160a3eb:	00 00 00 
  804160a3ee:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  804160a3f0:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804160a3f7:	ff 0f 00 
  804160a3fa:	48 89 c7             	mov    %rax,%rdi
  804160a3fd:	49 23 7c 24 38       	and    0x38(%r12),%rdi
  804160a402:	48 c1 e7 0c          	shl    $0xc,%rdi
  804160a406:	48 21 c7             	and    %rax,%rdi
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  804160a409:	49 89 fc             	mov    %rdi,%r12
  804160a40c:	49 83 cc 07          	or     $0x7,%r12
    if (pa > max_memory_map_addr)
  804160a410:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160a417:	00 00 00 
  804160a41a:	48 39 c7             	cmp    %rax,%rdi
  804160a41d:	0f 87 d3 00 00 00    	ja     804160a4f6 <init_address_space+0x14b>
    return (void *)(pa + KERN_BASE_ADDR);
  804160a423:	48 b9 00 00 00 40 80 	movabs $0x8040000000,%rcx
  804160a42a:	00 00 00 
  804160a42d:	48 01 cf             	add    %rcx,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  804160a430:	ba 00 10 00 00       	mov    $0x1000,%edx
  804160a435:	be 00 00 00 00       	mov    $0x0,%esi
  804160a43a:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160a441:	00 00 00 
  804160a444:	ff d0                	call   *%rax
    // LAB 8: Your code here
    pte_t pt = 0;
    int res = alloc_pt(&pt);
    if (res)
        return res;
    space->cr3 = PTE_ADDR(pt);
  804160a446:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  804160a44d:	ff ff 7f 
  804160a450:	4c 21 e1             	and    %r12,%rcx
  804160a453:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    if (pa > max_memory_map_addr)
  804160a457:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160a45e:	00 00 00 
  804160a461:	48 39 c1             	cmp    %rax,%rcx
  804160a464:	0f 87 bd 00 00 00    	ja     804160a527 <init_address_space+0x17c>
    return (void *)(pa + KERN_BASE_ADDR);
  804160a46a:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804160a471:	00 00 00 
  804160a474:	48 01 c1             	add    %rax,%rcx
  804160a477:	48 89 0b             	mov    %rcx,(%rbx)
    // LAB 8: Your code here
    space->pml4 = KADDR(space->cr3);
    // Allocate virtual tree root node
    // of type INTERMEDIATE_NODE with alloc_rescriptor() of type
    // LAB 8: Your code here
    space->root = alloc_descriptor(INTERMEDIATE_NODE);
  804160a47a:	bf 00 00 20 00       	mov    $0x200000,%edi
  804160a47f:	48 b8 77 57 60 41 80 	movabs $0x8041605777,%rax
  804160a486:	00 00 00 
  804160a489:	ff d0                	call   *%rax
  804160a48b:	48 89 43 10          	mov    %rax,0x10(%rbx)

    /* Initialize UVPT */
    // LAB 8: Your code here
    space->pml4[PML4_INDEX(UVPT)] = space->cr3 | PTE_P | PTE_U;
  804160a48f:	48 8b 13             	mov    (%rbx),%rdx
  804160a492:	48 8b 43 08          	mov    0x8(%rbx),%rax
  804160a496:	48 83 c8 05          	or     $0x5,%rax
  804160a49a:	48 89 42 10          	mov    %rax,0x10(%rdx)
    /* Why this call is required here and what does it do? */
    propagate_one_pml4(space, &kspace);
  804160a49e:	48 be b0 00 40 42 80 	movabs $0x80424000b0,%rsi
  804160a4a5:	00 00 00 
  804160a4a8:	48 89 df             	mov    %rbx,%rdi
  804160a4ab:	48 b8 0e 65 60 41 80 	movabs $0x804160650e,%rax
  804160a4b2:	00 00 00 
  804160a4b5:	ff d0                	call   *%rax
    return 0;
  804160a4b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804160a4bc:	5b                   	pop    %rbx
  804160a4bd:	41 5c                	pop    %r12
  804160a4bf:	5d                   	pop    %rbp
  804160a4c0:	c3                   	ret    
        assert(!page->refc);
  804160a4c1:	48 b9 54 1d 61 41 80 	movabs $0x8041611d54,%rcx
  804160a4c8:	00 00 00 
  804160a4cb:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160a4d2:	00 00 00 
  804160a4d5:	be d4 02 00 00       	mov    $0x2d4,%esi
  804160a4da:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a4e1:	00 00 00 
  804160a4e4:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a4e9:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a4f0:	00 00 00 
  804160a4f3:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804160a4f6:	49 89 c0             	mov    %rax,%r8
  804160a4f9:	48 89 f9             	mov    %rdi,%rcx
  804160a4fc:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160a503:	00 00 00 
  804160a506:	be db 02 00 00       	mov    $0x2db,%esi
  804160a50b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a512:	00 00 00 
  804160a515:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a51a:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160a521:	00 00 00 
  804160a524:	41 ff d1             	call   *%r9
  804160a527:	49 89 c0             	mov    %rax,%r8
  804160a52a:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160a531:	00 00 00 
  804160a534:	be fd 05 00 00       	mov    $0x5fd,%esi
  804160a539:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a540:	00 00 00 
  804160a543:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a548:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160a54f:	00 00 00 
  804160a552:	41 ff d1             	call   *%r9
        if (!page) return -E_NO_MEM;
  804160a555:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  804160a55a:	e9 5d ff ff ff       	jmp    804160a4bc <init_address_space+0x111>

000000804160a55f <kzalloc_region>:
    root.class = MAX_CLASS;
    root.state = PARTIAL_NODE;
}

void *
kzalloc_region(size_t size) {
  804160a55f:	55                   	push   %rbp
  804160a560:	48 89 e5             	mov    %rsp,%rbp
  804160a563:	53                   	push   %rbx
  804160a564:	48 83 ec 08          	sub    $0x8,%rsp
    assert(current_space);
  804160a568:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  804160a56f:	00 00 00 
  804160a572:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160a576:	74 6e                	je     804160a5e6 <kzalloc_region+0x87>

    size = ROUNDUP(size, PAGE_SIZE);
  804160a578:	4c 8d 87 ff 0f 00 00 	lea    0xfff(%rdi),%r8
  804160a57f:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8

    if (metaheaptop + size > KERN_HEAP_END) panic("Kernel heap overflow\n");
  804160a586:	48 b8 08 41 40 42 80 	movabs $0x8042404108,%rax
  804160a58d:	00 00 00 
  804160a590:	48 8b 18             	mov    (%rax),%rbx
  804160a593:	4a 8d 04 03          	lea    (%rbx,%r8,1),%rax
  804160a597:	48 ba 00 00 e0 3f 80 	movabs $0x803fe00000,%rdx
  804160a59e:	00 00 00 
  804160a5a1:	48 39 d0             	cmp    %rdx,%rax
  804160a5a4:	77 75                	ja     804160a61b <kzalloc_region+0xbc>

    uintptr_t res = metaheaptop;
    metaheaptop += size;
  804160a5a6:	48 a3 08 41 40 42 80 	movabs %rax,0x8042404108
  804160a5ad:	00 00 00 

    int r = map_region(&kspace, res, NULL, 0, size, PROT_R | PROT_W | ALLOC_ZERO);
  804160a5b0:	41 b9 06 00 10 00    	mov    $0x100006,%r9d
  804160a5b6:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160a5bb:	ba 00 00 00 00       	mov    $0x0,%edx
  804160a5c0:	48 89 de             	mov    %rbx,%rsi
  804160a5c3:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160a5ca:	00 00 00 
  804160a5cd:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160a5d4:	00 00 00 
  804160a5d7:	ff d0                	call   *%rax
    if (r < 0) panic("kzalloc_region: %i\n", r);
  804160a5d9:	85 c0                	test   %eax,%eax
  804160a5db:	78 68                	js     804160a645 <kzalloc_region+0xe6>
    }
    platform_asan_unpoison((void *)res, size);
#endif

    return (void *)res;
}
  804160a5dd:	48 89 d8             	mov    %rbx,%rax
  804160a5e0:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804160a5e4:	c9                   	leave  
  804160a5e5:	c3                   	ret    
    assert(current_space);
  804160a5e6:	48 b9 f6 1d 61 41 80 	movabs $0x8041611df6,%rcx
  804160a5ed:	00 00 00 
  804160a5f0:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160a5f7:	00 00 00 
  804160a5fa:	be 7e 06 00 00       	mov    $0x67e,%esi
  804160a5ff:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a606:	00 00 00 
  804160a609:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a60e:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a615:	00 00 00 
  804160a618:	41 ff d0             	call   *%r8
    if (metaheaptop + size > KERN_HEAP_END) panic("Kernel heap overflow\n");
  804160a61b:	48 ba 3b 1e 61 41 80 	movabs $0x8041611e3b,%rdx
  804160a622:	00 00 00 
  804160a625:	be 82 06 00 00       	mov    $0x682,%esi
  804160a62a:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a631:	00 00 00 
  804160a634:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a639:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160a640:	00 00 00 
  804160a643:	ff d1                	call   *%rcx
    if (r < 0) panic("kzalloc_region: %i\n", r);
  804160a645:	89 c1                	mov    %eax,%ecx
  804160a647:	48 ba 51 1e 61 41 80 	movabs $0x8041611e51,%rdx
  804160a64e:	00 00 00 
  804160a651:	be 88 06 00 00       	mov    $0x688,%esi
  804160a656:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a65d:	00 00 00 
  804160a660:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a665:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a66c:	00 00 00 
  804160a66f:	41 ff d0             	call   *%r8

000000804160a672 <mmio_map_region>:

static uintptr_t prev_mmio;
void *
mmio_map_region(physaddr_t addr, size_t size) {
  804160a672:	55                   	push   %rbp
  804160a673:	48 89 e5             	mov    %rsp,%rbp
  804160a676:	41 55                	push   %r13
  804160a678:	41 54                	push   %r12
  804160a67a:	53                   	push   %rbx
  804160a67b:	48 83 ec 08          	sub    $0x8,%rsp
    assert(current_space == &kspace);
  804160a67f:	48 ba a0 00 40 42 80 	movabs $0x80424000a0,%rdx
  804160a686:	00 00 00 
  804160a689:	48 b8 b0 00 40 42 80 	movabs $0x80424000b0,%rax
  804160a690:	00 00 00 
  804160a693:	48 39 02             	cmp    %rax,(%rdx)
  804160a696:	0f 85 81 00 00 00    	jne    804160a71d <mmio_map_region+0xab>
  804160a69c:	48 89 fb             	mov    %rdi,%rbx
  804160a69f:	49 89 f5             	mov    %rsi,%r13
    uintptr_t start = ROUNDDOWN(addr, PAGE_SIZE);
  804160a6a2:	49 89 fc             	mov    %rdi,%r12
  804160a6a5:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
    uintptr_t end = ROUNDUP(addr + size, PAGE_SIZE);

    prev_mmio = metaheaptop;
  804160a6ac:	48 ba 08 41 40 42 80 	movabs $0x8042404108,%rdx
  804160a6b3:	00 00 00 
  804160a6b6:	48 8b 32             	mov    (%rdx),%rsi
  804160a6b9:	48 89 f0             	mov    %rsi,%rax
  804160a6bc:	48 a3 f0 40 40 42 80 	movabs %rax,0x80424040f0
  804160a6c3:	00 00 00 
    uintptr_t end = ROUNDUP(addr + size, PAGE_SIZE);
  804160a6c6:	4a 8d 8c 2f ff 0f 00 	lea    0xfff(%rdi,%r13,1),%rcx
  804160a6cd:	00 
    metaheaptop += end - start;
  804160a6ce:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  804160a6d5:	4c 29 e1             	sub    %r12,%rcx
  804160a6d8:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
  804160a6dc:	48 89 02             	mov    %rax,(%rdx)

    if (map_physical_region(&kspace, prev_mmio, start, end - start, PROT_R | PROT_W | PROT_CD) < 0)
  804160a6df:	41 b8 1e 00 00 00    	mov    $0x1e,%r8d
  804160a6e5:	4c 89 e2             	mov    %r12,%rdx
  804160a6e8:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160a6ef:	00 00 00 
  804160a6f2:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160a6f9:	00 00 00 
  804160a6fc:	ff d0                	call   *%rax
  804160a6fe:	85 c0                	test   %eax,%eax
  804160a700:	78 50                	js     804160a752 <mmio_map_region+0xe0>
        panic("Cannot map physical region at %p of size %zd", (void *)addr, size);

    return (void *)(prev_mmio + addr - start);
  804160a702:	48 a1 f0 40 40 42 80 	movabs 0x80424040f0,%rax
  804160a709:	00 00 00 
  804160a70c:	48 01 d8             	add    %rbx,%rax
  804160a70f:	4c 29 e0             	sub    %r12,%rax
}
  804160a712:	48 83 c4 08          	add    $0x8,%rsp
  804160a716:	5b                   	pop    %rbx
  804160a717:	41 5c                	pop    %r12
  804160a719:	41 5d                	pop    %r13
  804160a71b:	5d                   	pop    %rbp
  804160a71c:	c3                   	ret    
    assert(current_space == &kspace);
  804160a71d:	48 b9 65 1e 61 41 80 	movabs $0x8041611e65,%rcx
  804160a724:	00 00 00 
  804160a727:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160a72e:	00 00 00 
  804160a731:	be 98 06 00 00       	mov    $0x698,%esi
  804160a736:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a73d:	00 00 00 
  804160a740:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a745:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a74c:	00 00 00 
  804160a74f:	41 ff d0             	call   *%r8
        panic("Cannot map physical region at %p of size %zd", (void *)addr, size);
  804160a752:	4d 89 e8             	mov    %r13,%r8
  804160a755:	48 89 d9             	mov    %rbx,%rcx
  804160a758:	48 ba 80 28 61 41 80 	movabs $0x8041612880,%rdx
  804160a75f:	00 00 00 
  804160a762:	be a0 06 00 00       	mov    $0x6a0,%esi
  804160a767:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a76e:	00 00 00 
  804160a771:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a776:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160a77d:	00 00 00 
  804160a780:	41 ff d1             	call   *%r9

000000804160a783 <mmio_remap_last_region>:

void *
mmio_remap_last_region(physaddr_t addr, void *oldva, size_t oldsz, size_t size) {
  804160a783:	55                   	push   %rbp
  804160a784:	48 89 e5             	mov    %rsp,%rbp
  804160a787:	49 89 f1             	mov    %rsi,%r9
  804160a78a:	48 89 ce             	mov    %rcx,%rsi
    uintptr_t start = ROUNDDOWN(addr, PAGE_SIZE);
  804160a78d:	49 89 f8             	mov    %rdi,%r8
  804160a790:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
    uintptr_t end = ROUNDUP(addr + size, PAGE_SIZE);
  804160a797:	48 8d 84 0f ff 0f 00 	lea    0xfff(%rdi,%rcx,1),%rax
  804160a79e:	00 
  804160a79f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804160a7a5:	48 89 c2             	mov    %rax,%rdx

    if (prev_mmio + addr - start != (uintptr_t)oldva &&
  804160a7a8:	48 a1 f0 40 40 42 80 	movabs 0x80424040f0,%rax
  804160a7af:	00 00 00 
  804160a7b2:	48 8d 0c 38          	lea    (%rax,%rdi,1),%rcx
  804160a7b6:	4c 29 c1             	sub    %r8,%rcx
  804160a7b9:	49 39 c9             	cmp    %rcx,%r9
  804160a7bc:	74 15                	je     804160a7d3 <mmio_remap_last_region+0x50>
        (prev_mmio + end - start != metaheaptop))
  804160a7be:	4c 29 c2             	sub    %r8,%rdx
  804160a7c1:	48 01 c2             	add    %rax,%rdx
  804160a7c4:	48 b9 08 41 40 42 80 	movabs $0x8042404108,%rcx
  804160a7cb:	00 00 00 
    if (prev_mmio + addr - start != (uintptr_t)oldva &&
  804160a7ce:	48 3b 11             	cmp    (%rcx),%rdx
  804160a7d1:	75 18                	jne    804160a7eb <mmio_remap_last_region+0x68>
        panic("Trying to remap non-last MMIO region!\n");

    metaheaptop = prev_mmio;
  804160a7d3:	48 a3 08 41 40 42 80 	movabs %rax,0x8042404108
  804160a7da:	00 00 00 
    return mmio_map_region(addr, size);
  804160a7dd:	48 b8 72 a6 60 41 80 	movabs $0x804160a672,%rax
  804160a7e4:	00 00 00 
  804160a7e7:	ff d0                	call   *%rax
}
  804160a7e9:	5d                   	pop    %rbp
  804160a7ea:	c3                   	ret    
        panic("Trying to remap non-last MMIO region!\n");
  804160a7eb:	48 ba b0 28 61 41 80 	movabs $0x80416128b0,%rdx
  804160a7f2:	00 00 00 
  804160a7f5:	be ac 06 00 00       	mov    $0x6ac,%esi
  804160a7fa:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a801:	00 00 00 
  804160a804:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a809:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160a810:	00 00 00 
  804160a813:	ff d1                	call   *%rcx

000000804160a815 <init_memory>:
    }
}
#endif

void
init_memory(void) {
  804160a815:	55                   	push   %rbp
  804160a816:	48 89 e5             	mov    %rsp,%rbp
  804160a819:	41 57                	push   %r15
  804160a81b:	41 56                	push   %r14
  804160a81d:	41 55                	push   %r13
  804160a81f:	41 54                	push   %r12
  804160a821:	53                   	push   %rbx
  804160a822:	48 83 ec 38          	sub    $0x38,%rsp
    metaheaptop = KERN_HEAP_START + ROUNDUP(uefi_lp->FrameBufferSize, PAGE_SIZE);
  804160a826:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  804160a82d:	00 00 00 
  804160a830:	8b 40 48             	mov    0x48(%rax),%eax
  804160a833:	48 05 ff 0f 00 00    	add    $0xfff,%rax
  804160a839:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  804160a83e:	48 ba 00 00 e0 1f 80 	movabs $0x801fe00000,%rdx
  804160a845:	00 00 00 
  804160a848:	48 01 d0             	add    %rdx,%rax
  804160a84b:	48 a3 08 41 40 42 80 	movabs %rax,0x8042404108
  804160a852:	00 00 00 
    for (size_t i = 0; i < MAX_CLASS; i++)
  804160a855:	48 b8 40 41 40 42 80 	movabs $0x8042404140,%rax
  804160a85c:	00 00 00 
  804160a85f:	48 8d 90 00 03 00 00 	lea    0x300(%rax),%rdx
    list->next = list->prev = list;
  804160a866:	48 89 00             	mov    %rax,(%rax)
  804160a869:	48 89 40 08          	mov    %rax,0x8(%rax)
    for (size_t i = 0; i < MAX_CLASS; i++)
  804160a86d:	48 83 c0 10          	add    $0x10,%rax
  804160a871:	48 39 d0             	cmp    %rdx,%rax
  804160a874:	75 f0                	jne    804160a866 <init_memory+0x51>
    list->next = list->prev = list;
  804160a876:	48 b8 20 41 40 42 80 	movabs $0x8042404120,%rax
  804160a87d:	00 00 00 
  804160a880:	48 89 00             	mov    %rax,(%rax)
  804160a883:	48 89 40 08          	mov    %rax,0x8(%rax)
    free_desc_count = INIT_DESCR;
  804160a887:	48 b8 10 41 40 42 80 	movabs $0x8042404110,%rax
  804160a88e:	00 00 00 
  804160a891:	48 c7 00 00 01 00 00 	movq   $0x100,(%rax)
    for (size_t i = 0; i < INIT_DESCR; i++)
  804160a898:	48 b8 e0 00 40 42 80 	movabs $0x80424000e0,%rax
  804160a89f:	00 00 00 
  804160a8a2:	48 8d b0 00 40 00 00 	lea    0x4000(%rax),%rsi
    list->next->prev = new;
  804160a8a9:	48 ba 20 41 40 42 80 	movabs $0x8042404120,%rdx
  804160a8b0:	00 00 00 
  804160a8b3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  804160a8b7:	48 89 01             	mov    %rax,(%rcx)
    new->next = list->next;
  804160a8ba:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  804160a8be:	48 89 48 08          	mov    %rcx,0x8(%rax)
    list->next = new;
  804160a8c2:	48 89 42 08          	mov    %rax,0x8(%rdx)
    new->prev = list;
  804160a8c6:	48 89 10             	mov    %rdx,(%rax)
    for (size_t i = 0; i < INIT_DESCR; i++)
  804160a8c9:	48 83 c0 40          	add    $0x40,%rax
  804160a8cd:	48 39 c6             	cmp    %rax,%rsi
  804160a8d0:	75 e1                	jne    804160a8b3 <init_memory+0x9e>
    list->next = list->prev = list;
  804160a8d2:	48 b8 60 00 40 42 80 	movabs $0x8042400060,%rax
  804160a8d9:	00 00 00 
  804160a8dc:	48 89 00             	mov    %rax,(%rax)
  804160a8df:	48 89 40 08          	mov    %rax,0x8(%rax)
    root.class = MAX_CLASS;
  804160a8e3:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  804160a8e7:	66 81 e2 00 f0       	and    $0xf000,%dx
  804160a8ec:	83 ca 30             	or     $0x30,%edx
  804160a8ef:	66 89 50 34          	mov    %dx,0x34(%rax)
    root.state = PARTIAL_NODE;
  804160a8f3:	c7 40 28 00 00 30 00 	movl   $0x300000,0x28(%rax)
    int res;
    (void)res;

    init_allocator();
    if (trace_init) cprintf("Memory allocator is initiallized\n");
  804160a8fa:	48 bf d8 28 61 41 80 	movabs $0x80416128d8,%rdi
  804160a901:	00 00 00 
  804160a904:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a909:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160a910:	00 00 00 
  804160a913:	ff d2                	call   *%rdx
    attach_region(0, PAGE_SIZE, RESERVED_NODE);
  804160a915:	ba 00 00 50 00       	mov    $0x500000,%edx
  804160a91a:	be 00 10 00 00       	mov    $0x1000,%esi
  804160a91f:	bf 00 00 00 00       	mov    $0x0,%edi
  804160a924:	48 b8 a9 68 60 41 80 	movabs $0x80416068a9,%rax
  804160a92b:	00 00 00 
  804160a92e:	ff d0                	call   *%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804160a930:	48 b8 00 60 40 42 80 	movabs $0x8042406000,%rax
  804160a937:	00 00 00 
  804160a93a:	48 ba ff ff ff 3f 80 	movabs $0x803fffffff,%rdx
  804160a941:	00 00 00 
  804160a944:	48 39 d0             	cmp    %rdx,%rax
  804160a947:	76 76                	jbe    804160a9bf <init_memory+0x1aa>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804160a949:	48 be 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rsi
  804160a950:	ff ff ff 
  804160a953:	48 01 c6             	add    %rax,%rsi
    attach_region(IOPHYSMEM, PADDR(end), RESERVED_NODE);
  804160a956:	ba 00 00 50 00       	mov    $0x500000,%edx
  804160a95b:	bf 00 00 0a 00       	mov    $0xa0000,%edi
  804160a960:	48 b8 a9 68 60 41 80 	movabs $0x80416068a9,%rax
  804160a967:	00 00 00 
  804160a96a:	ff d0                	call   *%rax
    if (uefi_lp && uefi_lp->MemoryMap) {
  804160a96c:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  804160a973:	00 00 00 
  804160a976:	48 85 c0             	test   %rax,%rax
  804160a979:	0f 84 f5 00 00 00    	je     804160aa74 <init_memory+0x25f>
  804160a97f:	48 8b 50 28          	mov    0x28(%rax),%rdx
  804160a983:	48 85 d2             	test   %rdx,%rdx
  804160a986:	0f 84 e8 00 00 00    	je     804160aa74 <init_memory+0x25f>
        EFI_MEMORY_DESCRIPTOR *start = (void *)uefi_lp->MemoryMap;
  804160a98c:	48 89 d3             	mov    %rdx,%rbx
        EFI_MEMORY_DESCRIPTOR *end = (void *)(uefi_lp->MemoryMap + uefi_lp->MemoryMapSize);
  804160a98f:	49 89 d5             	mov    %rdx,%r13
  804160a992:	4c 03 68 38          	add    0x38(%rax),%r13
        while (start < end) {
  804160a996:	4c 39 ea             	cmp    %r13,%rdx
  804160a999:	0f 83 b1 00 00 00    	jae    804160aa50 <init_memory+0x23b>
            max_memory_map_addr = MAX(start->NumberOfPages * EFI_PAGE_SIZE + start->PhysicalStart, max_memory_map_addr);
  804160a99f:	49 bc c8 00 40 42 80 	movabs $0x80424000c8,%r12
  804160a9a6:	00 00 00 
            attach_region(start->PhysicalStart, start->PhysicalStart + start->NumberOfPages * EFI_PAGE_SIZE, type);
  804160a9a9:	49 bf a9 68 60 41 80 	movabs $0x80416068a9,%r15
  804160a9b0:	00 00 00 
            start = (void *)((uint8_t *)start + uefi_lp->MemoryMapDescriptorSize);
  804160a9b3:	49 be 00 40 63 41 80 	movabs $0x8041634000,%r14
  804160a9ba:	00 00 00 
  804160a9bd:	eb 65                	jmp    804160aa24 <init_memory+0x20f>
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804160a9bf:	48 89 c1             	mov    %rax,%rcx
  804160a9c2:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160a9c9:	00 00 00 
  804160a9cc:	be 24 06 00 00       	mov    $0x624,%esi
  804160a9d1:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160a9d8:	00 00 00 
  804160a9db:	b8 00 00 00 00       	mov    $0x0,%eax
  804160a9e0:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160a9e7:	00 00 00 
  804160a9ea:	41 ff d0             	call   *%r8
            switch (start->Type) {
  804160a9ed:	ba 00 00 50 00       	mov    $0x500000,%edx
  804160a9f2:	85 c0                	test   %eax,%eax
  804160a9f4:	75 3f                	jne    804160aa35 <init_memory+0x220>
            max_memory_map_addr = MAX(start->NumberOfPages * EFI_PAGE_SIZE + start->PhysicalStart, max_memory_map_addr);
  804160a9f6:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  804160a9fa:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  804160a9fe:	48 c1 e6 0c          	shl    $0xc,%rsi
  804160aa02:	48 01 fe             	add    %rdi,%rsi
  804160aa05:	49 39 34 24          	cmp    %rsi,(%r12)
  804160aa09:	48 89 f0             	mov    %rsi,%rax
  804160aa0c:	49 0f 43 04 24       	cmovae (%r12),%rax
  804160aa11:	49 89 04 24          	mov    %rax,(%r12)
            attach_region(start->PhysicalStart, start->PhysicalStart + start->NumberOfPages * EFI_PAGE_SIZE, type);
  804160aa15:	41 ff d7             	call   *%r15
            start = (void *)((uint8_t *)start + uefi_lp->MemoryMapDescriptorSize);
  804160aa18:	49 8b 06             	mov    (%r14),%rax
  804160aa1b:	48 03 58 20          	add    0x20(%rax),%rbx
        while (start < end) {
  804160aa1f:	49 39 dd             	cmp    %rbx,%r13
  804160aa22:	76 2c                	jbe    804160aa50 <init_memory+0x23b>
            switch (start->Type) {
  804160aa24:	8b 03                	mov    (%rbx),%eax
  804160aa26:	83 f8 04             	cmp    $0x4,%eax
  804160aa29:	76 c2                	jbe    804160a9ed <init_memory+0x1d8>
  804160aa2b:	ba 00 00 50 00       	mov    $0x500000,%edx
  804160aa30:	83 f8 07             	cmp    $0x7,%eax
  804160aa33:	75 c1                	jne    804160a9f6 <init_memory+0x1e1>
                    type = start->Attribute & EFI_MEMORY_WB ? ALLOCATABLE_NODE : RESERVED_NODE;
  804160aa35:	48 8b 43 20          	mov    0x20(%rbx),%rax
  804160aa39:	83 e0 08             	and    $0x8,%eax
  804160aa3c:	48 83 f8 01          	cmp    $0x1,%rax
  804160aa40:	19 d2                	sbb    %edx,%edx
  804160aa42:	81 e2 00 00 10 00    	and    $0x100000,%edx
  804160aa48:	81 c2 00 00 40 00    	add    $0x400000,%edx
  804160aa4e:	eb a6                	jmp    804160a9f6 <init_memory+0x1e1>
        basemem = MIN(max_memory_map_addr, IOPHYSMEM);
  804160aa50:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160aa57:	00 00 00 
  804160aa5a:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  804160aa60:	be 00 00 0a 00       	mov    $0xa0000,%esi
  804160aa65:	48 0f 46 f0          	cmovbe %rax,%rsi
  804160aa69:	49 89 f5             	mov    %rsi,%r13
        extmem = max_memory_map_addr - basemem;
  804160aa6c:	48 29 f0             	sub    %rsi,%rax
  804160aa6f:	48 89 c3             	mov    %rax,%rbx
    if (uefi_lp && uefi_lp->MemoryMap) {
  804160aa72:	eb 6a                	jmp    804160aade <init_memory+0x2c9>
        basemem = cmos_read16(CMOS_BASELO) * KB;
  804160aa74:	bf 15 00 00 00       	mov    $0x15,%edi
  804160aa79:	48 bb 5f c5 60 41 80 	movabs $0x804160c55f,%rbx
  804160aa80:	00 00 00 
  804160aa83:	ff d3                	call   *%rbx
  804160aa85:	0f b7 f0             	movzwl %ax,%esi
  804160aa88:	48 c1 e6 0a          	shl    $0xa,%rsi
  804160aa8c:	49 89 f5             	mov    %rsi,%r13
        extmem = cmos_read16(CMOS_EXTLO) * KB;
  804160aa8f:	bf 17 00 00 00       	mov    $0x17,%edi
  804160aa94:	ff d3                	call   *%rbx
  804160aa96:	41 89 c4             	mov    %eax,%r12d
        size_t pextmem = (size_t)cmos_read16(CMOS_PEXTLO) * KB * 64;
  804160aa99:	bf 34 00 00 00       	mov    $0x34,%edi
  804160aa9e:	ff d3                	call   *%rbx
  804160aaa0:	0f b7 d8             	movzwl %ax,%ebx
        if (pextmem) extmem = (16 * MB + pextmem - MB);
  804160aaa3:	48 c1 e3 10          	shl    $0x10,%rbx
  804160aaa7:	0f 84 51 04 00 00    	je     804160aefe <init_memory+0x6e9>
  804160aaad:	48 81 c3 00 00 f0 00 	add    $0xf00000,%rbx
        max_memory_map_addr = extmem ? EXTPHYSMEM + extmem : basemem;
  804160aab4:	48 8d b3 00 00 10 00 	lea    0x100000(%rbx),%rsi
  804160aabb:	48 89 f0             	mov    %rsi,%rax
  804160aabe:	48 a3 c8 00 40 42 80 	movabs %rax,0x80424000c8
  804160aac5:	00 00 00 
        attach_region(0, max_memory_map_addr, ALLOCATABLE_NODE);
  804160aac8:	ba 00 00 40 00       	mov    $0x400000,%edx
  804160aacd:	bf 00 00 00 00       	mov    $0x0,%edi
  804160aad2:	48 b8 a9 68 60 41 80 	movabs $0x80416068a9,%rax
  804160aad9:	00 00 00 
  804160aadc:	ff d0                	call   *%rax
                (size_t)((basemem + extmem) / MB), (size_t)(basemem / KB), (size_t)(extmem / KB));
  804160aade:	48 89 d9             	mov    %rbx,%rcx
  804160aae1:	48 c1 e9 0a          	shr    $0xa,%rcx
  804160aae5:	4c 89 ea             	mov    %r13,%rdx
  804160aae8:	48 c1 ea 0a          	shr    $0xa,%rdx
  804160aaec:	4a 8d 34 2b          	lea    (%rbx,%r13,1),%rsi
  804160aaf0:	48 c1 ee 14          	shr    $0x14,%rsi
        cprintf("Physical memory: %zuM available, base = %zuK, extended = %zuK\n",
  804160aaf4:	48 bf 00 29 61 41 80 	movabs $0x8041612900,%rdi
  804160aafb:	00 00 00 
  804160aafe:	b8 00 00 00 00       	mov    $0x0,%eax
  804160ab03:	49 b8 99 c8 60 41 80 	movabs $0x804160c899,%r8
  804160ab0a:	00 00 00 
  804160ab0d:	41 ff d0             	call   *%r8
    check_physical_tree(&root);
  804160ab10:	48 bf 60 00 40 42 80 	movabs $0x8042400060,%rdi
  804160ab17:	00 00 00 
  804160ab1a:	48 b8 38 4d 60 41 80 	movabs $0x8041604d38,%rax
  804160ab21:	00 00 00 
  804160ab24:	ff d0                	call   *%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804160ab26:	48 b8 00 00 00 42 80 	movabs $0x8042000000,%rax
  804160ab2d:	00 00 00 
  804160ab30:	48 ba ff ff ff 3f 80 	movabs $0x803fffffff,%rdx
  804160ab37:	00 00 00 
  804160ab3a:	48 39 d0             	cmp    %rdx,%rax
  804160ab3d:	0f 86 d1 03 00 00    	jbe    804160af14 <init_memory+0x6ff>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804160ab43:	48 be 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rsi
  804160ab4a:	ff ff ff 
  804160ab4d:	48 01 c6             	add    %rax,%rsi
    one_page = page_lookup(NULL, PADDR(one_page_raw), MAX_ALLOCATION_CLASS, PARTIAL_NODE, 1);
  804160ab50:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804160ab56:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804160ab5b:	ba 09 00 00 00       	mov    $0x9,%edx
  804160ab60:	bf 00 00 00 00       	mov    $0x0,%edi
  804160ab65:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  804160ab6c:	00 00 00 
  804160ab6f:	ff d0                	call   *%rax
  804160ab71:	48 a3 f8 40 40 42 80 	movabs %rax,0x80424040f8
  804160ab78:	00 00 00 
    page_ref(one_page);
  804160ab7b:	48 89 c7             	mov    %rax,%rdi
  804160ab7e:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  804160ab85:	00 00 00 
  804160ab88:	ff d0                	call   *%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804160ab8a:	48 bb 00 00 20 42 80 	movabs $0x8042200000,%rbx
  804160ab91:	00 00 00 
  804160ab94:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804160ab9b:	00 00 00 
  804160ab9e:	48 39 c3             	cmp    %rax,%rbx
  804160aba1:	0f 86 9b 03 00 00    	jbe    804160af42 <init_memory+0x72d>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804160aba7:	48 be 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rsi
  804160abae:	ff ff ff 
  804160abb1:	48 01 de             	add    %rbx,%rsi
    zero_page = page_lookup(NULL, PADDR(zero_page_raw), MAX_ALLOCATION_CLASS, PARTIAL_NODE, 1);
  804160abb4:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804160abba:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804160abbf:	ba 09 00 00 00       	mov    $0x9,%edx
  804160abc4:	bf 00 00 00 00       	mov    $0x0,%edi
  804160abc9:	48 b8 03 59 60 41 80 	movabs $0x8041605903,%rax
  804160abd0:	00 00 00 
  804160abd3:	ff d0                	call   *%rax
  804160abd5:	49 89 c4             	mov    %rax,%r12
  804160abd8:	48 a3 00 41 40 42 80 	movabs %rax,0x8042404100
  804160abdf:	00 00 00 
    page_ref(zero_page);
  804160abe2:	48 89 c7             	mov    %rax,%rdi
  804160abe5:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  804160abec:	00 00 00 
  804160abef:	ff d0                	call   *%rax
    assert(zero_page && one_page);
  804160abf1:	4d 85 e4             	test   %r12,%r12
  804160abf4:	0f 84 76 03 00 00    	je     804160af70 <init_memory+0x75b>
  804160abfa:	48 b8 f8 40 40 42 80 	movabs $0x80424040f8,%rax
  804160ac01:	00 00 00 
  804160ac04:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160ac08:	0f 84 62 03 00 00    	je     804160af70 <init_memory+0x75b>

    detect_memory();
    check_physical_tree(&root);
  804160ac0e:	48 bf 60 00 40 42 80 	movabs $0x8042400060,%rdi
  804160ac15:	00 00 00 
  804160ac18:	48 b8 38 4d 60 41 80 	movabs $0x8041604d38,%rax
  804160ac1f:	00 00 00 
  804160ac22:	ff d0                	call   *%rax
    if (trace_init) cprintf("Physical memory tree is correct\n");
  804160ac24:	48 bf 40 29 61 41 80 	movabs $0x8041612940,%rdi
  804160ac2b:	00 00 00 
  804160ac2e:	b8 00 00 00 00       	mov    $0x0,%eax
  804160ac33:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160ac3a:	00 00 00 
  804160ac3d:	ff d2                	call   *%rdx
    struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  804160ac3f:	be 00 00 04 00       	mov    $0x40000,%esi
  804160ac44:	bf 00 00 00 00       	mov    $0x0,%edi
  804160ac49:	48 b8 a2 5d 60 41 80 	movabs $0x8041605da2,%rax
  804160ac50:	00 00 00 
  804160ac53:	ff d0                	call   *%rax
  804160ac55:	49 89 c4             	mov    %rax,%r12
    page_ref(page);
  804160ac58:	48 89 c7             	mov    %rax,%rdi
  804160ac5b:	48 b8 d2 47 60 41 80 	movabs $0x80416047d2,%rax
  804160ac62:	00 00 00 
  804160ac65:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  804160ac67:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804160ac6e:	ff 0f 00 
  804160ac71:	48 89 c1             	mov    %rax,%rcx
  804160ac74:	49 23 4c 24 38       	and    0x38(%r12),%rcx
  804160ac79:	48 c1 e1 0c          	shl    $0xc,%rcx
  804160ac7d:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  804160ac80:	48 a1 c8 00 40 42 80 	movabs 0x80424000c8,%rax
  804160ac87:	00 00 00 
  804160ac8a:	48 39 c1             	cmp    %rax,%rcx
  804160ac8d:	0f 87 12 03 00 00    	ja     804160afa5 <init_memory+0x790>
    return (void *)(pa + KERN_BASE_ADDR);
  804160ac93:	49 bd 00 00 00 40 80 	movabs $0x8040000000,%r13
  804160ac9a:	00 00 00 
  804160ac9d:	4a 8d 3c 29          	lea    (%rcx,%r13,1),%rdi
    kspace.pml4 = KADDR(page2pa(page));
  804160aca1:	49 bc b0 00 40 42 80 	movabs $0x80424000b0,%r12
  804160aca8:	00 00 00 
  804160acab:	49 89 3c 24          	mov    %rdi,(%r12)
    kspace.cr3 = page2pa(page);
  804160acaf:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    memset(kspace.pml4, 0, CLASS_SIZE(0));
  804160acb4:	ba 00 10 00 00       	mov    $0x1000,%edx
  804160acb9:	be 00 00 00 00       	mov    $0x0,%esi
  804160acbe:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160acc5:	00 00 00 
  804160acc8:	ff d0                	call   *%rax
    kspace.pml4[PML4_INDEX(UVPT)] = kspace.cr3 | PTE_P | PTE_U;
  804160acca:	49 8b 14 24          	mov    (%r12),%rdx
  804160acce:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  804160acd3:	48 83 c8 05          	or     $0x5,%rax
  804160acd7:	48 89 42 10          	mov    %rax,0x10(%rdx)
    kspace.root = alloc_descriptor(INTERMEDIATE_NODE);
  804160acdb:	bf 00 00 20 00       	mov    $0x200000,%edi
  804160ace0:	48 b8 77 57 60 41 80 	movabs $0x8041605777,%rax
  804160ace7:	00 00 00 
  804160acea:	ff d0                	call   *%rax
  804160acec:	49 89 44 24 10       	mov    %rax,0x10(%r12)
    /* NOTE We cannot use map_region to map memory allocated with ALLOC_WEAK */

    // LAB 7: Your code here
    // NOTE: You need to check if map_physical_region returned 0 everywhere! (and panic otherwise)
    // Map [0, max_memory_map_addr] to [KERN_BASE_ADDR, KERN_BASE_ADDR + max_memory_map_addr] as RW- + ALLOC_WEAK
    res = map_physical_region(&kspace, KERN_BASE_ADDR, 0, max_memory_map_addr, PROT_R | PROT_W | ALLOC_WEAK);
  804160acf1:	41 b8 06 00 02 00    	mov    $0x20006,%r8d
  804160acf7:	48 b8 c8 00 40 42 80 	movabs $0x80424000c8,%rax
  804160acfe:	00 00 00 
  804160ad01:	48 8b 08             	mov    (%rax),%rcx
  804160ad04:	ba 00 00 00 00       	mov    $0x0,%edx
  804160ad09:	4c 89 ee             	mov    %r13,%rsi
  804160ad0c:	4c 89 e7             	mov    %r12,%rdi
  804160ad0f:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160ad16:	00 00 00 
  804160ad19:	ff d0                	call   *%rax
    if (res) panic("Cannot map kernel");
  804160ad1b:	85 c0                	test   %eax,%eax
  804160ad1d:	0f 85 b0 02 00 00    	jne    804160afd3 <init_memory+0x7be>

    extern char __text_end[], __text_start[];
    assert(!((uintptr_t)__text_start & CLASS_MASK(0)));
  804160ad23:	48 b8 00 00 60 41 80 	movabs $0x8041600000,%rax
  804160ad2a:	00 00 00 
  804160ad2d:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804160ad32:	0f 85 c5 02 00 00    	jne    804160affd <init_memory+0x7e8>
    assert(__text_end - __text_start < MAX_LOW_ADDR_KERN_SIZE);
  804160ad38:	48 b9 a8 10 61 41 80 	movabs $0x80416110a8,%rcx
  804160ad3f:	00 00 00 
  804160ad42:	48 b8 00 00 60 41 80 	movabs $0x8041600000,%rax
  804160ad49:	00 00 00 
  804160ad4c:	48 29 c1             	sub    %rax,%rcx
  804160ad4f:	48 81 f9 ff ff 1f 03 	cmp    $0x31fffff,%rcx
  804160ad56:	0f 8f d6 02 00 00    	jg     804160b032 <init_memory+0x81d>
    assert((uintptr_t)(end - KERN_BASE_ADDR) < MIN(BOOT_MEM_SIZE, max_memory_map_addr));
  804160ad5c:	48 ba c8 00 40 42 80 	movabs $0x80424000c8,%rdx
  804160ad63:	00 00 00 
  804160ad66:	48 81 3a 00 00 00 40 	cmpq   $0x40000000,(%rdx)
  804160ad6d:	b8 00 00 00 40       	mov    $0x40000000,%eax
  804160ad72:	48 0f 46 02          	cmovbe (%rdx),%rax
  804160ad76:	48 ba 00 60 40 02 00 	movabs $0x2406000,%rdx
  804160ad7d:	00 00 00 
  804160ad80:	48 39 d0             	cmp    %rdx,%rax
  804160ad83:	0f 86 de 02 00 00    	jbe    804160b067 <init_memory+0x852>
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804160ad89:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804160ad90:	00 00 00 
  804160ad93:	48 bf 00 00 60 41 80 	movabs $0x8041600000,%rdi
  804160ad9a:	00 00 00 
  804160ad9d:	48 39 c7             	cmp    %rax,%rdi
  804160ada0:	0f 86 f6 02 00 00    	jbe    804160b09c <init_memory+0x887>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804160ada6:	48 b8 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rax
  804160adad:	ff ff ff 
  804160adb0:	48 bf 00 00 60 41 80 	movabs $0x8041600000,%rdi
  804160adb7:	00 00 00 
  804160adba:	48 01 f8             	add    %rdi,%rax
  804160adbd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* ...and make kernel .text section executable: */

    // LAB 7: Your code here
    // Map [PADDR(__text_start);PADDR(__text_end)] to [__text_start, __text_end] as RW-
    res = map_physical_region(&kspace,  (uintptr_t)__text_start, 
  804160adc1:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  804160adc7:	48 89 c2             	mov    %rax,%rdx
  804160adca:	48 89 fe             	mov    %rdi,%rsi
  804160adcd:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160add4:	00 00 00 
  804160add7:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160adde:	00 00 00 
  804160ade1:	ff d0                	call   *%rax
                                        PADDR(__text_start),
                                       __text_end - __text_start, PROT_R | PROT_X);
    if (res) panic("Cannot map kernel");
  804160ade3:	85 c0                	test   %eax,%eax
  804160ade5:	0f 85 df 02 00 00    	jne    804160b0ca <init_memory+0x8b5>
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804160adeb:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804160adf2:	00 00 00 
  804160adf5:	48 bf 00 40 61 41 80 	movabs $0x8041614000,%rdi
  804160adfc:	00 00 00 
  804160adff:	48 39 c7             	cmp    %rax,%rdi
  804160ae02:	0f 86 ec 02 00 00    	jbe    804160b0f4 <init_memory+0x8df>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804160ae08:	48 b8 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rax
  804160ae0f:	ff ff ff 
  804160ae12:	48 bf 00 40 61 41 80 	movabs $0x8041614000,%rdi
  804160ae19:	00 00 00 
  804160ae1c:	48 01 f8             	add    %rdi,%rax
  804160ae1f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

    /* Allocate kernel stacks */

    // LAB 7: Your code here
    // Map [PADDR(bootstack), PADDR(bootstack) + KERN_STACK_SIZE] to [KERN_STACK_TOP - KERN_STACK_SIZE, KERN_STACK_TOP] as RW-
    res = map_physical_region(&kspace, 
  804160ae23:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804160ae29:	b9 00 00 01 00       	mov    $0x10000,%ecx
  804160ae2e:	48 89 c2             	mov    %rax,%rdx
  804160ae31:	48 be 00 00 ff 3f 80 	movabs $0x803fff0000,%rsi
  804160ae38:	00 00 00 
  804160ae3b:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160ae42:	00 00 00 
  804160ae45:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160ae4c:	00 00 00 
  804160ae4f:	ff d0                	call   *%rax
                                       KERN_STACK_TOP - KERN_STACK_SIZE, PADDR(bootstack), 
                                       KERN_STACK_SIZE, PROT_R | PROT_W);
    if (res) panic("Cannot map kernel");
  804160ae51:	85 c0                	test   %eax,%eax
  804160ae53:	0f 85 c9 02 00 00    	jne    804160b122 <init_memory+0x90d>
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804160ae59:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804160ae60:	00 00 00 
  804160ae63:	48 bf 00 40 62 41 80 	movabs $0x8041624000,%rdi
  804160ae6a:	00 00 00 
  804160ae6d:	48 39 c7             	cmp    %rax,%rdi
  804160ae70:	0f 86 d6 02 00 00    	jbe    804160b14c <init_memory+0x937>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804160ae76:	48 b8 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rax
  804160ae7d:	ff ff ff 
  804160ae80:	48 bf 00 40 62 41 80 	movabs $0x8041624000,%rdi
  804160ae87:	00 00 00 
  804160ae8a:	48 01 f8             	add    %rdi,%rax
  804160ae8d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    // Map [PADDR(pfstack), PADDR(pfstack) + KERN_PF_STACK_SIZE] to [KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE, KERN_PF_STACK_TOP] as RW-
    res = map_physical_region(&kspace, 
  804160ae91:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804160ae97:	b9 00 00 01 00       	mov    $0x10000,%ecx
  804160ae9c:	48 89 c2             	mov    %rax,%rdx
  804160ae9f:	48 be 00 80 fd 3f 80 	movabs $0x803ffd8000,%rsi
  804160aea6:	00 00 00 
  804160aea9:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160aeb0:	00 00 00 
  804160aeb3:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160aeba:	00 00 00 
  804160aebd:	ff d0                	call   *%rax
                                       KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE, PADDR(pfstack), 
                                       KERN_PF_STACK_SIZE, PROT_R | PROT_W);
    if (res) panic("Cannot map kernel");
  804160aebf:	85 c0                	test   %eax,%eax
  804160aec1:	0f 85 b3 02 00 00    	jne    804160b17a <init_memory+0x965>

#ifdef SANITIZE_SHADOW_BASE
    init_s22dow_pre();
#endif

    EFI_MEMORY_DESCRIPTOR *mstart = (void *)uefi_lp->MemoryMap;
  804160aec7:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  804160aece:	00 00 00 
  804160aed1:	4c 8b 60 28          	mov    0x28(%rax),%r12
    EFI_MEMORY_DESCRIPTOR *mend = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapSize);
  804160aed5:	4d 89 e5             	mov    %r12,%r13
  804160aed8:	4c 03 68 38          	add    0x38(%rax),%r13
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804160aedc:	4d 39 ec             	cmp    %r13,%r12
  804160aedf:	0f 83 27 03 00 00    	jae    804160b20c <init_memory+0x9f7>
        if (mstart->Attribute & EFI_MEMORY_RUNTIME) {
            // LAB 7: Your code here
            // Map [mstart->PhysicalStart, mstart->PhysicalStart+mstart->NumberOfPages*PAGE_SIZE] to
            //     [mstart->VirtualStart, mstart->VirtualStart+mstart->NumberOfPages*PAGE_SIZE] as RW-
            res = map_physical_region(&kspace, 
  804160aee5:	49 bf 2d 87 60 41 80 	movabs $0x804160872d,%r15
  804160aeec:	00 00 00 
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804160aeef:	49 be 00 40 63 41 80 	movabs $0x8041634000,%r14
  804160aef6:	00 00 00 
  804160aef9:	e9 b2 02 00 00       	jmp    804160b1b0 <init_memory+0x99b>
        extmem = cmos_read16(CMOS_EXTLO) * KB;
  804160aefe:	41 0f b7 dc          	movzwl %r12w,%ebx
        max_memory_map_addr = extmem ? EXTPHYSMEM + extmem : basemem;
  804160af02:	48 c1 e3 0a          	shl    $0xa,%rbx
  804160af06:	0f 85 a8 fb ff ff    	jne    804160aab4 <init_memory+0x29f>
  804160af0c:	4c 89 ee             	mov    %r13,%rsi
  804160af0f:	e9 a7 fb ff ff       	jmp    804160aabb <init_memory+0x2a6>
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804160af14:	48 89 c1             	mov    %rax,%rcx
  804160af17:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160af1e:	00 00 00 
  804160af21:	be 58 06 00 00       	mov    $0x658,%esi
  804160af26:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160af2d:	00 00 00 
  804160af30:	b8 00 00 00 00       	mov    $0x0,%eax
  804160af35:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160af3c:	00 00 00 
  804160af3f:	41 ff d0             	call   *%r8
  804160af42:	48 89 d9             	mov    %rbx,%rcx
  804160af45:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160af4c:	00 00 00 
  804160af4f:	be 5b 06 00 00       	mov    $0x65b,%esi
  804160af54:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160af5b:	00 00 00 
  804160af5e:	b8 00 00 00 00       	mov    $0x0,%eax
  804160af63:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160af6a:	00 00 00 
  804160af6d:	41 ff d0             	call   *%r8
    assert(zero_page && one_page);
  804160af70:	48 b9 7e 1e 61 41 80 	movabs $0x8041611e7e,%rcx
  804160af77:	00 00 00 
  804160af7a:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160af81:	00 00 00 
  804160af84:	be 5e 06 00 00       	mov    $0x65e,%esi
  804160af89:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160af90:	00 00 00 
  804160af93:	b8 00 00 00 00       	mov    $0x0,%eax
  804160af98:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160af9f:	00 00 00 
  804160afa2:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804160afa5:	49 89 c0             	mov    %rax,%r8
  804160afa8:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160afaf:	00 00 00 
  804160afb2:	be b6 06 00 00       	mov    $0x6b6,%esi
  804160afb7:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160afbe:	00 00 00 
  804160afc1:	b8 00 00 00 00       	mov    $0x0,%eax
  804160afc6:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160afcd:	00 00 00 
  804160afd0:	41 ff d1             	call   *%r9
    if (res) panic("Cannot map kernel");
  804160afd3:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160afda:	00 00 00 
  804160afdd:	be 07 07 00 00       	mov    $0x707,%esi
  804160afe2:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160afe9:	00 00 00 
  804160afec:	b8 00 00 00 00       	mov    $0x0,%eax
  804160aff1:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160aff8:	00 00 00 
  804160affb:	ff d1                	call   *%rcx
    assert(!((uintptr_t)__text_start & CLASS_MASK(0)));
  804160affd:	48 b9 68 29 61 41 80 	movabs $0x8041612968,%rcx
  804160b004:	00 00 00 
  804160b007:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160b00e:	00 00 00 
  804160b011:	be 0a 07 00 00       	mov    $0x70a,%esi
  804160b016:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b01d:	00 00 00 
  804160b020:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b025:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b02c:	00 00 00 
  804160b02f:	41 ff d0             	call   *%r8
    assert(__text_end - __text_start < MAX_LOW_ADDR_KERN_SIZE);
  804160b032:	48 b9 98 29 61 41 80 	movabs $0x8041612998,%rcx
  804160b039:	00 00 00 
  804160b03c:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160b043:	00 00 00 
  804160b046:	be 0b 07 00 00       	mov    $0x70b,%esi
  804160b04b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b052:	00 00 00 
  804160b055:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b05a:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b061:	00 00 00 
  804160b064:	41 ff d0             	call   *%r8
    assert((uintptr_t)(end - KERN_BASE_ADDR) < MIN(BOOT_MEM_SIZE, max_memory_map_addr));
  804160b067:	48 b9 d0 29 61 41 80 	movabs $0x80416129d0,%rcx
  804160b06e:	00 00 00 
  804160b071:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160b078:	00 00 00 
  804160b07b:	be 0c 07 00 00       	mov    $0x70c,%esi
  804160b080:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b087:	00 00 00 
  804160b08a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b08f:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b096:	00 00 00 
  804160b099:	41 ff d0             	call   *%r8
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804160b09c:	48 89 f9             	mov    %rdi,%rcx
  804160b09f:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160b0a6:	00 00 00 
  804160b0a9:	be 13 07 00 00       	mov    $0x713,%esi
  804160b0ae:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b0b5:	00 00 00 
  804160b0b8:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b0bd:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b0c4:	00 00 00 
  804160b0c7:	41 ff d0             	call   *%r8
    if (res) panic("Cannot map kernel");
  804160b0ca:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b0d1:	00 00 00 
  804160b0d4:	be 15 07 00 00       	mov    $0x715,%esi
  804160b0d9:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b0e0:	00 00 00 
  804160b0e3:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b0e8:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b0ef:	00 00 00 
  804160b0f2:	ff d1                	call   *%rcx
  804160b0f4:	48 89 f9             	mov    %rdi,%rcx
  804160b0f7:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160b0fe:	00 00 00 
  804160b101:	be 1d 07 00 00       	mov    $0x71d,%esi
  804160b106:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b10d:	00 00 00 
  804160b110:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b115:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b11c:	00 00 00 
  804160b11f:	41 ff d0             	call   *%r8
    if (res) panic("Cannot map kernel");
  804160b122:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b129:	00 00 00 
  804160b12c:	be 1f 07 00 00       	mov    $0x71f,%esi
  804160b131:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b138:	00 00 00 
  804160b13b:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b140:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b147:	00 00 00 
  804160b14a:	ff d1                	call   *%rcx
  804160b14c:	48 89 f9             	mov    %rdi,%rcx
  804160b14f:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160b156:	00 00 00 
  804160b159:	be 22 07 00 00       	mov    $0x722,%esi
  804160b15e:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b165:	00 00 00 
  804160b168:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b16d:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b174:	00 00 00 
  804160b177:	41 ff d0             	call   *%r8
    if (res) panic("Cannot map kernel");
  804160b17a:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b181:	00 00 00 
  804160b184:	be 24 07 00 00       	mov    $0x724,%esi
  804160b189:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b190:	00 00 00 
  804160b193:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b198:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b19f:	00 00 00 
  804160b1a2:	ff d1                	call   *%rcx
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804160b1a4:	49 8b 06             	mov    (%r14),%rax
  804160b1a7:	4c 03 60 20          	add    0x20(%rax),%r12
  804160b1ab:	4d 39 e5             	cmp    %r12,%r13
  804160b1ae:	76 5c                	jbe    804160b20c <init_memory+0x9f7>
        if (mstart->Attribute & EFI_MEMORY_RUNTIME) {
  804160b1b0:	49 83 7c 24 20 00    	cmpq   $0x0,0x20(%r12)
  804160b1b6:	79 ec                	jns    804160b1a4 <init_memory+0x98f>
                                       mstart->VirtualStart, mstart->PhysicalStart, 
                                       mstart->NumberOfPages*PAGE_SIZE, PROT_R | PROT_W);
  804160b1b8:	49 8b 4c 24 18       	mov    0x18(%r12),%rcx
  804160b1bd:	48 c1 e1 0c          	shl    $0xc,%rcx
            res = map_physical_region(&kspace, 
  804160b1c1:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  804160b1c6:	49 8b 74 24 10       	mov    0x10(%r12),%rsi
  804160b1cb:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804160b1d1:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160b1d8:	00 00 00 
  804160b1db:	41 ff d7             	call   *%r15
            if (res) panic("Cannot map kernel");
  804160b1de:	85 c0                	test   %eax,%eax
  804160b1e0:	74 c2                	je     804160b1a4 <init_memory+0x98f>
  804160b1e2:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b1e9:	00 00 00 
  804160b1ec:	be 34 07 00 00       	mov    $0x734,%esi
  804160b1f1:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b1f8:	00 00 00 
  804160b1fb:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b200:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b207:	00 00 00 
  804160b20a:	ff d1                	call   *%rcx
    if (trace_memory_more) {
        cprintf("uefi_lp= %p %p\n", (void *)uefi_lp, (void *)uefi_lp->SelfVirtual);
    }

    /* Fixup loader params address after mapping it */
    uefi_lp = (LOADER_PARAMS *)uefi_lp->SelfVirtual;
  804160b20c:	48 b8 00 40 63 41 80 	movabs $0x8041634000,%rax
  804160b213:	00 00 00 
  804160b216:	48 8b 10             	mov    (%rax),%rdx
  804160b219:	48 8b 12             	mov    (%rdx),%rdx
  804160b21c:	48 89 10             	mov    %rdx,(%rax)
  804160b21f:	b8 23 00 05 80       	mov    $0x80050023,%eax
  804160b224:	0f 22 c0             	mov    %rax,%cr0
    asm volatile("movq %0,%%cr4" ::"r"(val));
  804160b227:	b8 30 01 00 00       	mov    $0x130,%eax
  804160b22c:	0f 22 e0             	mov    %rax,%cr4
    asm volatile("rdmsr"
  804160b22f:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
  804160b234:	0f 32                	rdmsr  
    asm volatile("rdmsr"
  804160b236:	0f 32                	rdmsr  
    /* Enable NX bit (execution protection) */
    uint64_t efer = rdmsr(EFER_MSR);
    efer |= EFER_NXE;
    wrmsr(EFER_MSR, efer);

    for (size_t i = 0; i < CLASS_SIZE(MAX_ALLOCATION_CLASS); i++) assert(!zero_page_raw[i]);
  804160b238:	48 b8 00 00 40 42 80 	movabs $0x8042400000,%rax
  804160b23f:	00 00 00 
  804160b242:	80 3b 00             	cmpb   $0x0,(%rbx)
  804160b245:	0f 85 b9 00 00 00    	jne    804160b304 <init_memory+0xaef>
  804160b24b:	48 83 c3 01          	add    $0x1,%rbx
  804160b24f:	48 39 c3             	cmp    %rax,%rbx
  804160b252:	75 ee                	jne    804160b242 <init_memory+0xa2d>

    switch_address_space(&kspace);
  804160b254:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160b25b:	00 00 00 
  804160b25e:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160b265:	00 00 00 
  804160b268:	ff d0                	call   *%rax
    /* One page is a page filled with 0xFF values -- ASAN poison */
    nosan_memset(one_page_raw, 0xFF, CLASS_SIZE(MAX_ALLOCATION_CLASS));
  804160b26a:	ba 00 00 20 00       	mov    $0x200000,%edx
  804160b26f:	be ff 00 00 00       	mov    $0xff,%esi
  804160b274:	48 bf 00 00 00 42 80 	movabs $0x8042000000,%rdi
  804160b27b:	00 00 00 
  804160b27e:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160b285:	00 00 00 
  804160b288:	ff d0                	call   *%rax
    /* Perform global constructor initialisation (e.g. asan)
    * This must be done as early as possible */
    extern void (*__ctors_start)();
    extern void (*__ctors_end)();
    void (**ctor)() = &__ctors_start;
    while (ctor < &__ctors_end) (*ctor++)();
  804160b28a:	48 ba 18 8a cc 41 80 	movabs $0x8041cc8a18,%rdx
  804160b291:	00 00 00 
  804160b294:	48 b8 18 8a cc 41 80 	movabs $0x8041cc8a18,%rax
  804160b29b:	00 00 00 
  804160b29e:	48 39 c2             	cmp    %rax,%rdx
  804160b2a1:	73 17                	jae    804160b2ba <init_memory+0xaa5>
    void (**ctor)() = &__ctors_start;
  804160b2a3:	48 89 d3             	mov    %rdx,%rbx
    while (ctor < &__ctors_end) (*ctor++)();
  804160b2a6:	49 89 c4             	mov    %rax,%r12
  804160b2a9:	48 83 c3 08          	add    $0x8,%rbx
  804160b2ad:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b2b2:	ff 53 f8             	call   *-0x8(%rbx)
  804160b2b5:	4c 39 e3             	cmp    %r12,%rbx
  804160b2b8:	72 ef                	jb     804160b2a9 <init_memory+0xa94>
    unpoison_meta(&root);
#endif

    /* Traps needs to be initiallized here
     * to alloc #PF to be handled during lazy allocation */
    trap_init();
  804160b2ba:	48 b8 52 ca 60 41 80 	movabs $0x804160ca52,%rax
  804160b2c1:	00 00 00 
  804160b2c4:	ff d0                	call   *%rax

    /* Check uefi memory mappings */
    mstart = (void *)uefi_lp->MemoryMapVirt;
  804160b2c6:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  804160b2cd:	00 00 00 
  804160b2d0:	48 8b 58 30          	mov    0x30(%rax),%rbx
    mend = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapSize);
  804160b2d4:	49 89 dc             	mov    %rbx,%r12
  804160b2d7:	4c 03 60 38          	add    0x38(%rax),%r12
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804160b2db:	4c 39 e3             	cmp    %r12,%rbx
  804160b2de:	0f 83 fc 00 00 00    	jae    804160b3e0 <init_memory+0xbcb>
    if (pa > max_memory_map_addr)
  804160b2e4:	49 bf c8 00 40 42 80 	movabs $0x80424000c8,%r15
  804160b2eb:	00 00 00 
        if (mstart->Attribute & EFI_MEMORY_RUNTIME) {
            int expected;
            nosan_memcpy(&expected, KADDR(mstart->PhysicalStart), sizeof(int));
  804160b2ee:	49 be b4 fe 60 41 80 	movabs $0x804160feb4,%r14
  804160b2f5:	00 00 00 
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804160b2f8:	49 bd 00 40 63 41 80 	movabs $0x8041634000,%r13
  804160b2ff:	00 00 00 
  804160b302:	eb 70                	jmp    804160b374 <init_memory+0xb5f>
    for (size_t i = 0; i < CLASS_SIZE(MAX_ALLOCATION_CLASS); i++) assert(!zero_page_raw[i]);
  804160b304:	48 b9 a6 1e 61 41 80 	movabs $0x8041611ea6,%rcx
  804160b30b:	00 00 00 
  804160b30e:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160b315:	00 00 00 
  804160b318:	be 48 07 00 00       	mov    $0x748,%esi
  804160b31d:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b324:	00 00 00 
  804160b327:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b32c:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b333:	00 00 00 
  804160b336:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804160b339:	48 89 f1             	mov    %rsi,%rcx
  804160b33c:	48 ba 98 23 61 41 80 	movabs $0x8041612398,%rdx
  804160b343:	00 00 00 
  804160b346:	be 63 07 00 00       	mov    $0x763,%esi
  804160b34b:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b352:	00 00 00 
  804160b355:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b35a:	49 b9 d9 02 60 41 80 	movabs $0x80416002d9,%r9
  804160b361:	00 00 00 
  804160b364:	41 ff d1             	call   *%r9
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804160b367:	49 8b 45 00          	mov    0x0(%r13),%rax
  804160b36b:	48 03 58 20          	add    0x20(%rax),%rbx
  804160b36f:	49 39 dc             	cmp    %rbx,%r12
  804160b372:	76 6c                	jbe    804160b3e0 <init_memory+0xbcb>
        if (mstart->Attribute & EFI_MEMORY_RUNTIME) {
  804160b374:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
  804160b379:	79 ec                	jns    804160b367 <init_memory+0xb52>
            nosan_memcpy(&expected, KADDR(mstart->PhysicalStart), sizeof(int));
  804160b37b:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    if (pa > max_memory_map_addr)
  804160b37f:	4d 8b 07             	mov    (%r15),%r8
  804160b382:	4c 39 c6             	cmp    %r8,%rsi
  804160b385:	77 b2                	ja     804160b339 <init_memory+0xb24>
    return (void *)(pa + KERN_BASE_ADDR);
  804160b387:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804160b38e:	00 00 00 
  804160b391:	48 01 c6             	add    %rax,%rsi
  804160b394:	ba 04 00 00 00       	mov    $0x4,%edx
  804160b399:	48 8d 7d cc          	lea    -0x34(%rbp),%rdi
  804160b39d:	41 ff d6             	call   *%r14
            assert(*(volatile int *)mstart->VirtualStart == expected);
  804160b3a0:	48 8b 43 10          	mov    0x10(%rbx),%rax
  804160b3a4:	8b 00                	mov    (%rax),%eax
  804160b3a6:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  804160b3a9:	74 bc                	je     804160b367 <init_memory+0xb52>
  804160b3ab:	48 b9 20 2a 61 41 80 	movabs $0x8041612a20,%rcx
  804160b3b2:	00 00 00 
  804160b3b5:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160b3bc:	00 00 00 
  804160b3bf:	be 64 07 00 00       	mov    $0x764,%esi
  804160b3c4:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b3cb:	00 00 00 
  804160b3ce:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b3d3:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b3da:	00 00 00 
  804160b3dd:	41 ff d0             	call   *%r8
    // LAB 7: Your code here
    // Map [FRAMEBUFFER, FRAMEBUFFER + uefi_lp->FrameBufferSize] to
    //     [uefi_lp->FrameBufferBase, uefi_lp->FrameBufferBase + uefi_lp->FrameBufferSize] RW- + PROT_WC
    res = map_physical_region(&kspace, 
                                       FRAMEBUFFER, uefi_lp->FrameBufferBase, 
                                       uefi_lp->FrameBufferSize, PROT_R | PROT_W | PROT_WC);
  804160b3e0:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  804160b3e7:	00 00 00 
    res = map_physical_region(&kspace, 
  804160b3ea:	8b 48 48             	mov    0x48(%rax),%ecx
  804160b3ed:	48 8b 50 40          	mov    0x40(%rax),%rdx
  804160b3f1:	41 b8 0e 00 00 00    	mov    $0xe,%r8d
  804160b3f7:	48 be 00 00 e0 1f 80 	movabs $0x801fe00000,%rsi
  804160b3fe:	00 00 00 
  804160b401:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160b408:	00 00 00 
  804160b40b:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160b412:	00 00 00 
  804160b415:	ff d0                	call   *%rax
    if (res) panic("Cannot map kernel");
  804160b417:	85 c0                	test   %eax,%eax
  804160b419:	0f 85 b2 01 00 00    	jne    804160b5d1 <init_memory+0xdbc>
    // Map [X86ADDR(KERN_BASE_ADDR),MIN(MAX_LOW_ADDR_KERN_SIZE, max_memory_map_addr)] to
    //     [0, MIN(MAX_LOW_ADDR_KERN_SIZE, max_memory_map_addr)] as RW + ALLOC_WEAK
    res = map_physical_region(&kspace, 
                                       X86ADDR(KERN_BASE_ADDR), 0,
                                       MIN(MAX_LOW_ADDR_KERN_SIZE, max_memory_map_addr), PROT_R | PROT_W | ALLOC_WEAK);
  804160b41f:	48 b8 c8 00 40 42 80 	movabs $0x80424000c8,%rax
  804160b426:	00 00 00 
  804160b429:	48 81 38 00 00 20 03 	cmpq   $0x3200000,(%rax)
  804160b430:	b9 00 00 20 03       	mov    $0x3200000,%ecx
  804160b435:	48 0f 46 08          	cmovbe (%rax),%rcx
    res = map_physical_region(&kspace, 
  804160b439:	41 b8 06 00 02 00    	mov    $0x20006,%r8d
  804160b43f:	ba 00 00 00 00       	mov    $0x0,%edx
  804160b444:	be 00 00 00 40       	mov    $0x40000000,%esi
  804160b449:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160b450:	00 00 00 
  804160b453:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160b45a:	00 00 00 
  804160b45d:	ff d0                	call   *%rax
    if (res) panic("Cannot map kernel");
  804160b45f:	85 c0                	test   %eax,%eax
  804160b461:	0f 85 94 01 00 00    	jne    804160b5fb <init_memory+0xde6>
    // Map [X86ADDR((uintptr_t)__text_start),ROUNDUP(X86ADDR((uintptr_t)__text_end), CLASS_SIZE(0))] to
    //     [PADDR(__text_start), ROUNDUP(__text_end, CLASS_SIZE(0))] as R-X
    res = map_physical_region(&kspace, 
                                       X86ADDR((uintptr_t)__text_start), PADDR(__text_start), 
                                       ROUNDUP((uintptr_t)__text_end, CLASS_SIZE(0)) - (uintptr_t)__text_start, PROT_R | PROT_X);
  804160b467:	48 b9 a7 20 61 41 80 	movabs $0x80416120a7,%rcx
  804160b46e:	00 00 00 
    res = map_physical_region(&kspace, 
  804160b471:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  804160b478:	48 b8 00 00 60 41 80 	movabs $0x8041600000,%rax
  804160b47f:	00 00 00 
  804160b482:	48 29 c1             	sub    %rax,%rcx
  804160b485:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  804160b489:	8b 75 a0             	mov    -0x60(%rbp),%esi
  804160b48c:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  804160b492:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804160b496:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160b49d:	00 00 00 
  804160b4a0:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160b4a7:	00 00 00 
  804160b4aa:	ff d0                	call   *%rax
    if (res) panic("Cannot map kernel");
  804160b4ac:	85 c0                	test   %eax,%eax
  804160b4ae:	0f 85 71 01 00 00    	jne    804160b625 <init_memory+0xe10>
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804160b4b4:	48 b9 00 40 62 41 80 	movabs $0x8041624000,%rcx
  804160b4bb:	00 00 00 
  804160b4be:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804160b4c5:	00 00 00 
  804160b4c8:	48 39 c1             	cmp    %rax,%rcx
  804160b4cb:	0f 86 7e 01 00 00    	jbe    804160b64f <init_memory+0xe3a>
    // Map [X86ADDR(KERN_STACK_TOP - KERN_STACK_SIZE), KERN_STACK_TOP] to
    //     [PADDR(bootstack), PADDR(boottop)] as RW-
    res = map_physical_region(&kspace, 
  804160b4d1:	48 b8 00 40 61 41 80 	movabs $0x8041614000,%rax
  804160b4d8:	00 00 00 
  804160b4db:	48 29 c1             	sub    %rax,%rcx
  804160b4de:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804160b4e4:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804160b4e8:	be 00 00 ff 3f       	mov    $0x3fff0000,%esi
  804160b4ed:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160b4f4:	00 00 00 
  804160b4f7:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160b4fe:	00 00 00 
  804160b501:	ff d0                	call   *%rax
                                       X86ADDR(KERN_STACK_TOP - KERN_STACK_SIZE), PADDR(bootstack),
                                       PADDR(bootstacktop) - PADDR(bootstack), PROT_R | PROT_W);
    if (res) panic("Cannot map kernel");
  804160b503:	85 c0                	test   %eax,%eax
  804160b505:	0f 85 6f 01 00 00    	jne    804160b67a <init_memory+0xe65>
  804160b50b:	48 b9 00 40 63 41 80 	movabs $0x8041634000,%rcx
  804160b512:	00 00 00 
  804160b515:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804160b51c:	00 00 00 
  804160b51f:	48 39 c1             	cmp    %rax,%rcx
  804160b522:	0f 86 7c 01 00 00    	jbe    804160b6a4 <init_memory+0xe8f>
    // Map [X86ADDR(KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE), KERN_PF_STACK_TOP] to
    //     [PADDR(pfstack), PADDR(pfstacktop)] as RW-
    res = map_physical_region(&kspace, 
  804160b528:	48 b8 00 40 62 41 80 	movabs $0x8041624000,%rax
  804160b52f:	00 00 00 
  804160b532:	48 29 c1             	sub    %rax,%rcx
  804160b535:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804160b53b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  804160b53f:	be 00 80 fd 3f       	mov    $0x3ffd8000,%esi
  804160b544:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160b54b:	00 00 00 
  804160b54e:	48 b8 2d 87 60 41 80 	movabs $0x804160872d,%rax
  804160b555:	00 00 00 
  804160b558:	ff d0                	call   *%rax
                                       X86ADDR(KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE), PADDR(pfstack),
                                       PADDR(pfstacktop) - PADDR(pfstack), PROT_R | PROT_W);
    if (res) panic("Cannot map kernel");
  804160b55a:	85 c0                	test   %eax,%eax
  804160b55c:	0f 85 6d 01 00 00    	jne    804160b6cf <init_memory+0xeba>
    
    if (trace_memory_more) dump_page_table(kspace.pml4);

    check_physical_tree(&root);
  804160b562:	48 bf 60 00 40 42 80 	movabs $0x8042400060,%rdi
  804160b569:	00 00 00 
  804160b56c:	48 b8 38 4d 60 41 80 	movabs $0x8041604d38,%rax
  804160b573:	00 00 00 
  804160b576:	ff d0                	call   *%rax
    if (trace_init) cprintf("Physical memory tree is stil correct\n");
  804160b578:	48 bf 58 2a 61 41 80 	movabs $0x8041612a58,%rdi
  804160b57f:	00 00 00 
  804160b582:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b587:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  804160b58e:	00 00 00 
  804160b591:	ff d3                	call   *%rbx

    check_virtual_tree(kspace.root, MAX_CLASS);
  804160b593:	be 30 00 00 00       	mov    $0x30,%esi
  804160b598:	48 b8 c0 00 40 42 80 	movabs $0x80424000c0,%rax
  804160b59f:	00 00 00 
  804160b5a2:	48 8b 38             	mov    (%rax),%rdi
  804160b5a5:	48 b8 62 53 60 41 80 	movabs $0x8041605362,%rax
  804160b5ac:	00 00 00 
  804160b5af:	ff d0                	call   *%rax
    if (trace_init) cprintf("Kernel virutal memory tree is correct\n");
  804160b5b1:	48 bf 80 2a 61 41 80 	movabs $0x8041612a80,%rdi
  804160b5b8:	00 00 00 
  804160b5bb:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b5c0:	ff d3                	call   *%rbx
}
  804160b5c2:	48 83 c4 38          	add    $0x38,%rsp
  804160b5c6:	5b                   	pop    %rbx
  804160b5c7:	41 5c                	pop    %r12
  804160b5c9:	41 5d                	pop    %r13
  804160b5cb:	41 5e                	pop    %r14
  804160b5cd:	41 5f                	pop    %r15
  804160b5cf:	5d                   	pop    %rbp
  804160b5d0:	c3                   	ret    
    if (res) panic("Cannot map kernel");
  804160b5d1:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b5d8:	00 00 00 
  804160b5db:	be 6f 07 00 00       	mov    $0x76f,%esi
  804160b5e0:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b5e7:	00 00 00 
  804160b5ea:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b5ef:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b5f6:	00 00 00 
  804160b5f9:	ff d1                	call   *%rcx
    if (res) panic("Cannot map kernel");
  804160b5fb:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b602:	00 00 00 
  804160b605:	be 75 07 00 00       	mov    $0x775,%esi
  804160b60a:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b611:	00 00 00 
  804160b614:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b619:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b620:	00 00 00 
  804160b623:	ff d1                	call   *%rcx
    if (res) panic("Cannot map kernel");
  804160b625:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b62c:	00 00 00 
  804160b62f:	be 7b 07 00 00       	mov    $0x77b,%esi
  804160b634:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b63b:	00 00 00 
  804160b63e:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b643:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b64a:	00 00 00 
  804160b64d:	ff d1                	call   *%rcx
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804160b64f:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160b656:	00 00 00 
  804160b659:	be 80 07 00 00       	mov    $0x780,%esi
  804160b65e:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b665:	00 00 00 
  804160b668:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b66d:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b674:	00 00 00 
  804160b677:	41 ff d0             	call   *%r8
    if (res) panic("Cannot map kernel");
  804160b67a:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b681:	00 00 00 
  804160b684:	be 81 07 00 00       	mov    $0x781,%esi
  804160b689:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b690:	00 00 00 
  804160b693:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b698:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b69f:	00 00 00 
  804160b6a2:	ff d1                	call   *%rcx
  804160b6a4:	48 ba 00 24 61 41 80 	movabs $0x8041612400,%rdx
  804160b6ab:	00 00 00 
  804160b6ae:	be 86 07 00 00       	mov    $0x786,%esi
  804160b6b3:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b6ba:	00 00 00 
  804160b6bd:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b6c2:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160b6c9:	00 00 00 
  804160b6cc:	41 ff d0             	call   *%r8
    if (res) panic("Cannot map kernel");
  804160b6cf:	48 ba 94 1e 61 41 80 	movabs $0x8041611e94,%rdx
  804160b6d6:	00 00 00 
  804160b6d9:	be 87 07 00 00       	mov    $0x787,%esi
  804160b6de:	48 bf e1 1b 61 41 80 	movabs $0x8041611be1,%rdi
  804160b6e5:	00 00 00 
  804160b6e8:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b6ed:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160b6f4:	00 00 00 
  804160b6f7:	ff d1                	call   *%rcx

000000804160b6f9 <user_mem_check>:
 *
 * Return 0 if check is passed or -E_FAULT if region
 * does not have enough permissions.
 */
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm) {
  804160b6f9:	55                   	push   %rbp
  804160b6fa:	48 89 e5             	mov    %rsp,%rbp
  804160b6fd:	41 57                	push   %r15
  804160b6ff:	41 56                	push   %r14
  804160b701:	41 55                	push   %r13
  804160b703:	41 54                	push   %r12
  804160b705:	53                   	push   %rbx
  804160b706:	48 83 ec 18          	sub    $0x18,%rsp
  804160b70a:	89 4d cc             	mov    %ecx,-0x34(%rbp)
    // LAB 8: Your code here

    struct Page* root = env->address_space.root;
  804160b70d:	4c 8b af f8 00 00 00 	mov    0xf8(%rdi),%r13
    void *va_cur =(void*)ROUNDDOWN(va, PAGE_SIZE);
  804160b714:	48 89 f3             	mov    %rsi,%rbx
  804160b717:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
    void *va_end = (void*)ROUNDUP(va + len, PAGE_SIZE);
  804160b71e:	4c 8d a4 16 ff 0f 00 	lea    0xfff(%rsi,%rdx,1),%r12
  804160b725:	00 
  804160b726:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12

    while (va_cur < va_end) {
  804160b72d:	4c 39 e3             	cmp    %r12,%rbx
  804160b730:	73 42                	jae    804160b774 <user_mem_check+0x7b>
  804160b732:	49 89 f7             	mov    %rsi,%r15
        struct Page *page = page_lookup_virtual(root, (uintptr_t)va_cur, 0, 0);
  804160b735:	49 be 8e 6a 60 41 80 	movabs $0x8041606a8e,%r14
  804160b73c:	00 00 00 
  804160b73f:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160b744:	ba 00 00 00 00       	mov    $0x0,%edx
  804160b749:	48 89 de             	mov    %rbx,%rsi
  804160b74c:	4c 89 ef             	mov    %r13,%rdi
  804160b74f:	41 ff d6             	call   *%r14
        if (!page->phy || (page->state & PAGE_PROT(perm)) != PAGE_PROT(perm)) {
  804160b752:	48 83 78 30 00       	cmpq   $0x0,0x30(%rax)
  804160b757:	74 31                	je     804160b78a <user_mem_check+0x91>
  804160b759:	8b 40 28             	mov    0x28(%rax),%eax
  804160b75c:	f7 d0                	not    %eax
  804160b75e:	23 45 cc             	and    -0x34(%rbp),%eax
  804160b761:	a9 ff ff 0f ff       	test   $0xff0fffff,%eax
  804160b766:	75 22                	jne    804160b78a <user_mem_check+0x91>
            user_mem_check_addr = (uintptr_t)(MAX(va, va_cur));
            return -E_FAULT;
        }
        va_cur += PAGE_SIZE;
  804160b768:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
    while (va_cur < va_end) {
  804160b76f:	49 39 dc             	cmp    %rbx,%r12
  804160b772:	77 cb                	ja     804160b73f <user_mem_check+0x46>
    }
    if ((uintptr_t)va_end > MAX_USER_READABLE) {
  804160b774:	48 b8 00 00 e0 1f 80 	movabs $0x801fe00000,%rax
  804160b77b:	00 00 00 
  804160b77e:	49 39 c4             	cmp    %rax,%r12
  804160b781:	77 2f                	ja     804160b7b2 <user_mem_check+0xb9>
        user_mem_check_addr = (uintptr_t)(MAX(MAX_USER_READABLE, (uintptr_t)va_cur));
        return -E_FAULT;    
    }

    return 0;
  804160b783:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b788:	eb 19                	jmp    804160b7a3 <user_mem_check+0xaa>
            user_mem_check_addr = (uintptr_t)(MAX(va, va_cur));
  804160b78a:	49 39 df             	cmp    %rbx,%r15
  804160b78d:	48 89 d8             	mov    %rbx,%rax
  804160b790:	49 0f 43 c7          	cmovae %r15,%rax
  804160b794:	48 a3 e8 40 40 42 80 	movabs %rax,0x80424040e8
  804160b79b:	00 00 00 
            return -E_FAULT;
  804160b79e:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
}
  804160b7a3:	48 83 c4 18          	add    $0x18,%rsp
  804160b7a7:	5b                   	pop    %rbx
  804160b7a8:	41 5c                	pop    %r12
  804160b7aa:	41 5d                	pop    %r13
  804160b7ac:	41 5e                	pop    %r14
  804160b7ae:	41 5f                	pop    %r15
  804160b7b0:	5d                   	pop    %rbp
  804160b7b1:	c3                   	ret    
        user_mem_check_addr = (uintptr_t)(MAX(MAX_USER_READABLE, (uintptr_t)va_cur));
  804160b7b2:	48 39 c3             	cmp    %rax,%rbx
  804160b7b5:	48 0f 43 c3          	cmovae %rbx,%rax
  804160b7b9:	48 a3 e8 40 40 42 80 	movabs %rax,0x80424040e8
  804160b7c0:	00 00 00 
        return -E_FAULT;    
  804160b7c3:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
  804160b7c8:	eb d9                	jmp    804160b7a3 <user_mem_check+0xaa>

000000804160b7ca <user_mem_assert>:

void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm) {
  804160b7ca:	55                   	push   %rbp
  804160b7cb:	48 89 e5             	mov    %rsp,%rbp
  804160b7ce:	53                   	push   %rbx
  804160b7cf:	48 83 ec 08          	sub    $0x8,%rsp
  804160b7d3:	48 89 fb             	mov    %rdi,%rbx
    if (user_mem_check(env, va, len, perm | PROT_USER_) < 0) {
  804160b7d6:	83 c9 20             	or     $0x20,%ecx
  804160b7d9:	48 b8 f9 b6 60 41 80 	movabs $0x804160b6f9,%rax
  804160b7e0:	00 00 00 
  804160b7e3:	ff d0                	call   *%rax
  804160b7e5:	85 c0                	test   %eax,%eax
  804160b7e7:	78 06                	js     804160b7ef <user_mem_assert+0x25>
        cprintf("[%08x] user_mem_check assertion failure for "
                "va=%016zx ip=%016zx\n",
                env->env_id, user_mem_check_addr, env->env_tf.tf_rip);
        env_destroy(env); /* may not return */
    }
}
  804160b7e9:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804160b7ed:	c9                   	leave  
  804160b7ee:	c3                   	ret    
        cprintf("[%08x] user_mem_check assertion failure for "
  804160b7ef:	48 8b 8b 98 00 00 00 	mov    0x98(%rbx),%rcx
  804160b7f6:	8b b3 c8 00 00 00    	mov    0xc8(%rbx),%esi
  804160b7fc:	48 b8 e8 40 40 42 80 	movabs $0x80424040e8,%rax
  804160b803:	00 00 00 
  804160b806:	48 8b 10             	mov    (%rax),%rdx
  804160b809:	48 bf a8 2a 61 41 80 	movabs $0x8041612aa8,%rdi
  804160b810:	00 00 00 
  804160b813:	b8 00 00 00 00       	mov    $0x0,%eax
  804160b818:	49 b8 99 c8 60 41 80 	movabs $0x804160c899,%r8
  804160b81f:	00 00 00 
  804160b822:	41 ff d0             	call   *%r8
        env_destroy(env); /* may not return */
  804160b825:	48 89 df             	mov    %rbx,%rdi
  804160b828:	48 b8 5e c0 60 41 80 	movabs $0x804160c05e,%rax
  804160b82f:	00 00 00 
  804160b832:	ff d0                	call   *%rax
}
  804160b834:	eb b3                	jmp    804160b7e9 <user_mem_assert+0x1f>

000000804160b836 <envid2env>:
 * RETURNS
 *     0 on success, -E_BAD_ENV on error.
 *   On success, sets *env_store to the environment.
 *   On error, sets *env_store to NULL. */
int
envid2env(envid_t envid, struct Env **env_store, bool need_check_perm) {
  804160b836:	89 d1                	mov    %edx,%ecx
    struct Env *env;

    /* If envid is zero, return the current environment. */
    if (!envid) {
  804160b838:	85 ff                	test   %edi,%edi
  804160b83a:	74 5b                	je     804160b897 <envid2env+0x61>
    /* Look up the Env structure via the index part of the envid,
     * then check the env_id field in that struct Env
     * to ensure that the envid is not stale
     * (i.e., does not refer to a _previous_ environment
     * that used the same slot in the envs[] array). */
    env = &envs[ENVX(envid)];
  804160b83c:	89 f8                	mov    %edi,%eax
  804160b83e:	25 ff 03 00 00       	and    $0x3ff,%eax
  804160b843:	48 8d 14 c0          	lea    (%rax,%rax,8),%rdx
  804160b847:	48 8d 14 50          	lea    (%rax,%rdx,2),%rdx
  804160b84b:	48 c1 e2 04          	shl    $0x4,%rdx
  804160b84f:	48 a1 48 44 40 42 80 	movabs 0x8042404448,%rax
  804160b856:	00 00 00 
  804160b859:	48 01 c2             	add    %rax,%rdx
    if (env->env_status == ENV_FREE || env->env_id != envid) {
  804160b85c:	83 ba d4 00 00 00 00 	cmpl   $0x0,0xd4(%rdx)
  804160b863:	74 42                	je     804160b8a7 <envid2env+0x71>
  804160b865:	39 ba c8 00 00 00    	cmp    %edi,0xc8(%rdx)
  804160b86b:	75 3a                	jne    804160b8a7 <envid2env+0x71>
    /* Check that the calling environment has legitimate permission
     * to manipulate the specified environment.
     * If checkperm is set, the specified environment
     * must be either the current environment
     * or an immediate child of the current environment. */
    if (need_check_perm && env != curenv && env->env_parent_id != curenv->env_id) {
  804160b86d:	84 c9                	test   %cl,%cl
  804160b86f:	74 1d                	je     804160b88e <envid2env+0x58>
  804160b871:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160b878:	00 00 00 
  804160b87b:	48 39 d0             	cmp    %rdx,%rax
  804160b87e:	74 0e                	je     804160b88e <envid2env+0x58>
  804160b880:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  804160b886:	39 82 cc 00 00 00    	cmp    %eax,0xcc(%rdx)
  804160b88c:	75 26                	jne    804160b8b4 <envid2env+0x7e>
        *env_store = NULL;
        return -E_BAD_ENV;
    }

    *env_store = env;
  804160b88e:	48 89 16             	mov    %rdx,(%rsi)
    return 0;
  804160b891:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804160b896:	c3                   	ret    
        *env_store = curenv;
  804160b897:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160b89e:	00 00 00 
  804160b8a1:	48 89 06             	mov    %rax,(%rsi)
        return 0;
  804160b8a4:	89 f8                	mov    %edi,%eax
  804160b8a6:	c3                   	ret    
        *env_store = NULL;
  804160b8a7:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
        return -E_BAD_ENV;
  804160b8ae:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804160b8b3:	c3                   	ret    
        *env_store = NULL;
  804160b8b4:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
        return -E_BAD_ENV;
  804160b8bb:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804160b8c0:	c3                   	ret    

000000804160b8c1 <env_init>:
 * Make sure the environments are in the free list in the same order
 * they are in the envs array (i.e., so that the first call to
 * env_alloc() returns envs[0]).
 */
void
env_init(void) {
  804160b8c1:	55                   	push   %rbp
  804160b8c2:	48 89 e5             	mov    %rsp,%rbp
  804160b8c5:	41 55                	push   %r13
  804160b8c7:	41 54                	push   %r12
  804160b8c9:	53                   	push   %rbx
  804160b8ca:	48 83 ec 08          	sub    $0x8,%rsp
    // LAB 12: Your code here

    /* kzalloc_region only works with current_space != NULL */
    if (current_space != NULL) {
  804160b8ce:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  804160b8d5:	00 00 00 
  804160b8d8:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160b8dc:	74 1b                	je     804160b8f9 <env_init+0x38>
        vsys = kzalloc_region(UVSYS_SIZE);
  804160b8de:	bf 00 10 00 00       	mov    $0x1000,%edi
  804160b8e3:	48 b8 5f a5 60 41 80 	movabs $0x804160a55f,%rax
  804160b8ea:	00 00 00 
  804160b8ed:	ff d0                	call   *%rax
  804160b8ef:	48 a3 40 44 40 42 80 	movabs %rax,0x8042404440
  804160b8f6:	00 00 00 
    }
    int res = map_region(current_space, UVSYS, &kspace, (uintptr_t)vsys, UVSYS_SIZE, PROT_R | PROT_USER_);
  804160b8f9:	41 b9 24 00 00 00    	mov    $0x24,%r9d
  804160b8ff:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  804160b905:	48 b8 40 44 40 42 80 	movabs $0x8042404440,%rax
  804160b90c:	00 00 00 
  804160b90f:	48 8b 08             	mov    (%rax),%rcx
  804160b912:	48 ba b0 00 40 42 80 	movabs $0x80424000b0,%rdx
  804160b919:	00 00 00 
  804160b91c:	48 be 00 f0 bf 1f 80 	movabs $0x801fbff000,%rsi
  804160b923:	00 00 00 
  804160b926:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  804160b92d:	00 00 00 
  804160b930:	48 8b 38             	mov    (%rax),%rdi
  804160b933:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160b93a:	00 00 00 
  804160b93d:	ff d0                	call   *%rax
    if (res < 0)
  804160b93f:	85 c0                	test   %eax,%eax
  804160b941:	0f 88 dd 00 00 00    	js     804160ba24 <env_init+0x163>
        panic("map_region: %i", res);

    /* Allocate envs array with kzalloc_region
     * (don't forget about rounding) */
    // LAB 8: Your code here
    map_region(current_space, (uintptr_t)UTEMP, &kspace, (uintptr_t)context.front, context.size * 2, PROT_R | PROT_W | PROT_USER_);
  804160b947:	48 b8 40 5b 40 42 80 	movabs $0x8042405b40,%rax
  804160b94e:	00 00 00 
  804160b951:	8b 58 10             	mov    0x10(%rax),%ebx
  804160b954:	44 8d 04 1b          	lea    (%rbx,%rbx,1),%r8d
  804160b958:	48 8b 48 18          	mov    0x18(%rax),%rcx
  804160b95c:	49 bc a0 00 40 42 80 	movabs $0x80424000a0,%r12
  804160b963:	00 00 00 
  804160b966:	41 b9 26 00 00 00    	mov    $0x26,%r9d
  804160b96c:	45 89 c0             	mov    %r8d,%r8d
  804160b96f:	48 ba b0 00 40 42 80 	movabs $0x80424000b0,%rdx
  804160b976:	00 00 00 
  804160b979:	be 00 00 40 00       	mov    $0x400000,%esi
  804160b97e:	49 8b 3c 24          	mov    (%r12),%rdi
  804160b982:	48 bb f6 a0 60 41 80 	movabs $0x804160a0f6,%rbx
  804160b989:	00 00 00 
  804160b98c:	ff d3                	call   *%rbx
    envs = (struct Env*)kzalloc_region(sizeof(struct Env) * NENV);
  804160b98e:	bf 00 c0 04 00       	mov    $0x4c000,%edi
  804160b993:	48 b8 5f a5 60 41 80 	movabs $0x804160a55f,%rax
  804160b99a:	00 00 00 
  804160b99d:	ff d0                	call   *%rax
  804160b99f:	48 89 c7             	mov    %rax,%rdi
  804160b9a2:	49 bd 48 44 40 42 80 	movabs $0x8042404448,%r13
  804160b9a9:	00 00 00 
  804160b9ac:	49 89 45 00          	mov    %rax,0x0(%r13)
    memset(envs, 0, sizeof(struct Env) * NENV);
  804160b9b0:	ba 00 c0 04 00       	mov    $0x4c000,%edx
  804160b9b5:	be 00 00 00 00       	mov    $0x0,%esi
  804160b9ba:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160b9c1:	00 00 00 
  804160b9c4:	ff d0                	call   *%rax
    /* Map envs to UENVS read-only,
     * but user-accessible (with PROT_USER_ set) */
    // LAB 8: Your code here
    res = map_region(current_space, UENVS, &kspace, (uintptr_t)envs, UENVS_SIZE, PROT_USER_ | PROT_R);
  804160b9c6:	41 b9 24 00 00 00    	mov    $0x24,%r9d
  804160b9cc:	41 b8 00 00 20 00    	mov    $0x200000,%r8d
  804160b9d2:	49 8b 4d 00          	mov    0x0(%r13),%rcx
  804160b9d6:	48 ba b0 00 40 42 80 	movabs $0x80424000b0,%rdx
  804160b9dd:	00 00 00 
  804160b9e0:	48 be 00 00 c0 1f 80 	movabs $0x801fc00000,%rsi
  804160b9e7:	00 00 00 
  804160b9ea:	49 8b 3c 24          	mov    (%r12),%rdi
  804160b9ee:	ff d3                	call   *%rbx
    if (res) {
  804160b9f0:	85 c0                	test   %eax,%eax
  804160b9f2:	75 5d                	jne    804160ba51 <env_init+0x190>
  804160b9f4:	48 b8 58 44 40 42 80 	movabs $0x8042404458,%rax
  804160b9fb:	00 00 00 
  804160b9fe:	4c 8b 00             	mov    (%rax),%r8
  804160ba01:	48 a1 48 44 40 42 80 	movabs 0x8042404448,%rax
  804160ba08:	00 00 00 
  804160ba0b:	48 8d b0 00 c0 04 00 	lea    0x4c000(%rax),%rsi
    /* Set up envs array */

    // LAB 3: Your code here
    struct Env* temp = NULL;
    for (int i = 0; i < NENV; ++i) {
        envs[i].env_id = 0;
  804160ba12:	bf 00 00 00 00       	mov    $0x0,%edi
    struct Env* temp = NULL;
  804160ba17:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160ba1c:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  804160ba22:	eb 68                	jmp    804160ba8c <env_init+0x1cb>
        panic("map_region: %i", res);
  804160ba24:	89 c1                	mov    %eax,%ecx
  804160ba26:	48 ba e9 2a 61 41 80 	movabs $0x8041612ae9,%rdx
  804160ba2d:	00 00 00 
  804160ba30:	be 69 00 00 00       	mov    $0x69,%esi
  804160ba35:	48 bf f8 2a 61 41 80 	movabs $0x8041612af8,%rdi
  804160ba3c:	00 00 00 
  804160ba3f:	b8 00 00 00 00       	mov    $0x0,%eax
  804160ba44:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160ba4b:	00 00 00 
  804160ba4e:	41 ff d0             	call   *%r8
        panic("can't map envs to current_space");
  804160ba51:	48 ba 70 2b 61 41 80 	movabs $0x8041612b70,%rdx
  804160ba58:	00 00 00 
  804160ba5b:	be 76 00 00 00       	mov    $0x76,%esi
  804160ba60:	48 bf f8 2a 61 41 80 	movabs $0x8041612af8,%rdi
  804160ba67:	00 00 00 
  804160ba6a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160ba6f:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160ba76:	00 00 00 
  804160ba79:	ff d1                	call   *%rcx
        envs[i].env_status = ENV_FREE;

        if (!temp) {
            //init the head of the env_free_list
            temp = env_free_list = &envs[i];
  804160ba7b:	49 89 c0             	mov    %rax,%r8
  804160ba7e:	44 89 cf             	mov    %r9d,%edi
    for (int i = 0; i < NENV; ++i) {
  804160ba81:	48 05 30 01 00 00    	add    $0x130,%rax
  804160ba87:	48 39 f0             	cmp    %rsi,%rax
  804160ba8a:	74 28                	je     804160bab4 <env_init+0x1f3>
        envs[i].env_id = 0;
  804160ba8c:	48 89 ca             	mov    %rcx,%rdx
  804160ba8f:	48 89 c1             	mov    %rax,%rcx
  804160ba92:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  804160ba99:	00 00 00 
        envs[i].env_status = ENV_FREE;
  804160ba9c:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  804160baa3:	00 00 00 
        if (!temp) {
  804160baa6:	48 85 d2             	test   %rdx,%rdx
  804160baa9:	74 d0                	je     804160ba7b <env_init+0x1ba>
        }
        else {
            //init other nodes
            temp->env_link = &envs[i];
  804160baab:	48 89 82 c0 00 00 00 	mov    %rax,0xc0(%rdx)
            temp = temp->env_link;
  804160bab2:	eb cd                	jmp    804160ba81 <env_init+0x1c0>
  804160bab4:	40 84 ff             	test   %dil,%dil
  804160bab7:	74 0d                	je     804160bac6 <env_init+0x205>
  804160bab9:	4c 89 c0             	mov    %r8,%rax
  804160babc:	48 a3 58 44 40 42 80 	movabs %rax,0x8042404458
  804160bac3:	00 00 00 
        }

    }
    
}
  804160bac6:	48 83 c4 08          	add    $0x8,%rsp
  804160baca:	5b                   	pop    %rbx
  804160bacb:	41 5c                	pop    %r12
  804160bacd:	41 5d                	pop    %r13
  804160bacf:	5d                   	pop    %rbp
  804160bad0:	c3                   	ret    

000000804160bad1 <env_alloc>:
 * Errors
 *    -E_NO_FREE_ENV if all NENVS environments are allocated
 *    -E_NO_MEM on memory exhaustion
 */
int
env_alloc(struct Env **newenv_store, envid_t parent_id, enum EnvType type) {
  804160bad1:	55                   	push   %rbp
  804160bad2:	48 89 e5             	mov    %rsp,%rbp
  804160bad5:	41 56                	push   %r14
  804160bad7:	41 55                	push   %r13
  804160bad9:	41 54                	push   %r12
  804160badb:	53                   	push   %rbx

    struct Env *env;
    if (!(env = env_free_list))
  804160badc:	48 b8 58 44 40 42 80 	movabs $0x8042404458,%rax
  804160bae3:	00 00 00 
  804160bae6:	48 8b 18             	mov    (%rax),%rbx
  804160bae9:	48 85 db             	test   %rbx,%rbx
  804160baec:	0f 84 57 01 00 00    	je     804160bc49 <env_alloc+0x178>
  804160baf2:	49 89 fd             	mov    %rdi,%r13
  804160baf5:	41 89 f6             	mov    %esi,%r14d
  804160baf8:	41 89 d4             	mov    %edx,%r12d
        return -E_NO_FREE_ENV;

    /* Allocate and set up the page directory for this environment. */
    int res = init_address_space(&env->address_space);
  804160bafb:	48 8d bb e8 00 00 00 	lea    0xe8(%rbx),%rdi
  804160bb02:	48 b8 ab a3 60 41 80 	movabs $0x804160a3ab,%rax
  804160bb09:	00 00 00 
  804160bb0c:	ff d0                	call   *%rax
    if (res < 0) return res;
  804160bb0e:	85 c0                	test   %eax,%eax
  804160bb10:	0f 88 2a 01 00 00    	js     804160bc40 <env_alloc+0x16f>

    /* Generate an env_id for this environment */
    int32_t generation = (env->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  804160bb16:	8b 83 c8 00 00 00    	mov    0xc8(%rbx),%eax
  804160bb1c:	05 00 10 00 00       	add    $0x1000,%eax
    /* Don't create a negative env_id */
    if (generation <= 0) generation = 1 << ENVGENSHIFT;
  804160bb21:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  804160bb26:	ba 00 10 00 00       	mov    $0x1000,%edx
  804160bb2b:	0f 4e c2             	cmovle %edx,%eax
    env->env_id = generation | (env - envs);
  804160bb2e:	48 ba 48 44 40 42 80 	movabs $0x8042404448,%rdx
  804160bb35:	00 00 00 
  804160bb38:	48 89 d9             	mov    %rbx,%rcx
  804160bb3b:	48 2b 0a             	sub    (%rdx),%rcx
  804160bb3e:	48 89 ca             	mov    %rcx,%rdx
  804160bb41:	48 c1 fa 04          	sar    $0x4,%rdx
  804160bb45:	69 d2 1b ca 6b 28    	imul   $0x286bca1b,%edx,%edx
  804160bb4b:	09 d0                	or     %edx,%eax
  804160bb4d:	89 83 c8 00 00 00    	mov    %eax,0xc8(%rbx)

    /* Set the basic status variables */
    env->env_parent_id = parent_id;
  804160bb53:	44 89 b3 cc 00 00 00 	mov    %r14d,0xcc(%rbx)
#ifdef CONFIG_KSPACE
    env->env_type = ENV_TYPE_KERNEL;
#else
    env->env_type = type;
  804160bb5a:	44 89 a3 d0 00 00 00 	mov    %r12d,0xd0(%rbx)
#endif
    env->env_status = ENV_RUNNABLE;
  804160bb61:	c7 83 d4 00 00 00 02 	movl   $0x2,0xd4(%rbx)
  804160bb68:	00 00 00 
    env->env_runs = 0;
  804160bb6b:	c7 83 d8 00 00 00 00 	movl   $0x0,0xd8(%rbx)
  804160bb72:	00 00 00 

    /* Clear out all the saved register state,
     * to prevent the register values
     * of a prior environment inhabiting this Env structure
     * from "leaking" into our new environment */
    memset(&env->env_tf, 0, sizeof(env->env_tf));
  804160bb75:	ba c0 00 00 00       	mov    $0xc0,%edx
  804160bb7a:	be 00 00 00 00       	mov    $0x0,%esi
  804160bb7f:	48 89 df             	mov    %rbx,%rdi
  804160bb82:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160bb89:	00 00 00 
  804160bb8c:	ff d0                	call   *%rax

    // LAB 3: Your code here:
    static uintptr_t stack_top = 0x2000000; 
    env->env_tf.tf_rsp = stack_top - (envs - env) * PROG_STACK_SIZE;
#else
    env->env_tf.tf_ds = GD_UD | 3;
  804160bb8e:	66 c7 83 80 00 00 00 	movw   $0x33,0x80(%rbx)
  804160bb95:	33 00 
    env->env_tf.tf_es = GD_UD | 3;
  804160bb97:	66 c7 43 78 33 00    	movw   $0x33,0x78(%rbx)
    env->env_tf.tf_ss = GD_UD | 3;
  804160bb9d:	66 c7 83 b8 00 00 00 	movw   $0x33,0xb8(%rbx)
  804160bba4:	33 00 
    env->env_tf.tf_cs = GD_UT | 3;
  804160bba6:	66 c7 83 a0 00 00 00 	movw   $0x2b,0xa0(%rbx)
  804160bbad:	2b 00 
    env->env_tf.tf_rsp = USER_STACK_TOP;
  804160bbaf:	48 b8 00 70 ff ff 7f 	movabs $0x7fffff7000,%rax
  804160bbb6:	00 00 00 
  804160bbb9:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
#endif

    /* For now init trapframe with IF set */
    env->env_tf.tf_rflags = FL_IF | (type == ENV_TYPE_FS ? FL_IOPL_3 : FL_IOPL_0);
  804160bbc0:	41 83 fc 03          	cmp    $0x3,%r12d
  804160bbc4:	b8 00 32 00 00       	mov    $0x3200,%eax
  804160bbc9:	ba 00 02 00 00       	mov    $0x200,%edx
  804160bbce:	48 0f 45 c2          	cmovne %rdx,%rax
  804160bbd2:	48 89 83 a8 00 00 00 	mov    %rax,0xa8(%rbx)

    /* Clear the page fault handler until user installs one. */
    env->env_pgfault_upcall = 0;
  804160bbd9:	48 c7 83 00 01 00 00 	movq   $0x0,0x100(%rbx)
  804160bbe0:	00 00 00 00 

    /* Also clear the IPC receiving flag. */
    env->env_ipc_recving = 0;
  804160bbe4:	c6 83 08 01 00 00 00 	movb   $0x0,0x108(%rbx)

    /* Commit the allocation */
    env_free_list = env->env_link;
  804160bbeb:	48 8b 83 c0 00 00 00 	mov    0xc0(%rbx),%rax
  804160bbf2:	48 a3 58 44 40 42 80 	movabs %rax,0x8042404458
  804160bbf9:	00 00 00 
    *newenv_store = env;
  804160bbfc:	49 89 5d 00          	mov    %rbx,0x0(%r13)

    if (trace_envs) cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, env->env_id);
  804160bc00:	8b 93 c8 00 00 00    	mov    0xc8(%rbx),%edx
  804160bc06:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160bc0d:	00 00 00 
  804160bc10:	be 00 00 00 00       	mov    $0x0,%esi
  804160bc15:	48 85 c0             	test   %rax,%rax
  804160bc18:	74 06                	je     804160bc20 <env_alloc+0x14f>
  804160bc1a:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  804160bc20:	48 bf 03 2b 61 41 80 	movabs $0x8041612b03,%rdi
  804160bc27:	00 00 00 
  804160bc2a:	b8 00 00 00 00       	mov    $0x0,%eax
  804160bc2f:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  804160bc36:	00 00 00 
  804160bc39:	ff d1                	call   *%rcx
    return 0;
  804160bc3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804160bc40:	5b                   	pop    %rbx
  804160bc41:	41 5c                	pop    %r12
  804160bc43:	41 5d                	pop    %r13
  804160bc45:	41 5e                	pop    %r14
  804160bc47:	5d                   	pop    %rbp
  804160bc48:	c3                   	ret    
        return -E_NO_FREE_ENV;
  804160bc49:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  804160bc4e:	eb f0                	jmp    804160bc40 <env_alloc+0x16f>

000000804160bc50 <bind_functions>:
 * its loaded address space specified by image_start/image_end.
 * Make sure you understand why you need to check that each binding
 * must be performed within the image_start/image_end range.
 */
int
bind_functions(struct Env *env, uint8_t *binary, size_t size, uintptr_t image_start, uintptr_t image_end) {
  804160bc50:	55                   	push   %rbp
  804160bc51:	48 89 e5             	mov    %rsp,%rbp
  804160bc54:	41 57                	push   %r15
  804160bc56:	41 56                	push   %r14
  804160bc58:	41 55                	push   %r13
  804160bc5a:	41 54                	push   %r12
  804160bc5c:	53                   	push   %rbx
  804160bc5d:	48 83 ec 18          	sub    $0x18,%rsp
  804160bc61:	49 89 f5             	mov    %rsi,%r13
    ElfHeader = (struct Elf*)binary;
    int sym_table_idx = -1;
    int str_table_idx = -1;

    
    sh = (struct Secthdr*)(binary + ElfHeader->e_shoff);
  804160bc64:	49 89 f1             	mov    %rsi,%r9
  804160bc67:	4c 03 4e 28          	add    0x28(%rsi),%r9
    
    for (int i = 0 ; i < ElfHeader->e_shnum; ++i) {
  804160bc6b:	0f b7 76 3c          	movzwl 0x3c(%rsi),%esi
  804160bc6f:	85 f6                	test   %esi,%esi
  804160bc71:	7e 3c                	jle    804160bcaf <bind_functions+0x5f>
  804160bc73:	49 8d 51 04          	lea    0x4(%r9),%rdx
  804160bc77:	b8 00 00 00 00       	mov    $0x0,%eax
    int str_table_idx = -1;
  804160bc7c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    int sym_table_idx = -1;
  804160bc81:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  804160bc87:	eb 0e                	jmp    804160bc97 <bind_functions+0x47>
  804160bc89:	41 89 c0             	mov    %eax,%r8d
    for (int i = 0 ; i < ElfHeader->e_shnum; ++i) {
  804160bc8c:	83 c0 01             	add    $0x1,%eax
  804160bc8f:	48 83 c2 40          	add    $0x40,%rdx
  804160bc93:	39 f0                	cmp    %esi,%eax
  804160bc95:	74 23                	je     804160bcba <bind_functions+0x6a>
        if (sh[i].sh_type == ELF_SHT_SYMTAB) {
  804160bc97:	8b 0a                	mov    (%rdx),%ecx
  804160bc99:	83 f9 02             	cmp    $0x2,%ecx
  804160bc9c:	74 eb                	je     804160bc89 <bind_functions+0x39>
            sym_table_idx = i;
        } else if (sh[i].sh_type == ELF_SHT_STRTAB && i != ElfHeader->e_shstrndx) {
  804160bc9e:	83 f9 03             	cmp    $0x3,%ecx
  804160bca1:	75 e9                	jne    804160bc8c <bind_functions+0x3c>
  804160bca3:	41 0f b7 4d 3e       	movzwl 0x3e(%r13),%ecx
  804160bca8:	39 c1                	cmp    %eax,%ecx
  804160bcaa:	0f 45 f8             	cmovne %eax,%edi
  804160bcad:	eb dd                	jmp    804160bc8c <bind_functions+0x3c>
    int str_table_idx = -1;
  804160bcaf:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    int sym_table_idx = -1;
  804160bcb4:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
        }
        
    }
    struct Elf64_Sym *st, *st_end;
    char  *string_table;
    string_table = (char*)(binary + sh[str_table_idx].sh_offset);
  804160bcba:	48 63 ff             	movslq %edi,%rdi
  804160bcbd:	48 c1 e7 06          	shl    $0x6,%rdi
  804160bcc1:	4d 8b 74 39 18       	mov    0x18(%r9,%rdi,1),%r14
    st = (struct Elf64_Sym*)(binary + sh[sym_table_idx].sh_offset);
  804160bcc6:	4d 63 c0             	movslq %r8d,%r8
  804160bcc9:	49 c1 e0 06          	shl    $0x6,%r8
  804160bccd:	4d 01 c8             	add    %r9,%r8
  804160bcd0:	4d 8b 60 18          	mov    0x18(%r8),%r12
  804160bcd4:	4b 8d 5c 25 00       	lea    0x0(%r13,%r12,1),%rbx
    st_end = (struct Elf64_Sym*)(binary + sh[sym_table_idx].sh_offset + sh[sym_table_idx].sh_size);
  804160bcd9:	4d 03 60 20          	add    0x20(%r8),%r12
  804160bcdd:	4d 01 ec             	add    %r13,%r12

    for (; st < st_end; ++st) {
  804160bce0:	4c 39 e3             	cmp    %r12,%rbx
  804160bce3:	73 58                	jae    804160bd3d <bind_functions+0xed>
        if (ELF_ST_BIND(st->st_info) == STB_GLOBAL && 
                ELF_ST_TYPE(st->st_info) == STT_OBJECT) {
            uintptr_t addr;
            addr = find_function(string_table + st->st_name);
  804160bce5:	49 bf 06 f1 60 41 80 	movabs $0x804160f106,%r15
  804160bcec:	00 00 00 
  804160bcef:	eb 09                	jmp    804160bcfa <bind_functions+0xaa>
    for (; st < st_end; ++st) {
  804160bcf1:	48 83 c3 18          	add    $0x18,%rbx
  804160bcf5:	49 39 dc             	cmp    %rbx,%r12
  804160bcf8:	76 43                	jbe    804160bd3d <bind_functions+0xed>
        if (ELF_ST_BIND(st->st_info) == STB_GLOBAL && 
  804160bcfa:	0f b6 43 04          	movzbl 0x4(%rbx),%eax
  804160bcfe:	89 c2                	mov    %eax,%edx
  804160bd00:	c0 ea 04             	shr    $0x4,%dl
  804160bd03:	80 fa 01             	cmp    $0x1,%dl
  804160bd06:	75 e9                	jne    804160bcf1 <bind_functions+0xa1>
  804160bd08:	83 e0 0f             	and    $0xf,%eax
  804160bd0b:	3c 01                	cmp    $0x1,%al
  804160bd0d:	75 e2                	jne    804160bcf1 <bind_functions+0xa1>
            addr = find_function(string_table + st->st_name);
  804160bd0f:	8b 3b                	mov    (%rbx),%edi
  804160bd11:	4c 01 f7             	add    %r14,%rdi
  804160bd14:	4c 01 ef             	add    %r13,%rdi
  804160bd17:	41 ff d7             	call   *%r15
  804160bd1a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (addr) {
  804160bd1e:	48 85 c0             	test   %rax,%rax
  804160bd21:	74 ce                	je     804160bcf1 <bind_functions+0xa1>
                memcpy((void*)st->st_value, &addr, st->st_size);
  804160bd23:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  804160bd27:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  804160bd2b:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160bd2f:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160bd36:	00 00 00 
  804160bd39:	ff d0                	call   *%rax
  804160bd3b:	eb b4                	jmp    804160bcf1 <bind_functions+0xa1>
            }
        }
    }
    
    return 0;
}
  804160bd3d:	b8 00 00 00 00       	mov    $0x0,%eax
  804160bd42:	48 83 c4 18          	add    $0x18,%rsp
  804160bd46:	5b                   	pop    %rbx
  804160bd47:	41 5c                	pop    %r12
  804160bd49:	41 5d                	pop    %r13
  804160bd4b:	41 5e                	pop    %r14
  804160bd4d:	41 5f                	pop    %r15
  804160bd4f:	5d                   	pop    %rbp
  804160bd50:	c3                   	ret    

000000804160bd51 <env_create>:
 * This function is ONLY called during kernel initialization,
 * before running the first user-mode environment.
 * The new env's parent ID is set to 0.
 */
void
env_create(uint8_t *binary, size_t size, enum EnvType type) {
  804160bd51:	55                   	push   %rbp
  804160bd52:	48 89 e5             	mov    %rsp,%rbp
  804160bd55:	41 57                	push   %r15
  804160bd57:	41 56                	push   %r14
  804160bd59:	41 55                	push   %r13
  804160bd5b:	41 54                	push   %r12
  804160bd5d:	53                   	push   %rbx
  804160bd5e:	48 83 ec 28          	sub    $0x28,%rsp
  804160bd62:	49 89 fc             	mov    %rdi,%r12
  804160bd65:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  804160bd69:	89 d3                	mov    %edx,%ebx
    // LAB 8: Your code here
    // LAB 3: Your code here
    struct Env *env;
    if (env_alloc(&env, 0, type) < 0) {
  804160bd6b:	be 00 00 00 00       	mov    $0x0,%esi
  804160bd70:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160bd74:	48 b8 d1 ba 60 41 80 	movabs $0x804160bad1,%rax
  804160bd7b:	00 00 00 
  804160bd7e:	ff d0                	call   *%rax
  804160bd80:	85 c0                	test   %eax,%eax
  804160bd82:	0f 88 b5 00 00 00    	js     804160be3d <env_create+0xec>
        panic("cant allocate env");
    }
    env->binary = binary;
  804160bd88:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160bd8c:	4c 89 a7 e0 00 00 00 	mov    %r12,0xe0(%rdi)
    env->env_type = type;
  804160bd93:	89 9f d0 00 00 00    	mov    %ebx,0xd0(%rdi)
    map_region(&env->address_space, (uintptr_t)UTEMP - context.size, &kspace, (uintptr_t)context.front, context.size, PROT_W | PROT_R | PROT_USER_);
  804160bd99:	48 b8 40 5b 40 42 80 	movabs $0x8042405b40,%rax
  804160bda0:	00 00 00 
  804160bda3:	44 8b 40 10          	mov    0x10(%rax),%r8d
  804160bda7:	48 8b 48 18          	mov    0x18(%rax),%rcx
  804160bdab:	be 00 00 40 00       	mov    $0x400000,%esi
  804160bdb0:	4c 29 c6             	sub    %r8,%rsi
  804160bdb3:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  804160bdba:	41 b9 26 00 00 00    	mov    $0x26,%r9d
  804160bdc0:	48 ba b0 00 40 42 80 	movabs $0x80424000b0,%rdx
  804160bdc7:	00 00 00 
  804160bdca:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160bdd1:	00 00 00 
  804160bdd4:	ff d0                	call   *%rax
    if (ElfHeader->e_magic != ELF_MAGIC) {
  804160bdd6:	41 81 3c 24 7f 45 4c 	cmpl   $0x464c457f,(%r12)
  804160bddd:	46 
  804160bdde:	0f 85 a8 01 00 00    	jne    804160bf8c <env_create+0x23b>
    if (!ElfHeader->e_phoff) {
  804160bde4:	49 8b 5c 24 20       	mov    0x20(%r12),%rbx
  804160bde9:	48 85 db             	test   %rbx,%rbx
  804160bdec:	0f 84 9a 01 00 00    	je     804160bf8c <env_create+0x23b>
    if (load_icode(env, binary, size) == E_INVALID_EXE) {
  804160bdf2:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804160bdf6:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    ph_start = (struct Proghdr*)(binary + ElfHeader->e_phoff);
  804160bdfa:	4c 01 e3             	add    %r12,%rbx
    ph_end = ph_start + ElfHeader->e_phnum;
  804160bdfd:	41 0f b7 54 24 38    	movzwl 0x38(%r12),%edx
  804160be03:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  804160be0a:	00 
  804160be0b:	48 29 d0             	sub    %rdx,%rax
  804160be0e:	4c 8d 2c c3          	lea    (%rbx,%rax,8),%r13
    switch_address_space(&env->address_space);
  804160be12:	4c 8d b1 e8 00 00 00 	lea    0xe8(%rcx),%r14
  804160be19:	4c 89 f7             	mov    %r14,%rdi
  804160be1c:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160be23:	00 00 00 
  804160be26:	ff d0                	call   *%rax
    for (struct Proghdr *ph = ph_start; ph < ph_end; ++ph) {
  804160be28:	4c 39 eb             	cmp    %r13,%rbx
  804160be2b:	0f 83 d4 00 00 00    	jae    804160bf05 <env_create+0x1b4>
        res = map_region(&env->address_space, 
  804160be31:	49 bf f6 a0 60 41 80 	movabs $0x804160a0f6,%r15
  804160be38:	00 00 00 
  804160be3b:	eb 37                	jmp    804160be74 <env_create+0x123>
        panic("cant allocate env");
  804160be3d:	48 ba 18 2b 61 41 80 	movabs $0x8041612b18,%rdx
  804160be44:	00 00 00 
  804160be47:	be 84 01 00 00       	mov    $0x184,%esi
  804160be4c:	48 bf f8 2a 61 41 80 	movabs $0x8041612af8,%rdi
  804160be53:	00 00 00 
  804160be56:	b8 00 00 00 00       	mov    $0x0,%eax
  804160be5b:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160be62:	00 00 00 
  804160be65:	ff d1                	call   *%rcx
    for (struct Proghdr *ph = ph_start; ph < ph_end; ++ph) {
  804160be67:	48 83 c3 38          	add    $0x38,%rbx
  804160be6b:	49 39 dd             	cmp    %rbx,%r13
  804160be6e:	0f 86 91 00 00 00    	jbe    804160bf05 <env_create+0x1b4>
        if (ph->p_type != ELF_PROG_LOAD)
  804160be74:	83 3b 01             	cmpl   $0x1,(%rbx)
  804160be77:	75 ee                	jne    804160be67 <env_create+0x116>
        if (ph->p_filesz > ph->p_memsz) 
  804160be79:	48 8b 43 28          	mov    0x28(%rbx),%rax
  804160be7d:	48 39 43 20          	cmp    %rax,0x20(%rbx)
  804160be81:	0f 87 05 01 00 00    	ja     804160bf8c <env_create+0x23b>
        uintptr_t aligned_start = ROUNDDOWN((uintptr_t)ph->p_va, PAGE_SIZE);
  804160be87:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  804160be8b:	48 89 d6             	mov    %rdx,%rsi
  804160be8e:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
        uintptr_t aligned_end = ROUNDUP((uintptr_t)ph->p_va + ph->p_memsz, PAGE_SIZE);
  804160be95:	4c 8d 84 10 ff 0f 00 	lea    0xfff(%rax,%rdx,1),%r8
  804160be9c:	00 
        res = map_region(&env->address_space, 
  804160be9d:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
  804160bea4:	41 b9 27 00 10 00    	mov    $0x100027,%r9d
  804160beaa:	49 29 f0             	sub    %rsi,%r8
  804160bead:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160beb2:	ba 00 00 00 00       	mov    $0x0,%edx
  804160beb7:	4c 89 f7             	mov    %r14,%rdi
  804160beba:	41 ff d7             	call   *%r15
        if (res)
  804160bebd:	85 c0                	test   %eax,%eax
  804160bebf:	0f 85 b3 00 00 00    	jne    804160bf78 <env_create+0x227>
        memmove((void*)ph->p_va, (void*)(binary + ph->p_offset), ph->p_filesz);
  804160bec5:	48 8b 53 20          	mov    0x20(%rbx),%rdx
  804160bec9:	4c 89 e6             	mov    %r12,%rsi
  804160becc:	48 03 73 08          	add    0x8(%rbx),%rsi
  804160bed0:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  804160bed4:	48 b8 4f fe 60 41 80 	movabs $0x804160fe4f,%rax
  804160bedb:	00 00 00 
  804160bede:	ff d0                	call   *%rax
        memset((void*)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz); 
  804160bee0:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  804160bee4:	48 8b 53 28          	mov    0x28(%rbx),%rdx
  804160bee8:	48 29 fa             	sub    %rdi,%rdx
  804160beeb:	48 03 7b 10          	add    0x10(%rbx),%rdi
  804160beef:	be 00 00 00 00       	mov    $0x0,%esi
  804160bef4:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160befb:	00 00 00 
  804160befe:	ff d0                	call   *%rax
  804160bf00:	e9 62 ff ff ff       	jmp    804160be67 <env_create+0x116>
    switch_address_space(&kspace);
  804160bf05:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160bf0c:	00 00 00 
  804160bf0f:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160bf16:	00 00 00 
  804160bf19:	ff d0                	call   *%rax
    env->env_tf.tf_rip = ElfHeader->e_entry;
  804160bf1b:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  804160bf20:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804160bf24:	48 89 87 98 00 00 00 	mov    %rax,0x98(%rdi)
    bind_functions(env, binary, size, 0, 0);
  804160bf2b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  804160bf31:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160bf36:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804160bf3a:	4c 89 e6             	mov    %r12,%rsi
  804160bf3d:	48 b8 50 bc 60 41 80 	movabs $0x804160bc50,%rax
  804160bf44:	00 00 00 
  804160bf47:	ff d0                	call   *%rax
    res = map_region(&env->address_space, 
  804160bf49:	41 b9 27 00 10 00    	mov    $0x100027,%r9d
  804160bf4f:	41 b8 00 00 01 00    	mov    $0x10000,%r8d
  804160bf55:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160bf5a:	ba 00 00 00 00       	mov    $0x0,%edx
  804160bf5f:	48 be 00 70 fe ff 7f 	movabs $0x7ffffe7000,%rsi
  804160bf66:	00 00 00 
  804160bf69:	4c 89 f7             	mov    %r14,%rdi
  804160bf6c:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160bf73:	00 00 00 
  804160bf76:	ff d0                	call   *%rax
    if (load_icode(env, binary, size) == E_INVALID_EXE) {
  804160bf78:	83 f8 08             	cmp    $0x8,%eax
  804160bf7b:	74 0f                	je     804160bf8c <env_create+0x23b>
        panic("INVALID EXE");
    }
}
  804160bf7d:	48 83 c4 28          	add    $0x28,%rsp
  804160bf81:	5b                   	pop    %rbx
  804160bf82:	41 5c                	pop    %r12
  804160bf84:	41 5d                	pop    %r13
  804160bf86:	41 5e                	pop    %r14
  804160bf88:	41 5f                	pop    %r15
  804160bf8a:	5d                   	pop    %rbp
  804160bf8b:	c3                   	ret    
        panic("INVALID EXE");
  804160bf8c:	48 ba 2a 2b 61 41 80 	movabs $0x8041612b2a,%rdx
  804160bf93:	00 00 00 
  804160bf96:	be 8a 01 00 00       	mov    $0x18a,%esi
  804160bf9b:	48 bf f8 2a 61 41 80 	movabs $0x8041612af8,%rdi
  804160bfa2:	00 00 00 
  804160bfa5:	b8 00 00 00 00       	mov    $0x0,%eax
  804160bfaa:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160bfb1:	00 00 00 
  804160bfb4:	ff d1                	call   *%rcx

000000804160bfb6 <env_free>:


/* Frees env and all memory it uses */
void
env_free(struct Env *env) {
  804160bfb6:	55                   	push   %rbp
  804160bfb7:	48 89 e5             	mov    %rsp,%rbp
  804160bfba:	41 54                	push   %r12
  804160bfbc:	53                   	push   %rbx
  804160bfbd:	48 89 fb             	mov    %rdi,%rbx

    /* Note the environment's demise. */
    if (trace_envs) cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, env->env_id);
  804160bfc0:	8b 97 c8 00 00 00    	mov    0xc8(%rdi),%edx
  804160bfc6:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160bfcd:	00 00 00 
  804160bfd0:	be 00 00 00 00       	mov    $0x0,%esi
  804160bfd5:	48 85 c0             	test   %rax,%rax
  804160bfd8:	74 06                	je     804160bfe0 <env_free+0x2a>
  804160bfda:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  804160bfe0:	48 bf 36 2b 61 41 80 	movabs $0x8041612b36,%rdi
  804160bfe7:	00 00 00 
  804160bfea:	b8 00 00 00 00       	mov    $0x0,%eax
  804160bfef:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  804160bff6:	00 00 00 
  804160bff9:	ff d1                	call   *%rcx

#ifndef CONFIG_KSPACE
    /* If freeing the current environment, switch to kern_pgdir
     * before freeing the page directory, just in case the page
     * gets reused. */
    if (&env->address_space == current_space)
  804160bffb:	4c 8d a3 e8 00 00 00 	lea    0xe8(%rbx),%r12
  804160c002:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  804160c009:	00 00 00 
  804160c00c:	4c 3b 20             	cmp    (%rax),%r12
  804160c00f:	74 35                	je     804160c046 <env_free+0x90>
        switch_address_space(&kspace);

    static_assert(MAX_USER_ADDRESS % HUGE_PAGE_SIZE == 0, "Misaligned MAX_USER_ADDRESS");
    release_address_space(&env->address_space);
  804160c011:	4c 89 e7             	mov    %r12,%rdi
  804160c014:	48 b8 84 93 60 41 80 	movabs $0x8041609384,%rax
  804160c01b:	00 00 00 
  804160c01e:	ff d0                	call   *%rax
#endif

    /* Return the environment to the free list */
    env->env_status = ENV_FREE;
  804160c020:	c7 83 d4 00 00 00 00 	movl   $0x0,0xd4(%rbx)
  804160c027:	00 00 00 
    env->env_link = env_free_list;
  804160c02a:	48 b8 58 44 40 42 80 	movabs $0x8042404458,%rax
  804160c031:	00 00 00 
  804160c034:	48 8b 10             	mov    (%rax),%rdx
  804160c037:	48 89 93 c0 00 00 00 	mov    %rdx,0xc0(%rbx)
    env_free_list = env;
  804160c03e:	48 89 18             	mov    %rbx,(%rax)
}
  804160c041:	5b                   	pop    %rbx
  804160c042:	41 5c                	pop    %r12
  804160c044:	5d                   	pop    %rbp
  804160c045:	c3                   	ret    
        switch_address_space(&kspace);
  804160c046:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160c04d:	00 00 00 
  804160c050:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160c057:	00 00 00 
  804160c05a:	ff d0                	call   *%rax
  804160c05c:	eb b3                	jmp    804160c011 <env_free+0x5b>

000000804160c05e <env_destroy>:
 *
 * If env was the current one, then runs a new environment
 * (and does not return to the caller)
 */
void
env_destroy(struct Env *env) {
  804160c05e:	55                   	push   %rbp
  804160c05f:	48 89 e5             	mov    %rsp,%rbp
  804160c062:	53                   	push   %rbx
  804160c063:	48 83 ec 08          	sub    $0x8,%rsp
  804160c067:	48 89 fb             	mov    %rdi,%rbx
    /* If env is currently running on other CPUs, we change its state to
     * ENV_DYING. A zombie environment will be freed the next time
     * it traps to the kernel. */
    // LAB 8: Your code here (set in_page_fault = 0)
   if (env->env_tf.tf_trapno == T_PGFLT) {
  804160c06a:	48 83 bf 88 00 00 00 	cmpq   $0xe,0x88(%rdi)
  804160c071:	0e 
  804160c072:	74 2b                	je     804160c09f <env_destroy+0x41>
        cprintf("in_page_fault\n");
        in_page_fault = 0;
   }

    // LAB 3: Your code here
    if (env->env_status == ENV_RUNNING && curenv != env) {
  804160c074:	83 bb d4 00 00 00 03 	cmpl   $0x3,0xd4(%rbx)
  804160c07b:	0f 85 8d 00 00 00    	jne    804160c10e <env_destroy+0xb0>
  804160c081:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160c088:	00 00 00 
  804160c08b:	48 39 18             	cmp    %rbx,(%rax)
  804160c08e:	74 7e                	je     804160c10e <env_destroy+0xb0>
        env->env_status = ENV_DYING;
  804160c090:	c7 83 d4 00 00 00 01 	movl   $0x1,0xd4(%rbx)
  804160c097:	00 00 00 
        return ;
  804160c09a:	e9 8d 00 00 00       	jmp    804160c12c <env_destroy+0xce>
        assert(current_space);
  804160c09f:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  804160c0a6:	00 00 00 
  804160c0a9:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160c0ad:	74 2a                	je     804160c0d9 <env_destroy+0x7b>
        cprintf("in_page_fault\n");
  804160c0af:	48 bf 4c 2b 61 41 80 	movabs $0x8041612b4c,%rdi
  804160c0b6:	00 00 00 
  804160c0b9:	b8 00 00 00 00       	mov    $0x0,%eax
  804160c0be:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160c0c5:	00 00 00 
  804160c0c8:	ff d2                	call   *%rdx
        in_page_fault = 0;
  804160c0ca:	48 b8 80 44 40 42 80 	movabs $0x8042404480,%rax
  804160c0d1:	00 00 00 
  804160c0d4:	c6 00 00             	movb   $0x0,(%rax)
  804160c0d7:	eb 9b                	jmp    804160c074 <env_destroy+0x16>
        assert(current_space);
  804160c0d9:	48 b9 f6 1d 61 41 80 	movabs $0x8041611df6,%rcx
  804160c0e0:	00 00 00 
  804160c0e3:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160c0ea:	00 00 00 
  804160c0ed:	be b3 01 00 00       	mov    $0x1b3,%esi
  804160c0f2:	48 bf f8 2a 61 41 80 	movabs $0x8041612af8,%rdi
  804160c0f9:	00 00 00 
  804160c0fc:	b8 00 00 00 00       	mov    $0x0,%eax
  804160c101:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160c108:	00 00 00 
  804160c10b:	41 ff d0             	call   *%r8
    }
    env_free(env);
  804160c10e:	48 89 df             	mov    %rbx,%rdi
  804160c111:	48 b8 b6 bf 60 41 80 	movabs $0x804160bfb6,%rax
  804160c118:	00 00 00 
  804160c11b:	ff d0                	call   *%rax

    if (curenv == env) {
  804160c11d:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160c124:	00 00 00 
  804160c127:	48 39 18             	cmp    %rbx,(%rax)
  804160c12a:	74 06                	je     804160c132 <env_destroy+0xd4>
        env = NULL;
        sched_yield();
    }
}
  804160c12c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804160c130:	c9                   	leave  
  804160c131:	c3                   	ret    
        sched_yield();
  804160c132:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  804160c139:	00 00 00 
  804160c13c:	ff d0                	call   *%rax

000000804160c13e <env_pop_tf>:
 *
 * This function does not return.
 */

_Noreturn void
env_pop_tf(struct Trapframe *tf) {
  804160c13e:	55                   	push   %rbp
  804160c13f:	48 89 e5             	mov    %rsp,%rbp
    asm volatile(
  804160c142:	48 89 fc             	mov    %rdi,%rsp
  804160c145:	4c 8b 3c 24          	mov    (%rsp),%r15
  804160c149:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  804160c14e:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  804160c153:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  804160c158:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  804160c15d:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  804160c162:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  804160c167:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  804160c16c:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  804160c171:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  804160c176:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  804160c17b:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  804160c180:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  804160c185:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  804160c18a:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  804160c18f:	8e 44 24 78          	mov    0x78(%rsp),%es
  804160c193:	8e 9c 24 80 00 00 00 	mov    0x80(%rsp),%ds
  804160c19a:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  804160c1a1:	48 cf                	iretq  
            "addq $152,%%rsp\n" /* skip tf_trapno and tf_errcode */
            "iretq" ::"g"(tf)
            : "memory");

    /* Mostly to placate the compiler */
    panic("Reached unreachable\n");
  804160c1a3:	48 ba 5b 2b 61 41 80 	movabs $0x8041612b5b,%rdx
  804160c1aa:	00 00 00 
  804160c1ad:	be f3 01 00 00       	mov    $0x1f3,%esi
  804160c1b2:	48 bf f8 2a 61 41 80 	movabs $0x8041612af8,%rdi
  804160c1b9:	00 00 00 
  804160c1bc:	b8 00 00 00 00       	mov    $0x0,%eax
  804160c1c1:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160c1c8:	00 00 00 
  804160c1cb:	ff d1                	call   *%rcx

000000804160c1cd <env_run>:
 *    env->env_tf.  Go back through the code you wrote above
 *    and make sure you have set the relevant parts of
 *    env->env_tf to sensible values.
 */
_Noreturn void
env_run(struct Env *env) {
  804160c1cd:	55                   	push   %rbp
  804160c1ce:	48 89 e5             	mov    %rsp,%rbp
  804160c1d1:	53                   	push   %rbx
  804160c1d2:	48 83 ec 08          	sub    $0x8,%rsp
    assert(env);
  804160c1d6:	48 85 ff             	test   %rdi,%rdi
  804160c1d9:	74 58                	je     804160c233 <env_run+0x66>
        if (curenv) cprintf("[%08X] env stopped: %s\n", curenv->env_id, state[curenv->env_status]);
        cprintf("[%08X] env started: %s\n", env->env_id, state[env->env_status]);
    }

    // LAB 3: Your code here
    if (curenv && curenv->env_status == ENV_RUNNING) 
  804160c1db:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160c1e2:	00 00 00 
  804160c1e5:	48 85 c0             	test   %rax,%rax
  804160c1e8:	74 09                	je     804160c1f3 <env_run+0x26>
  804160c1ea:	83 b8 d4 00 00 00 03 	cmpl   $0x3,0xd4(%rax)
  804160c1f1:	74 75                	je     804160c268 <env_run+0x9b>
        curenv->env_status = ENV_RUNNABLE;
    // LAB 8: Your code here

    curenv = env;
  804160c1f3:	48 bb 50 44 40 42 80 	movabs $0x8042404450,%rbx
  804160c1fa:	00 00 00 
  804160c1fd:	48 89 3b             	mov    %rdi,(%rbx)
    curenv->env_status = ENV_RUNNING;
  804160c200:	c7 87 d4 00 00 00 03 	movl   $0x3,0xd4(%rdi)
  804160c207:	00 00 00 
    curenv->env_runs++;
  804160c20a:	83 87 d8 00 00 00 01 	addl   $0x1,0xd8(%rdi)
    switch_address_space(&curenv->address_space);
  804160c211:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  804160c218:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160c21f:	00 00 00 
  804160c222:	ff d0                	call   *%rax
    env_pop_tf(&curenv->env_tf);
  804160c224:	48 8b 3b             	mov    (%rbx),%rdi
  804160c227:	48 b8 3e c1 60 41 80 	movabs $0x804160c13e,%rax
  804160c22e:	00 00 00 
  804160c231:	ff d0                	call   *%rax
    assert(env);
  804160c233:	48 b9 26 2b 61 41 80 	movabs $0x8041612b26,%rcx
  804160c23a:	00 00 00 
  804160c23d:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160c244:	00 00 00 
  804160c247:	be 0e 02 00 00       	mov    $0x20e,%esi
  804160c24c:	48 bf f8 2a 61 41 80 	movabs $0x8041612af8,%rdi
  804160c253:	00 00 00 
  804160c256:	b8 00 00 00 00       	mov    $0x0,%eax
  804160c25b:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160c262:	00 00 00 
  804160c265:	41 ff d0             	call   *%r8
        curenv->env_status = ENV_RUNNABLE;
  804160c268:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  804160c26f:	00 00 00 
  804160c272:	e9 7c ff ff ff       	jmp    804160c1f3 <env_run+0x26>

000000804160c277 <rtc_timer_pic_interrupt>:
cmos_read16(uint8_t reg) {
    return cmos_read8(reg) | (cmos_read8(reg + 1) << 8);
}

static void
rtc_timer_pic_interrupt(void) {
  804160c277:	55                   	push   %rbp
  804160c278:	48 89 e5             	mov    %rsp,%rbp
    // LAB 4: Your code here
    // Enable PIC interrupts.
     pic_irq_unmask(IRQ_CLOCK);
  804160c27b:	bf 08 00 00 00       	mov    $0x8,%edi
  804160c280:	48 b8 d3 c7 60 41 80 	movabs $0x804160c7d3,%rax
  804160c287:	00 00 00 
  804160c28a:	ff d0                	call   *%rax
}
  804160c28c:	5d                   	pop    %rbp
  804160c28d:	c3                   	ret    

000000804160c28e <cmos_read8>:
    asm volatile("inb %w1,%0"
  804160c28e:	b9 70 00 00 00       	mov    $0x70,%ecx
  804160c293:	89 ca                	mov    %ecx,%edx
  804160c295:	ec                   	in     (%dx),%al
    outb(CMOS_CMD, inb(CMOS_CMD) & ~CMOS_NMI_LOCK);
}

static inline void __attribute__((always_inline))
nmi_disable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
  804160c296:	83 c8 80             	or     $0xffffff80,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160c299:	ee                   	out    %al,(%dx)
  804160c29a:	89 f8                	mov    %edi,%eax
  804160c29c:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  804160c29d:	ba 71 00 00 00       	mov    $0x71,%edx
  804160c2a2:	ec                   	in     (%dx),%al
  804160c2a3:	89 c6                	mov    %eax,%esi
  804160c2a5:	89 ca                	mov    %ecx,%edx
  804160c2a7:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160c2a8:	83 e0 7f             	and    $0x7f,%eax
  804160c2ab:	ee                   	out    %al,(%dx)
}
  804160c2ac:	89 f0                	mov    %esi,%eax
  804160c2ae:	c3                   	ret    

000000804160c2af <get_time>:
        .enable_interrupts = rtc_timer_pic_interrupt,
        .handle_interrupts = rtc_timer_pic_handle,
};

static int
get_time(void) {
  804160c2af:	55                   	push   %rbp
  804160c2b0:	48 89 e5             	mov    %rsp,%rbp
  804160c2b3:	41 57                	push   %r15
  804160c2b5:	41 56                	push   %r14
  804160c2b7:	41 55                	push   %r13
  804160c2b9:	41 54                	push   %r12
  804160c2bb:	53                   	push   %rbx
  804160c2bc:	48 83 ec 58          	sub    $0x58,%rsp
    struct tm time;

    uint8_t s, m, h, d, M, y, Y, state;
    s = cmos_read8(RTC_SEC);
  804160c2c0:	bf 00 00 00 00       	mov    $0x0,%edi
  804160c2c5:	49 bd 8e c2 60 41 80 	movabs $0x804160c28e,%r13
  804160c2cc:	00 00 00 
  804160c2cf:	41 ff d5             	call   *%r13
  804160c2d2:	41 89 c6             	mov    %eax,%r14d
    m = cmos_read8(RTC_MIN);
  804160c2d5:	bf 02 00 00 00       	mov    $0x2,%edi
  804160c2da:	41 ff d5             	call   *%r13
  804160c2dd:	41 89 c4             	mov    %eax,%r12d
    h = cmos_read8(RTC_HOUR);
  804160c2e0:	bf 04 00 00 00       	mov    $0x4,%edi
  804160c2e5:	41 ff d5             	call   *%r13
  804160c2e8:	89 c3                	mov    %eax,%ebx
    d = cmos_read8(RTC_DAY);
  804160c2ea:	bf 07 00 00 00       	mov    $0x7,%edi
  804160c2ef:	41 ff d5             	call   *%r13
  804160c2f2:	41 89 c7             	mov    %eax,%r15d
    M = cmos_read8(RTC_MON);
  804160c2f5:	bf 08 00 00 00       	mov    $0x8,%edi
  804160c2fa:	41 ff d5             	call   *%r13
  804160c2fd:	88 45 8f             	mov    %al,-0x71(%rbp)
    y = cmos_read8(RTC_YEAR);
  804160c300:	bf 09 00 00 00       	mov    $0x9,%edi
  804160c305:	41 ff d5             	call   *%r13
  804160c308:	88 45 8e             	mov    %al,-0x72(%rbp)
    Y = cmos_read8(RTC_YEAR_HIGH);
  804160c30b:	bf 32 00 00 00       	mov    $0x32,%edi
  804160c310:	41 ff d5             	call   *%r13
  804160c313:	88 45 8d             	mov    %al,-0x73(%rbp)
    state = cmos_read8(RTC_BREG);
  804160c316:	bf 0b 00 00 00       	mov    $0xb,%edi
  804160c31b:	41 ff d5             	call   *%r13

    if (state & RTC_12H) {
  804160c31e:	a8 02                	test   $0x2,%al
  804160c320:	74 0d                	je     804160c32f <get_time+0x80>
        /* Fixup 12 hour mode */
        h = (h & 0x7F) + 12 * !!(h & 0x80);
  804160c322:	89 da                	mov    %ebx,%edx
  804160c324:	83 e2 7f             	and    $0x7f,%edx
  804160c327:	c0 fb 07             	sar    $0x7,%bl
  804160c32a:	83 e3 0c             	and    $0xc,%ebx
  804160c32d:	01 d3                	add    %edx,%ebx
    }

    if (!(state & RTC_BINARY)) {
  804160c32f:	a8 04                	test   $0x4,%al
  804160c331:	0f 85 86 00 00 00    	jne    804160c3bd <get_time+0x10e>
        /* Fixup binary mode */
        s = BCD2BIN(s);
  804160c337:	44 89 f0             	mov    %r14d,%eax
  804160c33a:	c0 e8 04             	shr    $0x4,%al
  804160c33d:	8d 14 80             	lea    (%rax,%rax,4),%edx
  804160c340:	41 83 e6 0f          	and    $0xf,%r14d
  804160c344:	45 8d 34 56          	lea    (%r14,%rdx,2),%r14d
        m = BCD2BIN(m);
  804160c348:	44 89 e0             	mov    %r12d,%eax
  804160c34b:	c0 e8 04             	shr    $0x4,%al
  804160c34e:	8d 14 80             	lea    (%rax,%rax,4),%edx
  804160c351:	41 83 e4 0f          	and    $0xf,%r12d
  804160c355:	45 8d 24 54          	lea    (%r12,%rdx,2),%r12d
        h = BCD2BIN(h);
  804160c359:	89 d8                	mov    %ebx,%eax
  804160c35b:	c0 e8 04             	shr    $0x4,%al
  804160c35e:	8d 14 80             	lea    (%rax,%rax,4),%edx
  804160c361:	83 e3 0f             	and    $0xf,%ebx
  804160c364:	8d 1c 53             	lea    (%rbx,%rdx,2),%ebx
        d = BCD2BIN(d);
  804160c367:	44 89 f8             	mov    %r15d,%eax
  804160c36a:	c0 e8 04             	shr    $0x4,%al
  804160c36d:	8d 14 80             	lea    (%rax,%rax,4),%edx
  804160c370:	41 83 e7 0f          	and    $0xf,%r15d
  804160c374:	45 8d 3c 57          	lea    (%r15,%rdx,2),%r15d
        M = BCD2BIN(M);
  804160c378:	0f b6 75 8f          	movzbl -0x71(%rbp),%esi
  804160c37c:	89 f0                	mov    %esi,%eax
  804160c37e:	c0 e8 04             	shr    $0x4,%al
  804160c381:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804160c384:	89 f2                	mov    %esi,%edx
  804160c386:	83 e2 0f             	and    $0xf,%edx
  804160c389:	8d 04 42             	lea    (%rdx,%rax,2),%eax
  804160c38c:	88 45 8f             	mov    %al,-0x71(%rbp)
        y = BCD2BIN(y);
  804160c38f:	0f b6 75 8e          	movzbl -0x72(%rbp),%esi
  804160c393:	89 f0                	mov    %esi,%eax
  804160c395:	c0 e8 04             	shr    $0x4,%al
  804160c398:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804160c39b:	89 f2                	mov    %esi,%edx
  804160c39d:	83 e2 0f             	and    $0xf,%edx
  804160c3a0:	8d 04 42             	lea    (%rdx,%rax,2),%eax
  804160c3a3:	88 45 8e             	mov    %al,-0x72(%rbp)
        Y = BCD2BIN(Y);
  804160c3a6:	0f b6 75 8d          	movzbl -0x73(%rbp),%esi
  804160c3aa:	89 f0                	mov    %esi,%eax
  804160c3ac:	c0 e8 04             	shr    $0x4,%al
  804160c3af:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804160c3b2:	89 f2                	mov    %esi,%edx
  804160c3b4:	83 e2 0f             	and    $0xf,%edx
  804160c3b7:	8d 04 42             	lea    (%rdx,%rax,2),%eax
  804160c3ba:	88 45 8d             	mov    %al,-0x73(%rbp)
    }

    time.tm_sec = s;
  804160c3bd:	45 0f b6 f6          	movzbl %r14b,%r14d
    time.tm_min = m;
  804160c3c1:	45 0f b6 e4          	movzbl %r12b,%r12d
    time.tm_hour = h;
  804160c3c5:	0f b6 db             	movzbl %bl,%ebx
    time.tm_mday = d;
  804160c3c8:	45 0f b6 ff          	movzbl %r15b,%r15d
    time.tm_mon = M - 1;
  804160c3cc:	0f b6 75 8f          	movzbl -0x71(%rbp),%esi
  804160c3d0:	83 ee 01             	sub    $0x1,%esi
    time.tm_year = y + Y * 100 - 1900;
  804160c3d3:	0f b6 55 8d          	movzbl -0x73(%rbp),%edx
  804160c3d7:	6b d2 64             	imul   $0x64,%edx,%edx
  804160c3da:	0f b6 45 8e          	movzbl -0x72(%rbp),%eax
  804160c3de:	01 c2                	add    %eax,%edx
                                    212, 243, 273, 304, 334, 365}[m] + \
                      (ISLEAP(y) && (m) > 1))

inline static int
timestamp(struct tm *time) {
    return DAY * (Y2DAYS(time->tm_year + 1900) - Y2DAYS(1970) +
  804160c3e0:	69 ca 6d 01 00 00    	imul   $0x16d,%edx,%ecx
  804160c3e6:	8d 7a 02             	lea    0x2(%rdx),%edi
  804160c3e9:	89 d0                	mov    %edx,%eax
  804160c3eb:	83 e8 01             	sub    $0x1,%eax
  804160c3ee:	0f 49 f8             	cmovns %eax,%edi
  804160c3f1:	c1 ff 02             	sar    $0x2,%edi
  804160c3f4:	01 cf                	add    %ecx,%edi
  804160c3f6:	48 63 c8             	movslq %eax,%rcx
  804160c3f9:	48 69 c9 1f 85 eb 51 	imul   $0x51eb851f,%rcx,%rcx
  804160c400:	49 89 ca             	mov    %rcx,%r10
  804160c403:	49 c1 fa 25          	sar    $0x25,%r10
  804160c407:	c1 f8 1f             	sar    $0x1f,%eax
  804160c40a:	41 89 c0             	mov    %eax,%r8d
  804160c40d:	45 29 d0             	sub    %r10d,%r8d
  804160c410:	44 01 c7             	add    %r8d,%edi
  804160c413:	48 c1 f9 27          	sar    $0x27,%rcx
  804160c417:	29 c1                	sub    %eax,%ecx
  804160c419:	8d bc 0f 59 05 f5 ff 	lea    -0xafaa7(%rdi,%rcx,1),%edi
                  M2DAYS(time->tm_mon, time->tm_year + 1900) + time->tm_mday - 1) +
  804160c420:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%rbp)
  804160c427:	c7 45 a0 1f 00 00 00 	movl   $0x1f,-0x60(%rbp)
  804160c42e:	c7 45 a4 3b 00 00 00 	movl   $0x3b,-0x5c(%rbp)
  804160c435:	c7 45 a8 5a 00 00 00 	movl   $0x5a,-0x58(%rbp)
  804160c43c:	c7 45 ac 78 00 00 00 	movl   $0x78,-0x54(%rbp)
  804160c443:	c7 45 b0 97 00 00 00 	movl   $0x97,-0x50(%rbp)
  804160c44a:	c7 45 b4 b5 00 00 00 	movl   $0xb5,-0x4c(%rbp)
  804160c451:	c7 45 b8 d4 00 00 00 	movl   $0xd4,-0x48(%rbp)
  804160c458:	c7 45 bc f3 00 00 00 	movl   $0xf3,-0x44(%rbp)
  804160c45f:	c7 45 c0 11 01 00 00 	movl   $0x111,-0x40(%rbp)
  804160c466:	c7 45 c4 30 01 00 00 	movl   $0x130,-0x3c(%rbp)
  804160c46d:	c7 45 c8 4e 01 00 00 	movl   $0x14e,-0x38(%rbp)
  804160c474:	c7 45 cc 6d 01 00 00 	movl   $0x16d,-0x34(%rbp)
  804160c47b:	48 63 c6             	movslq %esi,%rax
  804160c47e:	8b 44 85 9c          	mov    -0x64(%rbp,%rax,4),%eax
  804160c482:	48 63 ca             	movslq %edx,%rcx
  804160c485:	48 69 c9 1f 85 eb 51 	imul   $0x51eb851f,%rcx,%rcx
  804160c48c:	48 c1 f9 27          	sar    $0x27,%rcx
  804160c490:	69 c9 90 01 00 00    	imul   $0x190,%ecx,%ecx
  804160c496:	39 ca                	cmp    %ecx,%edx
  804160c498:	74 23                	je     804160c4bd <get_time+0x20e>
  804160c49a:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160c49f:	f6 c2 03             	test   $0x3,%dl
  804160c4a2:	75 22                	jne    804160c4c6 <get_time+0x217>
  804160c4a4:	48 63 ca             	movslq %edx,%rcx
  804160c4a7:	48 69 c9 1f 85 eb 51 	imul   $0x51eb851f,%rcx,%rcx
  804160c4ae:	48 c1 f9 25          	sar    $0x25,%rcx
  804160c4b2:	44 6b c1 64          	imul   $0x64,%ecx,%r8d
  804160c4b6:	89 d1                	mov    %edx,%ecx
  804160c4b8:	44 29 c1             	sub    %r8d,%ecx
  804160c4bb:	74 09                	je     804160c4c6 <get_time+0x217>
  804160c4bd:	83 fe 01             	cmp    $0x1,%esi
  804160c4c0:	0f 9f c1             	setg   %cl
  804160c4c3:	0f b6 c9             	movzbl %cl,%ecx
  804160c4c6:	01 c8                	add    %ecx,%eax
    return DAY * (Y2DAYS(time->tm_year + 1900) - Y2DAYS(1970) +
  804160c4c8:	01 f8                	add    %edi,%eax
                  M2DAYS(time->tm_mon, time->tm_year + 1900) + time->tm_mday - 1) +
  804160c4ca:	41 8d 54 07 ff       	lea    -0x1(%r15,%rax,1),%edx
    return DAY * (Y2DAYS(time->tm_year + 1900) - Y2DAYS(1970) +
  804160c4cf:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
           time->tm_hour * HOUR + time->tm_min * MINUTE + time->tm_sec;
  804160c4d5:	69 c3 10 0e 00 00    	imul   $0xe10,%ebx,%eax
                  M2DAYS(time->tm_mon, time->tm_year + 1900) + time->tm_mday - 1) +
  804160c4db:	01 d0                	add    %edx,%eax
           time->tm_hour * HOUR + time->tm_min * MINUTE + time->tm_sec;
  804160c4dd:	45 6b e4 3c          	imul   $0x3c,%r12d,%r12d
  804160c4e1:	44 01 e0             	add    %r12d,%eax
  804160c4e4:	44 01 f0             	add    %r14d,%eax

    return timestamp(&time);
}
  804160c4e7:	48 83 c4 58          	add    $0x58,%rsp
  804160c4eb:	5b                   	pop    %rbx
  804160c4ec:	41 5c                	pop    %r12
  804160c4ee:	41 5d                	pop    %r13
  804160c4f0:	41 5e                	pop    %r14
  804160c4f2:	41 5f                	pop    %r15
  804160c4f4:	5d                   	pop    %rbp
  804160c4f5:	c3                   	ret    

000000804160c4f6 <cmos_write8>:
    asm volatile("inb %w1,%0"
  804160c4f6:	b9 70 00 00 00       	mov    $0x70,%ecx
  804160c4fb:	89 ca                	mov    %ecx,%edx
  804160c4fd:	ec                   	in     (%dx),%al
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
  804160c4fe:	83 c8 80             	or     $0xffffff80,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160c501:	ee                   	out    %al,(%dx)
  804160c502:	89 f8                	mov    %edi,%eax
  804160c504:	ee                   	out    %al,(%dx)
  804160c505:	ba 71 00 00 00       	mov    $0x71,%edx
  804160c50a:	89 f0                	mov    %esi,%eax
  804160c50c:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  804160c50d:	89 ca                	mov    %ecx,%edx
  804160c50f:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160c510:	83 e0 7f             	and    $0x7f,%eax
  804160c513:	ee                   	out    %al,(%dx)
}
  804160c514:	c3                   	ret    

000000804160c515 <rtc_timer_init>:
    nmi_enable();
    return res;
}

void
rtc_timer_init(void) {
  804160c515:	55                   	push   %rbp
  804160c516:	48 89 e5             	mov    %rsp,%rbp
  804160c519:	41 54                	push   %r12
  804160c51b:	53                   	push   %rbx
    // LAB 4: Your code here
    // (use cmos_read8/cmos_write8)
    cmos_write8(RTC_AREG, cmos_read8(RTC_AREG) | RTC_500MS_RATE);
  804160c51c:	bf 0a 00 00 00       	mov    $0xa,%edi
  804160c521:	49 bc 8e c2 60 41 80 	movabs $0x804160c28e,%r12
  804160c528:	00 00 00 
  804160c52b:	41 ff d4             	call   *%r12
  804160c52e:	83 c8 0f             	or     $0xf,%eax
  804160c531:	0f b6 f0             	movzbl %al,%esi
  804160c534:	bf 0a 00 00 00       	mov    $0xa,%edi
  804160c539:	48 bb f6 c4 60 41 80 	movabs $0x804160c4f6,%rbx
  804160c540:	00 00 00 
  804160c543:	ff d3                	call   *%rbx
    cmos_write8(RTC_BREG, cmos_read8(RTC_BREG) | RTC_PIE);
  804160c545:	bf 0b 00 00 00       	mov    $0xb,%edi
  804160c54a:	41 ff d4             	call   *%r12
  804160c54d:	83 c8 40             	or     $0x40,%eax
  804160c550:	0f b6 f0             	movzbl %al,%esi
  804160c553:	bf 0b 00 00 00       	mov    $0xb,%edi
  804160c558:	ff d3                	call   *%rbx
}
  804160c55a:	5b                   	pop    %rbx
  804160c55b:	41 5c                	pop    %r12
  804160c55d:	5d                   	pop    %rbp
  804160c55e:	c3                   	ret    

000000804160c55f <cmos_read16>:
cmos_read16(uint8_t reg) {
  804160c55f:	55                   	push   %rbp
  804160c560:	48 89 e5             	mov    %rsp,%rbp
  804160c563:	41 55                	push   %r13
  804160c565:	41 54                	push   %r12
  804160c567:	53                   	push   %rbx
  804160c568:	48 83 ec 08          	sub    $0x8,%rsp
  804160c56c:	89 fb                	mov    %edi,%ebx
    return cmos_read8(reg) | (cmos_read8(reg + 1) << 8);
  804160c56e:	40 0f b6 ff          	movzbl %dil,%edi
  804160c572:	49 bd 8e c2 60 41 80 	movabs $0x804160c28e,%r13
  804160c579:	00 00 00 
  804160c57c:	41 ff d5             	call   *%r13
  804160c57f:	41 89 c4             	mov    %eax,%r12d
  804160c582:	8d 7b 01             	lea    0x1(%rbx),%edi
  804160c585:	40 0f b6 ff          	movzbl %dil,%edi
  804160c589:	41 ff d5             	call   *%r13
  804160c58c:	c1 e0 08             	shl    $0x8,%eax
  804160c58f:	45 0f b6 e4          	movzbl %r12b,%r12d
  804160c593:	44 09 e0             	or     %r12d,%eax
}
  804160c596:	48 83 c4 08          	add    $0x8,%rsp
  804160c59a:	5b                   	pop    %rbx
  804160c59b:	41 5c                	pop    %r12
  804160c59d:	41 5d                	pop    %r13
  804160c59f:	5d                   	pop    %rbp
  804160c5a0:	c3                   	ret    

000000804160c5a1 <gettime>:
gettime(void) {
  804160c5a1:	55                   	push   %rbp
  804160c5a2:	48 89 e5             	mov    %rsp,%rbp
  804160c5a5:	41 54                	push   %r12
  804160c5a7:	53                   	push   %rbx
    asm volatile("inb %w1,%0"
  804160c5a8:	ba 70 00 00 00       	mov    $0x70,%edx
  804160c5ad:	ec                   	in     (%dx),%al
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
  804160c5ae:	83 c8 80             	or     $0xffffff80,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160c5b1:	ee                   	out    %al,(%dx)
    while (cmos_read8(RTC_AREG) & RTC_UPDATE_IN_PROGRESS)
  804160c5b2:	48 bb 8e c2 60 41 80 	movabs $0x804160c28e,%rbx
  804160c5b9:	00 00 00 
  804160c5bc:	bf 0a 00 00 00       	mov    $0xa,%edi
  804160c5c1:	ff d3                	call   *%rbx
  804160c5c3:	84 c0                	test   %al,%al
  804160c5c5:	78 f5                	js     804160c5bc <gettime+0x1b>
    res = get_time();
  804160c5c7:	49 bc af c2 60 41 80 	movabs $0x804160c2af,%r12
  804160c5ce:	00 00 00 
  804160c5d1:	41 ff d4             	call   *%r12
  804160c5d4:	89 c3                	mov    %eax,%ebx
    if (res != get_time()) {
  804160c5d6:	41 ff d4             	call   *%r12
  804160c5d9:	39 d8                	cmp    %ebx,%eax
  804160c5db:	75 11                	jne    804160c5ee <gettime+0x4d>
    asm volatile("inb %w1,%0"
  804160c5dd:	ba 70 00 00 00       	mov    $0x70,%edx
  804160c5e2:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160c5e3:	83 e0 7f             	and    $0x7f,%eax
  804160c5e6:	ee                   	out    %al,(%dx)
}
  804160c5e7:	89 d8                	mov    %ebx,%eax
  804160c5e9:	5b                   	pop    %rbx
  804160c5ea:	41 5c                	pop    %r12
  804160c5ec:	5d                   	pop    %rbp
  804160c5ed:	c3                   	ret    
        res = get_time();
  804160c5ee:	41 ff d4             	call   *%r12
  804160c5f1:	89 c3                	mov    %eax,%ebx
  804160c5f3:	eb e8                	jmp    804160c5dd <gettime+0x3c>

000000804160c5f5 <rtc_check_status>:

uint8_t
rtc_check_status(void) {
  804160c5f5:	55                   	push   %rbp
  804160c5f6:	48 89 e5             	mov    %rsp,%rbp
    // LAB 4: Your code here
    // (use cmos_read8)
    
    return cmos_read8(RTC_CREG);
  804160c5f9:	bf 0c 00 00 00       	mov    $0xc,%edi
  804160c5fe:	48 b8 8e c2 60 41 80 	movabs $0x804160c28e,%rax
  804160c605:	00 00 00 
  804160c608:	ff d0                	call   *%rax
}
  804160c60a:	5d                   	pop    %rbp
  804160c60b:	c3                   	ret    

000000804160c60c <rtc_timer_pic_handle>:
rtc_timer_pic_handle(void) {
  804160c60c:	55                   	push   %rbp
  804160c60d:	48 89 e5             	mov    %rsp,%rbp
    rtc_check_status();
  804160c610:	48 b8 f5 c5 60 41 80 	movabs $0x804160c5f5,%rax
  804160c617:	00 00 00 
  804160c61a:	ff d0                	call   *%rax
    pic_send_eoi(IRQ_CLOCK);
  804160c61c:	bf 08 00 00 00       	mov    $0x8,%edi
  804160c621:	48 b8 27 c8 60 41 80 	movabs $0x804160c827,%rax
  804160c628:	00 00 00 
  804160c62b:	ff d0                	call   *%rax
}
  804160c62d:	5d                   	pop    %rbp
  804160c62e:	c3                   	ret    

000000804160c62f <print_irq_mask>:
    outb(IO_PIC1_DATA, (uint8_t)mask);
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
}

static void
print_irq_mask(uint16_t mask) {
  804160c62f:	55                   	push   %rbp
  804160c630:	48 89 e5             	mov    %rsp,%rbp
  804160c633:	41 55                	push   %r13
  804160c635:	41 54                	push   %r12
  804160c637:	53                   	push   %rbx
  804160c638:	48 83 ec 08          	sub    $0x8,%rsp
  804160c63c:	41 89 fc             	mov    %edi,%r12d
    cprintf("enabled interrupts:");
  804160c63f:	48 bf 94 2b 61 41 80 	movabs $0x8041612b94,%rdi
  804160c646:	00 00 00 
  804160c649:	b8 00 00 00 00       	mov    $0x0,%eax
  804160c64e:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160c655:	00 00 00 
  804160c658:	ff d2                	call   *%rdx
    for (int i = 0; i < 16; i++) {
  804160c65a:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (~mask & (1 << i))
  804160c65f:	45 0f b7 e4          	movzwl %r12w,%r12d
  804160c663:	41 f7 d4             	not    %r12d
            cprintf(" %d", i);
  804160c666:	49 bd 99 c8 60 41 80 	movabs $0x804160c899,%r13
  804160c66d:	00 00 00 
  804160c670:	eb 08                	jmp    804160c67a <print_irq_mask+0x4b>
    for (int i = 0; i < 16; i++) {
  804160c672:	83 c3 01             	add    $0x1,%ebx
  804160c675:	83 fb 10             	cmp    $0x10,%ebx
  804160c678:	74 1c                	je     804160c696 <print_irq_mask+0x67>
        if (~mask & (1 << i))
  804160c67a:	41 0f a3 dc          	bt     %ebx,%r12d
  804160c67e:	73 f2                	jae    804160c672 <print_irq_mask+0x43>
            cprintf(" %d", i);
  804160c680:	89 de                	mov    %ebx,%esi
  804160c682:	48 bf 0d 36 61 41 80 	movabs $0x804161360d,%rdi
  804160c689:	00 00 00 
  804160c68c:	b8 00 00 00 00       	mov    $0x0,%eax
  804160c691:	41 ff d5             	call   *%r13
  804160c694:	eb dc                	jmp    804160c672 <print_irq_mask+0x43>
    }
    cprintf("\n");
  804160c696:	48 bf 88 11 61 41 80 	movabs $0x8041611188,%rdi
  804160c69d:	00 00 00 
  804160c6a0:	b8 00 00 00 00       	mov    $0x0,%eax
  804160c6a5:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160c6ac:	00 00 00 
  804160c6af:	ff d2                	call   *%rdx
}
  804160c6b1:	48 83 c4 08          	add    $0x8,%rsp
  804160c6b5:	5b                   	pop    %rbx
  804160c6b6:	41 5c                	pop    %r12
  804160c6b8:	41 5d                	pop    %r13
  804160c6ba:	5d                   	pop    %rbp
  804160c6bb:	c3                   	ret    

000000804160c6bc <pic_init>:


/* Initialize the 8259A interrupt controllers. */
void
pic_init(void) {
  804160c6bc:	55                   	push   %rbp
  804160c6bd:	48 89 e5             	mov    %rsp,%rbp
  804160c6c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804160c6c5:	be 21 00 00 00       	mov    $0x21,%esi
  804160c6ca:	89 f2                	mov    %esi,%edx
  804160c6cc:	ee                   	out    %al,(%dx)
  804160c6cd:	b9 a1 00 00 00       	mov    $0xa1,%ecx
  804160c6d2:	89 ca                	mov    %ecx,%edx
  804160c6d4:	ee                   	out    %al,(%dx)
  804160c6d5:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  804160c6db:	bf 20 00 00 00       	mov    $0x20,%edi
  804160c6e0:	44 89 c8             	mov    %r9d,%eax
  804160c6e3:	89 fa                	mov    %edi,%edx
  804160c6e5:	ee                   	out    %al,(%dx)
  804160c6e6:	b8 20 00 00 00       	mov    $0x20,%eax
  804160c6eb:	89 f2                	mov    %esi,%edx
  804160c6ed:	ee                   	out    %al,(%dx)
  804160c6ee:	b8 04 00 00 00       	mov    $0x4,%eax
  804160c6f3:	ee                   	out    %al,(%dx)
  804160c6f4:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804160c6fa:	44 89 c0             	mov    %r8d,%eax
  804160c6fd:	ee                   	out    %al,(%dx)
  804160c6fe:	be a0 00 00 00       	mov    $0xa0,%esi
  804160c703:	44 89 c8             	mov    %r9d,%eax
  804160c706:	89 f2                	mov    %esi,%edx
  804160c708:	ee                   	out    %al,(%dx)
  804160c709:	b8 28 00 00 00       	mov    $0x28,%eax
  804160c70e:	89 ca                	mov    %ecx,%edx
  804160c710:	ee                   	out    %al,(%dx)
  804160c711:	b8 02 00 00 00       	mov    $0x2,%eax
  804160c716:	ee                   	out    %al,(%dx)
  804160c717:	44 89 c0             	mov    %r8d,%eax
  804160c71a:	ee                   	out    %al,(%dx)
  804160c71b:	41 b8 68 00 00 00    	mov    $0x68,%r8d
  804160c721:	44 89 c0             	mov    %r8d,%eax
  804160c724:	89 fa                	mov    %edi,%edx
  804160c726:	ee                   	out    %al,(%dx)
  804160c727:	b9 0a 00 00 00       	mov    $0xa,%ecx
  804160c72c:	89 c8                	mov    %ecx,%eax
  804160c72e:	ee                   	out    %al,(%dx)
  804160c72f:	44 89 c0             	mov    %r8d,%eax
  804160c732:	89 f2                	mov    %esi,%edx
  804160c734:	ee                   	out    %al,(%dx)
  804160c735:	89 c8                	mov    %ecx,%eax
  804160c737:	ee                   	out    %al,(%dx)

    /* OCW3 */
    outb(IO_PIC2_CMND, OCW3 | OCW3_SET);
    outb(IO_PIC2_CMND, OCW3 | OCW3_IRR);

    pic_initilalized = 1;
  804160c738:	48 b8 60 44 40 42 80 	movabs $0x8042404460,%rax
  804160c73f:	00 00 00 
  804160c742:	c6 00 01             	movb   $0x1,(%rax)

    if (irq_mask_8259A != 0xFFFF)
  804160c745:	48 b8 48 47 63 41 80 	movabs $0x8041634748,%rax
  804160c74c:	00 00 00 
  804160c74f:	66 8b 38             	mov    (%rax),%di
  804160c752:	66 83 ff ff          	cmp    $0xffff,%di
  804160c756:	75 11                	jne    804160c769 <pic_init+0xad>
        set_irq_mask(irq_mask_8259A);
    print_irq_mask(irq_mask_8259A);
  804160c758:	0f b7 ff             	movzwl %di,%edi
  804160c75b:	48 b8 2f c6 60 41 80 	movabs $0x804160c62f,%rax
  804160c762:	00 00 00 
  804160c765:	ff d0                	call   *%rax
}
  804160c767:	5d                   	pop    %rbp
  804160c768:	c3                   	ret    
  804160c769:	ba 21 00 00 00       	mov    $0x21,%edx
  804160c76e:	89 f8                	mov    %edi,%eax
  804160c770:	ee                   	out    %al,(%dx)
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
  804160c771:	89 f8                	mov    %edi,%eax
  804160c773:	66 c1 e8 08          	shr    $0x8,%ax
  804160c777:	ba a1 00 00 00       	mov    $0xa1,%edx
  804160c77c:	ee                   	out    %al,(%dx)
}
  804160c77d:	eb d9                	jmp    804160c758 <pic_init+0x9c>

000000804160c77f <pic_irq_mask>:

void
pic_irq_mask(uint8_t irq) {
    irq_mask_8259A |= (1 << irq);
  804160c77f:	b8 01 00 00 00       	mov    $0x1,%eax
  804160c784:	89 f9                	mov    %edi,%ecx
  804160c786:	d3 e0                	shl    %cl,%eax
  804160c788:	89 c7                	mov    %eax,%edi
  804160c78a:	48 b8 48 47 63 41 80 	movabs $0x8041634748,%rax
  804160c791:	00 00 00 
  804160c794:	66 0b 38             	or     (%rax),%di
  804160c797:	66 89 38             	mov    %di,(%rax)
    if (pic_initilalized) {
  804160c79a:	48 b8 60 44 40 42 80 	movabs $0x8042404460,%rax
  804160c7a1:	00 00 00 
  804160c7a4:	80 38 00             	cmpb   $0x0,(%rax)
  804160c7a7:	75 01                	jne    804160c7aa <pic_irq_mask+0x2b>
  804160c7a9:	c3                   	ret    
pic_irq_mask(uint8_t irq) {
  804160c7aa:	55                   	push   %rbp
  804160c7ab:	48 89 e5             	mov    %rsp,%rbp
  804160c7ae:	ba 21 00 00 00       	mov    $0x21,%edx
  804160c7b3:	89 f8                	mov    %edi,%eax
  804160c7b5:	ee                   	out    %al,(%dx)
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
  804160c7b6:	89 f8                	mov    %edi,%eax
  804160c7b8:	66 c1 e8 08          	shr    $0x8,%ax
  804160c7bc:	ba a1 00 00 00       	mov    $0xa1,%edx
  804160c7c1:	ee                   	out    %al,(%dx)
        set_irq_mask(irq_mask_8259A);
  804160c7c2:	0f b7 ff             	movzwl %di,%edi
        print_irq_mask(irq_mask_8259A);
  804160c7c5:	48 b8 2f c6 60 41 80 	movabs $0x804160c62f,%rax
  804160c7cc:	00 00 00 
  804160c7cf:	ff d0                	call   *%rax
    }
}
  804160c7d1:	5d                   	pop    %rbp
  804160c7d2:	c3                   	ret    

000000804160c7d3 <pic_irq_unmask>:

void
pic_irq_unmask(uint8_t irq) {
    irq_mask_8259A &= ~(1 << irq);
  804160c7d3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804160c7d8:	89 f9                	mov    %edi,%ecx
  804160c7da:	d3 c0                	rol    %cl,%eax
  804160c7dc:	89 c7                	mov    %eax,%edi
  804160c7de:	48 b8 48 47 63 41 80 	movabs $0x8041634748,%rax
  804160c7e5:	00 00 00 
  804160c7e8:	66 23 38             	and    (%rax),%di
  804160c7eb:	66 89 38             	mov    %di,(%rax)
    if (pic_initilalized) {
  804160c7ee:	48 b8 60 44 40 42 80 	movabs $0x8042404460,%rax
  804160c7f5:	00 00 00 
  804160c7f8:	80 38 00             	cmpb   $0x0,(%rax)
  804160c7fb:	75 01                	jne    804160c7fe <pic_irq_unmask+0x2b>
  804160c7fd:	c3                   	ret    
pic_irq_unmask(uint8_t irq) {
  804160c7fe:	55                   	push   %rbp
  804160c7ff:	48 89 e5             	mov    %rsp,%rbp
  804160c802:	ba 21 00 00 00       	mov    $0x21,%edx
  804160c807:	89 f8                	mov    %edi,%eax
  804160c809:	ee                   	out    %al,(%dx)
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
  804160c80a:	89 f8                	mov    %edi,%eax
  804160c80c:	66 c1 e8 08          	shr    $0x8,%ax
  804160c810:	ba a1 00 00 00       	mov    $0xa1,%edx
  804160c815:	ee                   	out    %al,(%dx)
        set_irq_mask(irq_mask_8259A);
  804160c816:	0f b7 ff             	movzwl %di,%edi
        print_irq_mask(irq_mask_8259A);
  804160c819:	48 b8 2f c6 60 41 80 	movabs $0x804160c62f,%rax
  804160c820:	00 00 00 
  804160c823:	ff d0                	call   *%rax
    }
}
  804160c825:	5d                   	pop    %rbp
  804160c826:	c3                   	ret    

000000804160c827 <pic_send_eoi>:

void
pic_send_eoi(uint8_t irq) {
    if (irq > 7) outb(IO_PIC2_CMND, PIC_EOI);
  804160c827:	40 80 ff 07          	cmp    $0x7,%dil
  804160c82b:	76 0b                	jbe    804160c838 <pic_send_eoi+0x11>
  804160c82d:	b8 20 00 00 00       	mov    $0x20,%eax
  804160c832:	ba a0 00 00 00       	mov    $0xa0,%edx
  804160c837:	ee                   	out    %al,(%dx)
  804160c838:	b8 20 00 00 00       	mov    $0x20,%eax
  804160c83d:	ba 20 00 00 00       	mov    $0x20,%edx
  804160c842:	ee                   	out    %al,(%dx)
    outb(IO_PIC1_CMND, PIC_EOI);
}
  804160c843:	c3                   	ret    

000000804160c844 <putch>:
#include <inc/types.h>
#include <inc/stdio.h>
#include <inc/stdarg.h>

static void
putch(int ch, int *cnt) {
  804160c844:	55                   	push   %rbp
  804160c845:	48 89 e5             	mov    %rsp,%rbp
  804160c848:	53                   	push   %rbx
  804160c849:	48 83 ec 08          	sub    $0x8,%rsp
  804160c84d:	48 89 f3             	mov    %rsi,%rbx
    cputchar(ch);
  804160c850:	48 b8 87 0c 60 41 80 	movabs $0x8041600c87,%rax
  804160c857:	00 00 00 
  804160c85a:	ff d0                	call   *%rax
    (*cnt)++;
  804160c85c:	83 03 01             	addl   $0x1,(%rbx)
}
  804160c85f:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804160c863:	c9                   	leave  
  804160c864:	c3                   	ret    

000000804160c865 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap) {
  804160c865:	55                   	push   %rbp
  804160c866:	48 89 e5             	mov    %rsp,%rbp
  804160c869:	48 83 ec 10          	sub    $0x10,%rsp
  804160c86d:	48 89 fa             	mov    %rdi,%rdx
  804160c870:	48 89 f1             	mov    %rsi,%rcx
    int count = 0;
  804160c873:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    vprintfmt((void *)putch, &count, fmt, ap);
  804160c87a:	48 8d 75 fc          	lea    -0x4(%rbp),%rsi
  804160c87e:	48 bf 44 c8 60 41 80 	movabs $0x804160c844,%rdi
  804160c885:	00 00 00 
  804160c888:	48 b8 27 f3 60 41 80 	movabs $0x804160f327,%rax
  804160c88f:	00 00 00 
  804160c892:	ff d0                	call   *%rax

    return count;
}
  804160c894:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804160c897:	c9                   	leave  
  804160c898:	c3                   	ret    

000000804160c899 <cprintf>:

int
cprintf(const char *fmt, ...) {
  804160c899:	55                   	push   %rbp
  804160c89a:	48 89 e5             	mov    %rsp,%rbp
  804160c89d:	48 83 ec 50          	sub    $0x50,%rsp
  804160c8a1:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  804160c8a5:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  804160c8a9:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  804160c8ad:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  804160c8b1:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_list ap;
    va_start(ap, fmt);
  804160c8b5:	c7 45 b8 08 00 00 00 	movl   $0x8,-0x48(%rbp)
  804160c8bc:	48 8d 45 10          	lea    0x10(%rbp),%rax
  804160c8c0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160c8c4:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  804160c8c8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int res = vcprintf(fmt, ap);
  804160c8cc:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
  804160c8d0:	48 b8 65 c8 60 41 80 	movabs $0x804160c865,%rax
  804160c8d7:	00 00 00 
  804160c8da:	ff d0                	call   *%rax
    va_end(ap);

    return res;
}
  804160c8dc:	c9                   	leave  
  804160c8dd:	c3                   	ret    

000000804160c8de <trap_init_percpu>:
    asm volatile("lgdt (%0)" ::"r"(p));
  804160c8de:	48 b8 60 47 63 41 80 	movabs $0x8041634760,%rax
  804160c8e5:	00 00 00 
  804160c8e8:	0f 01 10             	lgdt   (%rax)
    /* The kernel never uses GS or FS,
     * so we leave those set to the user data segment
     *
     * For good measure, clear the local descriptor table (LDT),
     * since we don't use it */
    asm volatile(
  804160c8eb:	b8 10 00 00 00       	mov    $0x10,%eax
  804160c8f0:	ba 33 00 00 00       	mov    $0x33,%edx
  804160c8f5:	b9 08 00 00 00       	mov    $0x8,%ecx
  804160c8fa:	8e ea                	mov    %edx,%gs
  804160c8fc:	8e e2                	mov    %edx,%fs
  804160c8fe:	8e c0                	mov    %eax,%es
  804160c900:	8e d8                	mov    %eax,%ds
  804160c902:	8e d0                	mov    %eax,%ss
  804160c904:	31 c0                	xor    %eax,%eax
  804160c906:	0f 00 d0             	lldt   %ax
  804160c909:	51                   	push   %rcx
  804160c90a:	48 b8 17 c9 60 41 80 	movabs $0x804160c917,%rax
  804160c911:	00 00 00 
  804160c914:	50                   	push   %rax
  804160c915:	48 cb                	lretq  
            "d"(GD_UD | 3), "c"(GD_KT)
            : "cc", "memory");

    /* Setup a TSS so that we get the right stack
     * when we trap to the kernel. */
    ts.ts_rsp0 = KERN_STACK_TOP;
  804160c917:	49 b8 c0 54 40 42 80 	movabs $0x80424054c0,%r8
  804160c91e:	00 00 00 
  804160c921:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804160c928:	00 00 00 
  804160c92b:	49 89 40 04          	mov    %rax,0x4(%r8)
    ts.ts_ist1 = KERN_PF_STACK_TOP;
  804160c92f:	48 8d 80 00 80 fe ff 	lea    -0x18000(%rax),%rax
  804160c936:	49 89 40 24          	mov    %rax,0x24(%r8)

    /* Initialize the TSS slot of the gdt. */
    *(volatile struct Segdesc64 *)(&gdt[(GD_TSS0 >> 3)]) = SEG64_TSS(STS_T64A, ((uint64_t)&ts), sizeof(struct Taskstate), 0);
  804160c93a:	be 00 00 00 00       	mov    $0x0,%esi
  804160c93f:	bf 00 00 00 00       	mov    $0x0,%edi
  804160c944:	48 89 f1             	mov    %rsi,%rcx
  804160c947:	66 b9 00 00          	mov    $0x0,%cx
  804160c94b:	48 83 c9 68          	or     $0x68,%rcx
  804160c94f:	41 0f b7 d0          	movzwl %r8w,%edx
  804160c953:	48 c1 e2 10          	shl    $0x10,%rdx
  804160c957:	48 b8 ff ff 00 00 ff 	movabs $0xffffffff0000ffff,%rax
  804160c95e:	ff ff ff 
  804160c961:	48 21 c1             	and    %rax,%rcx
  804160c964:	48 09 ca             	or     %rcx,%rdx
  804160c967:	4c 89 c0             	mov    %r8,%rax
  804160c96a:	48 c1 e8 10          	shr    $0x10,%rax
  804160c96e:	0f b6 c0             	movzbl %al,%eax
  804160c971:	48 c1 e0 20          	shl    $0x20,%rax
  804160c975:	49 89 c1             	mov    %rax,%r9
  804160c978:	48 b9 ff ff ff ff 00 	movabs $0xffffff00ffffffff,%rcx
  804160c97f:	ff ff ff 
  804160c982:	48 89 d0             	mov    %rdx,%rax
  804160c985:	48 21 c8             	and    %rcx,%rax
  804160c988:	4c 09 c8             	or     %r9,%rax
  804160c98b:	48 ba ff ff ff ff ff 	movabs $0xfffff0ffffffffff,%rdx
  804160c992:	f0 ff ff 
  804160c995:	48 21 d0             	and    %rdx,%rax
  804160c998:	48 ba 00 00 00 00 00 	movabs $0x90000000000,%rdx
  804160c99f:	09 00 00 
  804160c9a2:	48 09 d0             	or     %rdx,%rax
  804160c9a5:	48 0f ba f0 2c       	btr    $0x2c,%rax
  804160c9aa:	48 ba ff ff ff ff ff 	movabs $0xffff9fffffffffff,%rdx
  804160c9b1:	9f ff ff 
  804160c9b4:	48 21 d0             	and    %rdx,%rax
  804160c9b7:	48 0f ba e8 2f       	bts    $0x2f,%rax
  804160c9bc:	48 ba ff ff ff ff ff 	movabs $0xfff0ffffffffffff,%rdx
  804160c9c3:	ff f0 ff 
  804160c9c6:	48 21 d0             	and    %rdx,%rax
  804160c9c9:	48 0f ba f0 34       	btr    $0x34,%rax
  804160c9ce:	48 ba ff ff ff ff ff 	movabs $0xff9fffffffffffff,%rdx
  804160c9d5:	ff 9f ff 
  804160c9d8:	48 21 d0             	and    %rdx,%rax
  804160c9db:	48 0f ba f0 37       	btr    $0x37,%rax
  804160c9e0:	4c 89 c2             	mov    %r8,%rdx
  804160c9e3:	48 c1 ea 18          	shr    $0x18,%rdx
  804160c9e7:	48 c1 e2 38          	shl    $0x38,%rdx
  804160c9eb:	49 b9 ff ff ff ff ff 	movabs $0xffffffffffffff,%r9
  804160c9f2:	ff ff 00 
  804160c9f5:	4c 21 c8             	and    %r9,%rax
  804160c9f8:	48 09 d0             	or     %rdx,%rax
  804160c9fb:	48 89 c6             	mov    %rax,%rsi
  804160c9fe:	4c 89 c0             	mov    %r8,%rax
  804160ca01:	48 c1 e8 20          	shr    $0x20,%rax
  804160ca05:	49 89 f8             	mov    %rdi,%r8
  804160ca08:	48 ba 00 00 00 00 ff 	movabs $0xffffffff00000000,%rdx
  804160ca0f:	ff ff ff 
  804160ca12:	49 21 d0             	and    %rdx,%r8
  804160ca15:	49 09 c0             	or     %rax,%r8
  804160ca18:	4c 21 c1             	and    %r8,%rcx
  804160ca1b:	49 b8 ff ff ff ff ff 	movabs $0xffff00ffffffffff,%r8
  804160ca22:	00 ff ff 
  804160ca25:	4c 21 c1             	and    %r8,%rcx
  804160ca28:	89 cf                	mov    %ecx,%edi
  804160ca2a:	48 b8 80 47 63 41 80 	movabs $0x8041634780,%rax
  804160ca31:	00 00 00 
  804160ca34:	48 89 70 38          	mov    %rsi,0x38(%rax)
  804160ca38:	48 89 78 40          	mov    %rdi,0x40(%rax)
    asm volatile("ltr %0" ::"r"(sel));
  804160ca3c:	b8 38 00 00 00       	mov    $0x38,%eax
  804160ca41:	0f 00 d8             	ltr    %ax
    asm volatile("lidt (%0)" ::"r"(p));
  804160ca44:	48 b8 c8 47 63 41 80 	movabs $0x80416347c8,%rax
  804160ca4b:	00 00 00 
  804160ca4e:	0f 01 18             	lidt   (%rax)
     * bottom three bits are special; we leave them 0) */
    ltr(GD_TSS0);

    /* Load the IDT */
    lidt(&idt_pd);
}
  804160ca51:	c3                   	ret    

000000804160ca52 <trap_init>:
trap_init(void) {
  804160ca52:	55                   	push   %rbp
  804160ca53:	48 89 e5             	mov    %rsp,%rbp
   idt[IRQ_OFFSET + IRQ_CLOCK] = GATE(0, GD_KT, (uintptr_t)(&clock_thdlr), 0);
  804160ca56:	48 b8 a0 44 40 42 80 	movabs $0x80424044a0,%rax
  804160ca5d:	00 00 00 
  804160ca60:	48 ba 02 da 60 41 80 	movabs $0x804160da02,%rdx
  804160ca67:	00 00 00 
  804160ca6a:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  804160ca71:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  804160ca78:	08 00 
  804160ca7a:	c6 80 84 02 00 00 00 	movb   $0x0,0x284(%rax)
  804160ca81:	c6 80 85 02 00 00 8e 	movb   $0x8e,0x285(%rax)
  804160ca88:	48 89 d1             	mov    %rdx,%rcx
  804160ca8b:	48 c1 e9 10          	shr    $0x10,%rcx
  804160ca8f:	66 89 88 86 02 00 00 	mov    %cx,0x286(%rax)
  804160ca96:	48 c1 ea 20          	shr    $0x20,%rdx
  804160ca9a:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  804160caa0:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  804160caa7:	00 00 00 
   idt[IRQ_OFFSET + IRQ_TIMER] = GATE(0, GD_KT, (uintptr_t)(&timer_thdlr), 0);
  804160caaa:	48 ba 08 da 60 41 80 	movabs $0x804160da08,%rdx
  804160cab1:	00 00 00 
  804160cab4:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  804160cabb:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  804160cac2:	08 00 
  804160cac4:	c6 80 04 02 00 00 00 	movb   $0x0,0x204(%rax)
  804160cacb:	c6 80 05 02 00 00 8e 	movb   $0x8e,0x205(%rax)
  804160cad2:	48 89 d1             	mov    %rdx,%rcx
  804160cad5:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cad9:	66 89 88 06 02 00 00 	mov    %cx,0x206(%rax)
  804160cae0:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cae4:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  804160caea:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  804160caf1:	00 00 00 
   idt[T_DIVIDE] = GATE(0, GD_KT, (uintptr_t)(&divide_thdlr), 0);
  804160caf4:	48 ba 1e da 60 41 80 	movabs $0x804160da1e,%rdx
  804160cafb:	00 00 00 
  804160cafe:	66 89 10             	mov    %dx,(%rax)
  804160cb01:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  804160cb07:	c6 40 04 00          	movb   $0x0,0x4(%rax)
  804160cb0b:	c6 40 05 8e          	movb   $0x8e,0x5(%rax)
  804160cb0f:	48 89 d1             	mov    %rdx,%rcx
  804160cb12:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cb16:	66 89 48 06          	mov    %cx,0x6(%rax)
  804160cb1a:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cb1e:	89 50 08             	mov    %edx,0x8(%rax)
  804160cb21:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
   idt[T_DEBUG] = GATE(0, GD_KT, (uintptr_t)(&debug_thdlr), 0);
  804160cb28:	48 ba 28 da 60 41 80 	movabs $0x804160da28,%rdx
  804160cb2f:	00 00 00 
  804160cb32:	66 89 50 10          	mov    %dx,0x10(%rax)
  804160cb36:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  804160cb3c:	c6 40 14 00          	movb   $0x0,0x14(%rax)
  804160cb40:	c6 40 15 8e          	movb   $0x8e,0x15(%rax)
  804160cb44:	48 89 d1             	mov    %rdx,%rcx
  804160cb47:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cb4b:	66 89 48 16          	mov    %cx,0x16(%rax)
  804160cb4f:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cb53:	89 50 18             	mov    %edx,0x18(%rax)
  804160cb56:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
   idt[T_NMI] = GATE(0, GD_KT, (uintptr_t)(&nmi_thdlr), 0);
  804160cb5d:	48 ba 32 da 60 41 80 	movabs $0x804160da32,%rdx
  804160cb64:	00 00 00 
  804160cb67:	66 89 50 20          	mov    %dx,0x20(%rax)
  804160cb6b:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  804160cb71:	c6 40 24 00          	movb   $0x0,0x24(%rax)
  804160cb75:	c6 40 25 8e          	movb   $0x8e,0x25(%rax)
  804160cb79:	48 89 d1             	mov    %rdx,%rcx
  804160cb7c:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cb80:	66 89 48 26          	mov    %cx,0x26(%rax)
  804160cb84:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cb88:	89 50 28             	mov    %edx,0x28(%rax)
  804160cb8b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
   idt[T_BRKPT] = GATE(0, GD_KT, (uintptr_t)(&brkpt_thdlr), 3);
  804160cb92:	48 ba 3c da 60 41 80 	movabs $0x804160da3c,%rdx
  804160cb99:	00 00 00 
  804160cb9c:	66 89 50 30          	mov    %dx,0x30(%rax)
  804160cba0:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  804160cba6:	c6 40 34 00          	movb   $0x0,0x34(%rax)
  804160cbaa:	c6 40 35 ee          	movb   $0xee,0x35(%rax)
  804160cbae:	48 89 d1             	mov    %rdx,%rcx
  804160cbb1:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cbb5:	66 89 48 36          	mov    %cx,0x36(%rax)
  804160cbb9:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cbbd:	89 50 38             	mov    %edx,0x38(%rax)
  804160cbc0:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
   idt[T_OFLOW] = GATE(0, GD_KT, (uintptr_t)(&oflow_thdlr), 0);
  804160cbc7:	48 ba 46 da 60 41 80 	movabs $0x804160da46,%rdx
  804160cbce:	00 00 00 
  804160cbd1:	66 89 50 40          	mov    %dx,0x40(%rax)
  804160cbd5:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  804160cbdb:	c6 40 44 00          	movb   $0x0,0x44(%rax)
  804160cbdf:	c6 40 45 8e          	movb   $0x8e,0x45(%rax)
  804160cbe3:	48 89 d1             	mov    %rdx,%rcx
  804160cbe6:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cbea:	66 89 48 46          	mov    %cx,0x46(%rax)
  804160cbee:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cbf2:	89 50 48             	mov    %edx,0x48(%rax)
  804160cbf5:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
   idt[T_BOUND] = GATE(0, GD_KT, (uintptr_t)(&bound_thdlr), 0);
  804160cbfc:	48 ba 50 da 60 41 80 	movabs $0x804160da50,%rdx
  804160cc03:	00 00 00 
  804160cc06:	66 89 50 50          	mov    %dx,0x50(%rax)
  804160cc0a:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  804160cc10:	c6 40 54 00          	movb   $0x0,0x54(%rax)
  804160cc14:	c6 40 55 8e          	movb   $0x8e,0x55(%rax)
  804160cc18:	48 89 d1             	mov    %rdx,%rcx
  804160cc1b:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cc1f:	66 89 48 56          	mov    %cx,0x56(%rax)
  804160cc23:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cc27:	89 50 58             	mov    %edx,0x58(%rax)
  804160cc2a:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
   idt[T_ILLOP] = GATE(0, GD_KT, (uintptr_t)(&illop_thdlr), 0);
  804160cc31:	48 ba 5a da 60 41 80 	movabs $0x804160da5a,%rdx
  804160cc38:	00 00 00 
  804160cc3b:	66 89 50 60          	mov    %dx,0x60(%rax)
  804160cc3f:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  804160cc45:	c6 40 64 00          	movb   $0x0,0x64(%rax)
  804160cc49:	c6 40 65 8e          	movb   $0x8e,0x65(%rax)
  804160cc4d:	48 89 d1             	mov    %rdx,%rcx
  804160cc50:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cc54:	66 89 48 66          	mov    %cx,0x66(%rax)
  804160cc58:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cc5c:	89 50 68             	mov    %edx,0x68(%rax)
  804160cc5f:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
   idt[T_DEVICE] = GATE(0, GD_KT, (uintptr_t)(&device_thdlr), 0);
  804160cc66:	48 ba 64 da 60 41 80 	movabs $0x804160da64,%rdx
  804160cc6d:	00 00 00 
  804160cc70:	66 89 50 70          	mov    %dx,0x70(%rax)
  804160cc74:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  804160cc7a:	c6 40 74 00          	movb   $0x0,0x74(%rax)
  804160cc7e:	c6 40 75 8e          	movb   $0x8e,0x75(%rax)
  804160cc82:	48 89 d1             	mov    %rdx,%rcx
  804160cc85:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cc89:	66 89 48 76          	mov    %cx,0x76(%rax)
  804160cc8d:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cc91:	89 50 78             	mov    %edx,0x78(%rax)
  804160cc94:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
   idt[T_DBLFLT] = GATE(0, GD_KT, (uintptr_t)(&dblflt_thdlr), 0);
  804160cc9b:	48 ba 6e da 60 41 80 	movabs $0x804160da6e,%rdx
  804160cca2:	00 00 00 
  804160cca5:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  804160ccac:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  804160ccb3:	08 00 
  804160ccb5:	c6 80 84 00 00 00 00 	movb   $0x0,0x84(%rax)
  804160ccbc:	c6 80 85 00 00 00 8e 	movb   $0x8e,0x85(%rax)
  804160ccc3:	48 89 d1             	mov    %rdx,%rcx
  804160ccc6:	48 c1 e9 10          	shr    $0x10,%rcx
  804160ccca:	66 89 88 86 00 00 00 	mov    %cx,0x86(%rax)
  804160ccd1:	48 c1 ea 20          	shr    $0x20,%rdx
  804160ccd5:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  804160ccdb:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  804160cce2:	00 00 00 
   idt[T_TSS] = GATE(0, GD_KT, (uintptr_t)(&tss_thdlr), 0);
  804160cce5:	48 ba 76 da 60 41 80 	movabs $0x804160da76,%rdx
  804160ccec:	00 00 00 
  804160ccef:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  804160ccf6:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  804160ccfd:	08 00 
  804160ccff:	c6 80 a4 00 00 00 00 	movb   $0x0,0xa4(%rax)
  804160cd06:	c6 80 a5 00 00 00 8e 	movb   $0x8e,0xa5(%rax)
  804160cd0d:	48 89 d1             	mov    %rdx,%rcx
  804160cd10:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cd14:	66 89 88 a6 00 00 00 	mov    %cx,0xa6(%rax)
  804160cd1b:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cd1f:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  804160cd25:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  804160cd2c:	00 00 00 
   idt[T_SEGNP] = GATE(0, GD_KT, (uintptr_t)(&segnp_thdlr), 0);
  804160cd2f:	48 ba 7e da 60 41 80 	movabs $0x804160da7e,%rdx
  804160cd36:	00 00 00 
  804160cd39:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  804160cd40:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  804160cd47:	08 00 
  804160cd49:	c6 80 b4 00 00 00 00 	movb   $0x0,0xb4(%rax)
  804160cd50:	c6 80 b5 00 00 00 8e 	movb   $0x8e,0xb5(%rax)
  804160cd57:	48 89 d1             	mov    %rdx,%rcx
  804160cd5a:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cd5e:	66 89 88 b6 00 00 00 	mov    %cx,0xb6(%rax)
  804160cd65:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cd69:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  804160cd6f:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  804160cd76:	00 00 00 
   idt[T_STACK] = GATE(0, GD_KT, (uintptr_t)(&stack_thdlr), 0);
  804160cd79:	48 ba 86 da 60 41 80 	movabs $0x804160da86,%rdx
  804160cd80:	00 00 00 
  804160cd83:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  804160cd8a:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  804160cd91:	08 00 
  804160cd93:	c6 80 c4 00 00 00 00 	movb   $0x0,0xc4(%rax)
  804160cd9a:	c6 80 c5 00 00 00 8e 	movb   $0x8e,0xc5(%rax)
  804160cda1:	48 89 d1             	mov    %rdx,%rcx
  804160cda4:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cda8:	66 89 88 c6 00 00 00 	mov    %cx,0xc6(%rax)
  804160cdaf:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cdb3:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  804160cdb9:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  804160cdc0:	00 00 00 
   idt[T_GPFLT] = GATE(0, GD_KT, (uintptr_t)(&gpflt_thdlr), 0);
  804160cdc3:	48 ba 8e da 60 41 80 	movabs $0x804160da8e,%rdx
  804160cdca:	00 00 00 
  804160cdcd:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  804160cdd4:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  804160cddb:	08 00 
  804160cddd:	c6 80 d4 00 00 00 00 	movb   $0x0,0xd4(%rax)
  804160cde4:	c6 80 d5 00 00 00 8e 	movb   $0x8e,0xd5(%rax)
  804160cdeb:	48 89 d1             	mov    %rdx,%rcx
  804160cdee:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cdf2:	66 89 88 d6 00 00 00 	mov    %cx,0xd6(%rax)
  804160cdf9:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cdfd:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  804160ce03:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  804160ce0a:	00 00 00 
   idt[T_PGFLT] = GATE(0, GD_KT, (uintptr_t)(&pgflt_thdlr), 0);
  804160ce0d:	48 ba 96 da 60 41 80 	movabs $0x804160da96,%rdx
  804160ce14:	00 00 00 
  804160ce17:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  804160ce1e:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  804160ce25:	08 00 
  804160ce27:	c6 80 e5 00 00 00 8e 	movb   $0x8e,0xe5(%rax)
  804160ce2e:	48 89 d1             	mov    %rdx,%rcx
  804160ce31:	48 c1 e9 10          	shr    $0x10,%rcx
  804160ce35:	66 89 88 e6 00 00 00 	mov    %cx,0xe6(%rax)
  804160ce3c:	48 c1 ea 20          	shr    $0x20,%rdx
  804160ce40:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  804160ce46:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  804160ce4d:	00 00 00 
   idt[T_FPERR] = GATE(0, GD_KT, (uintptr_t)(&fperr_thdlr), 0);
  804160ce50:	48 ba 9e da 60 41 80 	movabs $0x804160da9e,%rdx
  804160ce57:	00 00 00 
  804160ce5a:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  804160ce61:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  804160ce68:	08 00 
  804160ce6a:	c6 80 04 01 00 00 00 	movb   $0x0,0x104(%rax)
  804160ce71:	c6 80 05 01 00 00 8e 	movb   $0x8e,0x105(%rax)
  804160ce78:	48 89 d1             	mov    %rdx,%rcx
  804160ce7b:	48 c1 e9 10          	shr    $0x10,%rcx
  804160ce7f:	66 89 88 06 01 00 00 	mov    %cx,0x106(%rax)
  804160ce86:	48 c1 ea 20          	shr    $0x20,%rdx
  804160ce8a:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  804160ce90:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  804160ce97:	00 00 00 
   idt[T_ALIGN] = GATE(0, GD_KT, (uintptr_t)(&align_thdlr), 0);
  804160ce9a:	48 ba a8 da 60 41 80 	movabs $0x804160daa8,%rdx
  804160cea1:	00 00 00 
  804160cea4:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  804160ceab:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  804160ceb2:	08 00 
  804160ceb4:	c6 80 14 01 00 00 00 	movb   $0x0,0x114(%rax)
  804160cebb:	c6 80 15 01 00 00 8e 	movb   $0x8e,0x115(%rax)
  804160cec2:	48 89 d1             	mov    %rdx,%rcx
  804160cec5:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cec9:	66 89 88 16 01 00 00 	mov    %cx,0x116(%rax)
  804160ced0:	48 c1 ea 20          	shr    $0x20,%rdx
  804160ced4:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  804160ceda:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  804160cee1:	00 00 00 
   idt[T_MCHK] = GATE(0, GD_KT, (uintptr_t)(&mchk_thdlr), 0);
  804160cee4:	48 ba b0 da 60 41 80 	movabs $0x804160dab0,%rdx
  804160ceeb:	00 00 00 
  804160ceee:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  804160cef5:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  804160cefc:	08 00 
  804160cefe:	c6 80 24 01 00 00 00 	movb   $0x0,0x124(%rax)
  804160cf05:	c6 80 25 01 00 00 8e 	movb   $0x8e,0x125(%rax)
  804160cf0c:	48 89 d1             	mov    %rdx,%rcx
  804160cf0f:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cf13:	66 89 88 26 01 00 00 	mov    %cx,0x126(%rax)
  804160cf1a:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cf1e:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  804160cf24:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  804160cf2b:	00 00 00 
   idt[T_SIMDERR] = GATE(0, GD_KT, (uintptr_t)(&simderr_thdlr), 0); 
  804160cf2e:	48 ba ba da 60 41 80 	movabs $0x804160daba,%rdx
  804160cf35:	00 00 00 
  804160cf38:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  804160cf3f:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  804160cf46:	08 00 
  804160cf48:	c6 80 34 01 00 00 00 	movb   $0x0,0x134(%rax)
  804160cf4f:	c6 80 35 01 00 00 8e 	movb   $0x8e,0x135(%rax)
  804160cf56:	48 89 d1             	mov    %rdx,%rcx
  804160cf59:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cf5d:	66 89 88 36 01 00 00 	mov    %cx,0x136(%rax)
  804160cf64:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cf68:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  804160cf6e:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  804160cf75:	00 00 00 
   idt[T_SYSCALL] = GATE(0, GD_KT, (uintptr_t)(&syscall_thdlr), 3); 
  804160cf78:	48 ba c4 da 60 41 80 	movabs $0x804160dac4,%rdx
  804160cf7f:	00 00 00 
  804160cf82:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  804160cf89:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  804160cf90:	08 00 
  804160cf92:	c6 80 04 03 00 00 00 	movb   $0x0,0x304(%rax)
  804160cf99:	c6 80 05 03 00 00 ee 	movb   $0xee,0x305(%rax)
  804160cfa0:	48 89 d1             	mov    %rdx,%rcx
  804160cfa3:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cfa7:	66 89 88 06 03 00 00 	mov    %cx,0x306(%rax)
  804160cfae:	48 c1 ea 20          	shr    $0x20,%rdx
  804160cfb2:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  804160cfb8:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  804160cfbf:	00 00 00 
    idt[T_PGFLT].gd_ist = 1;
  804160cfc2:	c6 80 e4 00 00 00 01 	movb   $0x1,0xe4(%rax)
   idt[IRQ_OFFSET + IRQ_KBD] = GATE(0, GD_KT, (uintptr_t)(&kbd_thdlr), 0);
  804160cfc9:	48 ba 0e da 60 41 80 	movabs $0x804160da0e,%rdx
  804160cfd0:	00 00 00 
  804160cfd3:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  804160cfda:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  804160cfe1:	08 00 
  804160cfe3:	c6 80 14 02 00 00 00 	movb   $0x0,0x214(%rax)
  804160cfea:	c6 80 15 02 00 00 8e 	movb   $0x8e,0x215(%rax)
  804160cff1:	48 89 d1             	mov    %rdx,%rcx
  804160cff4:	48 c1 e9 10          	shr    $0x10,%rcx
  804160cff8:	66 89 88 16 02 00 00 	mov    %cx,0x216(%rax)
  804160cfff:	48 c1 ea 20          	shr    $0x20,%rdx
  804160d003:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  804160d009:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  804160d010:	00 00 00 
   idt[IRQ_OFFSET + IRQ_SERIAL] = GATE(0, GD_KT, (uintptr_t)(&serial_thdlr), 0);
  804160d013:	48 ba 14 da 60 41 80 	movabs $0x804160da14,%rdx
  804160d01a:	00 00 00 
  804160d01d:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  804160d024:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  804160d02b:	08 00 
  804160d02d:	c6 80 44 02 00 00 00 	movb   $0x0,0x244(%rax)
  804160d034:	c6 80 45 02 00 00 8e 	movb   $0x8e,0x245(%rax)
  804160d03b:	48 89 d1             	mov    %rdx,%rcx
  804160d03e:	48 c1 e9 10          	shr    $0x10,%rcx
  804160d042:	66 89 88 46 02 00 00 	mov    %cx,0x246(%rax)
  804160d049:	48 c1 ea 20          	shr    $0x20,%rdx
  804160d04d:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  804160d053:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  804160d05a:	00 00 00 
    trap_init_percpu();
  804160d05d:	48 b8 de c8 60 41 80 	movabs $0x804160c8de,%rax
  804160d064:	00 00 00 
  804160d067:	ff d0                	call   *%rax
}
  804160d069:	5d                   	pop    %rbp
  804160d06a:	c3                   	ret    

000000804160d06b <print_regs>:
    cprintf("  rsp  0x%08lx\n", (unsigned long)tf->tf_rsp);
    cprintf("  ss   0x----%04x\n", tf->tf_ss);
}

void
print_regs(struct PushRegs *regs) {
  804160d06b:	55                   	push   %rbp
  804160d06c:	48 89 e5             	mov    %rsp,%rbp
  804160d06f:	41 54                	push   %r12
  804160d071:	53                   	push   %rbx
  804160d072:	48 89 fb             	mov    %rdi,%rbx
    cprintf("  r15  0x%08lx\n", (unsigned long)regs->reg_r15);
  804160d075:	48 8b 37             	mov    (%rdi),%rsi
  804160d078:	48 bf a8 2b 61 41 80 	movabs $0x8041612ba8,%rdi
  804160d07f:	00 00 00 
  804160d082:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d087:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  804160d08e:	00 00 00 
  804160d091:	41 ff d4             	call   *%r12
    cprintf("  r14  0x%08lx\n", (unsigned long)regs->reg_r14);
  804160d094:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  804160d098:	48 bf b8 2b 61 41 80 	movabs $0x8041612bb8,%rdi
  804160d09f:	00 00 00 
  804160d0a2:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d0a7:	41 ff d4             	call   *%r12
    cprintf("  r13  0x%08lx\n", (unsigned long)regs->reg_r13);
  804160d0aa:	48 8b 73 10          	mov    0x10(%rbx),%rsi
  804160d0ae:	48 bf c8 2b 61 41 80 	movabs $0x8041612bc8,%rdi
  804160d0b5:	00 00 00 
  804160d0b8:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d0bd:	41 ff d4             	call   *%r12
    cprintf("  r12  0x%08lx\n", (unsigned long)regs->reg_r12);
  804160d0c0:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  804160d0c4:	48 bf d8 2b 61 41 80 	movabs $0x8041612bd8,%rdi
  804160d0cb:	00 00 00 
  804160d0ce:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d0d3:	41 ff d4             	call   *%r12
    cprintf("  r11  0x%08lx\n", (unsigned long)regs->reg_r11);
  804160d0d6:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  804160d0da:	48 bf e8 2b 61 41 80 	movabs $0x8041612be8,%rdi
  804160d0e1:	00 00 00 
  804160d0e4:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d0e9:	41 ff d4             	call   *%r12
    cprintf("  r10  0x%08lx\n", (unsigned long)regs->reg_r10);
  804160d0ec:	48 8b 73 28          	mov    0x28(%rbx),%rsi
  804160d0f0:	48 bf f8 2b 61 41 80 	movabs $0x8041612bf8,%rdi
  804160d0f7:	00 00 00 
  804160d0fa:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d0ff:	41 ff d4             	call   *%r12
    cprintf("  r9   0x%08lx\n", (unsigned long)regs->reg_r9);
  804160d102:	48 8b 73 30          	mov    0x30(%rbx),%rsi
  804160d106:	48 bf 08 2c 61 41 80 	movabs $0x8041612c08,%rdi
  804160d10d:	00 00 00 
  804160d110:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d115:	41 ff d4             	call   *%r12
    cprintf("  r8   0x%08lx\n", (unsigned long)regs->reg_r8);
  804160d118:	48 8b 73 38          	mov    0x38(%rbx),%rsi
  804160d11c:	48 bf 18 2c 61 41 80 	movabs $0x8041612c18,%rdi
  804160d123:	00 00 00 
  804160d126:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d12b:	41 ff d4             	call   *%r12
    cprintf("  rdi  0x%08lx\n", (unsigned long)regs->reg_rdi);
  804160d12e:	48 8b 73 48          	mov    0x48(%rbx),%rsi
  804160d132:	48 bf 28 2c 61 41 80 	movabs $0x8041612c28,%rdi
  804160d139:	00 00 00 
  804160d13c:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d141:	41 ff d4             	call   *%r12
    cprintf("  rsi  0x%08lx\n", (unsigned long)regs->reg_rsi);
  804160d144:	48 8b 73 40          	mov    0x40(%rbx),%rsi
  804160d148:	48 bf 38 2c 61 41 80 	movabs $0x8041612c38,%rdi
  804160d14f:	00 00 00 
  804160d152:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d157:	41 ff d4             	call   *%r12
    cprintf("  rbp  0x%08lx\n", (unsigned long)regs->reg_rbp);
  804160d15a:	48 8b 73 50          	mov    0x50(%rbx),%rsi
  804160d15e:	48 bf 48 2c 61 41 80 	movabs $0x8041612c48,%rdi
  804160d165:	00 00 00 
  804160d168:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d16d:	41 ff d4             	call   *%r12
    cprintf("  rbx  0x%08lx\n", (unsigned long)regs->reg_rbx);
  804160d170:	48 8b 73 68          	mov    0x68(%rbx),%rsi
  804160d174:	48 bf 58 2c 61 41 80 	movabs $0x8041612c58,%rdi
  804160d17b:	00 00 00 
  804160d17e:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d183:	41 ff d4             	call   *%r12
    cprintf("  rdx  0x%08lx\n", (unsigned long)regs->reg_rdx);
  804160d186:	48 8b 73 58          	mov    0x58(%rbx),%rsi
  804160d18a:	48 bf 68 2c 61 41 80 	movabs $0x8041612c68,%rdi
  804160d191:	00 00 00 
  804160d194:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d199:	41 ff d4             	call   *%r12
    cprintf("  rcx  0x%08lx\n", (unsigned long)regs->reg_rcx);
  804160d19c:	48 8b 73 60          	mov    0x60(%rbx),%rsi
  804160d1a0:	48 bf 78 2c 61 41 80 	movabs $0x8041612c78,%rdi
  804160d1a7:	00 00 00 
  804160d1aa:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d1af:	41 ff d4             	call   *%r12
    cprintf("  rax  0x%08lx\n", (unsigned long)regs->reg_rax);
  804160d1b2:	48 8b 73 70          	mov    0x70(%rbx),%rsi
  804160d1b6:	48 bf 88 2c 61 41 80 	movabs $0x8041612c88,%rdi
  804160d1bd:	00 00 00 
  804160d1c0:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d1c5:	41 ff d4             	call   *%r12
}
  804160d1c8:	5b                   	pop    %rbx
  804160d1c9:	41 5c                	pop    %r12
  804160d1cb:	5d                   	pop    %rbp
  804160d1cc:	c3                   	ret    

000000804160d1cd <print_trapframe>:
print_trapframe(struct Trapframe *tf) {
  804160d1cd:	55                   	push   %rbp
  804160d1ce:	48 89 e5             	mov    %rsp,%rbp
  804160d1d1:	41 54                	push   %r12
  804160d1d3:	53                   	push   %rbx
  804160d1d4:	48 89 fb             	mov    %rdi,%rbx
    cprintf("TRAP frame at %p\n", tf);
  804160d1d7:	48 89 fe             	mov    %rdi,%rsi
  804160d1da:	48 bf f5 2c 61 41 80 	movabs $0x8041612cf5,%rdi
  804160d1e1:	00 00 00 
  804160d1e4:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d1e9:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  804160d1f0:	00 00 00 
  804160d1f3:	41 ff d4             	call   *%r12
    print_regs(&tf->tf_regs);
  804160d1f6:	48 89 df             	mov    %rbx,%rdi
  804160d1f9:	48 b8 6b d0 60 41 80 	movabs $0x804160d06b,%rax
  804160d200:	00 00 00 
  804160d203:	ff d0                	call   *%rax
    cprintf("  es   0x----%04x\n", tf->tf_es);
  804160d205:	0f b7 73 78          	movzwl 0x78(%rbx),%esi
  804160d209:	48 bf 07 2d 61 41 80 	movabs $0x8041612d07,%rdi
  804160d210:	00 00 00 
  804160d213:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d218:	41 ff d4             	call   *%r12
    cprintf("  ds   0x----%04x\n", tf->tf_ds);
  804160d21b:	0f b7 b3 80 00 00 00 	movzwl 0x80(%rbx),%esi
  804160d222:	48 bf 1a 2d 61 41 80 	movabs $0x8041612d1a,%rdi
  804160d229:	00 00 00 
  804160d22c:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d231:	41 ff d4             	call   *%r12
    cprintf("  trap 0x%08lx %s\n", (unsigned long)tf->tf_trapno, trapname(tf->tf_trapno));
  804160d234:	48 8b b3 88 00 00 00 	mov    0x88(%rbx),%rsi
    if (trapno < sizeof(excnames) / sizeof(excnames[0])) return excnames[trapno];
  804160d23b:	83 fe 13             	cmp    $0x13,%esi
  804160d23e:	0f 86 96 01 00 00    	jbe    804160d3da <print_trapframe+0x20d>
    if (trapno == T_SYSCALL) return "System call";
  804160d244:	48 ba 98 2c 61 41 80 	movabs $0x8041612c98,%rdx
  804160d24b:	00 00 00 
  804160d24e:	83 fe 30             	cmp    $0x30,%esi
  804160d251:	74 1e                	je     804160d271 <print_trapframe+0xa4>
    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) return "Hardware Interrupt";
  804160d253:	8d 46 e0             	lea    -0x20(%rsi),%eax
  804160d256:	83 f8 0f             	cmp    $0xf,%eax
  804160d259:	48 ba a4 2c 61 41 80 	movabs $0x8041612ca4,%rdx
  804160d260:	00 00 00 
  804160d263:	48 b8 b3 2c 61 41 80 	movabs $0x8041612cb3,%rax
  804160d26a:	00 00 00 
  804160d26d:	48 0f 46 d0          	cmovbe %rax,%rdx
    cprintf("  trap 0x%08lx %s\n", (unsigned long)tf->tf_trapno, trapname(tf->tf_trapno));
  804160d271:	48 bf 2d 2d 61 41 80 	movabs $0x8041612d2d,%rdi
  804160d278:	00 00 00 
  804160d27b:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d280:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  804160d287:	00 00 00 
  804160d28a:	ff d1                	call   *%rcx
    if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  804160d28c:	48 b8 a0 54 40 42 80 	movabs $0x80424054a0,%rax
  804160d293:	00 00 00 
  804160d296:	48 39 18             	cmp    %rbx,(%rax)
  804160d299:	0f 84 51 01 00 00    	je     804160d3f0 <print_trapframe+0x223>
    cprintf("  err  0x%08lx", (unsigned long)tf->tf_err);
  804160d29f:	48 8b b3 90 00 00 00 	mov    0x90(%rbx),%rsi
  804160d2a6:	48 bf 50 2d 61 41 80 	movabs $0x8041612d50,%rdi
  804160d2ad:	00 00 00 
  804160d2b0:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d2b5:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160d2bc:	00 00 00 
  804160d2bf:	ff d2                	call   *%rdx
    if (tf->tf_trapno == T_PGFLT) {
  804160d2c1:	48 83 bb 88 00 00 00 	cmpq   $0xe,0x88(%rbx)
  804160d2c8:	0e 
  804160d2c9:	0f 85 52 01 00 00    	jne    804160d421 <print_trapframe+0x254>
                tf->tf_err & FEC_P ? "protection" : "not-present");
  804160d2cf:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
        cprintf(" [%s, %s, %s]\n",
  804160d2d6:	a8 01                	test   $0x1,%al
  804160d2d8:	48 b9 c6 2c 61 41 80 	movabs $0x8041612cc6,%rcx
  804160d2df:	00 00 00 
  804160d2e2:	48 ba d1 2c 61 41 80 	movabs $0x8041612cd1,%rdx
  804160d2e9:	00 00 00 
  804160d2ec:	48 0f 44 ca          	cmove  %rdx,%rcx
  804160d2f0:	48 ba dd 2c 61 41 80 	movabs $0x8041612cdd,%rdx
  804160d2f7:	00 00 00 
  804160d2fa:	a8 02                	test   $0x2,%al
  804160d2fc:	75 1a                	jne    804160d318 <print_trapframe+0x14b>
                tf->tf_err & FEC_W ? "write" : tf->tf_err & FEC_I ? "execute" :
  804160d2fe:	a8 10                	test   $0x10,%al
  804160d300:	48 ba e3 2c 61 41 80 	movabs $0x8041612ce3,%rdx
  804160d307:	00 00 00 
  804160d30a:	48 be eb 2c 61 41 80 	movabs $0x8041612ceb,%rsi
  804160d311:	00 00 00 
  804160d314:	48 0f 44 d6          	cmove  %rsi,%rdx
        cprintf(" [%s, %s, %s]\n",
  804160d318:	a8 04                	test   $0x4,%al
  804160d31a:	48 be f0 2c 61 41 80 	movabs $0x8041612cf0,%rsi
  804160d321:	00 00 00 
  804160d324:	48 b8 23 2e 61 41 80 	movabs $0x8041612e23,%rax
  804160d32b:	00 00 00 
  804160d32e:	48 0f 44 f0          	cmove  %rax,%rsi
  804160d332:	48 bf 5f 2d 61 41 80 	movabs $0x8041612d5f,%rdi
  804160d339:	00 00 00 
  804160d33c:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d341:	49 b8 99 c8 60 41 80 	movabs $0x804160c899,%r8
  804160d348:	00 00 00 
  804160d34b:	41 ff d0             	call   *%r8
    cprintf("  rip  0x%08lx\n", (unsigned long)tf->tf_rip);
  804160d34e:	48 8b b3 98 00 00 00 	mov    0x98(%rbx),%rsi
  804160d355:	48 bf 6e 2d 61 41 80 	movabs $0x8041612d6e,%rdi
  804160d35c:	00 00 00 
  804160d35f:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d364:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  804160d36b:	00 00 00 
  804160d36e:	41 ff d4             	call   *%r12
    cprintf("  cs   0x----%04x\n", tf->tf_cs);
  804160d371:	0f b7 b3 a0 00 00 00 	movzwl 0xa0(%rbx),%esi
  804160d378:	48 bf 7e 2d 61 41 80 	movabs $0x8041612d7e,%rdi
  804160d37f:	00 00 00 
  804160d382:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d387:	41 ff d4             	call   *%r12
    cprintf("  flag 0x%08lx\n", (unsigned long)tf->tf_rflags);
  804160d38a:	48 8b b3 a8 00 00 00 	mov    0xa8(%rbx),%rsi
  804160d391:	48 bf 91 2d 61 41 80 	movabs $0x8041612d91,%rdi
  804160d398:	00 00 00 
  804160d39b:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d3a0:	41 ff d4             	call   *%r12
    cprintf("  rsp  0x%08lx\n", (unsigned long)tf->tf_rsp);
  804160d3a3:	48 8b b3 b0 00 00 00 	mov    0xb0(%rbx),%rsi
  804160d3aa:	48 bf a1 2d 61 41 80 	movabs $0x8041612da1,%rdi
  804160d3b1:	00 00 00 
  804160d3b4:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d3b9:	41 ff d4             	call   *%r12
    cprintf("  ss   0x----%04x\n", tf->tf_ss);
  804160d3bc:	0f b7 b3 b8 00 00 00 	movzwl 0xb8(%rbx),%esi
  804160d3c3:	48 bf b1 2d 61 41 80 	movabs $0x8041612db1,%rdi
  804160d3ca:	00 00 00 
  804160d3cd:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d3d2:	41 ff d4             	call   *%r12
}
  804160d3d5:	5b                   	pop    %rbx
  804160d3d6:	41 5c                	pop    %r12
  804160d3d8:	5d                   	pop    %rbp
  804160d3d9:	c3                   	ret    
    if (trapno < sizeof(excnames) / sizeof(excnames[0])) return excnames[trapno];
  804160d3da:	48 63 c6             	movslq %esi,%rax
  804160d3dd:	48 ba 00 31 61 41 80 	movabs $0x8041613100,%rdx
  804160d3e4:	00 00 00 
  804160d3e7:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  804160d3eb:	e9 81 fe ff ff       	jmp    804160d271 <print_trapframe+0xa4>
    if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  804160d3f0:	48 83 bb 88 00 00 00 	cmpq   $0xe,0x88(%rbx)
  804160d3f7:	0e 
  804160d3f8:	0f 85 a1 fe ff ff    	jne    804160d29f <print_trapframe+0xd2>
    asm volatile("movq %%cr2,%0"
  804160d3fe:	0f 20 d6             	mov    %cr2,%rsi
        cprintf("  cr2  0x%08lx\n", (unsigned long)rcr2());
  804160d401:	48 bf 40 2d 61 41 80 	movabs $0x8041612d40,%rdi
  804160d408:	00 00 00 
  804160d40b:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d410:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160d417:	00 00 00 
  804160d41a:	ff d2                	call   *%rdx
  804160d41c:	e9 7e fe ff ff       	jmp    804160d29f <print_trapframe+0xd2>
        cprintf("\n");
  804160d421:	48 bf 88 11 61 41 80 	movabs $0x8041611188,%rdi
  804160d428:	00 00 00 
  804160d42b:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d430:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160d437:	00 00 00 
  804160d43a:	ff d2                	call   *%rdx
  804160d43c:	e9 0d ff ff ff       	jmp    804160d34e <print_trapframe+0x181>

000000804160d441 <trap>:

/* We do not support recursive page faults in-kernel */
bool in_page_fault;

_Noreturn void
trap(struct Trapframe *tf) {
  804160d441:	55                   	push   %rbp
  804160d442:	48 89 e5             	mov    %rsp,%rbp
  804160d445:	41 56                	push   %r14
  804160d447:	41 55                	push   %r13
  804160d449:	41 54                	push   %r12
  804160d44b:	53                   	push   %rbx
  804160d44c:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  804160d453:	48 89 fb             	mov    %rdi,%rbx
    /* The environment may have set DF and some versions
     * of GCC rely on DF being clear */
    asm volatile("cld" ::
  804160d456:	fc                   	cld    
                         : "cc");

    /* Halt the CPU if some other CPU has called panic() */
    extern char *panicstr;
    if (panicstr) asm volatile("hlt");
  804160d457:	48 b8 00 00 e0 41 80 	movabs $0x8041e00000,%rax
  804160d45e:	00 00 00 
  804160d461:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160d465:	74 01                	je     804160d468 <trap+0x27>
  804160d467:	f4                   	hlt    
    asm volatile("pushfq; popq %0"
  804160d468:	9c                   	pushf  
  804160d469:	58                   	pop    %rax

    /* Check that interrupts are disabled.  If this assertion
     * fails, DO NOT be tempted to fix it by inserting a "cli" in
     * the interrupt path */
    assert(!(read_rflags() & FL_IF));
  804160d46a:	f6 c4 02             	test   $0x2,%ah
  804160d46d:	75 6a                	jne    804160d4d9 <trap+0x98>

    if (trace_traps) cprintf("Incoming TRAP[%ld] frame at %p\n", tf->tf_trapno, tf);
    if (trace_traps_more) print_trapframe(tf);

    /* #PF should be handled separately */
    if (tf->tf_trapno == T_PGFLT) {
  804160d46f:	48 83 bb 88 00 00 00 	cmpq   $0xe,0x88(%rbx)
  804160d476:	0e 
  804160d477:	0f 84 91 00 00 00    	je     804160d50e <trap+0xcd>
            in_page_fault = 0;
            env_pop_tf(tf);
        }
    }

    assert(curenv);
  804160d47d:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160d484:	00 00 00 
  804160d487:	48 85 c0             	test   %rax,%rax
  804160d48a:	0f 84 49 01 00 00    	je     804160d5d9 <trap+0x198>

    /* Copy trap frame (which is currently on the stack)
     * into 'curenv->env_tf', so that running the environment
     * will restart at the trap point */
    curenv->env_tf = *tf;
  804160d490:	b9 30 00 00 00       	mov    $0x30,%ecx
  804160d495:	48 89 c7             	mov    %rax,%rdi
  804160d498:	48 89 de             	mov    %rbx,%rsi
  804160d49b:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    /* The trapframe on the stack should be ignored from here on */
    tf = &curenv->env_tf;
  804160d49d:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160d4a4:	00 00 00 
  804160d4a7:	48 8b 18             	mov    (%rax),%rbx

    /* Record that tf is the last real trapframe so
     * print_trapframe can print some additional information */
    last_tf = tf;
  804160d4aa:	48 89 d8             	mov    %rbx,%rax
  804160d4ad:	48 a3 a0 54 40 42 80 	movabs %rax,0x80424054a0
  804160d4b4:	00 00 00 
    switch (tf->tf_trapno) {
  804160d4b7:	48 8b 83 88 00 00 00 	mov    0x88(%rbx),%rax
  804160d4be:	48 83 e8 03          	sub    $0x3,%rax
  804160d4c2:	48 83 f8 2d          	cmp    $0x2d,%rax
  804160d4c6:	0f 87 09 04 00 00    	ja     804160d8d5 <trap+0x494>
  804160d4cc:	48 ba 80 2f 61 41 80 	movabs $0x8041612f80,%rdx
  804160d4d3:	00 00 00 
  804160d4d6:	ff 24 c2             	jmp    *(%rdx,%rax,8)
    assert(!(read_rflags() & FL_IF));
  804160d4d9:	48 b9 c4 2d 61 41 80 	movabs $0x8041612dc4,%rcx
  804160d4e0:	00 00 00 
  804160d4e3:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160d4ea:	00 00 00 
  804160d4ed:	be 6b 01 00 00       	mov    $0x16b,%esi
  804160d4f2:	48 bf dd 2d 61 41 80 	movabs $0x8041612ddd,%rdi
  804160d4f9:	00 00 00 
  804160d4fc:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d501:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160d508:	00 00 00 
  804160d50b:	41 ff d0             	call   *%r8
        assert(current_space);
  804160d50e:	48 a1 a0 00 40 42 80 	movabs 0x80424000a0,%rax
  804160d515:	00 00 00 
  804160d518:	48 85 c0             	test   %rax,%rax
  804160d51b:	74 44                	je     804160d561 <trap+0x120>
        assert(!in_page_fault);
  804160d51d:	48 ba 80 44 40 42 80 	movabs $0x8042404480,%rdx
  804160d524:	00 00 00 
  804160d527:	80 3a 00             	cmpb   $0x0,(%rdx)
  804160d52a:	74 65                	je     804160d591 <trap+0x150>
  804160d52c:	48 b9 e9 2d 61 41 80 	movabs $0x8041612de9,%rcx
  804160d533:	00 00 00 
  804160d536:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160d53d:	00 00 00 
  804160d540:	be 73 01 00 00       	mov    $0x173,%esi
  804160d545:	48 bf dd 2d 61 41 80 	movabs $0x8041612ddd,%rdi
  804160d54c:	00 00 00 
  804160d54f:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d554:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160d55b:	00 00 00 
  804160d55e:	41 ff d0             	call   *%r8
        assert(current_space);
  804160d561:	48 b9 f6 1d 61 41 80 	movabs $0x8041611df6,%rcx
  804160d568:	00 00 00 
  804160d56b:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160d572:	00 00 00 
  804160d575:	be 72 01 00 00       	mov    $0x172,%esi
  804160d57a:	48 bf dd 2d 61 41 80 	movabs $0x8041612ddd,%rdi
  804160d581:	00 00 00 
  804160d584:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160d58b:	00 00 00 
  804160d58e:	41 ff d0             	call   *%r8
        in_page_fault = 1;
  804160d591:	48 b9 80 44 40 42 80 	movabs $0x8042404480,%rcx
  804160d598:	00 00 00 
  804160d59b:	c6 01 01             	movb   $0x1,(%rcx)
    asm volatile("movq %%cr2,%0"
  804160d59e:	0f 20 d6             	mov    %cr2,%rsi
        int res = force_alloc_page(current_space, va, MAX_ALLOCATION_CLASS);
  804160d5a1:	ba 09 00 00 00       	mov    $0x9,%edx
  804160d5a6:	48 89 c7             	mov    %rax,%rdi
  804160d5a9:	48 b8 ed 94 60 41 80 	movabs $0x80416094ed,%rax
  804160d5b0:	00 00 00 
  804160d5b3:	ff d0                	call   *%rax
        if (!res) {
  804160d5b5:	85 c0                	test   %eax,%eax
  804160d5b7:	0f 85 c0 fe ff ff    	jne    804160d47d <trap+0x3c>
            in_page_fault = 0;
  804160d5bd:	48 b8 80 44 40 42 80 	movabs $0x8042404480,%rax
  804160d5c4:	00 00 00 
  804160d5c7:	c6 00 00             	movb   $0x0,(%rax)
            env_pop_tf(tf);
  804160d5ca:	48 89 df             	mov    %rbx,%rdi
  804160d5cd:	48 b8 3e c1 60 41 80 	movabs $0x804160c13e,%rax
  804160d5d4:	00 00 00 
  804160d5d7:	ff d0                	call   *%rax
    assert(curenv);
  804160d5d9:	48 b9 f8 2d 61 41 80 	movabs $0x8041612df8,%rcx
  804160d5e0:	00 00 00 
  804160d5e3:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160d5ea:	00 00 00 
  804160d5ed:	be 9c 01 00 00       	mov    $0x19c,%esi
  804160d5f2:	48 bf dd 2d 61 41 80 	movabs $0x8041612ddd,%rdi
  804160d5f9:	00 00 00 
  804160d5fc:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160d603:	00 00 00 
  804160d606:	41 ff d0             	call   *%r8
        tf->tf_regs.reg_rax = syscall(
  804160d609:	4c 8b 4b 40          	mov    0x40(%rbx),%r9
  804160d60d:	4c 8b 43 48          	mov    0x48(%rbx),%r8
  804160d611:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
  804160d615:	48 8b 53 60          	mov    0x60(%rbx),%rdx
  804160d619:	48 8b 73 58          	mov    0x58(%rbx),%rsi
  804160d61d:	48 8b 7b 70          	mov    0x70(%rbx),%rdi
  804160d621:	48 83 ec 08          	sub    $0x8,%rsp
  804160d625:	ff 73 38             	push   0x38(%rbx)
  804160d628:	48 b8 02 e7 60 41 80 	movabs $0x804160e702,%rax
  804160d62f:	00 00 00 
  804160d632:	ff d0                	call   *%rax
  804160d634:	48 89 43 70          	mov    %rax,0x70(%rbx)
        return;
  804160d638:	48 83 c4 10          	add    $0x10,%rsp
    trap_dispatch(tf);

    /* If we made it to this point, then no other environment was
     * scheduled, so we should return to the current environment
     * if doing so makes sense */
    if (curenv && curenv->env_status == ENV_RUNNING)
  804160d63c:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160d643:	00 00 00 
  804160d646:	48 85 c0             	test   %rax,%rax
  804160d649:	74 0d                	je     804160d658 <trap+0x217>
  804160d64b:	83 b8 d4 00 00 00 03 	cmpl   $0x3,0xd4(%rax)
  804160d652:	0f 84 dd 02 00 00    	je     804160d935 <trap+0x4f4>
        env_run(curenv);
    else
        sched_yield();
  804160d658:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  804160d65f:	00 00 00 
  804160d662:	ff d0                	call   *%rax
  804160d664:	41 0f 20 d6          	mov    %cr2,%r14
    // LAB 9: Your code here:

    uintptr_t cr2 = rcr2();

    /* Handle kernel-mode page faults. */
    if (!(tf->tf_err & FEC_U)) {
  804160d668:	f6 83 90 00 00 00 04 	testb  $0x4,0x90(%rbx)
  804160d66f:	0f 84 44 01 00 00    	je     804160d7b9 <trap+0x378>


    static_assert(UTRAP_RIP == offsetof(struct UTrapframe, utf_rip), "UTRAP_RIP should be equal to RIP offset");
    static_assert(UTRAP_RSP == offsetof(struct UTrapframe, utf_rsp), "UTRAP_RSP should be equal to RSP offset");
    //cprintf("[id: %d]Pagefault handler: %p\n", curenv->env_id, (void*)curenv->env_pgfault_upcall);
    if (curenv->env_pgfault_upcall == NULL) {
  804160d675:	48 83 bb 00 01 00 00 	cmpq   $0x0,0x100(%rbx)
  804160d67c:	00 
  804160d67d:	0f 84 6f 01 00 00    	je     804160d7f2 <trap+0x3b1>
    }

    /* Force allocation of exception stack page to prevent memcpy from
     * causing pagefault during another pagefault */
    // LAB 9: Your code here:
    force_alloc_page(&curenv->address_space, USER_EXCEPTION_STACK_TOP - PAGE_SIZE, PAGE_SIZE); 
  804160d683:	48 8d bb e8 00 00 00 	lea    0xe8(%rbx),%rdi
  804160d68a:	ba 00 10 00 00       	mov    $0x1000,%edx
  804160d68f:	48 be 00 f0 ff ff 7f 	movabs $0x7ffffff000,%rsi
  804160d696:	00 00 00 
  804160d699:	48 b8 ed 94 60 41 80 	movabs $0x80416094ed,%rax
  804160d6a0:	00 00 00 
  804160d6a3:	ff d0                	call   *%rax
    /* Assert existance of exception stack using user mem assert */
    // LAB 9: Your code here:
    uintptr_t user_rsp = USER_EXCEPTION_STACK_TOP;
    //recursive case
    if (tf->tf_rsp < USER_EXCEPTION_STACK_TOP && tf->tf_rsp > USER_EXCEPTION_STACK_TOP - PAGE_SIZE) {
  804160d6a5:	48 8b 93 b0 00 00 00 	mov    0xb0(%rbx),%rdx
  804160d6ac:	48 b8 ff 0f 00 00 80 	movabs $0xffffff8000000fff,%rax
  804160d6b3:	ff ff ff 
  804160d6b6:	48 01 d0             	add    %rdx,%rax
    uintptr_t user_rsp = USER_EXCEPTION_STACK_TOP;
  804160d6b9:	49 bc 00 00 00 00 80 	movabs $0x8000000000,%r12
  804160d6c0:	00 00 00 
    if (tf->tf_rsp < USER_EXCEPTION_STACK_TOP && tf->tf_rsp > USER_EXCEPTION_STACK_TOP - PAGE_SIZE) {
  804160d6c3:	48 3d fe 0f 00 00    	cmp    $0xffe,%rax
  804160d6c9:	77 04                	ja     804160d6cf <trap+0x28e>
        user_rsp = tf->tf_rsp - sizeof(uintptr_t);
  804160d6cb:	4c 8d 62 f8          	lea    -0x8(%rdx),%r12
    } 
    user_rsp -= sizeof(struct UTrapframe);
  804160d6cf:	49 81 ec a0 00 00 00 	sub    $0xa0,%r12
    user_mem_assert(curenv, (const void*)user_rsp, sizeof(struct UTrapframe), PROT_W);
  804160d6d6:	49 bd 50 44 40 42 80 	movabs $0x8042404450,%r13
  804160d6dd:	00 00 00 
  804160d6e0:	b9 02 00 00 00       	mov    $0x2,%ecx
  804160d6e5:	ba a0 00 00 00       	mov    $0xa0,%edx
  804160d6ea:	4c 89 e6             	mov    %r12,%rsi
  804160d6ed:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  804160d6f1:	48 b8 ca b7 60 41 80 	movabs $0x804160b7ca,%rax
  804160d6f8:	00 00 00 
  804160d6fb:	ff d0                	call   *%rax


    /* Build local copy of UTrapframe */
    // LAB 9: Your code here:
    struct UTrapframe user_frame;
    user_frame.utf_fault_va = cr2;  
  804160d6fd:	4c 89 b5 40 ff ff ff 	mov    %r14,-0xc0(%rbp)
    user_frame.utf_err = tf->tf_err;
  804160d704:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
  804160d70b:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    user_frame.utf_regs = tf->tf_regs;
  804160d712:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
  804160d719:	b9 1e 00 00 00       	mov    $0x1e,%ecx
  804160d71e:	48 89 de             	mov    %rbx,%rsi
  804160d721:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    user_frame.utf_rip = tf->tf_rip;
  804160d723:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
  804160d72a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    user_frame.utf_rflags = tf->tf_rflags;
  804160d72e:	48 8b 83 a8 00 00 00 	mov    0xa8(%rbx),%rax
  804160d735:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    user_frame.utf_rsp = tf->tf_rsp;
  804160d739:	48 8b 83 b0 00 00 00 	mov    0xb0(%rbx),%rax
  804160d740:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    tf->tf_rsp = user_rsp;
  804160d744:	4c 89 a3 b0 00 00 00 	mov    %r12,0xb0(%rbx)
    tf->tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  804160d74b:	49 8b 45 00          	mov    0x0(%r13),%rax
  804160d74f:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  804160d756:	48 89 93 98 00 00 00 	mov    %rdx,0x98(%rbx)
    /* And then copy it userspace (nosan_memcpy) */
    // LAB 9: Your code here:
    struct AddressSpace *old = switch_address_space(&curenv->address_space);
  804160d75d:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804160d764:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160d76b:	00 00 00 
  804160d76e:	ff d0                	call   *%rax
  804160d770:	49 89 c5             	mov    %rax,%r13
    asm volatile("movq %%cr0,%0"
  804160d773:	0f 20 c0             	mov    %cr0,%rax
    uintptr_t old_cr0 = rcr0();
    if (old_cr0 & CR0_WP)
  804160d776:	a9 00 00 01 00       	test   $0x10000,%eax
  804160d77b:	0f 84 c3 01 00 00    	je     804160d944 <trap+0x503>
  804160d781:	0f 20 c0             	mov    %cr0,%rax
    lcr0(wp ? old | CR0_WP : old & ~CR0_WP);
  804160d784:	48 25 ff ff fe ff    	and    $0xfffffffffffeffff,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  804160d78a:	0f 22 c0             	mov    %rax,%cr0
        set_wp(0);
    nosan_memcpy((void*)user_rsp, &user_frame, sizeof(struct UTrapframe));
  804160d78d:	ba a0 00 00 00       	mov    $0xa0,%edx
  804160d792:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
  804160d799:	4c 89 e7             	mov    %r12,%rdi
  804160d79c:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160d7a3:	00 00 00 
  804160d7a6:	ff d0                	call   *%rax
    asm volatile("movq %%cr0,%0"
  804160d7a8:	0f 20 c0             	mov    %cr0,%rax
  804160d7ab:	48 0d 00 00 01 00    	or     $0x10000,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  804160d7b1:	0f 22 c0             	mov    %rax,%cr0
}
  804160d7b4:	e9 a6 01 00 00       	jmp    804160d95f <trap+0x51e>
        print_trapframe(tf);
  804160d7b9:	48 89 df             	mov    %rbx,%rdi
  804160d7bc:	48 b8 cd d1 60 41 80 	movabs $0x804160d1cd,%rax
  804160d7c3:	00 00 00 
  804160d7c6:	ff d0                	call   *%rax
        panic("Kernel pagefault\n");
  804160d7c8:	48 ba ff 2d 61 41 80 	movabs $0x8041612dff,%rdx
  804160d7cf:	00 00 00 
  804160d7d2:	be be 01 00 00       	mov    $0x1be,%esi
  804160d7d7:	48 bf dd 2d 61 41 80 	movabs $0x8041612ddd,%rdi
  804160d7de:	00 00 00 
  804160d7e1:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d7e6:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160d7ed:	00 00 00 
  804160d7f0:	ff d1                	call   *%rcx
        user_mem_assert(curenv, (void *)tf->tf_rsp, sizeof(struct UTrapframe), PROT_W);
  804160d7f2:	48 8b b3 b0 00 00 00 	mov    0xb0(%rbx),%rsi
  804160d7f9:	b9 02 00 00 00       	mov    $0x2,%ecx
  804160d7fe:	ba a0 00 00 00       	mov    $0xa0,%edx
  804160d803:	48 89 df             	mov    %rbx,%rdi
  804160d806:	48 b8 ca b7 60 41 80 	movabs $0x804160b7ca,%rax
  804160d80d:	00 00 00 
  804160d810:	ff d0                	call   *%rax
        print_trapframe(tf);
  804160d812:	48 89 df             	mov    %rbx,%rdi
  804160d815:	48 b8 cd d1 60 41 80 	movabs $0x804160d1cd,%rax
  804160d81c:	00 00 00 
  804160d81f:	ff d0                	call   *%rax
        env_destroy(curenv);
  804160d821:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160d828:	00 00 00 
  804160d82b:	48 8b 38             	mov    (%rax),%rdi
  804160d82e:	48 b8 5e c0 60 41 80 	movabs $0x804160c05e,%rax
  804160d835:	00 00 00 
  804160d838:	ff d0                	call   *%rax
        env_run(NULL);
  804160d83a:	bf 00 00 00 00       	mov    $0x0,%edi
  804160d83f:	48 b8 cd c1 60 41 80 	movabs $0x804160c1cd,%rax
  804160d846:	00 00 00 
  804160d849:	ff d0                	call   *%rax
        set_wp(1);
    switch_address_space(old);
    /* Reset in_page_fault flag */
    // LAB 9: Your code here:
    if (tf->tf_trapno == T_PGFLT)
        in_page_fault = 0;
  804160d84b:	48 b8 80 44 40 42 80 	movabs $0x8042404480,%rax
  804160d852:	00 00 00 
  804160d855:	c6 00 00             	movb   $0x0,(%rax)
  804160d858:	e9 1f 01 00 00       	jmp    804160d97c <trap+0x53b>
        monitor(tf);
  804160d85d:	48 89 df             	mov    %rbx,%rdi
  804160d860:	48 b8 b1 45 60 41 80 	movabs $0x80416045b1,%rax
  804160d867:	00 00 00 
  804160d86a:	ff d0                	call   *%rax
        return;
  804160d86c:	e9 cb fd ff ff       	jmp    804160d63c <trap+0x1fb>
        timer_for_schedule->handle_interrupts();
  804160d871:	48 a1 40 55 40 42 80 	movabs 0x8042405540,%rax
  804160d878:	00 00 00 
  804160d87b:	ff 50 20             	call   *0x20(%rax)
        vsys[VSYS_gettime] = gettime();
  804160d87e:	48 b8 40 44 40 42 80 	movabs $0x8042404440,%rax
  804160d885:	00 00 00 
  804160d888:	48 8b 18             	mov    (%rax),%rbx
  804160d88b:	48 b8 a1 c5 60 41 80 	movabs $0x804160c5a1,%rax
  804160d892:	00 00 00 
  804160d895:	ff d0                	call   *%rax
  804160d897:	89 03                	mov    %eax,(%rbx)
        sched_yield();
  804160d899:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  804160d8a0:	00 00 00 
  804160d8a3:	ff d0                	call   *%rax
        kbd_intr();
  804160d8a5:	48 b8 48 0b 60 41 80 	movabs $0x8041600b48,%rax
  804160d8ac:	00 00 00 
  804160d8af:	ff d0                	call   *%rax
        sched_yield();
  804160d8b1:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  804160d8b8:	00 00 00 
  804160d8bb:	ff d0                	call   *%rax
        serial_intr();
  804160d8bd:	48 b8 1c 0b 60 41 80 	movabs $0x8041600b1c,%rax
  804160d8c4:	00 00 00 
  804160d8c7:	ff d0                	call   *%rax
        sched_yield();
  804160d8c9:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  804160d8d0:	00 00 00 
  804160d8d3:	ff d0                	call   *%rax
        print_trapframe(tf);
  804160d8d5:	48 89 df             	mov    %rbx,%rdi
  804160d8d8:	48 b8 cd d1 60 41 80 	movabs $0x804160d1cd,%rax
  804160d8df:	00 00 00 
  804160d8e2:	ff d0                	call   *%rax
        if (!(tf->tf_cs & 3))
  804160d8e4:	f6 83 a0 00 00 00 03 	testb  $0x3,0xa0(%rbx)
  804160d8eb:	74 1e                	je     804160d90b <trap+0x4ca>
        env_destroy(curenv);
  804160d8ed:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160d8f4:	00 00 00 
  804160d8f7:	48 8b 38             	mov    (%rax),%rdi
  804160d8fa:	48 b8 5e c0 60 41 80 	movabs $0x804160c05e,%rax
  804160d901:	00 00 00 
  804160d904:	ff d0                	call   *%rax
  804160d906:	e9 31 fd ff ff       	jmp    804160d63c <trap+0x1fb>
            panic("Unhandled trap in kernel");
  804160d90b:	48 ba 11 2e 61 41 80 	movabs $0x8041612e11,%rdx
  804160d912:	00 00 00 
  804160d915:	be 55 01 00 00       	mov    $0x155,%esi
  804160d91a:	48 bf dd 2d 61 41 80 	movabs $0x8041612ddd,%rdi
  804160d921:	00 00 00 
  804160d924:	b8 00 00 00 00       	mov    $0x0,%eax
  804160d929:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160d930:	00 00 00 
  804160d933:	ff d1                	call   *%rcx
        env_run(curenv);
  804160d935:	48 89 c7             	mov    %rax,%rdi
  804160d938:	48 b8 cd c1 60 41 80 	movabs $0x804160c1cd,%rax
  804160d93f:	00 00 00 
  804160d942:	ff d0                	call   *%rax
    nosan_memcpy((void*)user_rsp, &user_frame, sizeof(struct UTrapframe));
  804160d944:	ba a0 00 00 00       	mov    $0xa0,%edx
  804160d949:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
  804160d950:	4c 89 e7             	mov    %r12,%rdi
  804160d953:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160d95a:	00 00 00 
  804160d95d:	ff d0                	call   *%rax
    switch_address_space(old);
  804160d95f:	4c 89 ef             	mov    %r13,%rdi
  804160d962:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160d969:	00 00 00 
  804160d96c:	ff d0                	call   *%rax
    if (tf->tf_trapno == T_PGFLT)
  804160d96e:	48 83 bb 88 00 00 00 	cmpq   $0xe,0x88(%rbx)
  804160d975:	0e 
  804160d976:	0f 84 cf fe ff ff    	je     804160d84b <trap+0x40a>
    /* Rerun current environment */
    // LAB 9: Your code here:
    env_run(curenv);
  804160d97c:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160d983:	00 00 00 
  804160d986:	48 8b 38             	mov    (%rax),%rdi
  804160d989:	48 b8 cd c1 60 41 80 	movabs $0x804160c1cd,%rax
  804160d990:	00 00 00 
  804160d993:	ff d0                	call   *%rax
  804160d995:	90                   	nop

000000804160d996 <_alltraps>:

.globl _alltraps
.type _alltraps, @function;
.align 2
_alltraps:
  subq $16,%rsp
  804160d996:	48 83 ec 10          	sub    $0x10,%rsp
  movw %ds,8(%rsp)
  804160d99a:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
  movw %es,(%rsp)
  804160d99e:	8c 04 24             	mov    %es,(%rsp)
  PUSHA
  804160d9a1:	48 83 ec 78          	sub    $0x78,%rsp
  804160d9a5:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  804160d9aa:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  804160d9af:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  804160d9b4:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  804160d9b9:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  804160d9be:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  804160d9c3:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  804160d9c8:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  804160d9cd:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  804160d9d2:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  804160d9d7:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  804160d9dc:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  804160d9e1:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  804160d9e6:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  804160d9eb:	4c 89 3c 24          	mov    %r15,(%rsp)
  movl $GD_KD,%eax
  804160d9ef:	b8 10 00 00 00       	mov    $0x10,%eax
  movw %ax,%ds
  804160d9f4:	8e d8                	mov    %eax,%ds
  movw %ax,%es
  804160d9f6:	8e c0                	mov    %eax,%es
  movq %rsp, %rdi
  804160d9f8:	48 89 e7             	mov    %rsp,%rdi
  call trap
  804160d9fb:	e8 41 fa ff ff       	call   804160d441 <trap>
  jmp .
  804160da00:	eb fe                	jmp    804160da00 <_alltraps+0x6a>

000000804160da02 <clock_thdlr>:
# LAB 8: Your code here
# Use TARPHANDLER or TRAPHANDLER_NOEC to setup
# all trap handlers' entry points
# (Look up their list in inc/trap.h)

TRAPHANDLER_NOEC(clock_thdlr, IRQ_OFFSET + IRQ_CLOCK)
  804160da02:	6a 00                	push   $0x0
  804160da04:	6a 28                	push   $0x28
  804160da06:	eb 8e                	jmp    804160d996 <_alltraps>

000000804160da08 <timer_thdlr>:
TRAPHANDLER_NOEC(timer_thdlr, IRQ_OFFSET + IRQ_TIMER)
  804160da08:	6a 00                	push   $0x0
  804160da0a:	6a 20                	push   $0x20
  804160da0c:	eb 88                	jmp    804160d996 <_alltraps>

000000804160da0e <kbd_thdlr>:

TRAPHANDLER_NOEC(kbd_thdlr, IRQ_OFFSET + IRQ_KBD)
  804160da0e:	6a 00                	push   $0x0
  804160da10:	6a 21                	push   $0x21
  804160da12:	eb 82                	jmp    804160d996 <_alltraps>

000000804160da14 <serial_thdlr>:
TRAPHANDLER_NOEC(serial_thdlr, IRQ_OFFSET + IRQ_SERIAL)
  804160da14:	6a 00                	push   $0x0
  804160da16:	6a 24                	push   $0x24
  804160da18:	e9 79 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da1d:	90                   	nop

000000804160da1e <divide_thdlr>:

TRAPHANDLER_NOEC(divide_thdlr, T_DIVIDE)
  804160da1e:	6a 00                	push   $0x0
  804160da20:	6a 00                	push   $0x0
  804160da22:	e9 6f ff ff ff       	jmp    804160d996 <_alltraps>
  804160da27:	90                   	nop

000000804160da28 <debug_thdlr>:
TRAPHANDLER_NOEC(debug_thdlr, T_DEBUG)
  804160da28:	6a 00                	push   $0x0
  804160da2a:	6a 01                	push   $0x1
  804160da2c:	e9 65 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da31:	90                   	nop

000000804160da32 <nmi_thdlr>:
TRAPHANDLER_NOEC(nmi_thdlr, T_NMI)
  804160da32:	6a 00                	push   $0x0
  804160da34:	6a 02                	push   $0x2
  804160da36:	e9 5b ff ff ff       	jmp    804160d996 <_alltraps>
  804160da3b:	90                   	nop

000000804160da3c <brkpt_thdlr>:
TRAPHANDLER_NOEC(brkpt_thdlr, T_BRKPT)
  804160da3c:	6a 00                	push   $0x0
  804160da3e:	6a 03                	push   $0x3
  804160da40:	e9 51 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da45:	90                   	nop

000000804160da46 <oflow_thdlr>:
TRAPHANDLER_NOEC(oflow_thdlr, T_OFLOW)
  804160da46:	6a 00                	push   $0x0
  804160da48:	6a 04                	push   $0x4
  804160da4a:	e9 47 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da4f:	90                   	nop

000000804160da50 <bound_thdlr>:
TRAPHANDLER_NOEC(bound_thdlr, T_BOUND)
  804160da50:	6a 00                	push   $0x0
  804160da52:	6a 05                	push   $0x5
  804160da54:	e9 3d ff ff ff       	jmp    804160d996 <_alltraps>
  804160da59:	90                   	nop

000000804160da5a <illop_thdlr>:
TRAPHANDLER_NOEC(illop_thdlr, T_ILLOP)
  804160da5a:	6a 00                	push   $0x0
  804160da5c:	6a 06                	push   $0x6
  804160da5e:	e9 33 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da63:	90                   	nop

000000804160da64 <device_thdlr>:
TRAPHANDLER_NOEC(device_thdlr, T_DEVICE)
  804160da64:	6a 00                	push   $0x0
  804160da66:	6a 07                	push   $0x7
  804160da68:	e9 29 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da6d:	90                   	nop

000000804160da6e <dblflt_thdlr>:
TRAPHANDLER(dblflt_thdlr, T_DBLFLT)
  804160da6e:	6a 08                	push   $0x8
  804160da70:	e9 21 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da75:	90                   	nop

000000804160da76 <tss_thdlr>:
TRAPHANDLER(tss_thdlr, T_TSS)
  804160da76:	6a 0a                	push   $0xa
  804160da78:	e9 19 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da7d:	90                   	nop

000000804160da7e <segnp_thdlr>:
TRAPHANDLER(segnp_thdlr, T_SEGNP)
  804160da7e:	6a 0b                	push   $0xb
  804160da80:	e9 11 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da85:	90                   	nop

000000804160da86 <stack_thdlr>:
TRAPHANDLER(stack_thdlr, T_STACK)
  804160da86:	6a 0c                	push   $0xc
  804160da88:	e9 09 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da8d:	90                   	nop

000000804160da8e <gpflt_thdlr>:
TRAPHANDLER(gpflt_thdlr, T_GPFLT)
  804160da8e:	6a 0d                	push   $0xd
  804160da90:	e9 01 ff ff ff       	jmp    804160d996 <_alltraps>
  804160da95:	90                   	nop

000000804160da96 <pgflt_thdlr>:
TRAPHANDLER(pgflt_thdlr, T_PGFLT)
  804160da96:	6a 0e                	push   $0xe
  804160da98:	e9 f9 fe ff ff       	jmp    804160d996 <_alltraps>
  804160da9d:	90                   	nop

000000804160da9e <fperr_thdlr>:
TRAPHANDLER_NOEC(fperr_thdlr, T_FPERR)
  804160da9e:	6a 00                	push   $0x0
  804160daa0:	6a 10                	push   $0x10
  804160daa2:	e9 ef fe ff ff       	jmp    804160d996 <_alltraps>
  804160daa7:	90                   	nop

000000804160daa8 <align_thdlr>:
TRAPHANDLER(align_thdlr, T_ALIGN)
  804160daa8:	6a 11                	push   $0x11
  804160daaa:	e9 e7 fe ff ff       	jmp    804160d996 <_alltraps>
  804160daaf:	90                   	nop

000000804160dab0 <mchk_thdlr>:
TRAPHANDLER_NOEC(mchk_thdlr, T_MCHK)
  804160dab0:	6a 00                	push   $0x0
  804160dab2:	6a 12                	push   $0x12
  804160dab4:	e9 dd fe ff ff       	jmp    804160d996 <_alltraps>
  804160dab9:	90                   	nop

000000804160daba <simderr_thdlr>:
TRAPHANDLER_NOEC(simderr_thdlr, T_SIMDERR)
  804160daba:	6a 00                	push   $0x0
  804160dabc:	6a 13                	push   $0x13
  804160dabe:	e9 d3 fe ff ff       	jmp    804160d996 <_alltraps>
  804160dac3:	90                   	nop

000000804160dac4 <syscall_thdlr>:

TRAPHANDLER_NOEC(syscall_thdlr, T_SYSCALL)
  804160dac4:	6a 00                	push   $0x0
  804160dac6:	6a 30                	push   $0x30
  804160dac8:	e9 c9 fe ff ff       	jmp    804160d996 <_alltraps>

000000804160dacd <acpi_find_table>:
    while ((inw(fadt->PM1aControlBlock) & 1) == 0) /* nothing */
        ;
}

static void *
acpi_find_table(const char *sign) {
  804160dacd:	55                   	push   %rbp
  804160dace:	48 89 e5             	mov    %rsp,%rbp
  804160dad1:	41 57                	push   %r15
  804160dad3:	41 56                	push   %r14
  804160dad5:	41 55                	push   %r13
  804160dad7:	41 54                	push   %r12
  804160dad9:	53                   	push   %rbx
  804160dada:	48 83 ec 28          	sub    $0x28,%rsp
  804160dade:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    // LAB 5: Your code here
    static RSDT *k_rsdt = NULL;
    static int entry_len;
    static int entry_size;

    if (!k_rsdt) {
  804160dae2:	48 b8 50 56 40 42 80 	movabs $0x8042405650,%rax
  804160dae9:	00 00 00 
  804160daec:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160daf0:	0f 84 db 00 00 00    	je     804160dbd1 <acpi_find_table+0x104>
        
        if (k_rsdp->Revision)
            entry_len /= 2;
    }
    ACPISDTHeader *curr = NULL;
    for (int i = 0; i < entry_len; ++i) {
  804160daf6:	48 b8 48 56 40 42 80 	movabs $0x8042405648,%rax
  804160dafd:	00 00 00 
  804160db00:	83 38 00             	cmpl   $0x0,(%rax)
  804160db03:	0f 8e 8c 01 00 00    	jle    804160dc95 <acpi_find_table+0x1c8>
  804160db09:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        uint64_t HeaderPtr = 0;
        memcpy(&HeaderPtr, (uint8_t*)k_rsdt->PointerToOtherSDT + i * entry_size, entry_size);
  804160db0f:	49 bf 4c 56 40 42 80 	movabs $0x804240564c,%r15
  804160db16:	00 00 00 
  804160db19:	49 be 50 56 40 42 80 	movabs $0x8042405650,%r14
  804160db20:	00 00 00 
  804160db23:	49 bd b4 fe 60 41 80 	movabs $0x804160feb4,%r13
  804160db2a:	00 00 00 
        uint64_t HeaderPtr = 0;
  804160db2d:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  804160db34:	00 
        memcpy(&HeaderPtr, (uint8_t*)k_rsdt->PointerToOtherSDT + i * entry_size, entry_size);
  804160db35:	41 8b 07             	mov    (%r15),%eax
  804160db38:	48 63 d0             	movslq %eax,%rdx
  804160db3b:	49 8b 0e             	mov    (%r14),%rcx
  804160db3e:	41 0f af c4          	imul   %r12d,%eax
  804160db42:	48 98                	cltq   
  804160db44:	48 8d 74 01 24       	lea    0x24(%rcx,%rax,1),%rsi
  804160db49:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160db4d:	41 ff d5             	call   *%r13
        
        ACPISDTHeader *va  = mmio_map_region(HeaderPtr, sizeof(ACPISDTHeader));
  804160db50:	be 24 00 00 00       	mov    $0x24,%esi
  804160db55:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160db59:	48 b8 72 a6 60 41 80 	movabs $0x804160a672,%rax
  804160db60:	00 00 00 
  804160db63:	ff d0                	call   *%rax
  804160db65:	48 89 c6             	mov    %rax,%rsi
        HeaderPtr = (uint64_t)mmio_remap_last_region(HeaderPtr, va, sizeof(ACPISDTHeader), va->Length);
  804160db68:	8b 48 04             	mov    0x4(%rax),%ecx
  804160db6b:	ba 24 00 00 00       	mov    $0x24,%edx
  804160db70:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160db74:	48 b8 83 a7 60 41 80 	movabs $0x804160a783,%rax
  804160db7b:	00 00 00 
  804160db7e:	ff d0                	call   *%rax
  804160db80:	48 89 c3             	mov    %rax,%rbx
  804160db83:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        
        curr = (ACPISDTHeader*)HeaderPtr;
        if (strncmp(curr->Signature, sign, 4) == 0) {
  804160db87:	ba 04 00 00 00       	mov    $0x4,%edx
  804160db8c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804160db90:	48 89 c7             	mov    %rax,%rdi
  804160db93:	48 b8 19 fd 60 41 80 	movabs $0x804160fd19,%rax
  804160db9a:	00 00 00 
  804160db9d:	ff d0                	call   *%rax
  804160db9f:	85 c0                	test   %eax,%eax
  804160dba1:	74 1c                	je     804160dbbf <acpi_find_table+0xf2>
    for (int i = 0; i < entry_len; ++i) {
  804160dba3:	41 83 c4 01          	add    $0x1,%r12d
  804160dba7:	48 b8 48 56 40 42 80 	movabs $0x8042405648,%rax
  804160dbae:	00 00 00 
  804160dbb1:	44 39 20             	cmp    %r12d,(%rax)
  804160dbb4:	0f 8f 73 ff ff ff    	jg     804160db2d <acpi_find_table+0x60>
            return curr;
        }
    } 
    return NULL;
  804160dbba:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  804160dbbf:	48 89 d8             	mov    %rbx,%rax
  804160dbc2:	48 83 c4 28          	add    $0x28,%rsp
  804160dbc6:	5b                   	pop    %rbx
  804160dbc7:	41 5c                	pop    %r12
  804160dbc9:	41 5d                	pop    %r13
  804160dbcb:	41 5e                	pop    %r14
  804160dbcd:	41 5f                	pop    %r15
  804160dbcf:	5d                   	pop    %rbp
  804160dbd0:	c3                   	ret    
        k_rsdp  = (RSDP*)uefi_lp->ACPIRoot;
  804160dbd1:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  804160dbd8:	00 00 00 
        k_rsdp = mmio_map_region((physaddr_t)k_rsdp, sizeof(RSDP));
  804160dbdb:	48 8b 78 10          	mov    0x10(%rax),%rdi
  804160dbdf:	be 24 00 00 00       	mov    $0x24,%esi
  804160dbe4:	48 b8 72 a6 60 41 80 	movabs $0x804160a672,%rax
  804160dbeb:	00 00 00 
  804160dbee:	ff d0                	call   *%rax
  804160dbf0:	48 89 c3             	mov    %rax,%rbx
        uint64_t sdt = k_rsdp->RsdtAddress;
  804160dbf3:	8b 78 10             	mov    0x10(%rax),%edi
        entry_size = 4;
  804160dbf6:	48 b8 4c 56 40 42 80 	movabs $0x804240564c,%rax
  804160dbfd:	00 00 00 
  804160dc00:	c7 00 04 00 00 00    	movl   $0x4,(%rax)
        uint64_t sdt = k_rsdp->RsdtAddress;
  804160dc06:	89 ff                	mov    %edi,%edi
        if (k_rsdp->Revision) {
  804160dc08:	80 7b 0f 00          	cmpb   $0x0,0xf(%rbx)
  804160dc0c:	74 14                	je     804160dc22 <acpi_find_table+0x155>
            sdt = k_rsdp->XsdtAddress;
  804160dc0e:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
            entry_size = 8;
  804160dc12:	48 b8 4c 56 40 42 80 	movabs $0x804240564c,%rax
  804160dc19:	00 00 00 
  804160dc1c:	c7 00 08 00 00 00    	movl   $0x8,(%rax)
        k_rsdt = (RSDT*)sdt;
  804160dc22:	49 bc 50 56 40 42 80 	movabs $0x8042405650,%r12
  804160dc29:	00 00 00 
  804160dc2c:	49 89 3c 24          	mov    %rdi,(%r12)
        RSDT *va = mmio_map_region((physaddr_t)k_rsdt, sizeof(RSDT));
  804160dc30:	be 24 00 00 00       	mov    $0x24,%esi
  804160dc35:	48 b8 72 a6 60 41 80 	movabs $0x804160a672,%rax
  804160dc3c:	00 00 00 
  804160dc3f:	ff d0                	call   *%rax
  804160dc41:	48 89 c6             	mov    %rax,%rsi
        k_rsdt = mmio_remap_last_region((physaddr_t)k_rsdt, va, sizeof(RSDT), va->h.Length);
  804160dc44:	8b 48 04             	mov    0x4(%rax),%ecx
  804160dc47:	ba 24 00 00 00       	mov    $0x24,%edx
  804160dc4c:	49 8b 3c 24          	mov    (%r12),%rdi
  804160dc50:	48 b8 83 a7 60 41 80 	movabs $0x804160a783,%rax
  804160dc57:	00 00 00 
  804160dc5a:	ff d0                	call   *%rax
  804160dc5c:	49 89 04 24          	mov    %rax,(%r12)
        entry_len = (k_rsdt->h.Length - sizeof(RSDT)) / 4;
  804160dc60:	8b 40 04             	mov    0x4(%rax),%eax
  804160dc63:	48 83 e8 24          	sub    $0x24,%rax
  804160dc67:	48 c1 e8 02          	shr    $0x2,%rax
  804160dc6b:	a3 48 56 40 42 80 00 	movabs %eax,0x8042405648
  804160dc72:	00 00 
        if (k_rsdp->Revision)
  804160dc74:	80 7b 0f 00          	cmpb   $0x0,0xf(%rbx)
  804160dc78:	0f 84 78 fe ff ff    	je     804160daf6 <acpi_find_table+0x29>
            entry_len /= 2;
  804160dc7e:	89 c2                	mov    %eax,%edx
  804160dc80:	c1 ea 1f             	shr    $0x1f,%edx
  804160dc83:	01 d0                	add    %edx,%eax
  804160dc85:	d1 f8                	sar    %eax
  804160dc87:	a3 48 56 40 42 80 00 	movabs %eax,0x8042405648
  804160dc8e:	00 00 
  804160dc90:	e9 61 fe ff ff       	jmp    804160daf6 <acpi_find_table+0x29>
    return NULL;
  804160dc95:	bb 00 00 00 00       	mov    $0x0,%ebx
  804160dc9a:	e9 20 ff ff ff       	jmp    804160dbbf <acpi_find_table+0xf2>

000000804160dc9f <hpet_handle_interrupts_tim0>:
    //tim1 trigger IRQ_CLOCK
    pic_irq_unmask(IRQ_CLOCK);
}

void
hpet_handle_interrupts_tim0(void) {
  804160dc9f:	55                   	push   %rbp
  804160dca0:	48 89 e5             	mov    %rsp,%rbp
    pic_send_eoi(IRQ_TIMER);
  804160dca3:	bf 00 00 00 00       	mov    $0x0,%edi
  804160dca8:	48 b8 27 c8 60 41 80 	movabs $0x804160c827,%rax
  804160dcaf:	00 00 00 
  804160dcb2:	ff d0                	call   *%rax
}
  804160dcb4:	5d                   	pop    %rbp
  804160dcb5:	c3                   	ret    

000000804160dcb6 <hpet_handle_interrupts_tim1>:

void
hpet_handle_interrupts_tim1(void) {
  804160dcb6:	55                   	push   %rbp
  804160dcb7:	48 89 e5             	mov    %rsp,%rbp
    pic_send_eoi(IRQ_CLOCK);
  804160dcba:	bf 08 00 00 00       	mov    $0x8,%edi
  804160dcbf:	48 b8 27 c8 60 41 80 	movabs $0x804160c827,%rax
  804160dcc6:	00 00 00 
  804160dcc9:	ff d0                	call   *%rax
}
  804160dccb:	5d                   	pop    %rbp
  804160dccc:	c3                   	ret    

000000804160dccd <hpet_cpu_frequency>:
uint64_t
hpet_cpu_frequency(void) {
    static uint64_t cpu_freq = 0;

    // LAB 5: Your code here
    if (!cpu_freq) {
  804160dccd:	48 b8 38 56 40 42 80 	movabs $0x8042405638,%rax
  804160dcd4:	00 00 00 
  804160dcd7:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160dcdb:	74 0b                	je     804160dce8 <hpet_cpu_frequency+0x1b>
        cpu_freq = (tsc_after - tsc_before) * time_int;
    }


    return cpu_freq;
}
  804160dcdd:	48 a1 38 56 40 42 80 	movabs 0x8042405638,%rax
  804160dce4:	00 00 00 
  804160dce7:	c3                   	ret    
        const uint64_t target = hpetFreq / time_int;
  804160dce8:	48 a1 68 56 40 42 80 	movabs 0x8042405668,%rax
  804160dcef:	00 00 00 
  804160dcf2:	48 c1 e8 02          	shr    $0x2,%rax
  804160dcf6:	48 ba c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%rdx
  804160dcfd:	c2 f5 28 
  804160dd00:	48 f7 e2             	mul    %rdx
  804160dd03:	48 89 d1             	mov    %rdx,%rcx
  804160dd06:	48 c1 e9 02          	shr    $0x2,%rcx
    return hpetReg->MAIN_CNT;
  804160dd0a:	48 a1 78 56 40 42 80 	movabs 0x8042405678,%rax
  804160dd11:	00 00 00 
  804160dd14:	48 8b b0 f0 00 00 00 	mov    0xf0(%rax),%rsi
    asm volatile("rdtsc"
  804160dd1b:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804160dd1d:	48 c1 e2 20          	shl    $0x20,%rdx
  804160dd21:	89 c0                	mov    %eax,%eax
  804160dd23:	48 89 d7             	mov    %rdx,%rdi
  804160dd26:	48 09 c7             	or     %rax,%rdi
  804160dd29:	48 ba 78 56 40 42 80 	movabs $0x8042405678,%rdx
  804160dd30:	00 00 00 
          asm("pause");
  804160dd33:	f3 90                	pause  
    return hpetReg->MAIN_CNT;
  804160dd35:	48 8b 02             	mov    (%rdx),%rax
  804160dd38:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
          counter = hpet_get_main_cnt() - start;
  804160dd3f:	48 29 f0             	sub    %rsi,%rax
        } while (counter < target);
  804160dd42:	48 39 c1             	cmp    %rax,%rcx
  804160dd45:	77 ec                	ja     804160dd33 <hpet_cpu_frequency+0x66>
    asm volatile("rdtsc"
  804160dd47:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804160dd49:	48 c1 e2 20          	shl    $0x20,%rdx
  804160dd4d:	89 c0                	mov    %eax,%eax
  804160dd4f:	48 09 c2             	or     %rax,%rdx
        cpu_freq = (tsc_after - tsc_before) * time_int;
  804160dd52:	48 89 d0             	mov    %rdx,%rax
  804160dd55:	48 29 f8             	sub    %rdi,%rax
  804160dd58:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  804160dd5c:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  804160dd60:	48 c1 e0 02          	shl    $0x2,%rax
  804160dd64:	48 a3 38 56 40 42 80 	movabs %rax,0x8042405638
  804160dd6b:	00 00 00 
  804160dd6e:	e9 6a ff ff ff       	jmp    804160dcdd <hpet_cpu_frequency+0x10>

000000804160dd73 <hpet_enable_interrupts_tim1>:
hpet_enable_interrupts_tim1(void) {
  804160dd73:	55                   	push   %rbp
  804160dd74:	48 89 e5             	mov    %rsp,%rbp
    hpetReg->GEN_CONF |= HPET_LEG_RT_CNF;
  804160dd77:	48 b8 78 56 40 42 80 	movabs $0x8042405678,%rax
  804160dd7e:	00 00 00 
  804160dd81:	48 8b 10             	mov    (%rax),%rdx
  804160dd84:	48 8b 42 10          	mov    0x10(%rdx),%rax
  804160dd88:	48 83 c8 02          	or     $0x2,%rax
  804160dd8c:	48 89 42 10          	mov    %rax,0x10(%rdx)
    hpetReg->TIM0_CONF |= IRQ_CLOCK << 9;
  804160dd90:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160dd97:	80 cc 10             	or     $0x10,%ah
  804160dd9a:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    hpetReg->TIM0_CONF |= HPET_TN_INT_ENB_CNF;
  804160dda1:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160dda8:	48 83 c8 04          	or     $0x4,%rax
  804160ddac:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    hpetReg->TIM0_CONF |= HPET_TN_TYPE_CNF;
  804160ddb3:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160ddba:	48 83 c8 08          	or     $0x8,%rax
  804160ddbe:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    hpetReg->TIM0_CONF |= HPET_TN_VAL_SET_CNF;
  804160ddc5:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160ddcc:	48 83 c8 40          	or     $0x40,%rax
  804160ddd0:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    return hpetReg->MAIN_CNT;
  804160ddd7:	48 8b 8a f0 00 00 00 	mov    0xf0(%rdx),%rcx
    hpetReg->TIM0_COMP = hpet_get_main_cnt() + hpetFreq * 3 / 2;
  804160ddde:	48 a1 68 56 40 42 80 	movabs 0x8042405668,%rax
  804160dde5:	00 00 00 
  804160dde8:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  804160ddec:	48 d1 e8             	shr    %rax
  804160ddef:	48 01 c1             	add    %rax,%rcx
  804160ddf2:	48 89 8a 08 01 00 00 	mov    %rcx,0x108(%rdx)
    hpetReg->TIM0_COMP = hpetFreq * 3 / 2;
  804160ddf9:	48 89 82 08 01 00 00 	mov    %rax,0x108(%rdx)
    pic_irq_unmask(IRQ_CLOCK);
  804160de00:	bf 08 00 00 00       	mov    $0x8,%edi
  804160de05:	48 b8 d3 c7 60 41 80 	movabs $0x804160c7d3,%rax
  804160de0c:	00 00 00 
  804160de0f:	ff d0                	call   *%rax
}
  804160de11:	5d                   	pop    %rbp
  804160de12:	c3                   	ret    

000000804160de13 <hpet_enable_interrupts_tim0>:
hpet_enable_interrupts_tim0(void) {
  804160de13:	55                   	push   %rbp
  804160de14:	48 89 e5             	mov    %rsp,%rbp
    hpetReg->GEN_CONF |= HPET_LEG_RT_CNF;
  804160de17:	48 b8 78 56 40 42 80 	movabs $0x8042405678,%rax
  804160de1e:	00 00 00 
  804160de21:	48 8b 10             	mov    (%rax),%rdx
  804160de24:	48 8b 42 10          	mov    0x10(%rdx),%rax
  804160de28:	48 83 c8 02          	or     $0x2,%rax
  804160de2c:	48 89 42 10          	mov    %rax,0x10(%rdx)
    hpetReg->TIM0_CONF |= IRQ_TIMER << 9;
  804160de30:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160de37:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    hpetReg->TIM0_CONF |= HPET_TN_INT_ENB_CNF;
  804160de3e:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160de45:	48 83 c8 04          	or     $0x4,%rax
  804160de49:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    hpetReg->TIM0_CONF |= HPET_TN_TYPE_CNF;
  804160de50:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160de57:	48 83 c8 08          	or     $0x8,%rax
  804160de5b:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    hpetReg->TIM0_CONF |= HPET_TN_VAL_SET_CNF;
  804160de62:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
  804160de69:	48 83 c8 40          	or     $0x40,%rax
  804160de6d:	48 89 82 00 01 00 00 	mov    %rax,0x100(%rdx)
    return hpetReg->MAIN_CNT;
  804160de74:	48 8b 8a f0 00 00 00 	mov    0xf0(%rdx),%rcx
    hpetReg->TIM0_COMP = hpet_get_main_cnt() + hpetFreq / 2;
  804160de7b:	48 a1 68 56 40 42 80 	movabs 0x8042405668,%rax
  804160de82:	00 00 00 
  804160de85:	48 d1 e8             	shr    %rax
  804160de88:	48 01 c1             	add    %rax,%rcx
  804160de8b:	48 89 8a 08 01 00 00 	mov    %rcx,0x108(%rdx)
    hpetReg->TIM0_COMP = hpetFreq / 2;
  804160de92:	48 89 82 08 01 00 00 	mov    %rax,0x108(%rdx)
    pic_irq_unmask(IRQ_TIMER);
  804160de99:	bf 00 00 00 00       	mov    $0x0,%edi
  804160de9e:	48 b8 d3 c7 60 41 80 	movabs $0x804160c7d3,%rax
  804160dea5:	00 00 00 
  804160dea8:	ff d0                	call   *%rax
}
  804160deaa:	5d                   	pop    %rbp
  804160deab:	c3                   	ret    

000000804160deac <get_fadt>:
    if (!kfadt)
  804160deac:	48 b8 58 56 40 42 80 	movabs $0x8042405658,%rax
  804160deb3:	00 00 00 
  804160deb6:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160deba:	74 0b                	je     804160dec7 <get_fadt+0x1b>
}
  804160debc:	48 a1 58 56 40 42 80 	movabs 0x8042405658,%rax
  804160dec3:	00 00 00 
  804160dec6:	c3                   	ret    
get_fadt(void) {
  804160dec7:	55                   	push   %rbp
  804160dec8:	48 89 e5             	mov    %rsp,%rbp
        kfadt = acpi_find_table("FACP");
  804160decb:	48 bf a0 31 61 41 80 	movabs $0x80416131a0,%rdi
  804160ded2:	00 00 00 
  804160ded5:	48 b8 cd da 60 41 80 	movabs $0x804160dacd,%rax
  804160dedc:	00 00 00 
  804160dedf:	ff d0                	call   *%rax
  804160dee1:	48 a3 58 56 40 42 80 	movabs %rax,0x8042405658
  804160dee8:	00 00 00 
}
  804160deeb:	48 a1 58 56 40 42 80 	movabs 0x8042405658,%rax
  804160def2:	00 00 00 
  804160def5:	5d                   	pop    %rbp
  804160def6:	c3                   	ret    

000000804160def7 <acpi_enable>:
acpi_enable(void) {
  804160def7:	55                   	push   %rbp
  804160def8:	48 89 e5             	mov    %rsp,%rbp
    FADT *fadt = get_fadt();
  804160defb:	48 b8 ac de 60 41 80 	movabs $0x804160deac,%rax
  804160df02:	00 00 00 
  804160df05:	ff d0                	call   *%rax
  804160df07:	48 89 c1             	mov    %rax,%rcx
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160df0a:	0f b6 40 34          	movzbl 0x34(%rax),%eax
  804160df0e:	8b 51 30             	mov    0x30(%rcx),%edx
  804160df11:	ee                   	out    %al,(%dx)
    while ((inw(fadt->PM1aControlBlock) & 1) == 0) /* nothing */
  804160df12:	8b 51 40             	mov    0x40(%rcx),%edx
    asm volatile("inw %w1,%0"
  804160df15:	66 ed                	in     (%dx),%ax
  804160df17:	a8 01                	test   $0x1,%al
  804160df19:	74 fa                	je     804160df15 <acpi_enable+0x1e>
}
  804160df1b:	5d                   	pop    %rbp
  804160df1c:	c3                   	ret    

000000804160df1d <get_hpet>:
    if (!khpet)
  804160df1d:	48 b8 40 56 40 42 80 	movabs $0x8042405640,%rax
  804160df24:	00 00 00 
  804160df27:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160df2b:	74 0b                	je     804160df38 <get_hpet+0x1b>
}
  804160df2d:	48 a1 40 56 40 42 80 	movabs 0x8042405640,%rax
  804160df34:	00 00 00 
  804160df37:	c3                   	ret    
get_hpet(void) {
  804160df38:	55                   	push   %rbp
  804160df39:	48 89 e5             	mov    %rsp,%rbp
        khpet = acpi_find_table("HPET");
  804160df3c:	48 bf a5 31 61 41 80 	movabs $0x80416131a5,%rdi
  804160df43:	00 00 00 
  804160df46:	48 b8 cd da 60 41 80 	movabs $0x804160dacd,%rax
  804160df4d:	00 00 00 
  804160df50:	ff d0                	call   *%rax
  804160df52:	48 a3 40 56 40 42 80 	movabs %rax,0x8042405640
  804160df59:	00 00 00 
}
  804160df5c:	48 a1 40 56 40 42 80 	movabs 0x8042405640,%rax
  804160df63:	00 00 00 
  804160df66:	5d                   	pop    %rbp
  804160df67:	c3                   	ret    

000000804160df68 <hpet_register>:
hpet_register(void) {
  804160df68:	55                   	push   %rbp
  804160df69:	48 89 e5             	mov    %rsp,%rbp
    HPET *hpet_timer = get_hpet();
  804160df6c:	48 b8 1d df 60 41 80 	movabs $0x804160df1d,%rax
  804160df73:	00 00 00 
  804160df76:	ff d0                	call   *%rax
    if (!hpet_timer->address.address) panic("hpet is unavailable\n");
  804160df78:	48 8b 78 2c          	mov    0x2c(%rax),%rdi
  804160df7c:	48 85 ff             	test   %rdi,%rdi
  804160df7f:	74 13                	je     804160df94 <hpet_register+0x2c>
    return mmio_map_region(paddr, sizeof(HPETRegister));
  804160df81:	be 00 04 00 00       	mov    $0x400,%esi
  804160df86:	48 b8 72 a6 60 41 80 	movabs $0x804160a672,%rax
  804160df8d:	00 00 00 
  804160df90:	ff d0                	call   *%rax
}
  804160df92:	5d                   	pop    %rbp
  804160df93:	c3                   	ret    
    if (!hpet_timer->address.address) panic("hpet is unavailable\n");
  804160df94:	48 ba aa 31 61 41 80 	movabs $0x80416131aa,%rdx
  804160df9b:	00 00 00 
  804160df9e:	be a4 00 00 00       	mov    $0xa4,%esi
  804160dfa3:	48 bf bf 31 61 41 80 	movabs $0x80416131bf,%rdi
  804160dfaa:	00 00 00 
  804160dfad:	b8 00 00 00 00       	mov    $0x0,%eax
  804160dfb2:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160dfb9:	00 00 00 
  804160dfbc:	ff d1                	call   *%rcx

000000804160dfbe <hpet_init>:
    if (hpetReg == NULL) {
  804160dfbe:	48 b8 78 56 40 42 80 	movabs $0x8042405678,%rax
  804160dfc5:	00 00 00 
  804160dfc8:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160dfcc:	74 01                	je     804160dfcf <hpet_init+0x11>
  804160dfce:	c3                   	ret    
hpet_init() {
  804160dfcf:	55                   	push   %rbp
  804160dfd0:	48 89 e5             	mov    %rsp,%rbp
  804160dfd3:	53                   	push   %rbx
  804160dfd4:	48 83 ec 08          	sub    $0x8,%rsp
    asm volatile("inb %w1,%0"
  804160dfd8:	ba 70 00 00 00       	mov    $0x70,%edx
  804160dfdd:	ec                   	in     (%dx),%al
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
  804160dfde:	83 c8 80             	or     $0xffffff80,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160dfe1:	ee                   	out    %al,(%dx)
        hpetReg = hpet_register();
  804160dfe2:	48 b8 68 df 60 41 80 	movabs $0x804160df68,%rax
  804160dfe9:	00 00 00 
  804160dfec:	ff d0                	call   *%rax
  804160dfee:	48 a3 78 56 40 42 80 	movabs %rax,0x8042405678
  804160dff5:	00 00 00 
        uint64_t cap = hpetReg->GCAP_ID;
  804160dff8:	48 8b 10             	mov    (%rax),%rdx
        hpetFemto = (uintptr_t)(cap >> 32);
  804160dffb:	48 89 d6             	mov    %rdx,%rsi
  804160dffe:	48 c1 ee 20          	shr    $0x20,%rsi
  804160e002:	48 89 f0             	mov    %rsi,%rax
  804160e005:	48 a3 70 56 40 42 80 	movabs %rax,0x8042405670
  804160e00c:	00 00 00 
        if (!(cap & HPET_LEG_RT_CAP)) panic("HPET has no LegacyReplacement mode");
  804160e00f:	f6 c6 80             	test   $0x80,%dh
  804160e012:	0f 84 9c 00 00 00    	je     804160e0b4 <hpet_init+0xf6>
        cprintf("hpetFemto = %lu\n", hpetFemto); 
  804160e018:	48 bf cc 31 61 41 80 	movabs $0x80416131cc,%rdi
  804160e01f:	00 00 00 
  804160e022:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e027:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  804160e02e:	00 00 00 
  804160e031:	ff d3                	call   *%rbx
        hpetFreq = (1 * Peta) / hpetFemto;
  804160e033:	48 bf 70 56 40 42 80 	movabs $0x8042405670,%rdi
  804160e03a:	00 00 00 
  804160e03d:	48 b8 00 80 c6 a4 7e 	movabs $0x38d7ea4c68000,%rax
  804160e044:	8d 03 00 
  804160e047:	ba 00 00 00 00       	mov    $0x0,%edx
  804160e04c:	48 f7 37             	divq   (%rdi)
  804160e04f:	48 89 c1             	mov    %rax,%rcx
  804160e052:	48 a3 68 56 40 42 80 	movabs %rax,0x8042405668
  804160e059:	00 00 00 
        cprintf("HPET: Frequency = %ld.%03ldMHz\n", (uintptr_t)(hpetFreq / Mega), (uintptr_t)(hpetFreq % Mega)); 
  804160e05c:	48 be db 34 b6 d7 82 	movabs $0x431bde82d7b634db,%rsi
  804160e063:	de 1b 43 
  804160e066:	48 f7 e6             	mul    %rsi
  804160e069:	48 89 d6             	mov    %rdx,%rsi
  804160e06c:	48 c1 ee 12          	shr    $0x12,%rsi
  804160e070:	48 69 c6 40 42 0f 00 	imul   $0xf4240,%rsi,%rax
  804160e077:	48 29 c1             	sub    %rax,%rcx
  804160e07a:	48 89 ca             	mov    %rcx,%rdx
  804160e07d:	48 bf a8 34 61 41 80 	movabs $0x80416134a8,%rdi
  804160e084:	00 00 00 
  804160e087:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e08c:	ff d3                	call   *%rbx
        hpetReg->GEN_CONF |= HPET_ENABLE_CNF;
  804160e08e:	48 a1 78 56 40 42 80 	movabs 0x8042405678,%rax
  804160e095:	00 00 00 
  804160e098:	48 8b 50 10          	mov    0x10(%rax),%rdx
  804160e09c:	48 83 ca 01          	or     $0x1,%rdx
  804160e0a0:	48 89 50 10          	mov    %rdx,0x10(%rax)
    asm volatile("inb %w1,%0"
  804160e0a4:	ba 70 00 00 00       	mov    $0x70,%edx
  804160e0a9:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804160e0aa:	83 e0 7f             	and    $0x7f,%eax
  804160e0ad:	ee                   	out    %al,(%dx)
}
  804160e0ae:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804160e0b2:	c9                   	leave  
  804160e0b3:	c3                   	ret    
        if (!(cap & HPET_LEG_RT_CAP)) panic("HPET has no LegacyReplacement mode");
  804160e0b4:	48 ba 80 34 61 41 80 	movabs $0x8041613480,%rdx
  804160e0bb:	00 00 00 
  804160e0be:	be d5 00 00 00       	mov    $0xd5,%esi
  804160e0c3:	48 bf bf 31 61 41 80 	movabs $0x80416131bf,%rdi
  804160e0ca:	00 00 00 
  804160e0cd:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e0d2:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  804160e0d9:	00 00 00 
  804160e0dc:	ff d1                	call   *%rcx

000000804160e0de <hpet_print_struct>:
hpet_print_struct(void) {
  804160e0de:	55                   	push   %rbp
  804160e0df:	48 89 e5             	mov    %rsp,%rbp
  804160e0e2:	41 54                	push   %r12
  804160e0e4:	53                   	push   %rbx
    HPET *hpet = get_hpet();
  804160e0e5:	48 b8 1d df 60 41 80 	movabs $0x804160df1d,%rax
  804160e0ec:	00 00 00 
  804160e0ef:	ff d0                	call   *%rax
  804160e0f1:	48 89 c3             	mov    %rax,%rbx
    cprintf("signature = %s\n", (hpet->h).Signature);
  804160e0f4:	48 89 c6             	mov    %rax,%rsi
  804160e0f7:	48 bf dd 31 61 41 80 	movabs $0x80416131dd,%rdi
  804160e0fe:	00 00 00 
  804160e101:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e106:	49 bc 99 c8 60 41 80 	movabs $0x804160c899,%r12
  804160e10d:	00 00 00 
  804160e110:	41 ff d4             	call   *%r12
    cprintf("length = %08x\n", (hpet->h).Length);
  804160e113:	8b 73 04             	mov    0x4(%rbx),%esi
  804160e116:	48 bf ed 31 61 41 80 	movabs $0x80416131ed,%rdi
  804160e11d:	00 00 00 
  804160e120:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e125:	41 ff d4             	call   *%r12
    cprintf("revision = %08x\n", (hpet->h).Revision);
  804160e128:	0f b6 73 08          	movzbl 0x8(%rbx),%esi
  804160e12c:	48 bf 11 32 61 41 80 	movabs $0x8041613211,%rdi
  804160e133:	00 00 00 
  804160e136:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e13b:	41 ff d4             	call   *%r12
    cprintf("checksum = %08x\n", (hpet->h).Checksum);
  804160e13e:	0f b6 73 09          	movzbl 0x9(%rbx),%esi
  804160e142:	48 bf fc 31 61 41 80 	movabs $0x80416131fc,%rdi
  804160e149:	00 00 00 
  804160e14c:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e151:	41 ff d4             	call   *%r12
    cprintf("oem_revision = %08x\n", (hpet->h).OEMRevision);
  804160e154:	8b 73 18             	mov    0x18(%rbx),%esi
  804160e157:	48 bf 0d 32 61 41 80 	movabs $0x804161320d,%rdi
  804160e15e:	00 00 00 
  804160e161:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e166:	41 ff d4             	call   *%r12
    cprintf("creator_id = %08x\n", (hpet->h).CreatorID);
  804160e169:	8b 73 1c             	mov    0x1c(%rbx),%esi
  804160e16c:	48 bf 22 32 61 41 80 	movabs $0x8041613222,%rdi
  804160e173:	00 00 00 
  804160e176:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e17b:	41 ff d4             	call   *%r12
    cprintf("creator_revision = %08x\n", (hpet->h).CreatorRevision);
  804160e17e:	8b 73 20             	mov    0x20(%rbx),%esi
  804160e181:	48 bf 35 32 61 41 80 	movabs $0x8041613235,%rdi
  804160e188:	00 00 00 
  804160e18b:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e190:	41 ff d4             	call   *%r12
    cprintf("hardware_rev_id = %08x\n", hpet->hardware_rev_id);
  804160e193:	0f b6 73 24          	movzbl 0x24(%rbx),%esi
  804160e197:	48 bf 4e 32 61 41 80 	movabs $0x804161324e,%rdi
  804160e19e:	00 00 00 
  804160e1a1:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e1a6:	41 ff d4             	call   *%r12
    cprintf("comparator_count = %08x\n", hpet->comparator_count);
  804160e1a9:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804160e1ad:	83 e6 1f             	and    $0x1f,%esi
  804160e1b0:	48 bf 66 32 61 41 80 	movabs $0x8041613266,%rdi
  804160e1b7:	00 00 00 
  804160e1ba:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e1bf:	41 ff d4             	call   *%r12
    cprintf("counter_size = %08x\n", hpet->counter_size);
  804160e1c2:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804160e1c6:	40 c0 ee 05          	shr    $0x5,%sil
  804160e1ca:	83 e6 01             	and    $0x1,%esi
  804160e1cd:	48 bf 7f 32 61 41 80 	movabs $0x804161327f,%rdi
  804160e1d4:	00 00 00 
  804160e1d7:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e1dc:	41 ff d4             	call   *%r12
    cprintf("reserved = %08x\n", hpet->reserved);
  804160e1df:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804160e1e3:	40 c0 ee 06          	shr    $0x6,%sil
  804160e1e7:	83 e6 01             	and    $0x1,%esi
  804160e1ea:	48 bf 94 32 61 41 80 	movabs $0x8041613294,%rdi
  804160e1f1:	00 00 00 
  804160e1f4:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e1f9:	41 ff d4             	call   *%r12
    cprintf("legacy_replacement = %08x\n", hpet->legacy_replacement);
  804160e1fc:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804160e200:	40 c0 ee 07          	shr    $0x7,%sil
  804160e204:	40 0f b6 f6          	movzbl %sil,%esi
  804160e208:	48 bf a5 32 61 41 80 	movabs $0x80416132a5,%rdi
  804160e20f:	00 00 00 
  804160e212:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e217:	41 ff d4             	call   *%r12
    cprintf("pci_vendor_id = %08x\n", hpet->pci_vendor_id);
  804160e21a:	0f b7 73 26          	movzwl 0x26(%rbx),%esi
  804160e21e:	48 bf c0 32 61 41 80 	movabs $0x80416132c0,%rdi
  804160e225:	00 00 00 
  804160e228:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e22d:	41 ff d4             	call   *%r12
    cprintf("hpet_number = %08x\n", hpet->hpet_number);
  804160e230:	0f b6 73 34          	movzbl 0x34(%rbx),%esi
  804160e234:	48 bf d6 32 61 41 80 	movabs $0x80416132d6,%rdi
  804160e23b:	00 00 00 
  804160e23e:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e243:	41 ff d4             	call   *%r12
    cprintf("minimum_tick = %08x\n", hpet->minimum_tick);
  804160e246:	0f b7 73 35          	movzwl 0x35(%rbx),%esi
  804160e24a:	48 bf ea 32 61 41 80 	movabs $0x80416132ea,%rdi
  804160e251:	00 00 00 
  804160e254:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e259:	41 ff d4             	call   *%r12
    cprintf("address_structure:\n");
  804160e25c:	48 bf ff 32 61 41 80 	movabs $0x80416132ff,%rdi
  804160e263:	00 00 00 
  804160e266:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e26b:	41 ff d4             	call   *%r12
    cprintf("address_space_id = %08x\n", (hpet->address).address_space_id);
  804160e26e:	0f b6 73 28          	movzbl 0x28(%rbx),%esi
  804160e272:	48 bf 13 33 61 41 80 	movabs $0x8041613313,%rdi
  804160e279:	00 00 00 
  804160e27c:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e281:	41 ff d4             	call   *%r12
    cprintf("register_bit_width = %08x\n", (hpet->address).register_bit_width);
  804160e284:	0f b6 73 29          	movzbl 0x29(%rbx),%esi
  804160e288:	48 bf 2c 33 61 41 80 	movabs $0x804161332c,%rdi
  804160e28f:	00 00 00 
  804160e292:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e297:	41 ff d4             	call   *%r12
    cprintf("register_bit_offset = %08x\n", (hpet->address).register_bit_offset);
  804160e29a:	0f b6 73 2a          	movzbl 0x2a(%rbx),%esi
  804160e29e:	48 bf 47 33 61 41 80 	movabs $0x8041613347,%rdi
  804160e2a5:	00 00 00 
  804160e2a8:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e2ad:	41 ff d4             	call   *%r12
    cprintf("address = %08lx\n", (unsigned long)(hpet->address).address);
  804160e2b0:	48 8b 73 2c          	mov    0x2c(%rbx),%rsi
  804160e2b4:	48 bf 63 33 61 41 80 	movabs $0x8041613363,%rdi
  804160e2bb:	00 00 00 
  804160e2be:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e2c3:	41 ff d4             	call   *%r12
}
  804160e2c6:	5b                   	pop    %rbx
  804160e2c7:	41 5c                	pop    %r12
  804160e2c9:	5d                   	pop    %rbp
  804160e2ca:	c3                   	ret    

000000804160e2cb <hpet_print_reg>:
hpet_print_reg(void) {
  804160e2cb:	55                   	push   %rbp
  804160e2cc:	48 89 e5             	mov    %rsp,%rbp
  804160e2cf:	41 54                	push   %r12
  804160e2d1:	53                   	push   %rbx
    cprintf("GCAP_ID = %016lx\n", (unsigned long)hpetReg->GCAP_ID);
  804160e2d2:	49 bc 78 56 40 42 80 	movabs $0x8042405678,%r12
  804160e2d9:	00 00 00 
  804160e2dc:	49 8b 04 24          	mov    (%r12),%rax
  804160e2e0:	48 8b 30             	mov    (%rax),%rsi
  804160e2e3:	48 bf 74 33 61 41 80 	movabs $0x8041613374,%rdi
  804160e2ea:	00 00 00 
  804160e2ed:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e2f2:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  804160e2f9:	00 00 00 
  804160e2fc:	ff d3                	call   *%rbx
    cprintf("GEN_CONF = %016lx\n", (unsigned long)hpetReg->GEN_CONF);
  804160e2fe:	49 8b 04 24          	mov    (%r12),%rax
  804160e302:	48 8b 70 10          	mov    0x10(%rax),%rsi
  804160e306:	48 bf 86 33 61 41 80 	movabs $0x8041613386,%rdi
  804160e30d:	00 00 00 
  804160e310:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e315:	ff d3                	call   *%rbx
    cprintf("GINTR_STA = %016lx\n", (unsigned long)hpetReg->GINTR_STA);
  804160e317:	49 8b 04 24          	mov    (%r12),%rax
  804160e31b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  804160e31f:	48 bf 99 33 61 41 80 	movabs $0x8041613399,%rdi
  804160e326:	00 00 00 
  804160e329:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e32e:	ff d3                	call   *%rbx
    cprintf("MAIN_CNT = %016lx\n", (unsigned long)hpetReg->MAIN_CNT);
  804160e330:	49 8b 04 24          	mov    (%r12),%rax
  804160e334:	48 8b b0 f0 00 00 00 	mov    0xf0(%rax),%rsi
  804160e33b:	48 bf ad 33 61 41 80 	movabs $0x80416133ad,%rdi
  804160e342:	00 00 00 
  804160e345:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e34a:	ff d3                	call   *%rbx
    cprintf("TIM0_CONF = %016lx\n", (unsigned long)hpetReg->TIM0_CONF);
  804160e34c:	49 8b 04 24          	mov    (%r12),%rax
  804160e350:	48 8b b0 00 01 00 00 	mov    0x100(%rax),%rsi
  804160e357:	48 bf c0 33 61 41 80 	movabs $0x80416133c0,%rdi
  804160e35e:	00 00 00 
  804160e361:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e366:	ff d3                	call   *%rbx
    cprintf("TIM0_COMP = %016lx\n", (unsigned long)hpetReg->TIM0_COMP);
  804160e368:	49 8b 04 24          	mov    (%r12),%rax
  804160e36c:	48 8b b0 08 01 00 00 	mov    0x108(%rax),%rsi
  804160e373:	48 bf d4 33 61 41 80 	movabs $0x80416133d4,%rdi
  804160e37a:	00 00 00 
  804160e37d:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e382:	ff d3                	call   *%rbx
    cprintf("TIM0_FSB = %016lx\n", (unsigned long)hpetReg->TIM0_FSB);
  804160e384:	49 8b 04 24          	mov    (%r12),%rax
  804160e388:	48 8b b0 10 01 00 00 	mov    0x110(%rax),%rsi
  804160e38f:	48 bf e8 33 61 41 80 	movabs $0x80416133e8,%rdi
  804160e396:	00 00 00 
  804160e399:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e39e:	ff d3                	call   *%rbx
    cprintf("TIM1_CONF = %016lx\n", (unsigned long)hpetReg->TIM1_CONF);
  804160e3a0:	49 8b 04 24          	mov    (%r12),%rax
  804160e3a4:	48 8b b0 20 01 00 00 	mov    0x120(%rax),%rsi
  804160e3ab:	48 bf fb 33 61 41 80 	movabs $0x80416133fb,%rdi
  804160e3b2:	00 00 00 
  804160e3b5:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e3ba:	ff d3                	call   *%rbx
    cprintf("TIM1_COMP = %016lx\n", (unsigned long)hpetReg->TIM1_COMP);
  804160e3bc:	49 8b 04 24          	mov    (%r12),%rax
  804160e3c0:	48 8b b0 28 01 00 00 	mov    0x128(%rax),%rsi
  804160e3c7:	48 bf 0f 34 61 41 80 	movabs $0x804161340f,%rdi
  804160e3ce:	00 00 00 
  804160e3d1:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e3d6:	ff d3                	call   *%rbx
    cprintf("TIM1_FSB = %016lx\n", (unsigned long)hpetReg->TIM1_FSB);
  804160e3d8:	49 8b 04 24          	mov    (%r12),%rax
  804160e3dc:	48 8b b0 30 01 00 00 	mov    0x130(%rax),%rsi
  804160e3e3:	48 bf 23 34 61 41 80 	movabs $0x8041613423,%rdi
  804160e3ea:	00 00 00 
  804160e3ed:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e3f2:	ff d3                	call   *%rbx
    cprintf("TIM2_CONF = %016lx\n", (unsigned long)hpetReg->TIM2_CONF);
  804160e3f4:	49 8b 04 24          	mov    (%r12),%rax
  804160e3f8:	48 8b b0 40 01 00 00 	mov    0x140(%rax),%rsi
  804160e3ff:	48 bf 36 34 61 41 80 	movabs $0x8041613436,%rdi
  804160e406:	00 00 00 
  804160e409:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e40e:	ff d3                	call   *%rbx
    cprintf("TIM2_COMP = %016lx\n", (unsigned long)hpetReg->TIM2_COMP);
  804160e410:	49 8b 04 24          	mov    (%r12),%rax
  804160e414:	48 8b b0 48 01 00 00 	mov    0x148(%rax),%rsi
  804160e41b:	48 bf 4a 34 61 41 80 	movabs $0x804161344a,%rdi
  804160e422:	00 00 00 
  804160e425:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e42a:	ff d3                	call   *%rbx
    cprintf("TIM2_FSB = %016lx\n", (unsigned long)hpetReg->TIM2_FSB);
  804160e42c:	49 8b 04 24          	mov    (%r12),%rax
  804160e430:	48 8b b0 50 01 00 00 	mov    0x150(%rax),%rsi
  804160e437:	48 bf 5e 34 61 41 80 	movabs $0x804161345e,%rdi
  804160e43e:	00 00 00 
  804160e441:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e446:	ff d3                	call   *%rbx
}
  804160e448:	5b                   	pop    %rbx
  804160e449:	41 5c                	pop    %r12
  804160e44b:	5d                   	pop    %rbp
  804160e44c:	c3                   	ret    

000000804160e44d <hpet_get_main_cnt>:
    return hpetReg->MAIN_CNT;
  804160e44d:	48 a1 78 56 40 42 80 	movabs 0x8042405678,%rax
  804160e454:	00 00 00 
  804160e457:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
}
  804160e45e:	c3                   	ret    

000000804160e45f <pmtimer_get_32_or_24>:

static int pmtimer_is_32bit = 0;
#define TMR_VAL_EXT (1U << 8U)

uint32_t 
pmtimer_get_32_or_24(uint32_t value) {
  804160e45f:	89 f8                	mov    %edi,%eax
    int res = value;

    if (!pmtimer_is_32bit) {
        res &= 0xFFFFFF;
  804160e461:	89 fa                	mov    %edi,%edx
  804160e463:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
  804160e469:	48 b9 60 56 40 42 80 	movabs $0x8042405660,%rcx
  804160e470:	00 00 00 
  804160e473:	83 39 00             	cmpl   $0x0,(%rcx)
  804160e476:	0f 44 c2             	cmove  %edx,%eax
    }

    return res;
}
  804160e479:	c3                   	ret    

000000804160e47a <pmtimer_get_timeval>:

uint32_t
pmtimer_get_timeval(void) {
  804160e47a:	55                   	push   %rbp
  804160e47b:	48 89 e5             	mov    %rsp,%rbp
    static FADT *fadt = NULL;
     if (!fadt)
  804160e47e:	48 b8 30 56 40 42 80 	movabs $0x8042405630,%rax
  804160e485:	00 00 00 
  804160e488:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160e48c:	74 32                	je     804160e4c0 <pmtimer_get_timeval+0x46>
        fadt = get_fadt();
    pmtimer_is_32bit = fadt->Flags & TMR_VAL_EXT;
  804160e48e:	48 b8 30 56 40 42 80 	movabs $0x8042405630,%rax
  804160e495:	00 00 00 
  804160e498:	48 8b 10             	mov    (%rax),%rdx
  804160e49b:	8b 42 70             	mov    0x70(%rdx),%eax
  804160e49e:	25 00 01 00 00       	and    $0x100,%eax
  804160e4a3:	a3 60 56 40 42 80 00 	movabs %eax,0x8042405660
  804160e4aa:	00 00 
    asm volatile("inl %w1,%0"
  804160e4ac:	8b 52 4c             	mov    0x4c(%rdx),%edx
  804160e4af:	ed                   	in     (%dx),%eax
  804160e4b0:	89 c7                	mov    %eax,%edi
    return pmtimer_get_32_or_24(inl(fadt->PMTimerBlock));
  804160e4b2:	48 b8 5f e4 60 41 80 	movabs $0x804160e45f,%rax
  804160e4b9:	00 00 00 
  804160e4bc:	ff d0                	call   *%rax
}
  804160e4be:	5d                   	pop    %rbp
  804160e4bf:	c3                   	ret    
        fadt = get_fadt();
  804160e4c0:	48 b8 ac de 60 41 80 	movabs $0x804160deac,%rax
  804160e4c7:	00 00 00 
  804160e4ca:	ff d0                	call   *%rax
  804160e4cc:	48 a3 30 56 40 42 80 	movabs %rax,0x8042405630
  804160e4d3:	00 00 00 
  804160e4d6:	eb b6                	jmp    804160e48e <pmtimer_get_timeval+0x14>

000000804160e4d8 <pmtimer_cpu_frequency>:
pmtimer_cpu_frequency(void) {
    static uint64_t cpu_freq = 0;


    // LAB 5: Your code here
    if (!cpu_freq) {
  804160e4d8:	48 b8 28 56 40 42 80 	movabs $0x8042405628,%rax
  804160e4df:	00 00 00 
  804160e4e2:	48 83 38 00          	cmpq   $0x0,(%rax)
  804160e4e6:	74 0b                	je     804160e4f3 <pmtimer_cpu_frequency+0x1b>
        cpu_freq = (tsc_after - tsc_before) * time_int;

    }

    return cpu_freq;
}
  804160e4e8:	48 a1 28 56 40 42 80 	movabs 0x8042405628,%rax
  804160e4ef:	00 00 00 
  804160e4f2:	c3                   	ret    
pmtimer_cpu_frequency(void) {
  804160e4f3:	55                   	push   %rbp
  804160e4f4:	48 89 e5             	mov    %rsp,%rbp
  804160e4f7:	41 55                	push   %r13
  804160e4f9:	41 54                	push   %r12
  804160e4fb:	53                   	push   %rbx
  804160e4fc:	48 83 ec 08          	sub    $0x8,%rsp
        uint32_t start = pmtimer_get_timeval();
  804160e500:	48 b8 7a e4 60 41 80 	movabs $0x804160e47a,%rax
  804160e507:	00 00 00 
  804160e50a:	ff d0                	call   *%rax
  804160e50c:	89 c3                	mov    %eax,%ebx
    asm volatile("rdtsc"
  804160e50e:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804160e510:	48 c1 e2 20          	shl    $0x20,%rdx
  804160e514:	89 c0                	mov    %eax,%eax
  804160e516:	48 09 c2             	or     %rax,%rdx
  804160e519:	49 89 d5             	mov    %rdx,%r13
          counter = pmtimer_get_timeval() - start;
  804160e51c:	49 bc 7a e4 60 41 80 	movabs $0x804160e47a,%r12
  804160e523:	00 00 00 
          asm("pause");
  804160e526:	f3 90                	pause  
          counter = pmtimer_get_timeval() - start;
  804160e528:	41 ff d4             	call   *%r12
  804160e52b:	29 d8                	sub    %ebx,%eax
        } while (counter < target);
  804160e52d:	3d d2 8b 00 00       	cmp    $0x8bd2,%eax
  804160e532:	76 f2                	jbe    804160e526 <pmtimer_cpu_frequency+0x4e>
    asm volatile("rdtsc"
  804160e534:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804160e536:	48 c1 e2 20          	shl    $0x20,%rdx
  804160e53a:	89 c0                	mov    %eax,%eax
  804160e53c:	48 09 c2             	or     %rax,%rdx
        cpu_freq = (tsc_after - tsc_before) * time_int;
  804160e53f:	48 89 d0             	mov    %rdx,%rax
  804160e542:	4c 29 e8             	sub    %r13,%rax
  804160e545:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  804160e549:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  804160e54d:	48 c1 e0 02          	shl    $0x2,%rax
  804160e551:	48 a3 28 56 40 42 80 	movabs %rax,0x8042405628
  804160e558:	00 00 00 
}
  804160e55b:	48 a1 28 56 40 42 80 	movabs 0x8042405628,%rax
  804160e562:	00 00 00 
  804160e565:	48 83 c4 08          	add    $0x8,%rsp
  804160e569:	5b                   	pop    %rbx
  804160e56a:	41 5c                	pop    %r12
  804160e56c:	41 5d                	pop    %r13
  804160e56e:	5d                   	pop    %rbp
  804160e56f:	c3                   	ret    

000000804160e570 <sched_halt>:
sched_halt(void) {

    /* For debugging and testing purposes, if there are no runnable
     * environments in the system, then drop into the kernel monitor */
    int i;
    for (i = 0; i < NENV; i++)
  804160e570:	48 a1 48 44 40 42 80 	movabs 0x8042404448,%rax
  804160e577:	00 00 00 
  804160e57a:	48 8d 90 d4 00 00 00 	lea    0xd4(%rax),%rdx
  804160e581:	b9 00 00 00 00       	mov    $0x0,%ecx
        if (envs[i].env_status == ENV_RUNNABLE ||
  804160e586:	8b 02                	mov    (%rdx),%eax
  804160e588:	83 e8 02             	sub    $0x2,%eax
  804160e58b:	83 f8 01             	cmp    $0x1,%eax
  804160e58e:	76 49                	jbe    804160e5d9 <sched_halt+0x69>
    for (i = 0; i < NENV; i++)
  804160e590:	83 c1 01             	add    $0x1,%ecx
  804160e593:	48 81 c2 30 01 00 00 	add    $0x130,%rdx
  804160e59a:	81 f9 00 04 00 00    	cmp    $0x400,%ecx
  804160e5a0:	75 e4                	jne    804160e586 <sched_halt+0x16>
sched_halt(void) {
  804160e5a2:	55                   	push   %rbp
  804160e5a3:	48 89 e5             	mov    %rsp,%rbp
  804160e5a6:	53                   	push   %rbx
  804160e5a7:	48 83 ec 08          	sub    $0x8,%rsp
            envs[i].env_status == ENV_RUNNING) break;
    if (i == NENV) {
        cprintf("No runnable environments in the system!\n");
  804160e5ab:	48 bf c8 34 61 41 80 	movabs $0x80416134c8,%rdi
  804160e5b2:	00 00 00 
  804160e5b5:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e5ba:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160e5c1:	00 00 00 
  804160e5c4:	ff d2                	call   *%rdx
        for (;;) monitor(NULL);
  804160e5c6:	48 bb b1 45 60 41 80 	movabs $0x80416045b1,%rbx
  804160e5cd:	00 00 00 
  804160e5d0:	bf 00 00 00 00       	mov    $0x0,%edi
  804160e5d5:	ff d3                	call   *%rbx
  804160e5d7:	eb f7                	jmp    804160e5d0 <sched_halt+0x60>
    if (i == NENV) {
  804160e5d9:	81 f9 00 04 00 00    	cmp    $0x400,%ecx
  804160e5df:	74 c1                	je     804160e5a2 <sched_halt+0x32>
    }

    /* Mark that no environment is running on CPU */
    curenv = NULL;
  804160e5e1:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160e5e8:	00 00 00 
  804160e5eb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* Reset stack pointer, enable interrupts and then halt */
    asm volatile(
  804160e5f2:	48 a1 84 56 40 42 80 	movabs 0x8042405684,%rax
  804160e5f9:	00 00 00 
  804160e5fc:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  804160e603:	48 89 c4             	mov    %rax,%rsp
  804160e606:	6a 00                	push   $0x0
  804160e608:	6a 00                	push   $0x0
  804160e60a:	fb                   	sti    
  804160e60b:	f4                   	hlt    
            "pushq $0\n"
            "sti\n"
            "hlt\n" ::"a"(cpu_ts.ts_rsp0));

    /* Unreachable */
    for (;;)
  804160e60c:	eb fe                	jmp    804160e60c <sched_halt+0x9c>

000000804160e60e <sched_yield>:
sched_yield(void) {
  804160e60e:	55                   	push   %rbp
  804160e60f:	48 89 e5             	mov    %rsp,%rbp
    int i = curenv ? (ENVX(curenv->env_id) + 1 % NENV) : 0; 
  804160e612:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160e619:	00 00 00 
  804160e61c:	4c 8b 00             	mov    (%rax),%r8
  804160e61f:	4d 85 c0             	test   %r8,%r8
  804160e622:	0f 84 c1 00 00 00    	je     804160e6e9 <sched_yield+0xdb>
  804160e628:	41 8b b0 c8 00 00 00 	mov    0xc8(%r8),%esi
  804160e62f:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
  804160e635:	83 c6 01             	add    $0x1,%esi
    for (;i < NENV; i = (i + 1) % NENV) {
  804160e638:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
  804160e63e:	7f 6c                	jg     804160e6ac <sched_yield+0x9e>
            if (envs[j].env_status == ENV_RUNNABLE)
  804160e640:	48 a1 48 44 40 42 80 	movabs 0x8042404448,%rax
  804160e647:	00 00 00 
  804160e64a:	eb 38                	jmp    804160e684 <sched_yield+0x76>
       if (j == NENV)
  804160e64c:	81 fa 00 04 00 00    	cmp    $0x400,%edx
  804160e652:	74 53                	je     804160e6a7 <sched_yield+0x99>
       if (envs[i].env_status == ENV_RUNNABLE) 
  804160e654:	48 63 d6             	movslq %esi,%rdx
  804160e657:	48 8d 0c d2          	lea    (%rdx,%rdx,8),%rcx
  804160e65b:	48 8d 3c 4a          	lea    (%rdx,%rcx,2),%rdi
  804160e65f:	48 c1 e7 04          	shl    $0x4,%rdi
  804160e663:	48 01 c7             	add    %rax,%rdi
  804160e666:	83 bf d4 00 00 00 02 	cmpl   $0x2,0xd4(%rdi)
  804160e66d:	74 6e                	je     804160e6dd <sched_yield+0xcf>
    for (;i < NENV; i = (i + 1) % NENV) {
  804160e66f:	83 c6 01             	add    $0x1,%esi
  804160e672:	89 f2                	mov    %esi,%edx
  804160e674:	c1 fa 1f             	sar    $0x1f,%edx
  804160e677:	c1 ea 16             	shr    $0x16,%edx
  804160e67a:	01 d6                	add    %edx,%esi
  804160e67c:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
  804160e682:	29 d6                	sub    %edx,%esi
       for (; j < NENV; ++j) {
  804160e684:	48 8d 88 d4 00 00 00 	lea    0xd4(%rax),%rcx
       int j = 0;
  804160e68b:	ba 00 00 00 00       	mov    $0x0,%edx
            if (envs[j].env_status == ENV_RUNNABLE)
  804160e690:	83 39 02             	cmpl   $0x2,(%rcx)
  804160e693:	74 b7                	je     804160e64c <sched_yield+0x3e>
       for (; j < NENV; ++j) {
  804160e695:	83 c2 01             	add    $0x1,%edx
  804160e698:	48 81 c1 30 01 00 00 	add    $0x130,%rcx
  804160e69f:	81 fa 00 04 00 00    	cmp    $0x400,%edx
  804160e6a5:	75 e9                	jne    804160e690 <sched_yield+0x82>
    if (curenv && curenv->env_status == ENV_RUNNING) 
  804160e6a7:	4d 85 c0             	test   %r8,%r8
  804160e6aa:	74 0a                	je     804160e6b6 <sched_yield+0xa8>
  804160e6ac:	41 83 b8 d4 00 00 00 	cmpl   $0x3,0xd4(%r8)
  804160e6b3:	03 
  804160e6b4:	74 3d                	je     804160e6f3 <sched_yield+0xe5>
    cprintf("Halt\n");
  804160e6b6:	48 bf f1 34 61 41 80 	movabs $0x80416134f1,%rdi
  804160e6bd:	00 00 00 
  804160e6c0:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e6c5:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160e6cc:	00 00 00 
  804160e6cf:	ff d2                	call   *%rdx
    sched_halt();
  804160e6d1:	48 b8 70 e5 60 41 80 	movabs $0x804160e570,%rax
  804160e6d8:	00 00 00 
  804160e6db:	ff d0                	call   *%rax
            env_run(&envs[i]);
  804160e6dd:	48 b8 cd c1 60 41 80 	movabs $0x804160c1cd,%rax
  804160e6e4:	00 00 00 
  804160e6e7:	ff d0                	call   *%rax
    int i = curenv ? (ENVX(curenv->env_id) + 1 % NENV) : 0; 
  804160e6e9:	be 00 00 00 00       	mov    $0x0,%esi
  804160e6ee:	e9 4d ff ff ff       	jmp    804160e640 <sched_yield+0x32>
         env_run(curenv);
  804160e6f3:	4c 89 c7             	mov    %r8,%rdi
  804160e6f6:	48 b8 cd c1 60 41 80 	movabs $0x804160c1cd,%rax
  804160e6fd:	00 00 00 
  804160e700:	ff d0                	call   *%rax

000000804160e702 <syscall>:

}

/* Dispatches to the correct kernel function, passing the arguments. */
uintptr_t
syscall(uintptr_t syscallno, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6) {
  804160e702:	55                   	push   %rbp
  804160e703:	48 89 e5             	mov    %rsp,%rbp
  804160e706:	41 57                	push   %r15
  804160e708:	41 56                	push   %r14
  804160e70a:	41 55                	push   %r13
  804160e70c:	41 54                	push   %r12
  804160e70e:	53                   	push   %rbx
  804160e70f:	48 83 ec 28          	sub    $0x28,%rsp
  804160e713:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    /* Call the function corresponding to the 'syscallno' parameter.
     * Return any appropriate return value. */
    // LAB 9: Your code here
    switch(syscallno) {
  804160e717:	48 83 ff 10          	cmp    $0x10,%rdi
  804160e71b:	0f 87 94 06 00 00    	ja     804160edb5 <syscall+0x6b3>
  804160e721:	48 89 fb             	mov    %rdi,%rbx
  804160e724:	49 89 f5             	mov    %rsi,%r13
  804160e727:	49 89 d4             	mov    %rdx,%r12
  804160e72a:	49 89 ce             	mov    %rcx,%r14
  804160e72d:	4d 89 c7             	mov    %r8,%r15
  804160e730:	48 b8 30 35 61 41 80 	movabs $0x8041613530,%rax
  804160e737:	00 00 00 
  804160e73a:	ff 24 f8             	jmp    *(%rax,%rdi,8)
    user_mem_assert(curenv, s, len, PROT_R);
  804160e73d:	b9 04 00 00 00       	mov    $0x4,%ecx
  804160e742:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160e749:	00 00 00 
  804160e74c:	48 8b 38             	mov    (%rax),%rdi
  804160e74f:	48 b8 ca b7 60 41 80 	movabs $0x804160b7ca,%rax
  804160e756:	00 00 00 
  804160e759:	ff d0                	call   *%rax
    cprintf("%.*s", (int)len, s);
  804160e75b:	4c 89 ea             	mov    %r13,%rdx
  804160e75e:	44 89 e6             	mov    %r12d,%esi
  804160e761:	48 bf 2a 35 61 41 80 	movabs $0x804161352a,%rdi
  804160e768:	00 00 00 
  804160e76b:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e770:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  804160e777:	00 00 00 
  804160e77a:	ff d1                	call   *%rcx
         case SYS_cputs: 
             return sys_cputs((const char*)a1, (size_t)a2);
  804160e77c:	48 89 d8             	mov    %rbx,%rax
    // LAB 9: Your code here
    // LAB 11: Your code here
    // LAB 12: Your code here

    return -E_NO_SYS;
}
  804160e77f:	48 83 c4 28          	add    $0x28,%rsp
  804160e783:	5b                   	pop    %rbx
  804160e784:	41 5c                	pop    %r12
  804160e786:	41 5d                	pop    %r13
  804160e788:	41 5e                	pop    %r14
  804160e78a:	41 5f                	pop    %r15
  804160e78c:	5d                   	pop    %rbp
  804160e78d:	c3                   	ret    
    return cons_getc();
  804160e78e:	48 b8 64 0b 60 41 80 	movabs $0x8041600b64,%rax
  804160e795:	00 00 00 
  804160e798:	ff d0                	call   *%rax
             return sys_cgetc();
  804160e79a:	48 98                	cltq   
  804160e79c:	eb e1                	jmp    804160e77f <syscall+0x7d>
    if (!curenv)
  804160e79e:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160e7a5:	00 00 00 
  804160e7a8:	48 85 c0             	test   %rax,%rax
  804160e7ab:	74 0a                	je     804160e7b7 <syscall+0xb5>
    return curenv->env_id;
  804160e7ad:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
             return sys_getenvid();
  804160e7b3:	48 98                	cltq   
  804160e7b5:	eb c8                	jmp    804160e77f <syscall+0x7d>
        return -E_BAD_ENV;
  804160e7b7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804160e7bc:	eb f5                	jmp    804160e7b3 <syscall+0xb1>
    res = envid2env(envid, &env, 1);
  804160e7be:	ba 01 00 00 00       	mov    $0x1,%edx
  804160e7c3:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160e7c7:	44 89 ef             	mov    %r13d,%edi
  804160e7ca:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160e7d1:	00 00 00 
  804160e7d4:	ff d0                	call   *%rax
  804160e7d6:	89 c3                	mov    %eax,%ebx
    if (res)
  804160e7d8:	85 c0                	test   %eax,%eax
  804160e7da:	75 58                	jne    804160e834 <syscall+0x132>
                curenv->env_id, env->env_id);
  804160e7dc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
        cprintf(env == curenv ?
  804160e7e0:	8b 8a c8 00 00 00    	mov    0xc8(%rdx),%ecx
                curenv->env_id, env->env_id);
  804160e7e6:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160e7ed:	00 00 00 
        cprintf(env == curenv ?
  804160e7f0:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  804160e7f6:	48 39 c2             	cmp    %rax,%rdx
  804160e7f9:	48 bf f7 34 61 41 80 	movabs $0x80416134f7,%rdi
  804160e800:	00 00 00 
  804160e803:	48 b8 12 35 61 41 80 	movabs $0x8041613512,%rax
  804160e80a:	00 00 00 
  804160e80d:	48 0f 45 f8          	cmovne %rax,%rdi
  804160e811:	89 ca                	mov    %ecx,%edx
  804160e813:	b8 00 00 00 00       	mov    $0x0,%eax
  804160e818:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  804160e81f:	00 00 00 
  804160e822:	ff d1                	call   *%rcx
    env_destroy(env);
  804160e824:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160e828:	48 b8 5e c0 60 41 80 	movabs $0x804160c05e,%rax
  804160e82f:	00 00 00 
  804160e832:	ff d0                	call   *%rax
             return sys_env_destroy((envid_t)a1);
  804160e834:	48 63 c3             	movslq %ebx,%rax
  804160e837:	e9 43 ff ff ff       	jmp    804160e77f <syscall+0x7d>
    res = env_alloc(&n_env, curenv->env_id, ENV_TYPE_USER);
  804160e83c:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160e843:	00 00 00 
  804160e846:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  804160e84c:	ba 02 00 00 00       	mov    $0x2,%edx
  804160e851:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804160e855:	48 b8 d1 ba 60 41 80 	movabs $0x804160bad1,%rax
  804160e85c:	00 00 00 
  804160e85f:	ff d0                	call   *%rax
    if (res < 0)
  804160e861:	85 c0                	test   %eax,%eax
  804160e863:	78 38                	js     804160e89d <syscall+0x19b>
    n_env->env_status = ENV_NOT_RUNNABLE;
  804160e865:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804160e869:	c7 82 d4 00 00 00 04 	movl   $0x4,0xd4(%rdx)
  804160e870:	00 00 00 
    n_env->env_tf = curenv->env_tf;
  804160e873:	48 b8 50 44 40 42 80 	movabs $0x8042404450,%rax
  804160e87a:	00 00 00 
  804160e87d:	48 8b 30             	mov    (%rax),%rsi
  804160e880:	b9 18 00 00 00       	mov    $0x18,%ecx
  804160e885:	48 89 d7             	mov    %rdx,%rdi
  804160e888:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    n_env->env_tf.tf_regs.reg_rax = 0;
  804160e88b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160e88f:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  804160e896:	00 
    return n_env->env_id;
  804160e897:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
             return sys_exofork();
  804160e89d:	48 98                	cltq   
  804160e89f:	e9 db fe ff ff       	jmp    804160e77f <syscall+0x7d>
    res = envid2env(envid, &env, 1);
  804160e8a4:	ba 01 00 00 00       	mov    $0x1,%edx
  804160e8a9:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160e8ad:	44 89 ef             	mov    %r13d,%edi
  804160e8b0:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160e8b7:	00 00 00 
  804160e8ba:	ff d0                	call   *%rax
    if (res < 0)
  804160e8bc:	85 c0                	test   %eax,%eax
  804160e8be:	78 22                	js     804160e8e2 <syscall+0x1e0>
    switch(status) {
  804160e8c0:	41 8d 54 24 fe       	lea    -0x2(%r12),%edx
  804160e8c5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160e8ca:	f7 c2 fd ff ff ff    	test   $0xfffffffd,%edx
  804160e8d0:	75 10                	jne    804160e8e2 <syscall+0x1e0>
    env->env_status = status;
  804160e8d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160e8d6:	44 89 a0 d4 00 00 00 	mov    %r12d,0xd4(%rax)
    return 0;
  804160e8dd:	b8 00 00 00 00       	mov    $0x0,%eax
             return sys_env_set_status((envid_t)a1, (int)a2);
  804160e8e2:	48 98                	cltq   
  804160e8e4:	e9 96 fe ff ff       	jmp    804160e77f <syscall+0x7d>
    res = envid2env(envid, &env, 1);
  804160e8e9:	ba 01 00 00 00       	mov    $0x1,%edx
  804160e8ee:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160e8f2:	44 89 ef             	mov    %r13d,%edi
  804160e8f5:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160e8fc:	00 00 00 
  804160e8ff:	ff d0                	call   *%rax
    if (res < 0)
  804160e901:	85 c0                	test   %eax,%eax
  804160e903:	78 49                	js     804160e94e <syscall+0x24c>
    if (addr >= MAX_USER_ADDRESS)
  804160e905:	48 b8 ff ff ff ff 7f 	movabs $0x7fffffffff,%rax
  804160e90c:	00 00 00 
  804160e90f:	49 39 c4             	cmp    %rax,%r12
  804160e912:	77 41                	ja     804160e955 <syscall+0x253>
    if (perm & ~PROT_ALL)
  804160e914:	41 f7 c7 00 f0 ff ff 	test   $0xfffff000,%r15d
  804160e91b:	75 3f                	jne    804160e95c <syscall+0x25a>
    return map_region(&env->address_space, addr, NULL, 0, size, perm | PROT_USER_ | PROT_LAZY);
  804160e91d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160e921:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804160e928:	45 89 f9             	mov    %r15d,%r9d
  804160e92b:	41 81 c9 a0 00 10 00 	or     $0x1000a0,%r9d
  804160e932:	4d 89 f0             	mov    %r14,%r8
  804160e935:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160e93a:	ba 00 00 00 00       	mov    $0x0,%edx
  804160e93f:	4c 89 e6             	mov    %r12,%rsi
  804160e942:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160e949:	00 00 00 
  804160e94c:	ff d0                	call   *%rax
             return sys_alloc_region((envid_t)a1, (uintptr_t)a2, (size_t)a3, (int)a4);
  804160e94e:	48 98                	cltq   
  804160e950:	e9 2a fe ff ff       	jmp    804160e77f <syscall+0x7d>
        return -E_INVAL;
  804160e955:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160e95a:	eb f2                	jmp    804160e94e <syscall+0x24c>
        return -E_INVAL;
  804160e95c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160e961:	eb eb                	jmp    804160e94e <syscall+0x24c>
    res = envid2env(srcenvid, &src, 1);
  804160e963:	ba 01 00 00 00       	mov    $0x1,%edx
  804160e968:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  804160e96c:	44 89 ef             	mov    %r13d,%edi
  804160e96f:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160e976:	00 00 00 
  804160e979:	ff d0                	call   *%rax
    if (res < 0)
  804160e97b:	85 c0                	test   %eax,%eax
  804160e97d:	78 6d                	js     804160e9ec <syscall+0x2ea>
    res = envid2env(dstenvid, &dst, 1);
  804160e97f:	ba 01 00 00 00       	mov    $0x1,%edx
  804160e984:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160e988:	44 89 f7             	mov    %r14d,%edi
  804160e98b:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160e992:	00 00 00 
  804160e995:	ff d0                	call   *%rax
    if (res < 0)
  804160e997:	85 c0                	test   %eax,%eax
  804160e999:	78 51                	js     804160e9ec <syscall+0x2ea>
    if (srcva >= MAX_USER_ADDRESS || dstva >= MAX_USER_ADDRESS)
  804160e99b:	48 b8 ff ff ff ff 7f 	movabs $0x7fffffffff,%rax
  804160e9a2:	00 00 00 
  804160e9a5:	49 39 c4             	cmp    %rax,%r12
  804160e9a8:	77 49                	ja     804160e9f3 <syscall+0x2f1>
  804160e9aa:	49 39 c7             	cmp    %rax,%r15
  804160e9ad:	77 44                	ja     804160e9f3 <syscall+0x2f1>
    if (perm & ~PROT_ALL || perm & ALLOC_ONE || perm & ALLOC_ZERO) 
  804160e9af:	f7 45 10 00 f0 ff ff 	testl  $0xfffff000,0x10(%rbp)
  804160e9b6:	75 42                	jne    804160e9fa <syscall+0x2f8>
    return map_region(&dst->address_space, dstva, &src->address_space, srcva, size, perm | PROT_USER_);
  804160e9b8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804160e9bc:	48 8d 90 e8 00 00 00 	lea    0xe8(%rax),%rdx
  804160e9c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160e9c7:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804160e9ce:	44 8b 4d 10          	mov    0x10(%rbp),%r9d
  804160e9d2:	41 83 c9 20          	or     $0x20,%r9d
  804160e9d6:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  804160e9da:	4c 89 e1             	mov    %r12,%rcx
  804160e9dd:	4c 89 fe             	mov    %r15,%rsi
  804160e9e0:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160e9e7:	00 00 00 
  804160e9ea:	ff d0                	call   *%rax
             return sys_map_region((envid_t)a1, (uintptr_t)a2, (envid_t)a3, (uintptr_t)a4, (size_t)a5, (int)a6);
  804160e9ec:	48 98                	cltq   
  804160e9ee:	e9 8c fd ff ff       	jmp    804160e77f <syscall+0x7d>
        return -E_INVAL;
  804160e9f3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160e9f8:	eb f2                	jmp    804160e9ec <syscall+0x2ea>
        return -E_INVAL;
  804160e9fa:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160e9ff:	eb eb                	jmp    804160e9ec <syscall+0x2ea>
    res = envid2env(envid, &env, 1);
  804160ea01:	ba 01 00 00 00       	mov    $0x1,%edx
  804160ea06:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160ea0a:	44 89 ef             	mov    %r13d,%edi
  804160ea0d:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160ea14:	00 00 00 
  804160ea17:	ff d0                	call   *%rax
    if (res < 0) 
  804160ea19:	85 c0                	test   %eax,%eax
  804160ea1b:	78 3a                	js     804160ea57 <syscall+0x355>
    if (va & CLASS_MASK(0) || va >= MAX_USER_ADDRESS)
  804160ea1d:	41 f7 c4 ff 0f 00 00 	test   $0xfff,%r12d
  804160ea24:	75 38                	jne    804160ea5e <syscall+0x35c>
  804160ea26:	48 b8 ff ff ff ff 7f 	movabs $0x7fffffffff,%rax
  804160ea2d:	00 00 00 
  804160ea30:	49 39 c4             	cmp    %rax,%r12
  804160ea33:	77 29                	ja     804160ea5e <syscall+0x35c>
    unmap_region(&env->address_space, va, size);
  804160ea35:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160ea39:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804160ea40:	4c 89 f2             	mov    %r14,%rdx
  804160ea43:	4c 89 e6             	mov    %r12,%rsi
  804160ea46:	48 b8 ba 90 60 41 80 	movabs $0x80416090ba,%rax
  804160ea4d:	00 00 00 
  804160ea50:	ff d0                	call   *%rax
    return 0;
  804160ea52:	b8 00 00 00 00       	mov    $0x0,%eax
             return sys_unmap_region((envid_t)a1, (uintptr_t)a2, (size_t)a3);
  804160ea57:	48 98                	cltq   
  804160ea59:	e9 21 fd ff ff       	jmp    804160e77f <syscall+0x7d>
        return -E_INVAL;
  804160ea5e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160ea63:	eb f2                	jmp    804160ea57 <syscall+0x355>
    int res = envid2env(envid, &env, 1);
  804160ea65:	ba 01 00 00 00       	mov    $0x1,%edx
  804160ea6a:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160ea6e:	44 89 ef             	mov    %r13d,%edi
  804160ea71:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160ea78:	00 00 00 
  804160ea7b:	ff d0                	call   *%rax
    if (res < 0)
  804160ea7d:	85 c0                	test   %eax,%eax
  804160ea7f:	78 10                	js     804160ea91 <syscall+0x38f>
    env->env_pgfault_upcall = func;
  804160ea81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160ea85:	4c 89 a0 00 01 00 00 	mov    %r12,0x100(%rax)
    return 0;
  804160ea8c:	b8 00 00 00 00       	mov    $0x0,%eax
             return sys_env_set_pgfault_upcall((envid_t)a1, (void*)a2);
  804160ea91:	48 98                	cltq   
  804160ea93:	e9 e7 fc ff ff       	jmp    804160e77f <syscall+0x7d>
    int res = envid2env(envid, &env, 0);
  804160ea98:	ba 00 00 00 00       	mov    $0x0,%edx
  804160ea9d:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160eaa1:	44 89 ef             	mov    %r13d,%edi
  804160eaa4:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160eaab:	00 00 00 
  804160eaae:	ff d0                	call   *%rax
    if (res < 0)
  804160eab0:	85 c0                	test   %eax,%eax
  804160eab2:	0f 88 86 00 00 00    	js     804160eb3e <syscall+0x43c>
    if (!env->env_ipc_recving)
  804160eab8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804160eabc:	80 ba 08 01 00 00 00 	cmpb   $0x0,0x108(%rdx)
  804160eac3:	0f 84 dc 00 00 00    	je     804160eba5 <syscall+0x4a3>
    if (srcva & CLASS_MASK(0) || env->env_ipc_dstva & CLASS_MASK(0))
  804160eac9:	41 f7 c6 ff 0f 00 00 	test   $0xfff,%r14d
  804160ead0:	0f 85 d6 00 00 00    	jne    804160ebac <syscall+0x4aa>
  804160ead6:	48 8b b2 10 01 00 00 	mov    0x110(%rdx),%rsi
  804160eadd:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
  804160eae3:	0f 85 ca 00 00 00    	jne    804160ebb3 <syscall+0x4b1>
    if (srcva < MAX_USER_ADDRESS && env->env_ipc_dstva < MAX_USER_ADDRESS) {
  804160eae9:	48 b8 ff ff ff ff 7f 	movabs $0x7fffffffff,%rax
  804160eaf0:	00 00 00 
  804160eaf3:	48 39 c6             	cmp    %rax,%rsi
  804160eaf6:	77 05                	ja     804160eafd <syscall+0x3fb>
  804160eaf8:	49 39 c6             	cmp    %rax,%r14
  804160eafb:	76 48                	jbe    804160eb45 <syscall+0x443>
        env->env_ipc_perm = 0;
  804160eafd:	c7 82 28 01 00 00 00 	movl   $0x0,0x128(%rdx)
  804160eb04:	00 00 00 
    env->env_ipc_recving = 0;
  804160eb07:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804160eb0b:	c6 82 08 01 00 00 00 	movb   $0x0,0x108(%rdx)
    env->env_ipc_from = curenv->env_id;
  804160eb12:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160eb19:	00 00 00 
  804160eb1c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  804160eb22:	89 82 24 01 00 00    	mov    %eax,0x124(%rdx)
             return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, a3, (size_t)a4, (int)a5);
  804160eb28:	44 89 a2 20 01 00 00 	mov    %r12d,0x120(%rdx)
    env->env_status = ENV_RUNNABLE;
  804160eb2f:	c7 82 d4 00 00 00 02 	movl   $0x2,0xd4(%rdx)
  804160eb36:	00 00 00 
    return 0;
  804160eb39:	b8 00 00 00 00       	mov    $0x0,%eax
             return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, a3, (size_t)a4, (int)a5);
  804160eb3e:	48 98                	cltq   
  804160eb40:	e9 3a fc ff ff       	jmp    804160e77f <syscall+0x7d>
        env->env_ipc_maxsz = MIN(env->env_ipc_maxsz, size);
  804160eb45:	4c 39 ba 18 01 00 00 	cmp    %r15,0x118(%rdx)
  804160eb4c:	4c 0f 46 ba 18 01 00 	cmovbe 0x118(%rdx),%r15
  804160eb53:	00 
  804160eb54:	4d 89 f8             	mov    %r15,%r8
  804160eb57:	4c 89 ba 18 01 00 00 	mov    %r15,0x118(%rdx)
        res = map_region(&env->address_space, env->env_ipc_dstva, 
  804160eb5e:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160eb65:	00 00 00 
  804160eb68:	48 05 e8 00 00 00    	add    $0xe8,%rax
  804160eb6e:	48 8d ba e8 00 00 00 	lea    0xe8(%rdx),%rdi
  804160eb75:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
  804160eb79:	41 89 d9             	mov    %ebx,%r9d
  804160eb7c:	41 83 c9 20          	or     $0x20,%r9d
  804160eb80:	4c 89 f1             	mov    %r14,%rcx
  804160eb83:	48 89 c2             	mov    %rax,%rdx
  804160eb86:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160eb8d:	00 00 00 
  804160eb90:	ff d0                	call   *%rax
        if (res < 0)
  804160eb92:	85 c0                	test   %eax,%eax
  804160eb94:	78 a8                	js     804160eb3e <syscall+0x43c>
        env->env_ipc_perm = perm;
  804160eb96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160eb9a:	89 98 28 01 00 00    	mov    %ebx,0x128(%rax)
  804160eba0:	e9 62 ff ff ff       	jmp    804160eb07 <syscall+0x405>
        return -E_IPC_NOT_RECV;
  804160eba5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  804160ebaa:	eb 92                	jmp    804160eb3e <syscall+0x43c>
         return -E_INVAL;
  804160ebac:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160ebb1:	eb 8b                	jmp    804160eb3e <syscall+0x43c>
  804160ebb3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160ebb8:	eb 84                	jmp    804160eb3e <syscall+0x43c>
    if (dstva & CLASS_MASK(0) || maxsize & CLASS_MASK(0))
  804160ebba:	48 89 f2             	mov    %rsi,%rdx
  804160ebbd:	4c 09 e2             	or     %r12,%rdx
             return sys_ipc_recv(a1, a2);
  804160ebc0:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
    if (dstva & CLASS_MASK(0) || maxsize & CLASS_MASK(0))
  804160ebc7:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
  804160ebcd:	0f 85 ac fb ff ff    	jne    804160e77f <syscall+0x7d>
    if (dstva < MAX_USER_ADDRESS && maxsize == 0) 
  804160ebd3:	48 b8 ff ff ff ff 7f 	movabs $0x7fffffffff,%rax
  804160ebda:	00 00 00 
  804160ebdd:	48 39 c6             	cmp    %rax,%rsi
  804160ebe0:	77 11                	ja     804160ebf3 <syscall+0x4f1>
  804160ebe2:	4d 85 e4             	test   %r12,%r12
  804160ebe5:	75 0c                	jne    804160ebf3 <syscall+0x4f1>
             return sys_ipc_recv(a1, a2);
  804160ebe7:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
  804160ebee:	e9 8c fb ff ff       	jmp    804160e77f <syscall+0x7d>
    curenv->env_ipc_recving = 1;
  804160ebf3:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160ebfa:	00 00 00 
  804160ebfd:	c6 80 08 01 00 00 01 	movb   $0x1,0x108(%rax)
    curenv->env_status = ENV_NOT_RUNNABLE;
  804160ec04:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  804160ec0b:	00 00 00 
    if (dstva < MAX_USER_ADDRESS) {
  804160ec0e:	48 ba ff ff ff ff 7f 	movabs $0x7fffffffff,%rdx
  804160ec15:	00 00 00 
  804160ec18:	49 39 d5             	cmp    %rdx,%r13
  804160ec1b:	77 0e                	ja     804160ec2b <syscall+0x529>
        curenv->env_ipc_dstva = dstva;
  804160ec1d:	4c 89 a8 10 01 00 00 	mov    %r13,0x110(%rax)
        curenv->env_ipc_maxsz = maxsize;
  804160ec24:	4c 89 a0 18 01 00 00 	mov    %r12,0x118(%rax)
    curenv->env_tf.tf_regs.reg_rax = 0;
  804160ec2b:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  804160ec32:	00 
    sched_yield();
  804160ec33:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  804160ec3a:	00 00 00 
  804160ec3d:	ff d0                	call   *%rax
    sched_yield();
  804160ec3f:	48 b8 0e e6 60 41 80 	movabs $0x804160e60e,%rax
  804160ec46:	00 00 00 
  804160ec49:	ff d0                	call   *%rax
    if (addr2 >= MAX_USER_ADDRESS)
  804160ec4b:	48 b8 ff ff ff ff 7f 	movabs $0x7fffffffff,%rax
  804160ec52:	00 00 00 
  804160ec55:	48 39 c1             	cmp    %rax,%rcx
  804160ec58:	77 37                	ja     804160ec91 <syscall+0x58f>
    return region_maxref(current_space, addr, size) - region_maxref(current_space, addr2, size2);
  804160ec5a:	48 bb a0 00 40 42 80 	movabs $0x80424000a0,%rbx
  804160ec61:	00 00 00 
  804160ec64:	48 8b 3b             	mov    (%rbx),%rdi
  804160ec67:	49 bd 93 91 60 41 80 	movabs $0x8041609193,%r13
  804160ec6e:	00 00 00 
  804160ec71:	41 ff d5             	call   *%r13
  804160ec74:	41 89 c4             	mov    %eax,%r12d
  804160ec77:	4c 89 fa             	mov    %r15,%rdx
  804160ec7a:	4c 89 f6             	mov    %r14,%rsi
  804160ec7d:	48 8b 3b             	mov    (%rbx),%rdi
  804160ec80:	41 ff d5             	call   *%r13
  804160ec83:	89 c2                	mov    %eax,%edx
  804160ec85:	44 89 e0             	mov    %r12d,%eax
  804160ec88:	29 d0                	sub    %edx,%eax
              return sys_region_refs(a1, (size_t)a2, a3, a4);
  804160ec8a:	48 98                	cltq   
  804160ec8c:	e9 ee fa ff ff       	jmp    804160e77f <syscall+0x7d>
        return region_maxref(current_space, addr, size);
  804160ec91:	48 b8 a0 00 40 42 80 	movabs $0x80424000a0,%rax
  804160ec98:	00 00 00 
  804160ec9b:	48 8b 38             	mov    (%rax),%rdi
  804160ec9e:	48 b8 93 91 60 41 80 	movabs $0x8041609193,%rax
  804160eca5:	00 00 00 
  804160eca8:	ff d0                	call   *%rax
  804160ecaa:	eb de                	jmp    804160ec8a <syscall+0x588>
    int res = envid2env(envid, &env, 0);
  804160ecac:	ba 00 00 00 00       	mov    $0x0,%edx
  804160ecb1:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804160ecb5:	44 89 ef             	mov    %r13d,%edi
  804160ecb8:	48 b8 36 b8 60 41 80 	movabs $0x804160b836,%rax
  804160ecbf:	00 00 00 
  804160ecc2:	ff d0                	call   *%rax
    if (res < 0) 
  804160ecc4:	85 c0                	test   %eax,%eax
  804160ecc6:	78 7b                	js     804160ed43 <syscall+0x641>
    user_mem_assert(env, tf, sizeof(struct Trapframe), PROT_USER_ | PROT_R);
  804160ecc8:	b9 24 00 00 00       	mov    $0x24,%ecx
  804160eccd:	ba c0 00 00 00       	mov    $0xc0,%edx
  804160ecd2:	4c 89 e6             	mov    %r12,%rsi
  804160ecd5:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160ecd9:	48 b8 ca b7 60 41 80 	movabs $0x804160b7ca,%rax
  804160ece0:	00 00 00 
  804160ece3:	ff d0                	call   *%rax
    if (!tf)
  804160ece5:	4d 85 e4             	test   %r12,%r12
  804160ece8:	74 60                	je     804160ed4a <syscall+0x648>
    nosan_memcpy(&env->env_tf, tf, sizeof(struct Trapframe));
  804160ecea:	ba c0 00 00 00       	mov    $0xc0,%edx
  804160ecef:	4c 89 e6             	mov    %r12,%rsi
  804160ecf2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804160ecf6:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160ecfd:	00 00 00 
  804160ed00:	ff d0                	call   *%rax
    env->env_tf.tf_ds = GD_UD | 3;
  804160ed02:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160ed06:	66 c7 80 80 00 00 00 	movw   $0x33,0x80(%rax)
  804160ed0d:	33 00 
    env->env_tf.tf_es = GD_UD | 3;
  804160ed0f:	66 c7 40 78 33 00    	movw   $0x33,0x78(%rax)
    env->env_tf.tf_ss = GD_UD | 3;
  804160ed15:	66 c7 80 b8 00 00 00 	movw   $0x33,0xb8(%rax)
  804160ed1c:	33 00 
    env->env_tf.tf_cs = GD_UT | 3;
  804160ed1e:	66 c7 80 a0 00 00 00 	movw   $0x2b,0xa0(%rax)
  804160ed25:	2b 00 
    env->env_tf.tf_rflags &= 0xFFF;
  804160ed27:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  804160ed2e:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
    env->env_tf.tf_rflags |= FL_IF;
  804160ed34:	80 ce 02             	or     $0x2,%dh
  804160ed37:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
    return 0;
  804160ed3e:	b8 00 00 00 00       	mov    $0x0,%eax
              return sys_env_set_trapframe((envid_t)a1, (struct Trapframe*)a2);
  804160ed43:	48 98                	cltq   
  804160ed45:	e9 35 fa ff ff       	jmp    804160e77f <syscall+0x7d>
        return -E_FAULT;
  804160ed4a:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
  804160ed4f:	eb f2                	jmp    804160ed43 <syscall+0x641>
    return gettime();
  804160ed51:	48 b8 a1 c5 60 41 80 	movabs $0x804160c5a1,%rax
  804160ed58:	00 00 00 
  804160ed5b:	ff d0                	call   *%rax
              return sys_gettime();
  804160ed5d:	48 98                	cltq   
  804160ed5f:	e9 1b fa ff ff       	jmp    804160e77f <syscall+0x7d>
            &kspace, (uintptr_t)context.front, context.size * 2, PROT_R | PROT_W | PROT_USER_);
  804160ed64:	48 b8 40 5b 40 42 80 	movabs $0x8042405b40,%rax
  804160ed6b:	00 00 00 
  804160ed6e:	8b 58 10             	mov    0x10(%rax),%ebx
  804160ed71:	44 8d 04 1b          	lea    (%rbx,%rbx,1),%r8d
    return map_region(&curenv->address_space, (uintptr_t)UTEMP, 
  804160ed75:	48 8b 48 18          	mov    0x18(%rax),%rcx
  804160ed79:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160ed80:	00 00 00 
  804160ed83:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804160ed8a:	41 b9 26 00 00 00    	mov    $0x26,%r9d
  804160ed90:	45 89 c0             	mov    %r8d,%r8d
  804160ed93:	48 ba b0 00 40 42 80 	movabs $0x80424000b0,%rdx
  804160ed9a:	00 00 00 
  804160ed9d:	be 00 00 40 00       	mov    $0x400000,%esi
  804160eda2:	48 b8 f6 a0 60 41 80 	movabs $0x804160a0f6,%rax
  804160eda9:	00 00 00 
  804160edac:	ff d0                	call   *%rax
              return sys_framebuffer_init();
  804160edae:	48 98                	cltq   
  804160edb0:	e9 ca f9 ff ff       	jmp    804160e77f <syscall+0x7d>
    switch(syscallno) {
  804160edb5:	48 c7 c0 f7 ff ff ff 	mov    $0xfffffffffffffff7,%rax
  804160edbc:	e9 be f9 ff ff       	jmp    804160e77f <syscall+0x7d>

000000804160edc1 <load_kernel_dwarf_info>:
#include <kern/env.h>
#include <inc/uefi.h>

void
load_kernel_dwarf_info(struct Dwarf_Addrs *addrs) {
    addrs->aranges_begin = (uint8_t *)(uefi_lp->DebugArangesStart);
  804160edc1:	48 ba 00 40 63 41 80 	movabs $0x8041634000,%rdx
  804160edc8:	00 00 00 
  804160edcb:	48 8b 02             	mov    (%rdx),%rax
  804160edce:	48 8b 48 58          	mov    0x58(%rax),%rcx
  804160edd2:	48 89 4f 10          	mov    %rcx,0x10(%rdi)
    addrs->aranges_end = (uint8_t *)(uefi_lp->DebugArangesEnd);
  804160edd6:	48 8b 48 60          	mov    0x60(%rax),%rcx
  804160edda:	48 89 4f 18          	mov    %rcx,0x18(%rdi)
    addrs->abbrev_begin = (uint8_t *)(uefi_lp->DebugAbbrevStart);
  804160edde:	48 8b 40 68          	mov    0x68(%rax),%rax
  804160ede2:	48 89 07             	mov    %rax,(%rdi)
    addrs->abbrev_end = (uint8_t *)(uefi_lp->DebugAbbrevEnd);
  804160ede5:	48 8b 02             	mov    (%rdx),%rax
  804160ede8:	48 8b 50 70          	mov    0x70(%rax),%rdx
  804160edec:	48 89 57 08          	mov    %rdx,0x8(%rdi)
    addrs->info_begin = (uint8_t *)(uefi_lp->DebugInfoStart);
  804160edf0:	48 8b 50 78          	mov    0x78(%rax),%rdx
  804160edf4:	48 89 57 20          	mov    %rdx,0x20(%rdi)
    addrs->info_end = (uint8_t *)(uefi_lp->DebugInfoEnd);
  804160edf8:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  804160edff:	48 89 57 28          	mov    %rdx,0x28(%rdi)
    addrs->line_begin = (uint8_t *)(uefi_lp->DebugLineStart);
  804160ee03:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  804160ee0a:	48 89 57 30          	mov    %rdx,0x30(%rdi)
    addrs->line_end = (uint8_t *)(uefi_lp->DebugLineEnd);
  804160ee0e:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  804160ee15:	48 89 57 38          	mov    %rdx,0x38(%rdi)
    addrs->str_begin = (uint8_t *)(uefi_lp->DebugStrStart);
  804160ee19:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  804160ee20:	48 89 57 40          	mov    %rdx,0x40(%rdi)
    addrs->str_end = (uint8_t *)(uefi_lp->DebugStrEnd);
  804160ee24:	48 8b 90 a0 00 00 00 	mov    0xa0(%rax),%rdx
  804160ee2b:	48 89 57 48          	mov    %rdx,0x48(%rdi)
    addrs->pubnames_begin = (uint8_t *)(uefi_lp->DebugPubnamesStart);
  804160ee2f:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  804160ee36:	48 89 57 50          	mov    %rdx,0x50(%rdi)
    addrs->pubnames_end = (uint8_t *)(uefi_lp->DebugPubnamesEnd);
  804160ee3a:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  804160ee41:	48 89 57 58          	mov    %rdx,0x58(%rdi)
    addrs->pubtypes_begin = (uint8_t *)(uefi_lp->DebugPubtypesStart);
  804160ee45:	48 8b 90 b8 00 00 00 	mov    0xb8(%rax),%rdx
  804160ee4c:	48 89 57 60          	mov    %rdx,0x60(%rdi)
    addrs->pubtypes_end = (uint8_t *)(uefi_lp->DebugPubtypesEnd);
  804160ee50:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  804160ee57:	48 89 47 68          	mov    %rax,0x68(%rdi)
}
  804160ee5b:	c3                   	ret    

000000804160ee5c <load_user_dwarf_info>:

void
load_user_dwarf_info(struct Dwarf_Addrs *addrs) {
  804160ee5c:	55                   	push   %rbp
  804160ee5d:	48 89 e5             	mov    %rsp,%rbp
    assert(curenv);
  804160ee60:	48 a1 50 44 40 42 80 	movabs 0x8042404450,%rax
  804160ee67:	00 00 00 
  804160ee6a:	48 85 c0             	test   %rax,%rax
  804160ee6d:	74 22                	je     804160ee91 <load_user_dwarf_info+0x35>

    uint8_t *binary = curenv->binary;
    assert(curenv->binary);
  804160ee6f:	48 83 b8 e0 00 00 00 	cmpq   $0x0,0xe0(%rax)
  804160ee76:	00 
  804160ee77:	74 48                	je     804160eec1 <load_user_dwarf_info+0x65>
            {&addrs->pubnames_end, &addrs->pubnames_begin, ".debug_pubnames"},
            {&addrs->pubtypes_end, &addrs->pubtypes_begin, ".debug_pubtypes"},
    };
    (void)sections;

    memset(addrs, 0, sizeof(*addrs));
  804160ee79:	ba 70 00 00 00       	mov    $0x70,%edx
  804160ee7e:	be 00 00 00 00       	mov    $0x0,%esi
  804160ee83:	48 b8 a5 fd 60 41 80 	movabs $0x804160fda5,%rax
  804160ee8a:	00 00 00 
  804160ee8d:	ff d0                	call   *%rax

    /* Load debug sections from curenv->binary elf image */
    // LAB 8: Your code here
}
  804160ee8f:	5d                   	pop    %rbp
  804160ee90:	c3                   	ret    
    assert(curenv);
  804160ee91:	48 b9 f8 2d 61 41 80 	movabs $0x8041612df8,%rcx
  804160ee98:	00 00 00 
  804160ee9b:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160eea2:	00 00 00 
  804160eea5:	be 21 00 00 00       	mov    $0x21,%esi
  804160eeaa:	48 bf b8 35 61 41 80 	movabs $0x80416135b8,%rdi
  804160eeb1:	00 00 00 
  804160eeb4:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160eebb:	00 00 00 
  804160eebe:	41 ff d0             	call   *%r8
    assert(curenv->binary);
  804160eec1:	48 b9 c6 35 61 41 80 	movabs $0x80416135c6,%rcx
  804160eec8:	00 00 00 
  804160eecb:	48 ba 16 14 61 41 80 	movabs $0x8041611416,%rdx
  804160eed2:	00 00 00 
  804160eed5:	be 24 00 00 00       	mov    $0x24,%esi
  804160eeda:	48 bf b8 35 61 41 80 	movabs $0x80416135b8,%rdi
  804160eee1:	00 00 00 
  804160eee4:	b8 00 00 00 00       	mov    $0x0,%eax
  804160eee9:	49 b8 d9 02 60 41 80 	movabs $0x80416002d9,%r8
  804160eef0:	00 00 00 
  804160eef3:	41 ff d0             	call   *%r8

000000804160eef6 <debuginfo_rip>:
 * instruction address, 'addr'.  Returns 0 if information was found, and
 * negative if not.  But even if it returns negative it has stored some
 * information into '*info'
 */
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info) {
  804160eef6:	55                   	push   %rbp
  804160eef7:	48 89 e5             	mov    %rsp,%rbp
  804160eefa:	41 56                	push   %r14
  804160eefc:	41 55                	push   %r13
  804160eefe:	41 54                	push   %r12
  804160ef00:	53                   	push   %rbx
  804160ef01:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
    if (!addr) return 0;
  804160ef08:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  804160ef0e:	48 85 ff             	test   %rdi,%rdi
  804160ef11:	75 13                	jne    804160ef26 <debuginfo_rip+0x30>
    function_by_info(&addrs, addr - 5, offset, &tmp_buf, &fn_addr);
    info->rip_fn_addr = fn_addr;
    strcpy(info->rip_fn_name, tmp_buf);
error:
    return res;
}
  804160ef13:	44 89 e0             	mov    %r12d,%eax
  804160ef16:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
  804160ef1d:	5b                   	pop    %rbx
  804160ef1e:	41 5c                	pop    %r12
  804160ef20:	41 5d                	pop    %r13
  804160ef22:	41 5e                	pop    %r14
  804160ef24:	5d                   	pop    %rbp
  804160ef25:	c3                   	ret    
  804160ef26:	49 89 fd             	mov    %rdi,%r13
  804160ef29:	48 89 f3             	mov    %rsi,%rbx
    strcpy(info->rip_file, UNKNOWN);
  804160ef2c:	48 be d5 35 61 41 80 	movabs $0x80416135d5,%rsi
  804160ef33:	00 00 00 
  804160ef36:	48 89 df             	mov    %rbx,%rdi
  804160ef39:	49 bc 54 fc 60 41 80 	movabs $0x804160fc54,%r12
  804160ef40:	00 00 00 
  804160ef43:	41 ff d4             	call   *%r12
    strcpy(info->rip_fn_name, UNKNOWN);
  804160ef46:	4c 8d b3 04 01 00 00 	lea    0x104(%rbx),%r14
  804160ef4d:	48 be d5 35 61 41 80 	movabs $0x80416135d5,%rsi
  804160ef54:	00 00 00 
  804160ef57:	4c 89 f7             	mov    %r14,%rdi
  804160ef5a:	41 ff d4             	call   *%r12
    info->rip_fn_namelen = sizeof UNKNOWN - 1;
  804160ef5d:	c7 83 04 02 00 00 09 	movl   $0x9,0x204(%rbx)
  804160ef64:	00 00 00 
    info->rip_line = 0;
  804160ef67:	c7 83 00 01 00 00 00 	movl   $0x0,0x100(%rbx)
  804160ef6e:	00 00 00 
    info->rip_fn_addr = addr;
  804160ef71:	4c 89 ab 08 02 00 00 	mov    %r13,0x208(%rbx)
    info->rip_fn_narg = 0;
  804160ef78:	c7 83 10 02 00 00 00 	movl   $0x0,0x210(%rbx)
  804160ef7f:	00 00 00 
    struct AddressSpace *old_address_space = switch_address_space(&kspace);
  804160ef82:	48 bf b0 00 40 42 80 	movabs $0x80424000b0,%rdi
  804160ef89:	00 00 00 
  804160ef8c:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160ef93:	00 00 00 
  804160ef96:	ff d0                	call   *%rax
  804160ef98:	49 89 c4             	mov    %rax,%r12
        load_user_dwarf_info(&addrs) : load_kernel_dwarf_info(&addrs);
  804160ef9b:	48 b8 ff ff df 1f 80 	movabs $0x801fdfffff,%rax
  804160efa2:	00 00 00 
  804160efa5:	49 39 c5             	cmp    %rax,%r13
  804160efa8:	0f 87 40 01 00 00    	ja     804160f0ee <debuginfo_rip+0x1f8>
  804160efae:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160efb5:	48 b8 5c ee 60 41 80 	movabs $0x804160ee5c,%rax
  804160efbc:	00 00 00 
  804160efbf:	ff d0                	call   *%rax
    switch_address_space(old_address_space);
  804160efc1:	4c 89 e7             	mov    %r12,%rdi
  804160efc4:	48 b8 85 94 60 41 80 	movabs $0x8041609485,%rax
  804160efcb:	00 00 00 
  804160efce:	ff d0                	call   *%rax
    Dwarf_Off offset = 0, line_offset = 0;
  804160efd0:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
  804160efd7:	00 00 00 00 
  804160efdb:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  804160efe2:	00 00 00 00 
    int res = info_by_address(&addrs, addr, &offset);
  804160efe6:	48 8d 95 68 ff ff ff 	lea    -0x98(%rbp),%rdx
  804160efed:	4c 89 ee             	mov    %r13,%rsi
  804160eff0:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160eff7:	48 b8 db 17 60 41 80 	movabs $0x80416017db,%rax
  804160effe:	00 00 00 
  804160f001:	ff d0                	call   *%rax
  804160f003:	41 89 c4             	mov    %eax,%r12d
    if (res < 0) goto error;
  804160f006:	85 c0                	test   %eax,%eax
  804160f008:	0f 88 05 ff ff ff    	js     804160ef13 <debuginfo_rip+0x1d>
    char *tmp_buf = NULL;
  804160f00e:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
  804160f015:	00 00 00 00 
    res = file_name_by_info(&addrs, offset, &tmp_buf, &line_offset);
  804160f019:	48 8d 8d 60 ff ff ff 	lea    -0xa0(%rbp),%rcx
  804160f020:	48 8d 95 58 ff ff ff 	lea    -0xa8(%rbp),%rdx
  804160f027:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  804160f02e:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160f035:	48 b8 87 1d 60 41 80 	movabs $0x8041601d87,%rax
  804160f03c:	00 00 00 
  804160f03f:	ff d0                	call   *%rax
  804160f041:	41 89 c4             	mov    %eax,%r12d
    if (res < 0) goto error;
  804160f044:	85 c0                	test   %eax,%eax
  804160f046:	0f 88 c7 fe ff ff    	js     804160ef13 <debuginfo_rip+0x1d>
    strncpy(info->rip_file, tmp_buf, sizeof(info->rip_file));
  804160f04c:	ba 00 01 00 00       	mov    $0x100,%edx
  804160f051:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
  804160f058:	48 89 df             	mov    %rbx,%rdi
  804160f05b:	48 b8 a0 fc 60 41 80 	movabs $0x804160fca0,%rax
  804160f062:	00 00 00 
  804160f065:	ff d0                	call   *%rax
    line_for_address(&addrs, addr - 5, line_offset, &info->rip_line);
  804160f067:	49 83 ed 05          	sub    $0x5,%r13
  804160f06b:	48 8d 8b 00 01 00 00 	lea    0x100(%rbx),%rcx
  804160f072:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  804160f079:	4c 89 ee             	mov    %r13,%rsi
  804160f07c:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160f083:	48 b8 6f 38 60 41 80 	movabs $0x804160386f,%rax
  804160f08a:	00 00 00 
  804160f08d:	ff d0                	call   *%rax
    uintptr_t fn_addr = 0;
  804160f08f:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  804160f096:	00 00 00 00 
    function_by_info(&addrs, addr - 5, offset, &tmp_buf, &fn_addr);
  804160f09a:	4c 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%r8
  804160f0a1:	48 8d 8d 58 ff ff ff 	lea    -0xa8(%rbp),%rcx
  804160f0a8:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  804160f0af:	4c 89 ee             	mov    %r13,%rsi
  804160f0b2:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160f0b9:	48 b8 a0 22 60 41 80 	movabs $0x80416022a0,%rax
  804160f0c0:	00 00 00 
  804160f0c3:	ff d0                	call   *%rax
    info->rip_fn_addr = fn_addr;
  804160f0c5:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  804160f0cc:	48 89 83 08 02 00 00 	mov    %rax,0x208(%rbx)
    strcpy(info->rip_fn_name, tmp_buf);
  804160f0d3:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
  804160f0da:	4c 89 f7             	mov    %r14,%rdi
  804160f0dd:	48 b8 54 fc 60 41 80 	movabs $0x804160fc54,%rax
  804160f0e4:	00 00 00 
  804160f0e7:	ff d0                	call   *%rax
  804160f0e9:	e9 25 fe ff ff       	jmp    804160ef13 <debuginfo_rip+0x1d>
        load_user_dwarf_info(&addrs) : load_kernel_dwarf_info(&addrs);
  804160f0ee:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160f0f5:	48 b8 c1 ed 60 41 80 	movabs $0x804160edc1,%rax
  804160f0fc:	00 00 00 
  804160f0ff:	ff d0                	call   *%rax
  804160f101:	e9 bb fe ff ff       	jmp    804160efc1 <debuginfo_rip+0xcb>

000000804160f106 <find_function>:

uintptr_t
find_function(const char *const fname) {
  804160f106:	55                   	push   %rbp
  804160f107:	48 89 e5             	mov    %rsp,%rbp
  804160f10a:	41 56                	push   %r14
  804160f10c:	41 55                	push   %r13
  804160f10e:	41 54                	push   %r12
  804160f110:	53                   	push   %rbx
  804160f111:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  804160f115:	49 89 fd             	mov    %rdi,%r13
     * It may also be useful to look to kernel symbol table for symbols defined
     * in assembly. */

    // LAB 3: Your code here:
    struct Dwarf_Addrs addrs;
    uintptr_t address = 0;
  804160f118:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
  804160f11f:	00 00 00 00 
   

    load_kernel_dwarf_info(&addrs);
  804160f123:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160f12a:	48 b8 c1 ed 60 41 80 	movabs $0x804160edc1,%rax
  804160f131:	00 00 00 
  804160f134:	ff d0                	call   *%rax
    if (!address_by_fname(&addrs, fname, &address)) {
  804160f136:	48 8d 95 68 ff ff ff 	lea    -0x98(%rbp),%rdx
  804160f13d:	4c 89 ee             	mov    %r13,%rsi
  804160f140:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160f147:	48 b8 90 29 60 41 80 	movabs $0x8041602990,%rax
  804160f14e:	00 00 00 
  804160f151:	ff d0                	call   *%rax
  804160f153:	85 c0                	test   %eax,%eax
  804160f155:	75 14                	jne    804160f16b <find_function+0x65>
        return address;
  804160f157:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
            !strcmp(fname, (char*)(uefi_lp->StringTableStart + st->st_name))) {
            return st->st_value;
        }
    }
    return 0;
}
  804160f15e:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
  804160f162:	5b                   	pop    %rbx
  804160f163:	41 5c                	pop    %r12
  804160f165:	41 5d                	pop    %r13
  804160f167:	41 5e                	pop    %r14
  804160f169:	5d                   	pop    %rbp
  804160f16a:	c3                   	ret    
    if (!naive_address_by_fname(&addrs, fname, &address)) {
  804160f16b:	48 8d 95 68 ff ff ff 	lea    -0x98(%rbp),%rdx
  804160f172:	4c 89 ee             	mov    %r13,%rsi
  804160f175:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
  804160f17c:	48 b8 79 31 60 41 80 	movabs $0x8041603179,%rax
  804160f183:	00 00 00 
  804160f186:	ff d0                	call   *%rax
  804160f188:	85 c0                	test   %eax,%eax
  804160f18a:	74 30                	je     804160f1bc <find_function+0xb6>
    for (struct Elf64_Sym *st = (struct Elf64_Sym*)uefi_lp->SymbolTableStart; 
  804160f18c:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  804160f193:	00 00 00 
  804160f196:	48 8b 98 c8 00 00 00 	mov    0xc8(%rax),%rbx
  804160f19d:	48 3b 98 d0 00 00 00 	cmp    0xd0(%rax),%rbx
  804160f1a4:	73 6c                	jae    804160f212 <find_function+0x10c>
            !strcmp(fname, (char*)(uefi_lp->StringTableStart + st->st_name))) {
  804160f1a6:	49 be f6 fc 60 41 80 	movabs $0x804160fcf6,%r14
  804160f1ad:	00 00 00 
            st < (struct Elf64_Sym*)uefi_lp->SymbolTableEnd; ++st) {
  804160f1b0:	49 bc 00 40 63 41 80 	movabs $0x8041634000,%r12
  804160f1b7:	00 00 00 
  804160f1ba:	eb 1a                	jmp    804160f1d6 <find_function+0xd0>
        return address;
  804160f1bc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  804160f1c3:	eb 99                	jmp    804160f15e <find_function+0x58>
            st < (struct Elf64_Sym*)uefi_lp->SymbolTableEnd; ++st) {
  804160f1c5:	48 83 c3 18          	add    $0x18,%rbx
  804160f1c9:	49 8b 04 24          	mov    (%r12),%rax
    for (struct Elf64_Sym *st = (struct Elf64_Sym*)uefi_lp->SymbolTableStart; 
  804160f1cd:	48 3b 98 d0 00 00 00 	cmp    0xd0(%rax),%rbx
  804160f1d4:	73 32                	jae    804160f208 <find_function+0x102>
        if (ELF_ST_BIND(st->st_info) == STB_GLOBAL && 
  804160f1d6:	0f b6 53 04          	movzbl 0x4(%rbx),%edx
  804160f1da:	89 d1                	mov    %edx,%ecx
  804160f1dc:	c0 e9 04             	shr    $0x4,%cl
  804160f1df:	80 f9 01             	cmp    $0x1,%cl
  804160f1e2:	75 e1                	jne    804160f1c5 <find_function+0xbf>
  804160f1e4:	83 e2 0f             	and    $0xf,%edx
  804160f1e7:	80 fa 02             	cmp    $0x2,%dl
  804160f1ea:	75 d9                	jne    804160f1c5 <find_function+0xbf>
            !strcmp(fname, (char*)(uefi_lp->StringTableStart + st->st_name))) {
  804160f1ec:	8b 33                	mov    (%rbx),%esi
  804160f1ee:	48 03 b0 d8 00 00 00 	add    0xd8(%rax),%rsi
  804160f1f5:	4c 89 ef             	mov    %r13,%rdi
  804160f1f8:	41 ff d6             	call   *%r14
            ELF_ST_TYPE(st->st_info) == STT_FUNC &&
  804160f1fb:	85 c0                	test   %eax,%eax
  804160f1fd:	75 c6                	jne    804160f1c5 <find_function+0xbf>
            return st->st_value;
  804160f1ff:	48 8b 43 08          	mov    0x8(%rbx),%rax
  804160f203:	e9 56 ff ff ff       	jmp    804160f15e <find_function+0x58>
    return 0;
  804160f208:	b8 00 00 00 00       	mov    $0x0,%eax
  804160f20d:	e9 4c ff ff ff       	jmp    804160f15e <find_function+0x58>
  804160f212:	b8 00 00 00 00       	mov    $0x0,%eax
  804160f217:	e9 42 ff ff ff       	jmp    804160f15e <find_function+0x58>

000000804160f21c <print_num>:
 * Print a number (base <= 16) in reverse order,
 * using specified putch function and associated pointer putdat.
 */
static void
print_num(void (*putch)(int, void *), void *put_arg,
          uintmax_t num, unsigned base, int width, char padc, bool capital) {
  804160f21c:	55                   	push   %rbp
  804160f21d:	48 89 e5             	mov    %rsp,%rbp
  804160f220:	41 57                	push   %r15
  804160f222:	41 56                	push   %r14
  804160f224:	41 55                	push   %r13
  804160f226:	41 54                	push   %r12
  804160f228:	53                   	push   %rbx
  804160f229:	48 83 ec 18          	sub    $0x18,%rsp
  804160f22d:	49 89 fc             	mov    %rdi,%r12
  804160f230:	49 89 f5             	mov    %rsi,%r13
  804160f233:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  804160f237:	8b 45 10             	mov    0x10(%rbp),%eax
  804160f23a:	89 45 c4             	mov    %eax,-0x3c(%rbp)
    /* First recursively print all preceding (more significant) digits */
    if (num >= base) {
  804160f23d:	41 89 cf             	mov    %ecx,%r15d
  804160f240:	49 39 d7             	cmp    %rdx,%r15
  804160f243:	76 5b                	jbe    804160f2a0 <print_num+0x84>
        print_num(putch, put_arg, num / base, base, width - 1, padc, capital);
    } else {
        /* Print any needed pad characters before first digit */
        while (--width > 0) {
  804160f245:	41 8d 58 ff          	lea    -0x1(%r8),%ebx
            putch(padc, put_arg);
  804160f249:	45 0f be f1          	movsbl %r9b,%r14d
        while (--width > 0) {
  804160f24d:	85 db                	test   %ebx,%ebx
  804160f24f:	7e 0e                	jle    804160f25f <print_num+0x43>
            putch(padc, put_arg);
  804160f251:	4c 89 ee             	mov    %r13,%rsi
  804160f254:	44 89 f7             	mov    %r14d,%edi
  804160f257:	41 ff d4             	call   *%r12
        while (--width > 0) {
  804160f25a:	83 eb 01             	sub    $0x1,%ebx
  804160f25d:	75 f2                	jne    804160f251 <print_num+0x35>
        }
    }

    const char *dig = capital ? "0123456789ABCDEF" : "0123456789abcdef";
  804160f25f:	80 7d c4 00          	cmpb   $0x0,-0x3c(%rbp)
  804160f263:	48 b9 df 35 61 41 80 	movabs $0x80416135df,%rcx
  804160f26a:	00 00 00 
  804160f26d:	48 b8 f0 35 61 41 80 	movabs $0x80416135f0,%rax
  804160f274:	00 00 00 
  804160f277:	48 0f 44 c8          	cmove  %rax,%rcx

    /* Then print this (the least significant) digit */
    putch(dig[num % base], put_arg);
  804160f27b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160f27f:	ba 00 00 00 00       	mov    $0x0,%edx
  804160f284:	49 f7 f7             	div    %r15
  804160f287:	0f be 3c 11          	movsbl (%rcx,%rdx,1),%edi
  804160f28b:	4c 89 ee             	mov    %r13,%rsi
  804160f28e:	41 ff d4             	call   *%r12
}
  804160f291:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  804160f295:	5b                   	pop    %rbx
  804160f296:	41 5c                	pop    %r12
  804160f298:	41 5d                	pop    %r13
  804160f29a:	41 5e                	pop    %r14
  804160f29c:	41 5f                	pop    %r15
  804160f29e:	5d                   	pop    %rbp
  804160f29f:	c3                   	ret    
        print_num(putch, put_arg, num / base, base, width - 1, padc, capital);
  804160f2a0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804160f2a4:	ba 00 00 00 00       	mov    $0x0,%edx
  804160f2a9:	49 f7 f7             	div    %r15
  804160f2ac:	48 83 ec 08          	sub    $0x8,%rsp
  804160f2b0:	0f b6 55 c4          	movzbl -0x3c(%rbp),%edx
  804160f2b4:	52                   	push   %rdx
  804160f2b5:	45 0f be c9          	movsbl %r9b,%r9d
  804160f2b9:	45 8d 40 ff          	lea    -0x1(%r8),%r8d
  804160f2bd:	48 89 c2             	mov    %rax,%rdx
  804160f2c0:	48 b8 1c f2 60 41 80 	movabs $0x804160f21c,%rax
  804160f2c7:	00 00 00 
  804160f2ca:	ff d0                	call   *%rax
  804160f2cc:	48 83 c4 10          	add    $0x10,%rsp
  804160f2d0:	eb 8d                	jmp    804160f25f <print_num+0x43>

000000804160f2d2 <sprintputch>:
    int count;
};

static void
sprintputch(int ch, struct sprintbuf *state) {
    state->count++;
  804160f2d2:	83 46 10 01          	addl   $0x1,0x10(%rsi)
    if (state->start < state->end) {
  804160f2d6:	48 8b 06             	mov    (%rsi),%rax
  804160f2d9:	48 3b 46 08          	cmp    0x8(%rsi),%rax
  804160f2dd:	73 0a                	jae    804160f2e9 <sprintputch+0x17>
        *state->start++ = ch;
  804160f2df:	48 8d 50 01          	lea    0x1(%rax),%rdx
  804160f2e3:	48 89 16             	mov    %rdx,(%rsi)
  804160f2e6:	40 88 38             	mov    %dil,(%rax)
    }
}
  804160f2e9:	c3                   	ret    

000000804160f2ea <printfmt>:
printfmt(void (*putch)(int, void *), void *putdat, const char *fmt, ...) {
  804160f2ea:	55                   	push   %rbp
  804160f2eb:	48 89 e5             	mov    %rsp,%rbp
  804160f2ee:	48 83 ec 50          	sub    $0x50,%rsp
  804160f2f2:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  804160f2f6:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  804160f2fa:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_start(ap, fmt);
  804160f2fe:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
  804160f305:	48 8d 45 10          	lea    0x10(%rbp),%rax
  804160f309:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f30d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  804160f311:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    vprintfmt(putch, putdat, fmt, ap);
  804160f315:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  804160f319:	48 b8 27 f3 60 41 80 	movabs $0x804160f327,%rax
  804160f320:	00 00 00 
  804160f323:	ff d0                	call   *%rax
}
  804160f325:	c9                   	leave  
  804160f326:	c3                   	ret    

000000804160f327 <vprintfmt>:
vprintfmt(void (*putch)(int, void *), void *put_arg, const char *fmt, va_list ap) {
  804160f327:	55                   	push   %rbp
  804160f328:	48 89 e5             	mov    %rsp,%rbp
  804160f32b:	41 57                	push   %r15
  804160f32d:	41 56                	push   %r14
  804160f32f:	41 55                	push   %r13
  804160f331:	41 54                	push   %r12
  804160f333:	53                   	push   %rbx
  804160f334:	48 83 ec 48          	sub    $0x48,%rsp
  804160f338:	49 89 fc             	mov    %rdi,%r12
  804160f33b:	49 89 f6             	mov    %rsi,%r14
  804160f33e:	49 89 d7             	mov    %rdx,%r15
    va_copy(aq, ap);
  804160f341:	48 8b 01             	mov    (%rcx),%rax
  804160f344:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  804160f348:	48 8b 41 08          	mov    0x8(%rcx),%rax
  804160f34c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f350:	48 8b 41 10          	mov    0x10(%rcx),%rax
  804160f354:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        while ((ch = *ufmt++) != '%') {
  804160f358:	49 8d 5f 01          	lea    0x1(%r15),%rbx
  804160f35c:	41 0f b6 3f          	movzbl (%r15),%edi
  804160f360:	40 80 ff 25          	cmp    $0x25,%dil
  804160f364:	74 18                	je     804160f37e <vprintfmt+0x57>
            if (!ch) return;
  804160f366:	40 84 ff             	test   %dil,%dil
  804160f369:	0f 84 d1 06 00 00    	je     804160fa40 <vprintfmt+0x719>
            putch(ch, put_arg);
  804160f36f:	40 0f b6 ff          	movzbl %dil,%edi
  804160f373:	4c 89 f6             	mov    %r14,%rsi
  804160f376:	41 ff d4             	call   *%r12
        while ((ch = *ufmt++) != '%') {
  804160f379:	49 89 df             	mov    %rbx,%r15
  804160f37c:	eb da                	jmp    804160f358 <vprintfmt+0x31>
            precision = va_arg(aq, int);
  804160f37e:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
        bool altflag = 0, zflag = 0;
  804160f382:	b9 00 00 00 00       	mov    $0x0,%ecx
  804160f387:	c6 45 98 00          	movb   $0x0,-0x68(%rbp)
        unsigned lflag = 0, base = 10;
  804160f38b:	ba 00 00 00 00       	mov    $0x0,%edx
        int width = -1, precision = -1;
  804160f390:	41 bd ff ff ff ff    	mov    $0xffffffff,%r13d
  804160f396:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,-0x54(%rbp)
        char padc = ' ';
  804160f39d:	c6 45 a0 20          	movb   $0x20,-0x60(%rbp)
            width = MAX(0, width);
  804160f3a1:	bf 00 00 00 00       	mov    $0x0,%edi
        switch (ch = *ufmt++) {
  804160f3a6:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804160f3ac:	4c 8d 7b 01          	lea    0x1(%rbx),%r15
  804160f3b0:	44 0f b6 0b          	movzbl (%rbx),%r9d
  804160f3b4:	41 8d 41 dd          	lea    -0x23(%r9),%eax
  804160f3b8:	3c 57                	cmp    $0x57,%al
  804160f3ba:	0f 87 65 06 00 00    	ja     804160fa25 <vprintfmt+0x6fe>
  804160f3c0:	0f b6 c0             	movzbl %al,%eax
  804160f3c3:	49 ba 80 37 61 41 80 	movabs $0x8041613780,%r10
  804160f3ca:	00 00 00 
  804160f3cd:	41 ff 24 c2          	jmp    *(%r10,%rax,8)
  804160f3d1:	4c 89 fb             	mov    %r15,%rbx
            altflag = 1;
  804160f3d4:	44 88 45 98          	mov    %r8b,-0x68(%rbp)
  804160f3d8:	eb d2                	jmp    804160f3ac <vprintfmt+0x85>
        switch (ch = *ufmt++) {
  804160f3da:	4c 89 fb             	mov    %r15,%rbx
  804160f3dd:	44 89 c1             	mov    %r8d,%ecx
  804160f3e0:	eb ca                	jmp    804160f3ac <vprintfmt+0x85>
            padc = ch;
  804160f3e2:	44 88 4d a0          	mov    %r9b,-0x60(%rbp)
        switch (ch = *ufmt++) {
  804160f3e6:	4c 89 fb             	mov    %r15,%rbx
            goto reswitch;
  804160f3e9:	eb c1                	jmp    804160f3ac <vprintfmt+0x85>
            precision = va_arg(aq, int);
  804160f3eb:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f3ee:	83 f8 2f             	cmp    $0x2f,%eax
  804160f3f1:	77 24                	ja     804160f417 <vprintfmt+0xf0>
  804160f3f3:	41 89 c1             	mov    %eax,%r9d
  804160f3f6:	49 01 f1             	add    %rsi,%r9
  804160f3f9:	83 c0 08             	add    $0x8,%eax
  804160f3fc:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f3ff:	45 8b 29             	mov    (%r9),%r13d
        switch (ch = *ufmt++) {
  804160f402:	4c 89 fb             	mov    %r15,%rbx
            if (width < 0) {
  804160f405:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  804160f409:	79 a1                	jns    804160f3ac <vprintfmt+0x85>
                width = precision;
  804160f40b:	44 89 6d ac          	mov    %r13d,-0x54(%rbp)
                precision = -1;
  804160f40f:	41 bd ff ff ff ff    	mov    $0xffffffff,%r13d
  804160f415:	eb 95                	jmp    804160f3ac <vprintfmt+0x85>
            precision = va_arg(aq, int);
  804160f417:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
  804160f41b:	49 8d 41 08          	lea    0x8(%r9),%rax
  804160f41f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f423:	eb da                	jmp    804160f3ff <vprintfmt+0xd8>
        switch (ch = *ufmt++) {
  804160f425:	45 0f b6 c9          	movzbl %r9b,%r9d
                precision = precision * 10 + ch - '0';
  804160f429:	45 8d 69 d0          	lea    -0x30(%r9),%r13d
                if ((ch = *ufmt) - '0' > 9) break;
  804160f42d:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
  804160f431:	3c 39                	cmp    $0x39,%al
  804160f433:	77 1e                	ja     804160f453 <vprintfmt+0x12c>
            for (precision = 0;; ++ufmt) {
  804160f435:	49 83 c7 01          	add    $0x1,%r15
                precision = precision * 10 + ch - '0';
  804160f439:	47 8d 4c ad 00       	lea    0x0(%r13,%r13,4),%r9d
  804160f43e:	0f b6 c0             	movzbl %al,%eax
  804160f441:	46 8d 6c 48 d0       	lea    -0x30(%rax,%r9,2),%r13d
                if ((ch = *ufmt) - '0' > 9) break;
  804160f446:	41 0f b6 07          	movzbl (%r15),%eax
  804160f44a:	3c 39                	cmp    $0x39,%al
  804160f44c:	76 e7                	jbe    804160f435 <vprintfmt+0x10e>
            for (precision = 0;; ++ufmt) {
  804160f44e:	4c 89 fb             	mov    %r15,%rbx
        process_precision:
  804160f451:	eb b2                	jmp    804160f405 <vprintfmt+0xde>
        switch (ch = *ufmt++) {
  804160f453:	4c 89 fb             	mov    %r15,%rbx
  804160f456:	eb ad                	jmp    804160f405 <vprintfmt+0xde>
            width = MAX(0, width);
  804160f458:	8b 45 ac             	mov    -0x54(%rbp),%eax
  804160f45b:	85 c0                	test   %eax,%eax
  804160f45d:	0f 48 c7             	cmovs  %edi,%eax
  804160f460:	89 45 ac             	mov    %eax,-0x54(%rbp)
        switch (ch = *ufmt++) {
  804160f463:	4c 89 fb             	mov    %r15,%rbx
            goto reswitch;
  804160f466:	e9 41 ff ff ff       	jmp    804160f3ac <vprintfmt+0x85>
            lflag++;
  804160f46b:	83 c2 01             	add    $0x1,%edx
        switch (ch = *ufmt++) {
  804160f46e:	4c 89 fb             	mov    %r15,%rbx
            goto reswitch;
  804160f471:	e9 36 ff ff ff       	jmp    804160f3ac <vprintfmt+0x85>
            putch(va_arg(aq, int), put_arg);
  804160f476:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f479:	83 f8 2f             	cmp    $0x2f,%eax
  804160f47c:	77 18                	ja     804160f496 <vprintfmt+0x16f>
  804160f47e:	89 c2                	mov    %eax,%edx
  804160f480:	48 01 f2             	add    %rsi,%rdx
  804160f483:	83 c0 08             	add    $0x8,%eax
  804160f486:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f489:	4c 89 f6             	mov    %r14,%rsi
  804160f48c:	8b 3a                	mov    (%rdx),%edi
  804160f48e:	41 ff d4             	call   *%r12
            break;
  804160f491:	e9 c2 fe ff ff       	jmp    804160f358 <vprintfmt+0x31>
            putch(va_arg(aq, int), put_arg);
  804160f496:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804160f49a:	48 8d 42 08          	lea    0x8(%rdx),%rax
  804160f49e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f4a2:	eb e5                	jmp    804160f489 <vprintfmt+0x162>
            int err = va_arg(aq, int);
  804160f4a4:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f4a7:	83 f8 2f             	cmp    $0x2f,%eax
  804160f4aa:	77 5b                	ja     804160f507 <vprintfmt+0x1e0>
  804160f4ac:	89 c2                	mov    %eax,%edx
  804160f4ae:	48 01 d6             	add    %rdx,%rsi
  804160f4b1:	83 c0 08             	add    $0x8,%eax
  804160f4b4:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f4b7:	8b 0e                	mov    (%rsi),%ecx
            if (err < 0) err = -err;
  804160f4b9:	89 c8                	mov    %ecx,%eax
  804160f4bb:	c1 f8 1f             	sar    $0x1f,%eax
  804160f4be:	31 c1                	xor    %eax,%ecx
  804160f4c0:	29 c1                	sub    %eax,%ecx
            if (err >= MAXERROR || !(strerr = error_string[err])) {
  804160f4c2:	83 f9 13             	cmp    $0x13,%ecx
  804160f4c5:	7f 4e                	jg     804160f515 <vprintfmt+0x1ee>
  804160f4c7:	48 63 c1             	movslq %ecx,%rax
  804160f4ca:	48 ba 40 3a 61 41 80 	movabs $0x8041613a40,%rdx
  804160f4d1:	00 00 00 
  804160f4d4:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  804160f4d8:	48 85 c0             	test   %rax,%rax
  804160f4db:	74 38                	je     804160f515 <vprintfmt+0x1ee>
                printfmt(putch, put_arg, "%s", strerr);
  804160f4dd:	48 89 c1             	mov    %rax,%rcx
  804160f4e0:	48 ba 28 14 61 41 80 	movabs $0x8041611428,%rdx
  804160f4e7:	00 00 00 
  804160f4ea:	4c 89 f6             	mov    %r14,%rsi
  804160f4ed:	4c 89 e7             	mov    %r12,%rdi
  804160f4f0:	b8 00 00 00 00       	mov    $0x0,%eax
  804160f4f5:	49 b8 ea f2 60 41 80 	movabs $0x804160f2ea,%r8
  804160f4fc:	00 00 00 
  804160f4ff:	41 ff d0             	call   *%r8
  804160f502:	e9 51 fe ff ff       	jmp    804160f358 <vprintfmt+0x31>
            int err = va_arg(aq, int);
  804160f507:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f50b:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f50f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f513:	eb a2                	jmp    804160f4b7 <vprintfmt+0x190>
                printfmt(putch, put_arg, "error %d", err);
  804160f515:	48 ba 08 36 61 41 80 	movabs $0x8041613608,%rdx
  804160f51c:	00 00 00 
  804160f51f:	4c 89 f6             	mov    %r14,%rsi
  804160f522:	4c 89 e7             	mov    %r12,%rdi
  804160f525:	b8 00 00 00 00       	mov    $0x0,%eax
  804160f52a:	49 b8 ea f2 60 41 80 	movabs $0x804160f2ea,%r8
  804160f531:	00 00 00 
  804160f534:	41 ff d0             	call   *%r8
  804160f537:	e9 1c fe ff ff       	jmp    804160f358 <vprintfmt+0x31>
            const char *ptr = va_arg(aq, char *);
  804160f53c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f53f:	83 f8 2f             	cmp    $0x2f,%eax
  804160f542:	77 55                	ja     804160f599 <vprintfmt+0x272>
  804160f544:	89 c2                	mov    %eax,%edx
  804160f546:	48 01 d6             	add    %rdx,%rsi
  804160f549:	83 c0 08             	add    $0x8,%eax
  804160f54c:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f54f:	48 8b 16             	mov    (%rsi),%rdx
            if (!ptr) ptr = "(null)";
  804160f552:	48 85 d2             	test   %rdx,%rdx
  804160f555:	48 b8 01 36 61 41 80 	movabs $0x8041613601,%rax
  804160f55c:	00 00 00 
  804160f55f:	48 0f 45 c2          	cmovne %rdx,%rax
  804160f563:	48 89 45 90          	mov    %rax,-0x70(%rbp)
            if (width > 0 && padc != '-') {
  804160f567:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  804160f56b:	7e 06                	jle    804160f573 <vprintfmt+0x24c>
  804160f56d:	80 7d a0 2d          	cmpb   $0x2d,-0x60(%rbp)
  804160f571:	75 34                	jne    804160f5a7 <vprintfmt+0x280>
            for (; (ch = *ptr++) && (precision < 0 || --precision >= 0); width--) {
  804160f573:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804160f577:	48 8d 58 01          	lea    0x1(%rax),%rbx
  804160f57b:	0f b6 00             	movzbl (%rax),%eax
  804160f57e:	84 c0                	test   %al,%al
  804160f580:	0f 84 b2 00 00 00    	je     804160f638 <vprintfmt+0x311>
  804160f586:	4c 89 75 a0          	mov    %r14,-0x60(%rbp)
  804160f58a:	44 0f b6 75 98       	movzbl -0x68(%rbp),%r14d
  804160f58f:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  804160f593:	44 8b 7d ac          	mov    -0x54(%rbp),%r15d
  804160f597:	eb 74                	jmp    804160f60d <vprintfmt+0x2e6>
            const char *ptr = va_arg(aq, char *);
  804160f599:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f59d:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f5a1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f5a5:	eb a8                	jmp    804160f54f <vprintfmt+0x228>
                width -= strnlen(ptr, precision);
  804160f5a7:	49 63 f5             	movslq %r13d,%rsi
  804160f5aa:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804160f5ae:	48 b8 36 fc 60 41 80 	movabs $0x804160fc36,%rax
  804160f5b5:	00 00 00 
  804160f5b8:	ff d0                	call   *%rax
  804160f5ba:	48 89 c2             	mov    %rax,%rdx
  804160f5bd:	8b 45 ac             	mov    -0x54(%rbp),%eax
  804160f5c0:	29 d0                	sub    %edx,%eax
                while (width-- > 0) putch(padc, put_arg);
  804160f5c2:	8d 48 ff             	lea    -0x1(%rax),%ecx
  804160f5c5:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  804160f5c8:	85 c0                	test   %eax,%eax
  804160f5ca:	7e a7                	jle    804160f573 <vprintfmt+0x24c>
  804160f5cc:	0f be 5d a0          	movsbl -0x60(%rbp),%ebx
  804160f5d0:	44 89 6d a0          	mov    %r13d,-0x60(%rbp)
  804160f5d4:	41 89 cd             	mov    %ecx,%r13d
  804160f5d7:	4c 89 f6             	mov    %r14,%rsi
  804160f5da:	89 df                	mov    %ebx,%edi
  804160f5dc:	41 ff d4             	call   *%r12
  804160f5df:	41 83 ed 01          	sub    $0x1,%r13d
  804160f5e3:	41 83 fd ff          	cmp    $0xffffffff,%r13d
  804160f5e7:	75 ee                	jne    804160f5d7 <vprintfmt+0x2b0>
  804160f5e9:	44 89 6d ac          	mov    %r13d,-0x54(%rbp)
  804160f5ed:	44 8b 6d a0          	mov    -0x60(%rbp),%r13d
  804160f5f1:	eb 80                	jmp    804160f573 <vprintfmt+0x24c>
                putch(altflag && (ch < ' ' || ch > '~') ? '?' : ch, put_arg);
  804160f5f3:	0f b6 f8             	movzbl %al,%edi
  804160f5f6:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804160f5fa:	41 ff d4             	call   *%r12
            for (; (ch = *ptr++) && (precision < 0 || --precision >= 0); width--) {
  804160f5fd:	41 83 ef 01          	sub    $0x1,%r15d
  804160f601:	48 83 c3 01          	add    $0x1,%rbx
  804160f605:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  804160f609:	84 c0                	test   %al,%al
  804160f60b:	74 1f                	je     804160f62c <vprintfmt+0x305>
  804160f60d:	45 85 ed             	test   %r13d,%r13d
  804160f610:	78 06                	js     804160f618 <vprintfmt+0x2f1>
  804160f612:	41 83 ed 01          	sub    $0x1,%r13d
  804160f616:	78 46                	js     804160f65e <vprintfmt+0x337>
                putch(altflag && (ch < ' ' || ch > '~') ? '?' : ch, put_arg);
  804160f618:	45 84 f6             	test   %r14b,%r14b
  804160f61b:	74 d6                	je     804160f5f3 <vprintfmt+0x2cc>
  804160f61d:	8d 50 e0             	lea    -0x20(%rax),%edx
  804160f620:	bf 3f 00 00 00       	mov    $0x3f,%edi
  804160f625:	80 fa 5e             	cmp    $0x5e,%dl
  804160f628:	77 cc                	ja     804160f5f6 <vprintfmt+0x2cf>
  804160f62a:	eb c7                	jmp    804160f5f3 <vprintfmt+0x2cc>
  804160f62c:	44 89 7d ac          	mov    %r15d,-0x54(%rbp)
  804160f630:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
  804160f634:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
            while (width-- > 0) putch(' ', put_arg);
  804160f638:	8b 45 ac             	mov    -0x54(%rbp),%eax
  804160f63b:	8d 58 ff             	lea    -0x1(%rax),%ebx
  804160f63e:	85 c0                	test   %eax,%eax
  804160f640:	0f 8e 12 fd ff ff    	jle    804160f358 <vprintfmt+0x31>
  804160f646:	4c 89 f6             	mov    %r14,%rsi
  804160f649:	bf 20 00 00 00       	mov    $0x20,%edi
  804160f64e:	41 ff d4             	call   *%r12
  804160f651:	83 eb 01             	sub    $0x1,%ebx
  804160f654:	83 fb ff             	cmp    $0xffffffff,%ebx
  804160f657:	75 ed                	jne    804160f646 <vprintfmt+0x31f>
  804160f659:	e9 fa fc ff ff       	jmp    804160f358 <vprintfmt+0x31>
  804160f65e:	44 89 7d ac          	mov    %r15d,-0x54(%rbp)
  804160f662:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
  804160f666:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
  804160f66a:	eb cc                	jmp    804160f638 <vprintfmt+0x311>
    if (zflag) return va_arg(*ap, size_t);
  804160f66c:	45 89 cd             	mov    %r9d,%r13d
  804160f66f:	84 c9                	test   %cl,%cl
  804160f671:	75 25                	jne    804160f698 <vprintfmt+0x371>
    switch (lflag) {
  804160f673:	85 d2                	test   %edx,%edx
  804160f675:	74 57                	je     804160f6ce <vprintfmt+0x3a7>
  804160f677:	83 fa 01             	cmp    $0x1,%edx
  804160f67a:	74 78                	je     804160f6f4 <vprintfmt+0x3cd>
        return va_arg(*ap, long long);
  804160f67c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f67f:	83 f8 2f             	cmp    $0x2f,%eax
  804160f682:	0f 87 92 00 00 00    	ja     804160f71a <vprintfmt+0x3f3>
  804160f688:	89 c2                	mov    %eax,%edx
  804160f68a:	48 01 d6             	add    %rdx,%rsi
  804160f68d:	83 c0 08             	add    $0x8,%eax
  804160f690:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f693:	48 8b 1e             	mov    (%rsi),%rbx
  804160f696:	eb 16                	jmp    804160f6ae <vprintfmt+0x387>
    if (zflag) return va_arg(*ap, size_t);
  804160f698:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f69b:	83 f8 2f             	cmp    $0x2f,%eax
  804160f69e:	77 20                	ja     804160f6c0 <vprintfmt+0x399>
  804160f6a0:	89 c2                	mov    %eax,%edx
  804160f6a2:	48 01 d6             	add    %rdx,%rsi
  804160f6a5:	83 c0 08             	add    $0x8,%eax
  804160f6a8:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f6ab:	48 8b 1e             	mov    (%rsi),%rbx
            if (i < 0) {
  804160f6ae:	48 85 db             	test   %rbx,%rbx
  804160f6b1:	78 78                	js     804160f72b <vprintfmt+0x404>
            num = i;
  804160f6b3:	48 89 da             	mov    %rbx,%rdx
        unsigned lflag = 0, base = 10;
  804160f6b6:	b9 0a 00 00 00       	mov    $0xa,%ecx
            goto number;
  804160f6bb:	e9 49 02 00 00       	jmp    804160f909 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  804160f6c0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f6c4:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f6c8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f6cc:	eb dd                	jmp    804160f6ab <vprintfmt+0x384>
        return va_arg(*ap, int);
  804160f6ce:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f6d1:	83 f8 2f             	cmp    $0x2f,%eax
  804160f6d4:	77 10                	ja     804160f6e6 <vprintfmt+0x3bf>
  804160f6d6:	89 c2                	mov    %eax,%edx
  804160f6d8:	48 01 d6             	add    %rdx,%rsi
  804160f6db:	83 c0 08             	add    $0x8,%eax
  804160f6de:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f6e1:	48 63 1e             	movslq (%rsi),%rbx
  804160f6e4:	eb c8                	jmp    804160f6ae <vprintfmt+0x387>
  804160f6e6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f6ea:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f6ee:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f6f2:	eb ed                	jmp    804160f6e1 <vprintfmt+0x3ba>
        return va_arg(*ap, long);
  804160f6f4:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f6f7:	83 f8 2f             	cmp    $0x2f,%eax
  804160f6fa:	77 10                	ja     804160f70c <vprintfmt+0x3e5>
  804160f6fc:	89 c2                	mov    %eax,%edx
  804160f6fe:	48 01 d6             	add    %rdx,%rsi
  804160f701:	83 c0 08             	add    $0x8,%eax
  804160f704:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f707:	48 8b 1e             	mov    (%rsi),%rbx
  804160f70a:	eb a2                	jmp    804160f6ae <vprintfmt+0x387>
  804160f70c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f710:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f714:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f718:	eb ed                	jmp    804160f707 <vprintfmt+0x3e0>
        return va_arg(*ap, long long);
  804160f71a:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f71e:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f722:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f726:	e9 68 ff ff ff       	jmp    804160f693 <vprintfmt+0x36c>
                putch('-', put_arg);
  804160f72b:	4c 89 f6             	mov    %r14,%rsi
  804160f72e:	bf 2d 00 00 00       	mov    $0x2d,%edi
  804160f733:	41 ff d4             	call   *%r12
                i = -i;
  804160f736:	48 f7 db             	neg    %rbx
  804160f739:	e9 75 ff ff ff       	jmp    804160f6b3 <vprintfmt+0x38c>
    if (zflag) return va_arg(*ap, size_t);
  804160f73e:	45 89 cd             	mov    %r9d,%r13d
  804160f741:	84 c9                	test   %cl,%cl
  804160f743:	75 2d                	jne    804160f772 <vprintfmt+0x44b>
    switch (lflag) {
  804160f745:	85 d2                	test   %edx,%edx
  804160f747:	74 57                	je     804160f7a0 <vprintfmt+0x479>
  804160f749:	83 fa 01             	cmp    $0x1,%edx
  804160f74c:	74 7f                	je     804160f7cd <vprintfmt+0x4a6>
        return va_arg(*ap, unsigned long long);
  804160f74e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f751:	83 f8 2f             	cmp    $0x2f,%eax
  804160f754:	0f 87 a1 00 00 00    	ja     804160f7fb <vprintfmt+0x4d4>
  804160f75a:	89 c2                	mov    %eax,%edx
  804160f75c:	48 01 d6             	add    %rdx,%rsi
  804160f75f:	83 c0 08             	add    $0x8,%eax
  804160f762:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f765:	48 8b 16             	mov    (%rsi),%rdx
        unsigned lflag = 0, base = 10;
  804160f768:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned long long);
  804160f76d:	e9 97 01 00 00       	jmp    804160f909 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  804160f772:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f775:	83 f8 2f             	cmp    $0x2f,%eax
  804160f778:	77 18                	ja     804160f792 <vprintfmt+0x46b>
  804160f77a:	89 c2                	mov    %eax,%edx
  804160f77c:	48 01 d6             	add    %rdx,%rsi
  804160f77f:	83 c0 08             	add    $0x8,%eax
  804160f782:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f785:	48 8b 16             	mov    (%rsi),%rdx
        unsigned lflag = 0, base = 10;
  804160f788:	b9 0a 00 00 00       	mov    $0xa,%ecx
    if (zflag) return va_arg(*ap, size_t);
  804160f78d:	e9 77 01 00 00       	jmp    804160f909 <vprintfmt+0x5e2>
  804160f792:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f796:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f79a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f79e:	eb e5                	jmp    804160f785 <vprintfmt+0x45e>
        return va_arg(*ap, unsigned int);
  804160f7a0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f7a3:	83 f8 2f             	cmp    $0x2f,%eax
  804160f7a6:	77 17                	ja     804160f7bf <vprintfmt+0x498>
  804160f7a8:	89 c2                	mov    %eax,%edx
  804160f7aa:	48 01 d6             	add    %rdx,%rsi
  804160f7ad:	83 c0 08             	add    $0x8,%eax
  804160f7b0:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f7b3:	8b 16                	mov    (%rsi),%edx
        unsigned lflag = 0, base = 10;
  804160f7b5:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned int);
  804160f7ba:	e9 4a 01 00 00       	jmp    804160f909 <vprintfmt+0x5e2>
  804160f7bf:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f7c3:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f7c7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f7cb:	eb e6                	jmp    804160f7b3 <vprintfmt+0x48c>
        return va_arg(*ap, unsigned long);
  804160f7cd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f7d0:	83 f8 2f             	cmp    $0x2f,%eax
  804160f7d3:	77 18                	ja     804160f7ed <vprintfmt+0x4c6>
  804160f7d5:	89 c2                	mov    %eax,%edx
  804160f7d7:	48 01 d6             	add    %rdx,%rsi
  804160f7da:	83 c0 08             	add    $0x8,%eax
  804160f7dd:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f7e0:	48 8b 16             	mov    (%rsi),%rdx
        unsigned lflag = 0, base = 10;
  804160f7e3:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned long);
  804160f7e8:	e9 1c 01 00 00       	jmp    804160f909 <vprintfmt+0x5e2>
  804160f7ed:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f7f1:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f7f5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f7f9:	eb e5                	jmp    804160f7e0 <vprintfmt+0x4b9>
        return va_arg(*ap, unsigned long long);
  804160f7fb:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f7ff:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f803:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f807:	e9 59 ff ff ff       	jmp    804160f765 <vprintfmt+0x43e>
    if (zflag) return va_arg(*ap, size_t);
  804160f80c:	45 89 cd             	mov    %r9d,%r13d
  804160f80f:	84 c9                	test   %cl,%cl
  804160f811:	75 2d                	jne    804160f840 <vprintfmt+0x519>
    switch (lflag) {
  804160f813:	85 d2                	test   %edx,%edx
  804160f815:	74 57                	je     804160f86e <vprintfmt+0x547>
  804160f817:	83 fa 01             	cmp    $0x1,%edx
  804160f81a:	74 7c                	je     804160f898 <vprintfmt+0x571>
        return va_arg(*ap, unsigned long long);
  804160f81c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f81f:	83 f8 2f             	cmp    $0x2f,%eax
  804160f822:	0f 87 9b 00 00 00    	ja     804160f8c3 <vprintfmt+0x59c>
  804160f828:	89 c2                	mov    %eax,%edx
  804160f82a:	48 01 d6             	add    %rdx,%rsi
  804160f82d:	83 c0 08             	add    $0x8,%eax
  804160f830:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f833:	48 8b 16             	mov    (%rsi),%rdx
            base = 8;
  804160f836:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned long long);
  804160f83b:	e9 c9 00 00 00       	jmp    804160f909 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  804160f840:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f843:	83 f8 2f             	cmp    $0x2f,%eax
  804160f846:	77 18                	ja     804160f860 <vprintfmt+0x539>
  804160f848:	89 c2                	mov    %eax,%edx
  804160f84a:	48 01 d6             	add    %rdx,%rsi
  804160f84d:	83 c0 08             	add    $0x8,%eax
  804160f850:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f853:	48 8b 16             	mov    (%rsi),%rdx
            base = 8;
  804160f856:	b9 08 00 00 00       	mov    $0x8,%ecx
    if (zflag) return va_arg(*ap, size_t);
  804160f85b:	e9 a9 00 00 00       	jmp    804160f909 <vprintfmt+0x5e2>
  804160f860:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f864:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f868:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f86c:	eb e5                	jmp    804160f853 <vprintfmt+0x52c>
        return va_arg(*ap, unsigned int);
  804160f86e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f871:	83 f8 2f             	cmp    $0x2f,%eax
  804160f874:	77 14                	ja     804160f88a <vprintfmt+0x563>
  804160f876:	89 c2                	mov    %eax,%edx
  804160f878:	48 01 d6             	add    %rdx,%rsi
  804160f87b:	83 c0 08             	add    $0x8,%eax
  804160f87e:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f881:	8b 16                	mov    (%rsi),%edx
            base = 8;
  804160f883:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned int);
  804160f888:	eb 7f                	jmp    804160f909 <vprintfmt+0x5e2>
  804160f88a:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f88e:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f892:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f896:	eb e9                	jmp    804160f881 <vprintfmt+0x55a>
        return va_arg(*ap, unsigned long);
  804160f898:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f89b:	83 f8 2f             	cmp    $0x2f,%eax
  804160f89e:	77 15                	ja     804160f8b5 <vprintfmt+0x58e>
  804160f8a0:	89 c2                	mov    %eax,%edx
  804160f8a2:	48 01 d6             	add    %rdx,%rsi
  804160f8a5:	83 c0 08             	add    $0x8,%eax
  804160f8a8:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f8ab:	48 8b 16             	mov    (%rsi),%rdx
            base = 8;
  804160f8ae:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned long);
  804160f8b3:	eb 54                	jmp    804160f909 <vprintfmt+0x5e2>
  804160f8b5:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f8b9:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f8bd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f8c1:	eb e8                	jmp    804160f8ab <vprintfmt+0x584>
        return va_arg(*ap, unsigned long long);
  804160f8c3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f8c7:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f8cb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f8cf:	e9 5f ff ff ff       	jmp    804160f833 <vprintfmt+0x50c>
            putch('0', put_arg);
  804160f8d4:	45 89 cd             	mov    %r9d,%r13d
  804160f8d7:	4c 89 f6             	mov    %r14,%rsi
  804160f8da:	bf 30 00 00 00       	mov    $0x30,%edi
  804160f8df:	41 ff d4             	call   *%r12
            putch('x', put_arg);
  804160f8e2:	4c 89 f6             	mov    %r14,%rsi
  804160f8e5:	bf 78 00 00 00       	mov    $0x78,%edi
  804160f8ea:	41 ff d4             	call   *%r12
            num = (uintptr_t)va_arg(aq, void *);
  804160f8ed:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f8f0:	83 f8 2f             	cmp    $0x2f,%eax
  804160f8f3:	77 47                	ja     804160f93c <vprintfmt+0x615>
  804160f8f5:	89 c2                	mov    %eax,%edx
  804160f8f7:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  804160f8fb:	83 c0 08             	add    $0x8,%eax
  804160f8fe:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f901:	48 8b 12             	mov    (%rdx),%rdx
            base = 16;
  804160f904:	b9 10 00 00 00       	mov    $0x10,%ecx
            print_num(putch, put_arg, num, base, width, padc, ch == 'X');
  804160f909:	48 83 ec 08          	sub    $0x8,%rsp
  804160f90d:	41 80 fd 58          	cmp    $0x58,%r13b
  804160f911:	0f 94 c0             	sete   %al
  804160f914:	0f b6 c0             	movzbl %al,%eax
  804160f917:	50                   	push   %rax
  804160f918:	44 0f be 4d a0       	movsbl -0x60(%rbp),%r9d
  804160f91d:	44 8b 45 ac          	mov    -0x54(%rbp),%r8d
  804160f921:	4c 89 f6             	mov    %r14,%rsi
  804160f924:	4c 89 e7             	mov    %r12,%rdi
  804160f927:	48 b8 1c f2 60 41 80 	movabs $0x804160f21c,%rax
  804160f92e:	00 00 00 
  804160f931:	ff d0                	call   *%rax
            break;
  804160f933:	48 83 c4 10          	add    $0x10,%rsp
  804160f937:	e9 1c fa ff ff       	jmp    804160f358 <vprintfmt+0x31>
            num = (uintptr_t)va_arg(aq, void *);
  804160f93c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804160f940:	48 8d 42 08          	lea    0x8(%rdx),%rax
  804160f944:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f948:	eb b7                	jmp    804160f901 <vprintfmt+0x5da>
    if (zflag) return va_arg(*ap, size_t);
  804160f94a:	45 89 cd             	mov    %r9d,%r13d
  804160f94d:	84 c9                	test   %cl,%cl
  804160f94f:	75 2a                	jne    804160f97b <vprintfmt+0x654>
    switch (lflag) {
  804160f951:	85 d2                	test   %edx,%edx
  804160f953:	74 54                	je     804160f9a9 <vprintfmt+0x682>
  804160f955:	83 fa 01             	cmp    $0x1,%edx
  804160f958:	74 7c                	je     804160f9d6 <vprintfmt+0x6af>
        return va_arg(*ap, unsigned long long);
  804160f95a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f95d:	83 f8 2f             	cmp    $0x2f,%eax
  804160f960:	0f 87 9e 00 00 00    	ja     804160fa04 <vprintfmt+0x6dd>
  804160f966:	89 c2                	mov    %eax,%edx
  804160f968:	48 01 d6             	add    %rdx,%rsi
  804160f96b:	83 c0 08             	add    $0x8,%eax
  804160f96e:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f971:	48 8b 16             	mov    (%rsi),%rdx
            base = 16;
  804160f974:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned long long);
  804160f979:	eb 8e                	jmp    804160f909 <vprintfmt+0x5e2>
    if (zflag) return va_arg(*ap, size_t);
  804160f97b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f97e:	83 f8 2f             	cmp    $0x2f,%eax
  804160f981:	77 18                	ja     804160f99b <vprintfmt+0x674>
  804160f983:	89 c2                	mov    %eax,%edx
  804160f985:	48 01 d6             	add    %rdx,%rsi
  804160f988:	83 c0 08             	add    $0x8,%eax
  804160f98b:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f98e:	48 8b 16             	mov    (%rsi),%rdx
            base = 16;
  804160f991:	b9 10 00 00 00       	mov    $0x10,%ecx
    if (zflag) return va_arg(*ap, size_t);
  804160f996:	e9 6e ff ff ff       	jmp    804160f909 <vprintfmt+0x5e2>
  804160f99b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f99f:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f9a3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f9a7:	eb e5                	jmp    804160f98e <vprintfmt+0x667>
        return va_arg(*ap, unsigned int);
  804160f9a9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f9ac:	83 f8 2f             	cmp    $0x2f,%eax
  804160f9af:	77 17                	ja     804160f9c8 <vprintfmt+0x6a1>
  804160f9b1:	89 c2                	mov    %eax,%edx
  804160f9b3:	48 01 d6             	add    %rdx,%rsi
  804160f9b6:	83 c0 08             	add    $0x8,%eax
  804160f9b9:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f9bc:	8b 16                	mov    (%rsi),%edx
            base = 16;
  804160f9be:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned int);
  804160f9c3:	e9 41 ff ff ff       	jmp    804160f909 <vprintfmt+0x5e2>
  804160f9c8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f9cc:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f9d0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160f9d4:	eb e6                	jmp    804160f9bc <vprintfmt+0x695>
        return va_arg(*ap, unsigned long);
  804160f9d6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804160f9d9:	83 f8 2f             	cmp    $0x2f,%eax
  804160f9dc:	77 18                	ja     804160f9f6 <vprintfmt+0x6cf>
  804160f9de:	89 c2                	mov    %eax,%edx
  804160f9e0:	48 01 d6             	add    %rdx,%rsi
  804160f9e3:	83 c0 08             	add    $0x8,%eax
  804160f9e6:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804160f9e9:	48 8b 16             	mov    (%rsi),%rdx
            base = 16;
  804160f9ec:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned long);
  804160f9f1:	e9 13 ff ff ff       	jmp    804160f909 <vprintfmt+0x5e2>
  804160f9f6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160f9fa:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160f9fe:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160fa02:	eb e5                	jmp    804160f9e9 <vprintfmt+0x6c2>
        return va_arg(*ap, unsigned long long);
  804160fa04:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804160fa08:	48 8d 46 08          	lea    0x8(%rsi),%rax
  804160fa0c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160fa10:	e9 5c ff ff ff       	jmp    804160f971 <vprintfmt+0x64a>
            putch(ch, put_arg);
  804160fa15:	4c 89 f6             	mov    %r14,%rsi
  804160fa18:	bf 25 00 00 00       	mov    $0x25,%edi
  804160fa1d:	41 ff d4             	call   *%r12
            break;
  804160fa20:	e9 33 f9 ff ff       	jmp    804160f358 <vprintfmt+0x31>
            putch('%', put_arg);
  804160fa25:	4c 89 f6             	mov    %r14,%rsi
  804160fa28:	bf 25 00 00 00       	mov    $0x25,%edi
  804160fa2d:	41 ff d4             	call   *%r12
            while ((--ufmt)[-1] != '%') /* nothing */
  804160fa30:	49 83 ef 01          	sub    $0x1,%r15
  804160fa34:	41 80 7f ff 25       	cmpb   $0x25,-0x1(%r15)
  804160fa39:	75 f5                	jne    804160fa30 <vprintfmt+0x709>
  804160fa3b:	e9 18 f9 ff ff       	jmp    804160f358 <vprintfmt+0x31>
}
  804160fa40:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  804160fa44:	5b                   	pop    %rbx
  804160fa45:	41 5c                	pop    %r12
  804160fa47:	41 5d                	pop    %r13
  804160fa49:	41 5e                	pop    %r14
  804160fa4b:	41 5f                	pop    %r15
  804160fa4d:	5d                   	pop    %rbp
  804160fa4e:	c3                   	ret    

000000804160fa4f <vsnprintf>:

int
vsnprintf(char *buf, size_t n, const char *fmt, va_list ap) {
  804160fa4f:	55                   	push   %rbp
  804160fa50:	48 89 e5             	mov    %rsp,%rbp
  804160fa53:	48 83 ec 20          	sub    $0x20,%rsp
    struct sprintbuf state = {buf, buf + n - 1, 0};
  804160fa57:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804160fa5b:	48 8d 44 37 ff       	lea    -0x1(%rdi,%rsi,1),%rax
  804160fa60:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  804160fa64:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

    if (!buf || n < 1) return -E_INVAL;
  804160fa6b:	48 85 ff             	test   %rdi,%rdi
  804160fa6e:	74 2b                	je     804160fa9b <vsnprintf+0x4c>
  804160fa70:	48 85 f6             	test   %rsi,%rsi
  804160fa73:	74 26                	je     804160fa9b <vsnprintf+0x4c>

    /* Print the string to the buffer */
    vprintfmt((void *)sprintputch, &state, fmt, ap);
  804160fa75:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  804160fa79:	48 bf d2 f2 60 41 80 	movabs $0x804160f2d2,%rdi
  804160fa80:	00 00 00 
  804160fa83:	48 b8 27 f3 60 41 80 	movabs $0x804160f327,%rax
  804160fa8a:	00 00 00 
  804160fa8d:	ff d0                	call   *%rax

    /* Null terminate the buffer */
    *state.start = '\0';
  804160fa8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804160fa93:	c6 00 00             	movb   $0x0,(%rax)

    return state.count;
  804160fa96:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  804160fa99:	c9                   	leave  
  804160fa9a:	c3                   	ret    
    if (!buf || n < 1) return -E_INVAL;
  804160fa9b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804160faa0:	eb f7                	jmp    804160fa99 <vsnprintf+0x4a>

000000804160faa2 <snprintf>:

int
snprintf(char *buf, size_t n, const char *fmt, ...) {
  804160faa2:	55                   	push   %rbp
  804160faa3:	48 89 e5             	mov    %rsp,%rbp
  804160faa6:	48 83 ec 50          	sub    $0x50,%rsp
  804160faaa:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  804160faae:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  804160fab2:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_list ap;

    va_start(ap, fmt);
  804160fab6:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
  804160fabd:	48 8d 45 10          	lea    0x10(%rbp),%rax
  804160fac1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804160fac5:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  804160fac9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int rc = vsnprintf(buf, n, fmt, ap);
  804160facd:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  804160fad1:	48 b8 4f fa 60 41 80 	movabs $0x804160fa4f,%rax
  804160fad8:	00 00 00 
  804160fadb:	ff d0                	call   *%rax
    va_end(ap);

    return rc;
}
  804160fadd:	c9                   	leave  
  804160fade:	c3                   	ret    

000000804160fadf <readline>:
#define BUFLEN 1024

static char buf[BUFLEN];

char *
readline(const char *prompt) {
  804160fadf:	55                   	push   %rbp
  804160fae0:	48 89 e5             	mov    %rsp,%rbp
  804160fae3:	41 57                	push   %r15
  804160fae5:	41 56                	push   %r14
  804160fae7:	41 55                	push   %r13
  804160fae9:	41 54                	push   %r12
  804160faeb:	53                   	push   %rbx
  804160faec:	48 83 ec 08          	sub    $0x8,%rsp
    if (prompt) {
  804160faf0:	48 85 ff             	test   %rdi,%rdi
  804160faf3:	74 1e                	je     804160fb13 <readline+0x34>
#if JOS_KERNEL
        cprintf("%s", prompt);
  804160faf5:	48 89 fe             	mov    %rdi,%rsi
  804160faf8:	48 bf 28 14 61 41 80 	movabs $0x8041611428,%rdi
  804160faff:	00 00 00 
  804160fb02:	b8 00 00 00 00       	mov    $0x0,%eax
  804160fb07:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160fb0e:	00 00 00 
  804160fb11:	ff d2                	call   *%rdx
#else
        fprintf(1, "%s", prompt);
#endif
    }

    bool echo = iscons(0);
  804160fb13:	bf 00 00 00 00       	mov    $0x0,%edi
  804160fb18:	48 b8 3c 0d 60 41 80 	movabs $0x8041600d3c,%rax
  804160fb1f:	00 00 00 
  804160fb22:	ff d0                	call   *%rax
  804160fb24:	41 89 c6             	mov    %eax,%r14d

    for (size_t i = 0;;) {
  804160fb27:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        int c = getchar();
  804160fb2d:	49 bd 1d 0d 60 41 80 	movabs $0x8041600d1d,%r13
  804160fb34:	00 00 00 
                cprintf("read error: %i\n", c);
            return NULL;
        } else if ((c == '\b' || c == '\x7F')) {
            if (i) {
                if (echo) {
                    cputchar('\b');
  804160fb37:	49 bf 87 0c 60 41 80 	movabs $0x8041600c87,%r15
  804160fb3e:	00 00 00 
  804160fb41:	eb 46                	jmp    804160fb89 <readline+0xaa>
            return NULL;
  804160fb43:	b8 00 00 00 00       	mov    $0x0,%eax
            if (c != -E_EOF)
  804160fb48:	83 fb f4             	cmp    $0xfffffff4,%ebx
  804160fb4b:	75 0f                	jne    804160fb5c <readline+0x7d>
            }
            buf[i] = 0;
            return buf;
        }
    }
}
  804160fb4d:	48 83 c4 08          	add    $0x8,%rsp
  804160fb51:	5b                   	pop    %rbx
  804160fb52:	41 5c                	pop    %r12
  804160fb54:	41 5d                	pop    %r13
  804160fb56:	41 5e                	pop    %r14
  804160fb58:	41 5f                	pop    %r15
  804160fb5a:	5d                   	pop    %rbp
  804160fb5b:	c3                   	ret    
                cprintf("read error: %i\n", c);
  804160fb5c:	89 de                	mov    %ebx,%esi
  804160fb5e:	48 bf ff 3a 61 41 80 	movabs $0x8041613aff,%rdi
  804160fb65:	00 00 00 
  804160fb68:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  804160fb6f:	00 00 00 
  804160fb72:	ff d2                	call   *%rdx
            return NULL;
  804160fb74:	b8 00 00 00 00       	mov    $0x0,%eax
  804160fb79:	eb d2                	jmp    804160fb4d <readline+0x6e>
            if (i) {
  804160fb7b:	4d 85 e4             	test   %r12,%r12
  804160fb7e:	74 09                	je     804160fb89 <readline+0xaa>
                if (echo) {
  804160fb80:	45 85 f6             	test   %r14d,%r14d
  804160fb83:	75 3f                	jne    804160fbc4 <readline+0xe5>
                i--;
  804160fb85:	49 83 ec 01          	sub    $0x1,%r12
        int c = getchar();
  804160fb89:	41 ff d5             	call   *%r13
  804160fb8c:	89 c3                	mov    %eax,%ebx
        if (c < 0) {
  804160fb8e:	85 c0                	test   %eax,%eax
  804160fb90:	78 b1                	js     804160fb43 <readline+0x64>
        } else if ((c == '\b' || c == '\x7F')) {
  804160fb92:	83 f8 08             	cmp    $0x8,%eax
  804160fb95:	74 e4                	je     804160fb7b <readline+0x9c>
  804160fb97:	83 f8 7f             	cmp    $0x7f,%eax
  804160fb9a:	74 df                	je     804160fb7b <readline+0x9c>
        } else if (c >= ' ') {
  804160fb9c:	83 f8 1f             	cmp    $0x1f,%eax
  804160fb9f:	7e 44                	jle    804160fbe5 <readline+0x106>
            if (i < BUFLEN - 1) {
  804160fba1:	49 81 fc fe 03 00 00 	cmp    $0x3fe,%r12
  804160fba8:	77 df                	ja     804160fb89 <readline+0xaa>
                if (echo) {
  804160fbaa:	45 85 f6             	test   %r14d,%r14d
  804160fbad:	75 2f                	jne    804160fbde <readline+0xff>
                buf[i++] = (char)c;
  804160fbaf:	48 b8 00 57 40 42 80 	movabs $0x8042405700,%rax
  804160fbb6:	00 00 00 
  804160fbb9:	42 88 1c 20          	mov    %bl,(%rax,%r12,1)
  804160fbbd:	4d 8d 64 24 01       	lea    0x1(%r12),%r12
  804160fbc2:	eb c5                	jmp    804160fb89 <readline+0xaa>
                    cputchar('\b');
  804160fbc4:	bf 08 00 00 00       	mov    $0x8,%edi
  804160fbc9:	41 ff d7             	call   *%r15
                    cputchar(' ');
  804160fbcc:	bf 20 00 00 00       	mov    $0x20,%edi
  804160fbd1:	41 ff d7             	call   *%r15
                    cputchar('\b');
  804160fbd4:	bf 08 00 00 00       	mov    $0x8,%edi
  804160fbd9:	41 ff d7             	call   *%r15
  804160fbdc:	eb a7                	jmp    804160fb85 <readline+0xa6>
                    cputchar(c);
  804160fbde:	89 c7                	mov    %eax,%edi
  804160fbe0:	41 ff d7             	call   *%r15
  804160fbe3:	eb ca                	jmp    804160fbaf <readline+0xd0>
        } else if (c == '\n' || c == '\r') {
  804160fbe5:	83 f8 0a             	cmp    $0xa,%eax
  804160fbe8:	74 05                	je     804160fbef <readline+0x110>
  804160fbea:	83 f8 0d             	cmp    $0xd,%eax
  804160fbed:	75 9a                	jne    804160fb89 <readline+0xaa>
            if (echo) {
  804160fbef:	45 85 f6             	test   %r14d,%r14d
  804160fbf2:	75 14                	jne    804160fc08 <readline+0x129>
            buf[i] = 0;
  804160fbf4:	48 b8 00 57 40 42 80 	movabs $0x8042405700,%rax
  804160fbfb:	00 00 00 
  804160fbfe:	42 c6 04 20 00       	movb   $0x0,(%rax,%r12,1)
            return buf;
  804160fc03:	e9 45 ff ff ff       	jmp    804160fb4d <readline+0x6e>
                cputchar('\n');
  804160fc08:	bf 0a 00 00 00       	mov    $0xa,%edi
  804160fc0d:	48 b8 87 0c 60 41 80 	movabs $0x8041600c87,%rax
  804160fc14:	00 00 00 
  804160fc17:	ff d0                	call   *%rax
  804160fc19:	eb d9                	jmp    804160fbf4 <readline+0x115>

000000804160fc1b <strlen>:
#define ASM 1

size_t
strlen(const char *s) {
    size_t n = 0;
    while (*s++) n++;
  804160fc1b:	80 3f 00             	cmpb   $0x0,(%rdi)
  804160fc1e:	74 10                	je     804160fc30 <strlen+0x15>
    size_t n = 0;
  804160fc20:	b8 00 00 00 00       	mov    $0x0,%eax
    while (*s++) n++;
  804160fc25:	48 83 c0 01          	add    $0x1,%rax
  804160fc29:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  804160fc2d:	75 f6                	jne    804160fc25 <strlen+0xa>
  804160fc2f:	c3                   	ret    
    size_t n = 0;
  804160fc30:	b8 00 00 00 00       	mov    $0x0,%eax
    return n;
}
  804160fc35:	c3                   	ret    

000000804160fc36 <strnlen>:

size_t
strnlen(const char *s, size_t size) {
    size_t n = 0;
  804160fc36:	b8 00 00 00 00       	mov    $0x0,%eax
    while (n < size && *s++) n++;
  804160fc3b:	48 85 f6             	test   %rsi,%rsi
  804160fc3e:	74 10                	je     804160fc50 <strnlen+0x1a>
  804160fc40:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  804160fc44:	74 09                	je     804160fc4f <strnlen+0x19>
  804160fc46:	48 83 c0 01          	add    $0x1,%rax
  804160fc4a:	48 39 c6             	cmp    %rax,%rsi
  804160fc4d:	75 f1                	jne    804160fc40 <strnlen+0xa>
    return n;
}
  804160fc4f:	c3                   	ret    
    size_t n = 0;
  804160fc50:	48 89 f0             	mov    %rsi,%rax
  804160fc53:	c3                   	ret    

000000804160fc54 <strcpy>:

char *
strcpy(char *dst, const char *src) {
    char *res = dst;
    while ((*dst++ = *src++)) /* nothing */
  804160fc54:	b8 00 00 00 00       	mov    $0x0,%eax
  804160fc59:	0f b6 14 06          	movzbl (%rsi,%rax,1),%edx
  804160fc5d:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804160fc60:	48 83 c0 01          	add    $0x1,%rax
  804160fc64:	84 d2                	test   %dl,%dl
  804160fc66:	75 f1                	jne    804160fc59 <strcpy+0x5>
        ;
    return res;
}
  804160fc68:	48 89 f8             	mov    %rdi,%rax
  804160fc6b:	c3                   	ret    

000000804160fc6c <strcat>:

char *
strcat(char *dst, const char *src) {
  804160fc6c:	55                   	push   %rbp
  804160fc6d:	48 89 e5             	mov    %rsp,%rbp
  804160fc70:	41 54                	push   %r12
  804160fc72:	53                   	push   %rbx
  804160fc73:	48 89 fb             	mov    %rdi,%rbx
  804160fc76:	49 89 f4             	mov    %rsi,%r12
    size_t len = strlen(dst);
  804160fc79:	48 b8 1b fc 60 41 80 	movabs $0x804160fc1b,%rax
  804160fc80:	00 00 00 
  804160fc83:	ff d0                	call   *%rax
    strcpy(dst + len, src);
  804160fc85:	48 8d 3c 03          	lea    (%rbx,%rax,1),%rdi
  804160fc89:	4c 89 e6             	mov    %r12,%rsi
  804160fc8c:	48 b8 54 fc 60 41 80 	movabs $0x804160fc54,%rax
  804160fc93:	00 00 00 
  804160fc96:	ff d0                	call   *%rax
    return dst;
}
  804160fc98:	48 89 d8             	mov    %rbx,%rax
  804160fc9b:	5b                   	pop    %rbx
  804160fc9c:	41 5c                	pop    %r12
  804160fc9e:	5d                   	pop    %rbp
  804160fc9f:	c3                   	ret    

000000804160fca0 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
    char *ret = dst;
    while (size-- > 0) {
  804160fca0:	48 85 d2             	test   %rdx,%rdx
  804160fca3:	74 1d                	je     804160fcc2 <strncpy+0x22>
  804160fca5:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
  804160fca9:	48 89 f8             	mov    %rdi,%rax
        *dst++ = *src;
  804160fcac:	48 83 c0 01          	add    $0x1,%rax
  804160fcb0:	0f b6 16             	movzbl (%rsi),%edx
  804160fcb3:	88 50 ff             	mov    %dl,-0x1(%rax)
        /* If strlen(src) < size, null-pad
         * 'dst' out to 'size' chars */
        if (*src) src++;
  804160fcb6:	80 fa 01             	cmp    $0x1,%dl
  804160fcb9:	48 83 de ff          	sbb    $0xffffffffffffffff,%rsi
    while (size-- > 0) {
  804160fcbd:	48 39 c1             	cmp    %rax,%rcx
  804160fcc0:	75 ea                	jne    804160fcac <strncpy+0xc>
    }
    return ret;
}
  804160fcc2:	48 89 f8             	mov    %rdi,%rax
  804160fcc5:	c3                   	ret    

000000804160fcc6 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size) {
    char *dst_in = dst;
    if (size) {
  804160fcc6:	48 89 f8             	mov    %rdi,%rax
  804160fcc9:	48 85 d2             	test   %rdx,%rdx
  804160fccc:	74 24                	je     804160fcf2 <strlcpy+0x2c>
        while (--size > 0 && *src)
  804160fcce:	48 83 ea 01          	sub    $0x1,%rdx
  804160fcd2:	74 1b                	je     804160fcef <strlcpy+0x29>
  804160fcd4:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
  804160fcd8:	0f b6 16             	movzbl (%rsi),%edx
  804160fcdb:	84 d2                	test   %dl,%dl
  804160fcdd:	74 10                	je     804160fcef <strlcpy+0x29>
            *dst++ = *src++;
  804160fcdf:	48 83 c6 01          	add    $0x1,%rsi
  804160fce3:	48 83 c0 01          	add    $0x1,%rax
  804160fce7:	88 50 ff             	mov    %dl,-0x1(%rax)
        while (--size > 0 && *src)
  804160fcea:	48 39 c8             	cmp    %rcx,%rax
  804160fced:	75 e9                	jne    804160fcd8 <strlcpy+0x12>
        *dst = '\0';
  804160fcef:	c6 00 00             	movb   $0x0,(%rax)
    }
    return dst - dst_in;
  804160fcf2:	48 29 f8             	sub    %rdi,%rax
}
  804160fcf5:	c3                   	ret    

000000804160fcf6 <strcmp>:
    return dstlen + srclen;
}

int
strcmp(const char *p, const char *q) {
    while (*p && *p == *q) p++, q++;
  804160fcf6:	0f b6 07             	movzbl (%rdi),%eax
  804160fcf9:	84 c0                	test   %al,%al
  804160fcfb:	74 13                	je     804160fd10 <strcmp+0x1a>
  804160fcfd:	38 06                	cmp    %al,(%rsi)
  804160fcff:	75 0f                	jne    804160fd10 <strcmp+0x1a>
  804160fd01:	48 83 c7 01          	add    $0x1,%rdi
  804160fd05:	48 83 c6 01          	add    $0x1,%rsi
  804160fd09:	0f b6 07             	movzbl (%rdi),%eax
  804160fd0c:	84 c0                	test   %al,%al
  804160fd0e:	75 ed                	jne    804160fcfd <strcmp+0x7>
    return (int)((unsigned char)*p - (unsigned char)*q);
  804160fd10:	0f b6 c0             	movzbl %al,%eax
  804160fd13:	0f b6 16             	movzbl (%rsi),%edx
  804160fd16:	29 d0                	sub    %edx,%eax
}
  804160fd18:	c3                   	ret    

000000804160fd19 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n) {
    while (n && *p && *p == *q) n--, p++, q++;
  804160fd19:	48 85 d2             	test   %rdx,%rdx
  804160fd1c:	74 1f                	je     804160fd3d <strncmp+0x24>
  804160fd1e:	0f b6 07             	movzbl (%rdi),%eax
  804160fd21:	84 c0                	test   %al,%al
  804160fd23:	74 1e                	je     804160fd43 <strncmp+0x2a>
  804160fd25:	3a 06                	cmp    (%rsi),%al
  804160fd27:	75 1a                	jne    804160fd43 <strncmp+0x2a>
  804160fd29:	48 83 c7 01          	add    $0x1,%rdi
  804160fd2d:	48 83 c6 01          	add    $0x1,%rsi
  804160fd31:	48 83 ea 01          	sub    $0x1,%rdx
  804160fd35:	75 e7                	jne    804160fd1e <strncmp+0x5>

    if (!n) return 0;
  804160fd37:	b8 00 00 00 00       	mov    $0x0,%eax
  804160fd3c:	c3                   	ret    
  804160fd3d:	b8 00 00 00 00       	mov    $0x0,%eax
  804160fd42:	c3                   	ret    
  804160fd43:	48 85 d2             	test   %rdx,%rdx
  804160fd46:	74 09                	je     804160fd51 <strncmp+0x38>

    return (int)((unsigned char)*p - (unsigned char)*q);
  804160fd48:	0f b6 07             	movzbl (%rdi),%eax
  804160fd4b:	0f b6 16             	movzbl (%rsi),%edx
  804160fd4e:	29 d0                	sub    %edx,%eax
  804160fd50:	c3                   	ret    
    if (!n) return 0;
  804160fd51:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804160fd56:	c3                   	ret    

000000804160fd57 <strchr>:

/* Return a pointer to the first occurrence of 'c' in 's',
 *  * or a null pointer if the string has no 'c' */
char *
strchr(const char *str, int c) {
    for (; *str; str++) {
  804160fd57:	0f b6 07             	movzbl (%rdi),%eax
  804160fd5a:	84 c0                	test   %al,%al
  804160fd5c:	74 18                	je     804160fd76 <strchr+0x1f>
        if (*str == c) {
  804160fd5e:	0f be c0             	movsbl %al,%eax
  804160fd61:	39 f0                	cmp    %esi,%eax
  804160fd63:	74 17                	je     804160fd7c <strchr+0x25>
    for (; *str; str++) {
  804160fd65:	48 83 c7 01          	add    $0x1,%rdi
  804160fd69:	0f b6 07             	movzbl (%rdi),%eax
  804160fd6c:	84 c0                	test   %al,%al
  804160fd6e:	75 ee                	jne    804160fd5e <strchr+0x7>
            return (char *)str;
        }
    }
    return NULL;
  804160fd70:	b8 00 00 00 00       	mov    $0x0,%eax
  804160fd75:	c3                   	ret    
  804160fd76:	b8 00 00 00 00       	mov    $0x0,%eax
  804160fd7b:	c3                   	ret    
  804160fd7c:	48 89 f8             	mov    %rdi,%rax
}
  804160fd7f:	c3                   	ret    

000000804160fd80 <strfind>:

/* Return a pointer to the first occurrence of 'c' in 's',
 *  * or a pointer to the string-ending null character if the string has no 'c' */
char *
strfind(const char *str, int ch) {
    for (; *str && *str != ch; str++) /* nothing */
  804160fd80:	0f b6 07             	movzbl (%rdi),%eax
  804160fd83:	84 c0                	test   %al,%al
  804160fd85:	74 16                	je     804160fd9d <strfind+0x1d>
  804160fd87:	0f be c0             	movsbl %al,%eax
  804160fd8a:	39 f0                	cmp    %esi,%eax
  804160fd8c:	74 13                	je     804160fda1 <strfind+0x21>
  804160fd8e:	48 83 c7 01          	add    $0x1,%rdi
  804160fd92:	0f b6 07             	movzbl (%rdi),%eax
  804160fd95:	84 c0                	test   %al,%al
  804160fd97:	75 ee                	jne    804160fd87 <strfind+0x7>
  804160fd99:	48 89 f8             	mov    %rdi,%rax
        ;
    return (char *)str;
}
  804160fd9c:	c3                   	ret    
    for (; *str && *str != ch; str++) /* nothing */
  804160fd9d:	48 89 f8             	mov    %rdi,%rax
  804160fda0:	c3                   	ret    
  804160fda1:	48 89 f8             	mov    %rdi,%rax
  804160fda4:	c3                   	ret    

000000804160fda5 <memset>:


#if ASM
void *
memset(void *v, int c, size_t n) {
  804160fda5:	49 89 f8             	mov    %rdi,%r8
    uint8_t *ptr = v;
    ssize_t ni = n;

    if (__builtin_expect((ni -= ((8 - ((uintptr_t)v & 7))) & 7) < 0, 0)) {
  804160fda8:	48 89 f8             	mov    %rdi,%rax
  804160fdab:	48 f7 d8             	neg    %rax
  804160fdae:	83 e0 07             	and    $0x7,%eax
  804160fdb1:	49 89 d1             	mov    %rdx,%r9
  804160fdb4:	49 29 c1             	sub    %rax,%r9
  804160fdb7:	78 32                	js     804160fdeb <memset+0x46>
        while (n-- > 0) *ptr++ = c;
        return v;
    }

    uint64_t k = 0x101010101010101ULL * (c & 0xFFU);
  804160fdb9:	40 0f b6 c6          	movzbl %sil,%eax
  804160fdbd:	48 be 01 01 01 01 01 	movabs $0x101010101010101,%rsi
  804160fdc4:	01 01 01 
  804160fdc7:	48 0f af c6          	imul   %rsi,%rax

    if (__builtin_expect((uintptr_t)ptr & 7, 0)) {
  804160fdcb:	40 f6 c7 07          	test   $0x7,%dil
  804160fdcf:	75 34                	jne    804160fe05 <memset+0x60>
        if ((uintptr_t)ptr & 1) *ptr = k, ptr += 1;
        if ((uintptr_t)ptr & 2) *(uint16_t *)ptr = k, ptr += 2;
        if ((uintptr_t)ptr & 4) *(uint32_t *)ptr = k, ptr += 4;
    }

    if (__builtin_expect(ni >> 3, 1)) {
  804160fdd1:	4c 89 c9             	mov    %r9,%rcx
  804160fdd4:	48 c1 f9 03          	sar    $0x3,%rcx
  804160fdd8:	74 08                	je     804160fde2 <memset+0x3d>
        asm volatile("cld; rep stosq\n" ::"D"(ptr), "a"(k), "c"(ni >> 3)
  804160fdda:	fc                   	cld    
  804160fddb:	f3 48 ab             	rep stos %rax,%es:(%rdi)
                     : "cc", "memory");
        ni &= 7;
  804160fdde:	41 83 e1 07          	and    $0x7,%r9d
    }

    if (__builtin_expect(ni, 0)) {
  804160fde2:	4d 85 c9             	test   %r9,%r9
  804160fde5:	75 45                	jne    804160fe2c <memset+0x87>
        if (ni & 2) *(uint16_t *)ptr = k, ptr += 2;
        if (ni & 1) *ptr = k;
    }

    return v;
}
  804160fde7:	4c 89 c0             	mov    %r8,%rax
  804160fdea:	c3                   	ret    
        while (n-- > 0) *ptr++ = c;
  804160fdeb:	48 85 d2             	test   %rdx,%rdx
  804160fdee:	74 f7                	je     804160fde7 <memset+0x42>
  804160fdf0:	48 01 fa             	add    %rdi,%rdx
    uint8_t *ptr = v;
  804160fdf3:	48 89 f8             	mov    %rdi,%rax
        while (n-- > 0) *ptr++ = c;
  804160fdf6:	48 83 c0 01          	add    $0x1,%rax
  804160fdfa:	40 88 70 ff          	mov    %sil,-0x1(%rax)
  804160fdfe:	48 39 c2             	cmp    %rax,%rdx
  804160fe01:	75 f3                	jne    804160fdf6 <memset+0x51>
  804160fe03:	eb e2                	jmp    804160fde7 <memset+0x42>
        if ((uintptr_t)ptr & 1) *ptr = k, ptr += 1;
  804160fe05:	40 f6 c7 01          	test   $0x1,%dil
  804160fe09:	74 06                	je     804160fe11 <memset+0x6c>
  804160fe0b:	88 07                	mov    %al,(%rdi)
  804160fe0d:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
        if ((uintptr_t)ptr & 2) *(uint16_t *)ptr = k, ptr += 2;
  804160fe11:	40 f6 c7 02          	test   $0x2,%dil
  804160fe15:	74 07                	je     804160fe1e <memset+0x79>
  804160fe17:	66 89 07             	mov    %ax,(%rdi)
  804160fe1a:	48 83 c7 02          	add    $0x2,%rdi
        if ((uintptr_t)ptr & 4) *(uint32_t *)ptr = k, ptr += 4;
  804160fe1e:	40 f6 c7 04          	test   $0x4,%dil
  804160fe22:	74 ad                	je     804160fdd1 <memset+0x2c>
  804160fe24:	89 07                	mov    %eax,(%rdi)
  804160fe26:	48 83 c7 04          	add    $0x4,%rdi
  804160fe2a:	eb a5                	jmp    804160fdd1 <memset+0x2c>
        if (ni & 4) *(uint32_t *)ptr = k, ptr += 4;
  804160fe2c:	41 f6 c1 04          	test   $0x4,%r9b
  804160fe30:	74 06                	je     804160fe38 <memset+0x93>
  804160fe32:	89 07                	mov    %eax,(%rdi)
  804160fe34:	48 83 c7 04          	add    $0x4,%rdi
        if (ni & 2) *(uint16_t *)ptr = k, ptr += 2;
  804160fe38:	41 f6 c1 02          	test   $0x2,%r9b
  804160fe3c:	74 07                	je     804160fe45 <memset+0xa0>
  804160fe3e:	66 89 07             	mov    %ax,(%rdi)
  804160fe41:	48 83 c7 02          	add    $0x2,%rdi
        if (ni & 1) *ptr = k;
  804160fe45:	41 f6 c1 01          	test   $0x1,%r9b
  804160fe49:	74 9c                	je     804160fde7 <memset+0x42>
  804160fe4b:	88 07                	mov    %al,(%rdi)
  804160fe4d:	eb 98                	jmp    804160fde7 <memset+0x42>

000000804160fe4f <memmove>:

void *
memmove(void *dst, const void *src, size_t n) {
  804160fe4f:	48 89 f8             	mov    %rdi,%rax
  804160fe52:	48 89 d1             	mov    %rdx,%rcx
    const char *s = src;
    char *d = dst;

    if (s < d && s + n > d) {
  804160fe55:	48 39 fe             	cmp    %rdi,%rsi
  804160fe58:	73 39                	jae    804160fe93 <memmove+0x44>
  804160fe5a:	48 01 f2             	add    %rsi,%rdx
  804160fe5d:	48 39 fa             	cmp    %rdi,%rdx
  804160fe60:	76 31                	jbe    804160fe93 <memmove+0x44>
        s += n;
        d += n;
  804160fe62:	48 01 cf             	add    %rcx,%rdi
        if (!(((intptr_t)s & 7) | ((intptr_t)d & 7) | (n & 7))) {
  804160fe65:	48 89 d6             	mov    %rdx,%rsi
  804160fe68:	48 09 fe             	or     %rdi,%rsi
  804160fe6b:	48 09 ce             	or     %rcx,%rsi
  804160fe6e:	40 f6 c6 07          	test   $0x7,%sil
  804160fe72:	75 12                	jne    804160fe86 <memmove+0x37>
            asm volatile("std; rep movsq\n" ::"D"(d - 8), "S"(s - 8), "c"(n / 8)
  804160fe74:	48 83 ef 08          	sub    $0x8,%rdi
  804160fe78:	48 8d 72 f8          	lea    -0x8(%rdx),%rsi
  804160fe7c:	48 c1 e9 03          	shr    $0x3,%rcx
  804160fe80:	fd                   	std    
  804160fe81:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        } else {
            asm volatile("std; rep movsb\n" ::"D"(d - 1), "S"(s - 1), "c"(n)
                         : "cc", "memory");
        }
        /* Some versions of GCC rely on DF being clear */
        asm volatile("cld" ::
  804160fe84:	fc                   	cld    
  804160fe85:	c3                   	ret    
            asm volatile("std; rep movsb\n" ::"D"(d - 1), "S"(s - 1), "c"(n)
  804160fe86:	48 83 ef 01          	sub    $0x1,%rdi
  804160fe8a:	48 8d 72 ff          	lea    -0x1(%rdx),%rsi
  804160fe8e:	fd                   	std    
  804160fe8f:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
  804160fe91:	eb f1                	jmp    804160fe84 <memmove+0x35>
                             : "cc");
    } else {
        if (!(((intptr_t)s & 7) | ((intptr_t)d & 7) | (n & 7))) {
  804160fe93:	48 89 f2             	mov    %rsi,%rdx
  804160fe96:	48 09 c2             	or     %rax,%rdx
  804160fe99:	48 09 ca             	or     %rcx,%rdx
  804160fe9c:	f6 c2 07             	test   $0x7,%dl
  804160fe9f:	75 0c                	jne    804160fead <memmove+0x5e>
            asm volatile("cld; rep movsq\n" ::"D"(d), "S"(s), "c"(n / 8)
  804160fea1:	48 c1 e9 03          	shr    $0x3,%rcx
  804160fea5:	48 89 c7             	mov    %rax,%rdi
  804160fea8:	fc                   	cld    
  804160fea9:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
  804160feac:	c3                   	ret    
                         : "cc", "memory");
        } else {
            asm volatile("cld; rep movsb\n" ::"D"(d), "S"(s), "c"(n)
  804160fead:	48 89 c7             	mov    %rax,%rdi
  804160feb0:	fc                   	cld    
  804160feb1:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
                         : "cc", "memory");
        }
    }
    return dst;
}
  804160feb3:	c3                   	ret    

000000804160feb4 <memcpy>:
    return dst;
}
#endif

void *
memcpy(void *dst, const void *src, size_t n) {
  804160feb4:	55                   	push   %rbp
  804160feb5:	48 89 e5             	mov    %rsp,%rbp
    return memmove(dst, src, n);
  804160feb8:	48 b8 4f fe 60 41 80 	movabs $0x804160fe4f,%rax
  804160febf:	00 00 00 
  804160fec2:	ff d0                	call   *%rax
}
  804160fec4:	5d                   	pop    %rbp
  804160fec5:	c3                   	ret    

000000804160fec6 <strlcat>:
strlcat(char *restrict dst, const char *restrict src, size_t maxlen) {
  804160fec6:	55                   	push   %rbp
  804160fec7:	48 89 e5             	mov    %rsp,%rbp
  804160feca:	41 57                	push   %r15
  804160fecc:	41 56                	push   %r14
  804160fece:	41 55                	push   %r13
  804160fed0:	41 54                	push   %r12
  804160fed2:	53                   	push   %rbx
  804160fed3:	48 83 ec 08          	sub    $0x8,%rsp
  804160fed7:	49 89 fe             	mov    %rdi,%r14
  804160feda:	49 89 f7             	mov    %rsi,%r15
  804160fedd:	48 89 d3             	mov    %rdx,%rbx
    const size_t srclen = strlen(src);
  804160fee0:	48 89 f7             	mov    %rsi,%rdi
  804160fee3:	48 b8 1b fc 60 41 80 	movabs $0x804160fc1b,%rax
  804160feea:	00 00 00 
  804160feed:	ff d0                	call   *%rax
  804160feef:	49 89 c4             	mov    %rax,%r12
    const size_t dstlen = strnlen(dst, maxlen);
  804160fef2:	48 89 de             	mov    %rbx,%rsi
  804160fef5:	4c 89 f7             	mov    %r14,%rdi
  804160fef8:	48 b8 36 fc 60 41 80 	movabs $0x804160fc36,%rax
  804160feff:	00 00 00 
  804160ff02:	ff d0                	call   *%rax
  804160ff04:	49 89 c5             	mov    %rax,%r13
    if (dstlen == maxlen) return maxlen + srclen;
  804160ff07:	48 39 c3             	cmp    %rax,%rbx
  804160ff0a:	74 36                	je     804160ff42 <strlcat+0x7c>
    if (srclen < maxlen - dstlen) {
  804160ff0c:	48 89 d8             	mov    %rbx,%rax
  804160ff0f:	4c 29 e8             	sub    %r13,%rax
  804160ff12:	4c 39 e0             	cmp    %r12,%rax
  804160ff15:	76 30                	jbe    804160ff47 <strlcat+0x81>
        memcpy(dst + dstlen, src, srclen + 1);
  804160ff17:	49 8d 54 24 01       	lea    0x1(%r12),%rdx
  804160ff1c:	4b 8d 3c 2e          	lea    (%r14,%r13,1),%rdi
  804160ff20:	4c 89 fe             	mov    %r15,%rsi
  804160ff23:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160ff2a:	00 00 00 
  804160ff2d:	ff d0                	call   *%rax
    return dstlen + srclen;
  804160ff2f:	4b 8d 04 2c          	lea    (%r12,%r13,1),%rax
}
  804160ff33:	48 83 c4 08          	add    $0x8,%rsp
  804160ff37:	5b                   	pop    %rbx
  804160ff38:	41 5c                	pop    %r12
  804160ff3a:	41 5d                	pop    %r13
  804160ff3c:	41 5e                	pop    %r14
  804160ff3e:	41 5f                	pop    %r15
  804160ff40:	5d                   	pop    %rbp
  804160ff41:	c3                   	ret    
    if (dstlen == maxlen) return maxlen + srclen;
  804160ff42:	4c 01 e0             	add    %r12,%rax
  804160ff45:	eb ec                	jmp    804160ff33 <strlcat+0x6d>
        memcpy(dst + dstlen, src, maxlen - 1);
  804160ff47:	48 83 eb 01          	sub    $0x1,%rbx
  804160ff4b:	4b 8d 3c 2e          	lea    (%r14,%r13,1),%rdi
  804160ff4f:	48 89 da             	mov    %rbx,%rdx
  804160ff52:	4c 89 fe             	mov    %r15,%rsi
  804160ff55:	48 b8 b4 fe 60 41 80 	movabs $0x804160feb4,%rax
  804160ff5c:	00 00 00 
  804160ff5f:	ff d0                	call   *%rax
        dst[dstlen + maxlen - 1] = '\0';
  804160ff61:	49 01 de             	add    %rbx,%r14
  804160ff64:	43 c6 04 2e 00       	movb   $0x0,(%r14,%r13,1)
  804160ff69:	eb c4                	jmp    804160ff2f <strlcat+0x69>

000000804160ff6b <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n) {
  804160ff6b:	49 89 f0             	mov    %rsi,%r8
  804160ff6e:	48 89 d6             	mov    %rdx,%rsi
    const uint8_t *s1 = (const uint8_t *)v1;
    const uint8_t *s2 = (const uint8_t *)v2;

    while (n-- > 0) {
  804160ff71:	48 85 d2             	test   %rdx,%rdx
  804160ff74:	74 2a                	je     804160ffa0 <memcmp+0x35>
  804160ff76:	b8 00 00 00 00       	mov    $0x0,%eax
        if (*s1 != *s2) {
  804160ff7b:	0f b6 14 07          	movzbl (%rdi,%rax,1),%edx
  804160ff7f:	41 0f b6 0c 00       	movzbl (%r8,%rax,1),%ecx
  804160ff84:	38 ca                	cmp    %cl,%dl
  804160ff86:	75 0f                	jne    804160ff97 <memcmp+0x2c>
    while (n-- > 0) {
  804160ff88:	48 83 c0 01          	add    $0x1,%rax
  804160ff8c:	48 39 c6             	cmp    %rax,%rsi
  804160ff8f:	75 ea                	jne    804160ff7b <memcmp+0x10>
            return (int)*s1 - (int)*s2;
        }
        s1++, s2++;
    }

    return 0;
  804160ff91:	b8 00 00 00 00       	mov    $0x0,%eax
  804160ff96:	c3                   	ret    
            return (int)*s1 - (int)*s2;
  804160ff97:	0f b6 c2             	movzbl %dl,%eax
  804160ff9a:	0f b6 c9             	movzbl %cl,%ecx
  804160ff9d:	29 c8                	sub    %ecx,%eax
  804160ff9f:	c3                   	ret    
    return 0;
  804160ffa0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804160ffa5:	c3                   	ret    

000000804160ffa6 <memfind>:

void *
memfind(const void *src, int c, size_t n) {
    const void *end = (const char *)src + n;
  804160ffa6:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
    for (; src < end; src++) {
  804160ffaa:	48 39 c7             	cmp    %rax,%rdi
  804160ffad:	73 0f                	jae    804160ffbe <memfind+0x18>
        if (*(const unsigned char *)src == (unsigned char)c) break;
  804160ffaf:	40 38 37             	cmp    %sil,(%rdi)
  804160ffb2:	74 0e                	je     804160ffc2 <memfind+0x1c>
    for (; src < end; src++) {
  804160ffb4:	48 83 c7 01          	add    $0x1,%rdi
  804160ffb8:	48 39 f8             	cmp    %rdi,%rax
  804160ffbb:	75 f2                	jne    804160ffaf <memfind+0x9>
  804160ffbd:	c3                   	ret    
  804160ffbe:	48 89 f8             	mov    %rdi,%rax
  804160ffc1:	c3                   	ret    
  804160ffc2:	48 89 f8             	mov    %rdi,%rax
    }
    return (void *)src;
}
  804160ffc5:	c3                   	ret    

000000804160ffc6 <strtol>:

long
strtol(const char *s, char **endptr, int base) {
  804160ffc6:	49 89 f2             	mov    %rsi,%r10
  804160ffc9:	41 89 d0             	mov    %edx,%r8d
    /* Gobble initial whitespace */
    while (*s == ' ' || *s == '\t') s++;
  804160ffcc:	0f b6 37             	movzbl (%rdi),%esi
  804160ffcf:	40 80 fe 20          	cmp    $0x20,%sil
  804160ffd3:	74 06                	je     804160ffdb <strtol+0x15>
  804160ffd5:	40 80 fe 09          	cmp    $0x9,%sil
  804160ffd9:	75 13                	jne    804160ffee <strtol+0x28>
  804160ffdb:	48 83 c7 01          	add    $0x1,%rdi
  804160ffdf:	0f b6 37             	movzbl (%rdi),%esi
  804160ffe2:	40 80 fe 20          	cmp    $0x20,%sil
  804160ffe6:	74 f3                	je     804160ffdb <strtol+0x15>
  804160ffe8:	40 80 fe 09          	cmp    $0x9,%sil
  804160ffec:	74 ed                	je     804160ffdb <strtol+0x15>

    bool neg = *s == '-';

    /* Plus/minus sign */
    if (*s == '+' || *s == '-') s++;
  804160ffee:	8d 46 d5             	lea    -0x2b(%rsi),%eax
  804160fff1:	83 e0 fd             	and    $0xfffffffd,%eax
  804160fff4:	3c 01                	cmp    $0x1,%al
  804160fff6:	48 83 d7 00          	adc    $0x0,%rdi

    /* Hex or octal base prefix */
    if ((!base || base == 16) && (s[0] == '0' && s[1] == 'x')) {
  804160fffa:	41 f7 c0 ef ff ff ff 	test   $0xffffffef,%r8d
  8041610001:	75 11                	jne    8041610014 <strtol+0x4e>
  8041610003:	80 3f 30             	cmpb   $0x30,(%rdi)
  8041610006:	74 16                	je     804161001e <strtol+0x58>
        s += 2;
    } else if (!base && s[0] == '0') {
        base = 8;
        s++;
    } else if (!base) {
        base = 10;
  8041610008:	45 85 c0             	test   %r8d,%r8d
  804161000b:	b8 0a 00 00 00       	mov    $0xa,%eax
  8041610010:	44 0f 44 c0          	cmove  %eax,%r8d
    }

    /* Digits */
    long val = 0;
  8041610014:	ba 00 00 00 00       	mov    $0x0,%edx
            break;

        if (dig >= base) break;

        /* We don't properly detect overflow! */
        val = val * base + dig;
  8041610019:	4d 63 c8             	movslq %r8d,%r9
  804161001c:	eb 38                	jmp    8041610056 <strtol+0x90>
    if ((!base || base == 16) && (s[0] == '0' && s[1] == 'x')) {
  804161001e:	80 7f 01 78          	cmpb   $0x78,0x1(%rdi)
  8041610022:	74 11                	je     8041610035 <strtol+0x6f>
    } else if (!base && s[0] == '0') {
  8041610024:	45 85 c0             	test   %r8d,%r8d
  8041610027:	75 eb                	jne    8041610014 <strtol+0x4e>
        s++;
  8041610029:	48 83 c7 01          	add    $0x1,%rdi
        base = 8;
  804161002d:	41 b8 08 00 00 00    	mov    $0x8,%r8d
        s++;
  8041610033:	eb df                	jmp    8041610014 <strtol+0x4e>
        s += 2;
  8041610035:	48 83 c7 02          	add    $0x2,%rdi
        base = 16;
  8041610039:	41 b8 10 00 00 00    	mov    $0x10,%r8d
        s += 2;
  804161003f:	eb d3                	jmp    8041610014 <strtol+0x4e>
            dig -= '0';
  8041610041:	83 e8 30             	sub    $0x30,%eax
        if (dig >= base) break;
  8041610044:	0f b6 c8             	movzbl %al,%ecx
  8041610047:	44 39 c1             	cmp    %r8d,%ecx
  804161004a:	7d 1f                	jge    804161006b <strtol+0xa5>
        val = val * base + dig;
  804161004c:	49 0f af d1          	imul   %r9,%rdx
  8041610050:	0f b6 c0             	movzbl %al,%eax
  8041610053:	48 01 c2             	add    %rax,%rdx
        uint8_t dig = *s++;
  8041610056:	48 83 c7 01          	add    $0x1,%rdi
  804161005a:	0f b6 47 ff          	movzbl -0x1(%rdi),%eax
        if (dig - '0' < 10)
  804161005e:	3c 39                	cmp    $0x39,%al
  8041610060:	76 df                	jbe    8041610041 <strtol+0x7b>
        else if (dig - 'a' < 27)
  8041610062:	3c 7b                	cmp    $0x7b,%al
  8041610064:	77 05                	ja     804161006b <strtol+0xa5>
            dig -= 'a' - 10;
  8041610066:	83 e8 57             	sub    $0x57,%eax
  8041610069:	eb d9                	jmp    8041610044 <strtol+0x7e>
    }

    if (endptr) *endptr = (char *)s;
  804161006b:	4d 85 d2             	test   %r10,%r10
  804161006e:	74 03                	je     8041610073 <strtol+0xad>
  8041610070:	49 89 3a             	mov    %rdi,(%r10)

    return (neg ? -val : val);
  8041610073:	48 89 d0             	mov    %rdx,%rax
  8041610076:	48 f7 d8             	neg    %rax
  8041610079:	40 80 fe 2d          	cmp    $0x2d,%sil
  804161007d:	48 0f 44 d0          	cmove  %rax,%rdx
}
  8041610081:	48 89 d0             	mov    %rdx,%rax
  8041610084:	c3                   	ret    

0000008041610085 <tsc_calibrate>:

    return delta;
}

uint64_t
tsc_calibrate(void) {
  8041610085:	55                   	push   %rbp
  8041610086:	48 89 e5             	mov    %rsp,%rbp
  8041610089:	41 57                	push   %r15
  804161008b:	41 56                	push   %r14
  804161008d:	41 55                	push   %r13
  804161008f:	41 54                	push   %r12
  8041610091:	53                   	push   %rbx
  8041610092:	48 83 ec 18          	sub    $0x18,%rsp
    static uint64_t cpu_freq;

    if (!cpu_freq) {
  8041610096:	48 a1 00 5b 40 42 80 	movabs 0x8042405b00,%rax
  804161009d:	00 00 00 
  80416100a0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80416100a4:	48 85 c0             	test   %rax,%rax
  80416100a7:	0f 85 7f 01 00 00    	jne    804161022c <tsc_calibrate+0x1a7>
        int i = TIMES;
        while (--i > 0) {
  80416100ad:	41 be 63 00 00 00    	mov    $0x63,%r14d
    asm volatile("inb %w1,%0"
  80416100b3:	41 bd 61 00 00 00    	mov    $0x61,%r13d
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  80416100b9:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
  80416100bf:	be 42 00 00 00       	mov    $0x42,%esi
  80416100c4:	eb 30                	jmp    80416100f6 <tsc_calibrate+0x71>
    uint64_t tsc = 0;
  80416100c6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
    while (count++ < 50000) {
  80416100ca:	bf 01 00 00 00       	mov    $0x1,%edi
  80416100cf:	eb 6d                	jmp    804161013e <tsc_calibrate+0xb9>
    uint64_t tsc = 0;
  80416100d1:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    while (count++ < 50000) {
  80416100d5:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80416100db:	e9 bc 00 00 00       	jmp    804161019c <tsc_calibrate+0x117>
        for (i = 1; i <= MAX_QUICK_PIT_ITERATIONS; i++) {
  80416100e0:	83 c3 01             	add    $0x1,%ebx
  80416100e3:	41 83 e9 01          	sub    $0x1,%r9d
  80416100e7:	83 fb 75             	cmp    $0x75,%ebx
  80416100ea:	75 76                	jne    8041610162 <tsc_calibrate+0xdd>
        while (--i > 0) {
  80416100ec:	41 83 ee 01          	sub    $0x1,%r14d
  80416100f0:	0f 84 56 01 00 00    	je     804161024c <tsc_calibrate+0x1c7>
    asm volatile("inb %w1,%0"
  80416100f6:	44 89 ea             	mov    %r13d,%edx
  80416100f9:	ec                   	in     (%dx),%al
    outb(0x61, (inb(0x61) & ~0x02) | 0x01);
  80416100fa:	83 e0 fc             	and    $0xfffffffc,%eax
  80416100fd:	83 c8 01             	or     $0x1,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8041610100:	ee                   	out    %al,(%dx)
  8041610101:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
  8041610106:	ba 43 00 00 00       	mov    $0x43,%edx
  804161010b:	ee                   	out    %al,(%dx)
  804161010c:	44 89 e0             	mov    %r12d,%eax
  804161010f:	89 f2                	mov    %esi,%edx
  8041610111:	ee                   	out    %al,(%dx)
  8041610112:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  8041610113:	ec                   	in     (%dx),%al
  8041610114:	ec                   	in     (%dx),%al
  8041610115:	ec                   	in     (%dx),%al
  8041610116:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  8041610117:	3c ff                	cmp    $0xff,%al
  8041610119:	75 ab                	jne    80416100c6 <tsc_calibrate+0x41>
    while (count++ < 50000) {
  804161011b:	bf 01 00 00 00       	mov    $0x1,%edi
    asm volatile("rdtsc"
  8041610120:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  8041610122:	48 c1 e2 20          	shl    $0x20,%rdx
  8041610126:	89 c1                	mov    %eax,%ecx
  8041610128:	48 09 d1             	or     %rdx,%rcx
  804161012b:	83 c7 01             	add    $0x1,%edi
  804161012e:	81 ff 51 c3 00 00    	cmp    $0xc351,%edi
  8041610134:	74 08                	je     804161013e <tsc_calibrate+0xb9>
    asm volatile("inb %w1,%0"
  8041610136:	89 f2                	mov    %esi,%edx
  8041610138:	ec                   	in     (%dx),%al
  8041610139:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  804161013a:	3c ff                	cmp    $0xff,%al
  804161013c:	74 e2                	je     8041610120 <tsc_calibrate+0x9b>
    asm volatile("rdtsc"
  804161013e:	0f 31                	rdtsc  
    if (pit_expect_msb(0xFF, &tsc, &d1)) {
  8041610140:	83 ff 06             	cmp    $0x6,%edi
  8041610143:	7e a7                	jle    80416100ec <tsc_calibrate+0x67>
    return (uint64_t)lo | ((uint64_t)hi << 32);
  8041610145:	48 c1 e2 20          	shl    $0x20,%rdx
  8041610149:	89 c0                	mov    %eax,%eax
  804161014b:	48 09 c2             	or     %rax,%rdx
  804161014e:	49 89 d3             	mov    %rdx,%r11
    *deltap = read_tsc() - tsc;
  8041610151:	49 89 d7             	mov    %rdx,%r15
  8041610154:	49 29 cf             	sub    %rcx,%r15
  8041610157:	41 b9 fe ff ff ff    	mov    $0xfffffffe,%r9d
        for (i = 1; i <= MAX_QUICK_PIT_ITERATIONS; i++) {
  804161015d:	bb 01 00 00 00       	mov    $0x1,%ebx
            if (!pit_expect_msb(0xFF - i, &delta, &d2)) break;
  8041610162:	88 5d cf             	mov    %bl,-0x31(%rbp)
    asm volatile("inb %w1,%0"
  8041610165:	89 f2                	mov    %esi,%edx
  8041610167:	ec                   	in     (%dx),%al
  8041610168:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  8041610169:	41 38 c1             	cmp    %al,%r9b
  804161016c:	0f 85 5f ff ff ff    	jne    80416100d1 <tsc_calibrate+0x4c>
    while (count++ < 50000) {
  8041610172:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    asm volatile("rdtsc"
  8041610178:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804161017a:	48 c1 e2 20          	shl    $0x20,%rdx
  804161017e:	89 c0                	mov    %eax,%eax
  8041610180:	48 89 d7             	mov    %rdx,%rdi
  8041610183:	48 09 c7             	or     %rax,%rdi
  8041610186:	41 83 c0 01          	add    $0x1,%r8d
  804161018a:	41 81 f8 51 c3 00 00 	cmp    $0xc351,%r8d
  8041610191:	74 09                	je     804161019c <tsc_calibrate+0x117>
    asm volatile("inb %w1,%0"
  8041610193:	89 f2                	mov    %esi,%edx
  8041610195:	ec                   	in     (%dx),%al
  8041610196:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  8041610197:	41 38 c1             	cmp    %al,%r9b
  804161019a:	74 dc                	je     8041610178 <tsc_calibrate+0xf3>
    asm volatile("rdtsc"
  804161019c:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804161019e:	48 c1 e2 20          	shl    $0x20,%rdx
  80416101a2:	89 c0                	mov    %eax,%eax
  80416101a4:	48 09 c2             	or     %rax,%rdx
    *deltap = read_tsc() - tsc;
  80416101a7:	48 29 fa             	sub    %rdi,%rdx
            if (!pit_expect_msb(0xFF - i, &delta, &d2)) break;
  80416101aa:	41 83 f8 06          	cmp    $0x6,%r8d
  80416101ae:	0f 8e 38 ff ff ff    	jle    80416100ec <tsc_calibrate+0x67>
            delta -= tsc;
  80416101b4:	48 89 f8             	mov    %rdi,%rax
  80416101b7:	48 29 c8             	sub    %rcx,%rax
            if (d1 + d2 >= delta >> 11) continue;
  80416101ba:	4d 8d 04 17          	lea    (%r15,%rdx,1),%r8
  80416101be:	48 89 c7             	mov    %rax,%rdi
  80416101c1:	48 c1 ef 0b          	shr    $0xb,%rdi
  80416101c5:	49 39 f8             	cmp    %rdi,%r8
  80416101c8:	0f 83 12 ff ff ff    	jae    80416100e0 <tsc_calibrate+0x5b>
    asm volatile("inb %w1,%0"
  80416101ce:	48 89 c7             	mov    %rax,%rdi
  80416101d1:	49 89 d2             	mov    %rdx,%r10
  80416101d4:	89 f2                	mov    %esi,%edx
  80416101d6:	ec                   	in     (%dx),%al
  80416101d7:	ec                   	in     (%dx),%al
            if (!pit_verify_msb(0xFE - i)) break;
  80416101d8:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  80416101dd:	2a 55 cf             	sub    -0x31(%rbp),%dl
  80416101e0:	38 c2                	cmp    %al,%dl
  80416101e2:	0f 85 04 ff ff ff    	jne    80416100ec <tsc_calibrate+0x67>
    delta += (long)(d2 - d1) / 2;
  80416101e8:	4c 29 d9             	sub    %r11,%rcx
  80416101eb:	49 01 ca             	add    %rcx,%r10
  80416101ee:	4c 89 d0             	mov    %r10,%rax
  80416101f1:	48 c1 e8 3f          	shr    $0x3f,%rax
  80416101f5:	49 01 c2             	add    %rax,%r10
  80416101f8:	49 d1 fa             	sar    %r10
  80416101fb:	4c 01 d7             	add    %r10,%rdi
    delta *= PIT_TICK_RATE;
  80416101fe:	48 69 ff de 34 12 00 	imul   $0x1234de,%rdi,%rdi
    delta /= i * 256 * 1000;
  8041610205:	69 cb 00 e8 03 00    	imul   $0x3e800,%ebx,%ecx
  804161020b:	48 63 c9             	movslq %ecx,%rcx
  804161020e:	48 89 f8             	mov    %rdi,%rax
  8041610211:	ba 00 00 00 00       	mov    $0x0,%edx
  8041610216:	48 f7 f1             	div    %rcx
            if ((cpu_freq = quick_pit_calibrate())) break;
  8041610219:	48 39 cf             	cmp    %rcx,%rdi
  804161021c:	0f 82 ca fe ff ff    	jb     80416100ec <tsc_calibrate+0x67>
  8041610222:	48 a3 00 5b 40 42 80 	movabs %rax,0x8042405b00
  8041610229:	00 00 00 
            cpu_freq = DEFAULT_FREQ;
            cprintf("Can't calibrate pit timer. Using default frequency\n");
        }
    }

    return cpu_freq * 1000;
  804161022c:	48 a1 00 5b 40 42 80 	movabs 0x8042405b00,%rax
  8041610233:	00 00 00 
  8041610236:	48 69 c0 e8 03 00 00 	imul   $0x3e8,%rax,%rax
}
  804161023d:	48 83 c4 18          	add    $0x18,%rsp
  8041610241:	5b                   	pop    %rbx
  8041610242:	41 5c                	pop    %r12
  8041610244:	41 5d                	pop    %r13
  8041610246:	41 5e                	pop    %r14
  8041610248:	41 5f                	pop    %r15
  804161024a:	5d                   	pop    %rbp
  804161024b:	c3                   	ret    
            cpu_freq = DEFAULT_FREQ;
  804161024c:	48 b8 00 5b 40 42 80 	movabs $0x8042405b00,%rax
  8041610253:	00 00 00 
  8041610256:	48 c7 00 a0 25 26 00 	movq   $0x2625a0,(%rax)
            cprintf("Can't calibrate pit timer. Using default frequency\n");
  804161025d:	48 bf 10 3b 61 41 80 	movabs $0x8041613b10,%rdi
  8041610264:	00 00 00 
  8041610267:	b8 00 00 00 00       	mov    $0x0,%eax
  804161026c:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610273:	00 00 00 
  8041610276:	ff d2                	call   *%rdx
  8041610278:	eb b2                	jmp    804161022c <tsc_calibrate+0x1a7>

000000804161027a <print_time>:

void
print_time(unsigned seconds) {
  804161027a:	55                   	push   %rbp
  804161027b:	48 89 e5             	mov    %rsp,%rbp
  804161027e:	89 fe                	mov    %edi,%esi
    cprintf("%u\n", seconds);
  8041610280:	48 bf 44 3b 61 41 80 	movabs $0x8041613b44,%rdi
  8041610287:	00 00 00 
  804161028a:	b8 00 00 00 00       	mov    $0x0,%eax
  804161028f:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610296:	00 00 00 
  8041610299:	ff d2                	call   *%rdx
}
  804161029b:	5d                   	pop    %rbp
  804161029c:	c3                   	ret    

000000804161029d <print_timer_error>:

void
print_timer_error(void) {
  804161029d:	55                   	push   %rbp
  804161029e:	48 89 e5             	mov    %rsp,%rbp
    cprintf("Timer Error\n");
  80416102a1:	48 bf 48 3b 61 41 80 	movabs $0x8041613b48,%rdi
  80416102a8:	00 00 00 
  80416102ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80416102b0:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  80416102b7:	00 00 00 
  80416102ba:	ff d2                	call   *%rdx
}
  80416102bc:	5d                   	pop    %rbp
  80416102bd:	c3                   	ret    

00000080416102be <timer_start>:
static int timer_id = -1;
static uint64_t timer = 0;
static uint64_t freq = 0;

void
timer_start(const char *name) {
  80416102be:	55                   	push   %rbp
  80416102bf:	48 89 e5             	mov    %rsp,%rbp
  80416102c2:	41 56                	push   %r14
  80416102c4:	41 55                	push   %r13
  80416102c6:	41 54                	push   %r12
  80416102c8:	53                   	push   %rbx
  80416102c9:	49 89 fd             	mov    %rdi,%r13
    for (int i = 0; i < MAX_TIMERS; ++i) {
  80416102cc:	49 bc 60 55 40 42 80 	movabs $0x8042405560,%r12
  80416102d3:	00 00 00 
  80416102d6:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (timertab[i].timer_name && !strcmp(name, timertab[i].timer_name)) {
  80416102db:	49 be f6 fc 60 41 80 	movabs $0x804160fcf6,%r14
  80416102e2:	00 00 00 
  80416102e5:	eb 0c                	jmp    80416102f3 <timer_start+0x35>
    for (int i = 0; i < MAX_TIMERS; ++i) {
  80416102e7:	83 c3 01             	add    $0x1,%ebx
  80416102ea:	49 83 c4 28          	add    $0x28,%r12
  80416102ee:	83 fb 05             	cmp    $0x5,%ebx
  80416102f1:	74 61                	je     8041610354 <timer_start+0x96>
        if (timertab[i].timer_name && !strcmp(name, timertab[i].timer_name)) {
  80416102f3:	49 8b 34 24          	mov    (%r12),%rsi
  80416102f7:	48 85 f6             	test   %rsi,%rsi
  80416102fa:	74 eb                	je     80416102e7 <timer_start+0x29>
  80416102fc:	4c 89 ef             	mov    %r13,%rdi
  80416102ff:	41 ff d6             	call   *%r14
  8041610302:	85 c0                	test   %eax,%eax
  8041610304:	75 e1                	jne    80416102e7 <timer_start+0x29>
            timer_id = i;
  8041610306:	89 d8                	mov    %ebx,%eax
  8041610308:	a3 a0 48 63 41 80 00 	movabs %eax,0x80416348a0
  804161030f:	00 00 
            timer_started = 1;
  8041610311:	48 b8 18 5b 40 42 80 	movabs $0x8042405b18,%rax
  8041610318:	00 00 00 
  804161031b:	c6 00 01             	movb   $0x1,(%rax)
            freq = timertab[i].get_cpu_freq();
  804161031e:	48 63 db             	movslq %ebx,%rbx
  8041610321:	48 8d 14 9b          	lea    (%rbx,%rbx,4),%rdx
  8041610325:	48 b8 60 55 40 42 80 	movabs $0x8042405560,%rax
  804161032c:	00 00 00 
  804161032f:	ff 54 d0 10          	call   *0x10(%rax,%rdx,8)
  8041610333:	48 a3 08 5b 40 42 80 	movabs %rax,0x8042405b08
  804161033a:	00 00 00 
    asm volatile("rdtsc"
  804161033d:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804161033f:	48 c1 e2 20          	shl    $0x20,%rdx
  8041610343:	89 c0                	mov    %eax,%eax
  8041610345:	48 09 d0             	or     %rdx,%rax
  8041610348:	48 a3 10 5b 40 42 80 	movabs %rax,0x8042405b10
  804161034f:	00 00 00 
            timer = read_tsc();
            return;
  8041610352:	eb 0c                	jmp    8041610360 <timer_start+0xa2>
        }
    }
    print_timer_error();
  8041610354:	48 b8 9d 02 61 41 80 	movabs $0x804161029d,%rax
  804161035b:	00 00 00 
  804161035e:	ff d0                	call   *%rax

}
  8041610360:	5b                   	pop    %rbx
  8041610361:	41 5c                	pop    %r12
  8041610363:	41 5d                	pop    %r13
  8041610365:	41 5e                	pop    %r14
  8041610367:	5d                   	pop    %rbp
  8041610368:	c3                   	ret    

0000008041610369 <timer_stop>:

void
timer_stop(void) {
  8041610369:	55                   	push   %rbp
  804161036a:	48 89 e5             	mov    %rsp,%rbp
    if (!timer_started || timer_id < 0) {
  804161036d:	48 b8 18 5b 40 42 80 	movabs $0x8042405b18,%rax
  8041610374:	00 00 00 
  8041610377:	80 38 00             	cmpb   $0x0,(%rax)
  804161037a:	74 69                	je     80416103e5 <timer_stop+0x7c>
  804161037c:	48 b8 a0 48 63 41 80 	movabs $0x80416348a0,%rax
  8041610383:	00 00 00 
  8041610386:	83 38 00             	cmpl   $0x0,(%rax)
  8041610389:	78 5a                	js     80416103e5 <timer_stop+0x7c>
        print_timer_error();
        return;
    }
    timer_id = -1;
  804161038b:	48 b8 a0 48 63 41 80 	movabs $0x80416348a0,%rax
  8041610392:	00 00 00 
  8041610395:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
    timer_started = 0;
  804161039b:	48 b8 18 5b 40 42 80 	movabs $0x8042405b18,%rax
  80416103a2:	00 00 00 
  80416103a5:	c6 00 00             	movb   $0x0,(%rax)
    asm volatile("rdtsc"
  80416103a8:	0f 31                	rdtsc  
    return (uint64_t)lo | ((uint64_t)hi << 32);
  80416103aa:	48 c1 e2 20          	shl    $0x20,%rdx
  80416103ae:	89 c0                	mov    %eax,%eax
  80416103b0:	48 09 c2             	or     %rax,%rdx
    print_time((read_tsc() - timer) / freq);
  80416103b3:	48 b8 10 5b 40 42 80 	movabs $0x8042405b10,%rax
  80416103ba:	00 00 00 
  80416103bd:	48 2b 10             	sub    (%rax),%rdx
  80416103c0:	48 89 d0             	mov    %rdx,%rax
  80416103c3:	48 b9 08 5b 40 42 80 	movabs $0x8042405b08,%rcx
  80416103ca:	00 00 00 
  80416103cd:	ba 00 00 00 00       	mov    $0x0,%edx
  80416103d2:	48 f7 31             	divq   (%rcx)
  80416103d5:	89 c7                	mov    %eax,%edi
  80416103d7:	48 b8 7a 02 61 41 80 	movabs $0x804161027a,%rax
  80416103de:	00 00 00 
  80416103e1:	ff d0                	call   *%rax
  80416103e3:	eb 0c                	jmp    80416103f1 <timer_stop+0x88>
        print_timer_error();
  80416103e5:	48 b8 9d 02 61 41 80 	movabs $0x804161029d,%rax
  80416103ec:	00 00 00 
  80416103ef:	ff d0                	call   *%rax
}
  80416103f1:	5d                   	pop    %rbp
  80416103f2:	c3                   	ret    

00000080416103f3 <timer_cpu_frequency>:

void
timer_cpu_frequency(const char *name) {
  80416103f3:	55                   	push   %rbp
  80416103f4:	48 89 e5             	mov    %rsp,%rbp
  80416103f7:	41 56                	push   %r14
  80416103f9:	41 55                	push   %r13
  80416103fb:	41 54                	push   %r12
  80416103fd:	53                   	push   %rbx
  80416103fe:	49 89 fd             	mov    %rdi,%r13
    for (int i = 0; i < MAX_TIMERS; ++i) {
  8041610401:	49 bc 60 55 40 42 80 	movabs $0x8042405560,%r12
  8041610408:	00 00 00 
  804161040b:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (timertab[i].timer_name && !strcmp(name, timertab[i].timer_name)) {
  8041610410:	49 be f6 fc 60 41 80 	movabs $0x804160fcf6,%r14
  8041610417:	00 00 00 
  804161041a:	eb 0c                	jmp    8041610428 <timer_cpu_frequency+0x35>
    for (int i = 0; i < MAX_TIMERS; ++i) {
  804161041c:	83 c3 01             	add    $0x1,%ebx
  804161041f:	49 83 c4 28          	add    $0x28,%r12
  8041610423:	83 fb 05             	cmp    $0x5,%ebx
  8041610426:	74 48                	je     8041610470 <timer_cpu_frequency+0x7d>
        if (timertab[i].timer_name && !strcmp(name, timertab[i].timer_name)) {
  8041610428:	49 8b 34 24          	mov    (%r12),%rsi
  804161042c:	48 85 f6             	test   %rsi,%rsi
  804161042f:	74 eb                	je     804161041c <timer_cpu_frequency+0x29>
  8041610431:	4c 89 ef             	mov    %r13,%rdi
  8041610434:	41 ff d6             	call   *%r14
  8041610437:	85 c0                	test   %eax,%eax
  8041610439:	75 e1                	jne    804161041c <timer_cpu_frequency+0x29>
            cprintf("%lu\n", timertab[i].get_cpu_freq());
  804161043b:	48 63 db             	movslq %ebx,%rbx
  804161043e:	48 8d 14 9b          	lea    (%rbx,%rbx,4),%rdx
  8041610442:	48 b8 60 55 40 42 80 	movabs $0x8042405560,%rax
  8041610449:	00 00 00 
  804161044c:	ff 54 d0 10          	call   *0x10(%rax,%rdx,8)
  8041610450:	48 89 c6             	mov    %rax,%rsi
  8041610453:	48 bf d8 31 61 41 80 	movabs $0x80416131d8,%rdi
  804161045a:	00 00 00 
  804161045d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610462:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610469:	00 00 00 
  804161046c:	ff d2                	call   *%rdx
            return ;
  804161046e:	eb 0c                	jmp    804161047c <timer_cpu_frequency+0x89>
        }
    }
    print_timer_error();
  8041610470:	48 b8 9d 02 61 41 80 	movabs $0x804161029d,%rax
  8041610477:	00 00 00 
  804161047a:	ff d0                	call   *%rax
}
  804161047c:	5b                   	pop    %rbx
  804161047d:	41 5c                	pop    %r12
  804161047f:	41 5d                	pop    %r13
  8041610481:	41 5e                	pop    %r14
  8041610483:	5d                   	pop    %rbp
  8041610484:	c3                   	ret    

0000008041610485 <efi_call_in_32bit_mode>:

extern void _efi_call_in_32bit_mode_asm(uint32_t func, efi_registers *efi_reg, void *stack_contents, size_t stack_contents_size);

/* stack_contents_size is 16-byte multiple */
int
efi_call_in_32bit_mode(uint32_t func, efi_registers *efi_reg, void *stack_contents, size_t stack_contents_size, uint32_t *efi_status) {
  8041610485:	55                   	push   %rbp
  8041610486:	48 89 e5             	mov    %rsp,%rbp
  8041610489:	41 54                	push   %r12
  804161048b:	53                   	push   %rbx
  804161048c:	48 89 f3             	mov    %rsi,%rbx

    if (!func || !efi_reg || !stack_contents || (stack_contents_size & 15)) return -E_INVAL;
  804161048f:	85 ff                	test   %edi,%edi
  8041610491:	40 0f 94 c6          	sete   %sil
  8041610495:	48 85 db             	test   %rbx,%rbx
  8041610498:	0f 94 c0             	sete   %al
  804161049b:	40 08 c6             	or     %al,%sil
  804161049e:	75 44                	jne    80416104e4 <efi_call_in_32bit_mode+0x5f>
  80416104a0:	4d 89 c4             	mov    %r8,%r12
  80416104a3:	48 85 d2             	test   %rdx,%rdx
  80416104a6:	74 3c                	je     80416104e4 <efi_call_in_32bit_mode+0x5f>
  80416104a8:	f6 c1 0f             	test   $0xf,%cl
  80416104ab:	75 3e                	jne    80416104eb <efi_call_in_32bit_mode+0x66>

    /* We need to set up kernel data segments for 32 bit mode
     * before calling asm. */
    asm volatile("movw %%ax,%%es\n\t"
  80416104ad:	b8 20 00 00 00       	mov    $0x20,%eax
  80416104b2:	8e c0                	mov    %eax,%es
  80416104b4:	8e d8                	mov    %eax,%ds
  80416104b6:	8e d0                	mov    %eax,%ss
                 "movw %%ax,%%ds\n\t"
                 "movw %%ax,%%ss" ::"a"(GD_KD32));

    _efi_call_in_32bit_mode_asm(func, efi_reg, stack_contents, stack_contents_size);
  80416104b8:	48 89 de             	mov    %rbx,%rsi
  80416104bb:	48 b8 f2 04 61 41 80 	movabs $0x80416104f2,%rax
  80416104c2:	00 00 00 
  80416104c5:	ff d0                	call   *%rax

    /* Restore 64 bit kernel data segments */
    asm volatile("movw %%ax,%%es\n\t"
  80416104c7:	b8 10 00 00 00       	mov    $0x10,%eax
  80416104cc:	8e c0                	mov    %eax,%es
  80416104ce:	8e d8                	mov    %eax,%ds
  80416104d0:	8e d0                	mov    %eax,%ss
                 "movw %%ax,%%ds\n\t"
                 "movw %%ax,%%ss" ::"a"(GD_KD));

    *efi_status = (uint32_t)efi_reg->rax;
  80416104d2:	48 8b 43 20          	mov    0x20(%rbx),%rax
  80416104d6:	41 89 04 24          	mov    %eax,(%r12)

    return 0;
  80416104da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80416104df:	5b                   	pop    %rbx
  80416104e0:	41 5c                	pop    %r12
  80416104e2:	5d                   	pop    %rbp
  80416104e3:	c3                   	ret    
    if (!func || !efi_reg || !stack_contents || (stack_contents_size & 15)) return -E_INVAL;
  80416104e4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80416104e9:	eb f4                	jmp    80416104df <efi_call_in_32bit_mode+0x5a>
  80416104eb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80416104f0:	eb ed                	jmp    80416104df <efi_call_in_32bit_mode+0x5a>

00000080416104f2 <_efi_call_in_32bit_mode_asm>:
.align 2

.globl _efi_call_in_32bit_mode_asm
.type _efi_call_in_32bit_mode_asm, @function;
_efi_call_in_32bit_mode_asm:
    pushq %rbp
  80416104f2:	55                   	push   %rbp
    movq %rsp, %rbp
  80416104f3:	48 89 e5             	mov    %rsp,%rbp
    # Save non-volatile registers
    push %rbx
  80416104f6:	53                   	push   %rbx
    push %r12
  80416104f7:	41 54                	push   %r12
    push %r13
  80416104f9:	41 55                	push   %r13
    push %r14
  80416104fb:	41 56                	push   %r14
    push %r15
  80416104fd:	41 57                	push   %r15

    # save parameters that we will need later
    push %rsi
  80416104ff:	56                   	push   %rsi
    push %rcx
  8041610500:	51                   	push   %rcx
    # Save %rbp and align to 16-byte boundary
    # efi_reg in %rsi
    # stack_contents into %rdx
    # s_c_s into %rcx
    # s_c_s into %rcx
    push %rbp
  8041610501:	55                   	push   %rbp

    # Make room for stack contents
    sub %rcx, %rsp
  8041610502:	48 29 cc             	sub    %rcx,%rsp

    COPY_STACK(%rdx, %rcx, %r8)
  8041610505:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8

000000804161050c <copyloop>:
  804161050c:	4a 8b 04 02          	mov    (%rdx,%r8,1),%rax
  8041610510:	4a 89 04 04          	mov    %rax,(%rsp,%r8,1)
  8041610514:	49 83 c0 08          	add    $0x8,%r8
  8041610518:	49 39 c8             	cmp    %rcx,%r8
  804161051b:	75 ef                	jne    804161050c <copyloop>

    # Here in long-mode, with high kernel addresses,
    # but with the kernel double-mapped in the bottom 4GB.
    # We now switch to compat mode and call into EFI.
    ENTER_COMPAT_MODE()
  804161051d:	e8 00 00 00 00       	call   8041610522 <copyloop+0x16>
  8041610522:	48 81 04 24 11 00 00 	addq   $0x11,(%rsp)
  8041610529:	00 
  804161052a:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%rsp)
  8041610531:	00 
  8041610532:	cb                   	lret   

    # call EFI runtime
    call *%edi
  8041610533:	ff d7                	call   *%rdi

    ENTER_64BIT_MODE()
  8041610535:	6a 08                	push   $0x8
  8041610537:	e8 00 00 00 00       	call   804161053c <copyloop+0x30>
  804161053c:	81 04 24 08 00 00 00 	addl   $0x8,(%rsp)
  8041610543:	cb                   	lret   

    # load efi_reg into %esi
    mov -48(%rbp), %rsi
  8041610544:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    /* save RAX back */
    mov %rax, 32(%rsi)
  8041610548:	48 89 46 20          	mov    %rax,0x20(%rsi)

    # load s_c_s into %rcx
    mov -56(%rbp), %rcx
  804161054c:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    # discard stack contents
    add %rcx, %rsp
  8041610550:	48 01 cc             	add    %rcx,%rsp
    # restore full 64-bit frame pointer
    # which the 32-bit EFI will have truncated
    # our full %rsp will be restored by EMARF
    pop %rbp
  8041610553:	5d                   	pop    %rbp

    pop %rcx
  8041610554:	59                   	pop    %rcx
    pop %rsi
  8041610555:	5e                   	pop    %rsi
    pop %r15
  8041610556:	41 5f                	pop    %r15
    pop %r14
  8041610558:	41 5e                	pop    %r14
    pop %r13
  804161055a:	41 5d                	pop    %r13
    pop %r12
  804161055c:	41 5c                	pop    %r12
    pop %rbx
  804161055e:	5b                   	pop    %rbx

    leave
  804161055f:	c9                   	leave  
    ret
  8041610560:	c3                   	ret    

0000008041610561 <pci_config_read_dword>:

};

uint32_t pci_config_read_dword(pci_device_t *pciDevice, uint8_t reg) {
    // Build address.
    uint32_t address = PCI_PORT_ENABLE_BIT | ((uint32_t)pciDevice->Bus << 16)
  8041610561:	0f b6 47 18          	movzbl 0x18(%rdi),%eax
  8041610565:	c1 e0 10             	shl    $0x10,%eax
        | ((uint32_t)pciDevice->Device << 11) | ((uint32_t)pciDevice->Function << 8) | (reg & 0xFC);
  8041610568:	0f b6 57 1a          	movzbl 0x1a(%rdi),%edx
  804161056c:	c1 e2 08             	shl    $0x8,%edx
  804161056f:	09 d0                	or     %edx,%eax
  8041610571:	81 e6 fc 00 00 00    	and    $0xfc,%esi
  8041610577:	09 f0                	or     %esi,%eax
  8041610579:	0f b6 77 19          	movzbl 0x19(%rdi),%esi
  804161057d:	c1 e6 0b             	shl    $0xb,%esi
  8041610580:	09 f0                	or     %esi,%eax
    uint32_t address = PCI_PORT_ENABLE_BIT | ((uint32_t)pciDevice->Bus << 16)
  8041610582:	0d 00 00 00 80       	or     $0x80000000,%eax
    asm volatile("outl %0,%w1" ::"a"(data), "d"(port));
  8041610587:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  804161058c:	ef                   	out    %eax,(%dx)
    asm volatile("inl %w1,%0"
  804161058d:	ba fc 0c 00 00       	mov    $0xcfc,%edx
  8041610592:	ed                   	in     (%dx),%eax
    // Send address to PCI system.
    outl(PCI_PORT_ADDRESS, address);

    // Read 32-bit data value from PCI system.
    return inl(PCI_PORT_DATA);
}
  8041610593:	c3                   	ret    

0000008041610594 <pci_config_read_word>:

uint16_t pci_config_read_word(pci_device_t *pciDevice, uint8_t reg) {
  8041610594:	55                   	push   %rbp
  8041610595:	48 89 e5             	mov    %rsp,%rbp
  8041610598:	53                   	push   %rbx
  8041610599:	48 83 ec 08          	sub    $0x8,%rsp
  804161059d:	89 f3                	mov    %esi,%ebx
    // Read 16-bit value.
    return (uint16_t)(pci_config_read_dword(pciDevice, reg) >> ((reg & 0x2) * 8) & 0xFFFF);
  804161059f:	40 0f b6 f6          	movzbl %sil,%esi
  80416105a3:	48 b8 61 05 61 41 80 	movabs $0x8041610561,%rax
  80416105aa:	00 00 00 
  80416105ad:	ff d0                	call   *%rax
  80416105af:	83 e3 02             	and    $0x2,%ebx
  80416105b2:	8d 0c dd 00 00 00 00 	lea    0x0(,%rbx,8),%ecx
  80416105b9:	d3 e8                	shr    %cl,%eax
}
  80416105bb:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80416105bf:	c9                   	leave  
  80416105c0:	c3                   	ret    

00000080416105c1 <pci_config_read_byte>:

uint8_t pci_config_read_byte(pci_device_t *pciDevice, uint8_t reg) {
  80416105c1:	55                   	push   %rbp
  80416105c2:	48 89 e5             	mov    %rsp,%rbp
  80416105c5:	53                   	push   %rbx
  80416105c6:	48 83 ec 08          	sub    $0x8,%rsp
  80416105ca:	89 f3                	mov    %esi,%ebx
    // Read 8-bit value.
    return (uint8_t)(pci_config_read_dword(pciDevice, reg) >> ((reg & 0x3) * 8) & 0xFF);
  80416105cc:	40 0f b6 f6          	movzbl %sil,%esi
  80416105d0:	48 b8 61 05 61 41 80 	movabs $0x8041610561,%rax
  80416105d7:	00 00 00 
  80416105da:	ff d0                	call   *%rax
  80416105dc:	83 e3 03             	and    $0x3,%ebx
  80416105df:	8d 0c dd 00 00 00 00 	lea    0x0(,%rbx,8),%ecx
  80416105e6:	d3 e8                	shr    %cl,%eax
}
  80416105e8:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80416105ec:	c9                   	leave  
  80416105ed:	c3                   	ret    

00000080416105ee <pci_config_write_dword>:

void pci_config_write_dword(pci_device_t *pciDevice, uint8_t reg, uint32_t value) {
  80416105ee:	89 d1                	mov    %edx,%ecx
    // Build address.
    uint32_t address = PCI_PORT_ENABLE_BIT | ((uint32_t)pciDevice->Bus << 16)
  80416105f0:	0f b6 57 18          	movzbl 0x18(%rdi),%edx
  80416105f4:	c1 e2 10             	shl    $0x10,%edx
        | ((uint32_t)pciDevice->Device << 11) | ((uint32_t)pciDevice->Function << 8) | (reg & 0xFC);
  80416105f7:	0f b6 47 1a          	movzbl 0x1a(%rdi),%eax
  80416105fb:	c1 e0 08             	shl    $0x8,%eax
  80416105fe:	09 c2                	or     %eax,%edx
  8041610600:	89 f0                	mov    %esi,%eax
  8041610602:	25 fc 00 00 00       	and    $0xfc,%eax
  8041610607:	09 d0                	or     %edx,%eax
  8041610609:	0f b6 57 19          	movzbl 0x19(%rdi),%edx
  804161060d:	c1 e2 0b             	shl    $0xb,%edx
  8041610610:	09 d0                	or     %edx,%eax
    uint32_t address = PCI_PORT_ENABLE_BIT | ((uint32_t)pciDevice->Bus << 16)
  8041610612:	0d 00 00 00 80       	or     $0x80000000,%eax
    asm volatile("outl %0,%w1" ::"a"(data), "d"(port));
  8041610617:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  804161061c:	ef                   	out    %eax,(%dx)
  804161061d:	ba fc 0c 00 00       	mov    $0xcfc,%edx
  8041610622:	89 c8                	mov    %ecx,%eax
  8041610624:	ef                   	out    %eax,(%dx)
    // Send address to PCI system.
    outl(PCI_PORT_ADDRESS, address);

    // Write 32-bit value to PCI system.
    outl(PCI_PORT_DATA, value);
}
  8041610625:	c3                   	ret    

0000008041610626 <pci_config_write_word>:

void pci_config_write_word(pci_device_t *pciDevice, uint8_t reg, uint16_t value) {
  8041610626:	55                   	push   %rbp
  8041610627:	48 89 e5             	mov    %rsp,%rbp
  804161062a:	41 56                	push   %r14
  804161062c:	41 55                	push   %r13
  804161062e:	41 54                	push   %r12
  8041610630:	53                   	push   %rbx
  8041610631:	49 89 fd             	mov    %rdi,%r13
  8041610634:	89 f3                	mov    %esi,%ebx
  8041610636:	41 89 d4             	mov    %edx,%r12d
    // Get current 32-bit value.
    uint32_t currentValue = pci_config_read_dword(pciDevice, reg);
  8041610639:	44 0f b6 f6          	movzbl %sil,%r14d
  804161063d:	44 89 f6             	mov    %r14d,%esi
  8041610640:	48 b8 61 05 61 41 80 	movabs $0x8041610561,%rax
  8041610647:	00 00 00 
  804161064a:	ff d0                	call   *%rax

    // Replace portion of the 32-bit value with the new 16-bit value.
    uint32_t newValue = ((uint32_t)value << ((reg & 0x2) * 8)) | (currentValue & (0xFFFF0000 >> (reg & 0x2) * 8));
  804161064c:	83 e3 02             	and    $0x2,%ebx
  804161064f:	8d 0c dd 00 00 00 00 	lea    0x0(,%rbx,8),%ecx
  8041610656:	ba 00 00 ff ff       	mov    $0xffff0000,%edx
  804161065b:	d3 ea                	shr    %cl,%edx
  804161065d:	21 c2                	and    %eax,%edx
  804161065f:	45 0f b7 e4          	movzwl %r12w,%r12d
  8041610663:	41 d3 e4             	shl    %cl,%r12d
  8041610666:	44 09 e2             	or     %r12d,%edx

    // Write the resulting 32-bit value.
    pci_config_write_dword(pciDevice, reg, newValue);
  8041610669:	44 89 f6             	mov    %r14d,%esi
  804161066c:	4c 89 ef             	mov    %r13,%rdi
  804161066f:	48 b8 ee 05 61 41 80 	movabs $0x80416105ee,%rax
  8041610676:	00 00 00 
  8041610679:	ff d0                	call   *%rax
}
  804161067b:	5b                   	pop    %rbx
  804161067c:	41 5c                	pop    %r12
  804161067e:	41 5d                	pop    %r13
  8041610680:	41 5e                	pop    %r14
  8041610682:	5d                   	pop    %rbp
  8041610683:	c3                   	ret    

0000008041610684 <pci_config_write_byte>:

void pci_config_write_byte(pci_device_t *pciDevice, uint8_t reg, uint8_t value) {
  8041610684:	55                   	push   %rbp
  8041610685:	48 89 e5             	mov    %rsp,%rbp
  8041610688:	41 56                	push   %r14
  804161068a:	41 55                	push   %r13
  804161068c:	41 54                	push   %r12
  804161068e:	53                   	push   %rbx
  804161068f:	49 89 fd             	mov    %rdi,%r13
  8041610692:	89 f3                	mov    %esi,%ebx
  8041610694:	41 89 d4             	mov    %edx,%r12d
    // Get current 16-bit value.
    uint16_t currentValue = pci_config_read_word(pciDevice, reg);
  8041610697:	44 0f b6 f6          	movzbl %sil,%r14d
  804161069b:	44 89 f6             	mov    %r14d,%esi
  804161069e:	48 b8 94 05 61 41 80 	movabs $0x8041610594,%rax
  80416106a5:	00 00 00 
  80416106a8:	ff d0                	call   *%rax

    // Replace portion of 16-bit value with the new 8-bit value.
    uint16_t newValue = ((uint16_t)value << ((reg & 0x1) * 8)) | (currentValue & (0xFF00 >> (reg & 0x1) * 8));
  80416106aa:	83 e3 01             	and    $0x1,%ebx
  80416106ad:	8d 0c dd 00 00 00 00 	lea    0x0(,%rbx,8),%ecx
  80416106b4:	ba 00 ff 00 00       	mov    $0xff00,%edx
  80416106b9:	d3 fa                	sar    %cl,%edx
  80416106bb:	21 d0                	and    %edx,%eax
  80416106bd:	41 0f b6 d4          	movzbl %r12b,%edx
  80416106c1:	d3 e2                	shl    %cl,%edx
  80416106c3:	09 d0                	or     %edx,%eax

    // Write the resulting 16-bit value.
    pci_config_write_word(pciDevice, reg, newValue);
  80416106c5:	0f b7 d0             	movzwl %ax,%edx
  80416106c8:	44 89 f6             	mov    %r14d,%esi
  80416106cb:	4c 89 ef             	mov    %r13,%rdi
  80416106ce:	48 b8 26 06 61 41 80 	movabs $0x8041610626,%rax
  80416106d5:	00 00 00 
  80416106d8:	ff d0                	call   *%rax
}
  80416106da:	5b                   	pop    %rbx
  80416106db:	41 5c                	pop    %r12
  80416106dd:	41 5d                	pop    %r13
  80416106df:	41 5e                	pop    %r14
  80416106e1:	5d                   	pop    %rbp
  80416106e2:	c3                   	ret    

00000080416106e3 <pci_enable_busmaster>:

void pci_enable_busmaster(pci_device_t *pciDevice) {
  80416106e3:	55                   	push   %rbp
  80416106e4:	48 89 e5             	mov    %rsp,%rbp
  80416106e7:	53                   	push   %rbx
  80416106e8:	48 83 ec 08          	sub    $0x8,%rsp
  80416106ec:	48 89 fb             	mov    %rdi,%rbx
    // Set busmaster bit.
    pci_config_write_word(pciDevice, PCI_REG_COMMAND, pci_config_read_word(pciDevice, PCI_REG_COMMAND) | PCI_CMD_BUSMASTER);
  80416106ef:	be 04 00 00 00       	mov    $0x4,%esi
  80416106f4:	48 b8 94 05 61 41 80 	movabs $0x8041610594,%rax
  80416106fb:	00 00 00 
  80416106fe:	ff d0                	call   *%rax
  8041610700:	83 c8 04             	or     $0x4,%eax
  8041610703:	0f b7 d0             	movzwl %ax,%edx
  8041610706:	be 04 00 00 00       	mov    $0x4,%esi
  804161070b:	48 89 df             	mov    %rbx,%rdi
  804161070e:	48 b8 26 06 61 41 80 	movabs $0x8041610626,%rax
  8041610715:	00 00 00 
  8041610718:	ff d0                	call   *%rax
}
  804161071a:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804161071e:	c9                   	leave  
  804161071f:	c3                   	ret    

0000008041610720 <pci_print_info>:

/**
 * Print the description for a PCI device
 * @param dev PCIDevice struct with PCI device info
 */
void pci_print_info(pci_device_t *pciDevice) {
  8041610720:	55                   	push   %rbp
  8041610721:	48 89 e5             	mov    %rsp,%rbp
  8041610724:	41 57                	push   %r15
  8041610726:	41 56                	push   %r14
  8041610728:	41 55                	push   %r13
  804161072a:	41 54                	push   %r12
  804161072c:	53                   	push   %rbx
  804161072d:	48 83 ec 08          	sub    $0x8,%rsp
  8041610731:	49 89 fd             	mov    %rdi,%r13
    // Print base info
    cprintf("\e[94mPCI device: %4X:%4X (%4X:%4X) | Class %X Sub %X | Bus %d Device %d Function %d\n", 
  8041610734:	0f b7 4f 20          	movzwl 0x20(%rdi),%ecx
  8041610738:	0f b7 57 1e          	movzwl 0x1e(%rdi),%edx
  804161073c:	0f b7 77 1c          	movzwl 0x1c(%rdi),%esi
  8041610740:	0f b6 47 1a          	movzbl 0x1a(%rdi),%eax
  8041610744:	50                   	push   %rax
  8041610745:	0f b6 47 19          	movzbl 0x19(%rdi),%eax
  8041610749:	50                   	push   %rax
  804161074a:	0f b6 47 18          	movzbl 0x18(%rdi),%eax
  804161074e:	50                   	push   %rax
  804161074f:	0f b6 47 26          	movzbl 0x26(%rdi),%eax
  8041610753:	50                   	push   %rax
  8041610754:	44 0f b6 4f 25       	movzbl 0x25(%rdi),%r9d
  8041610759:	44 0f b7 47 22       	movzwl 0x22(%rdi),%r8d
  804161075e:	48 bf 20 3d 61 41 80 	movabs $0x8041613d20,%rdi
  8041610765:	00 00 00 
  8041610768:	b8 00 00 00 00       	mov    $0x0,%eax
  804161076d:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  8041610774:	00 00 00 
  8041610777:	ff d3                	call   *%rbx
        pciDevice->VendorId, pciDevice->DeviceId, pciDevice->SubVendorId, pciDevice->SubDeviceId, pciDevice->Class, pciDevice->Subclass, pciDevice->Bus, 
        pciDevice->Device, pciDevice->Function);
    
    // Print class info and base addresses
    cprintf("\e[96m  - %s\n", pci_class_descriptions[pciDevice->Class]);
  8041610779:	48 83 c4 20          	add    $0x20,%rsp
  804161077d:	41 0f b6 55 25       	movzbl 0x25(%r13),%edx
  8041610782:	48 b8 00 49 63 41 80 	movabs $0x8041634900,%rax
  8041610789:	00 00 00 
  804161078c:	48 8b 34 d0          	mov    (%rax,%rdx,8),%rsi
  8041610790:	48 bf 73 3b 61 41 80 	movabs $0x8041613b73,%rdi
  8041610797:	00 00 00 
  804161079a:	b8 00 00 00 00       	mov    $0x0,%eax
  804161079f:	ff d3                	call   *%rbx

    // Print base addresses.
    for (uint8_t i = 0; i < PCI_BAR_COUNT; i++) {
  80416107a1:	4d 8d 65 30          	lea    0x30(%r13),%r12
    cprintf("\e[96m  - %s\n", pci_class_descriptions[pciDevice->Class]);
  80416107a5:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (pciDevice->BaseAddresses[i].BaseAddress)
            cprintf("  - BAR%u: 0x%X Size: %ld (%s)\n", i, pciDevice->BaseAddresses[i].BaseAddress, pciDevice->BaseAddresses[i].Size, pciDevice->BaseAddresses[i].PortMapped ? "port-mapped" : "memory-mapped");
  80416107aa:	49 bf 59 3b 61 41 80 	movabs $0x8041613b59,%r15
  80416107b1:	00 00 00 
  80416107b4:	49 be 99 c8 60 41 80 	movabs $0x804160c899,%r14
  80416107bb:	00 00 00 
  80416107be:	eb 0e                	jmp    80416107ce <pci_print_info+0xae>
    for (uint8_t i = 0; i < PCI_BAR_COUNT; i++) {
  80416107c0:	48 83 c3 01          	add    $0x1,%rbx
  80416107c4:	49 83 c4 10          	add    $0x10,%r12
  80416107c8:	48 83 fb 06          	cmp    $0x6,%rbx
  80416107cc:	74 37                	je     8041610805 <pci_print_info+0xe5>
        if (pciDevice->BaseAddresses[i].BaseAddress)
  80416107ce:	89 de                	mov    %ebx,%esi
  80416107d0:	41 8b 54 24 04       	mov    0x4(%r12),%edx
  80416107d5:	85 d2                	test   %edx,%edx
  80416107d7:	74 e7                	je     80416107c0 <pci_print_info+0xa0>
            cprintf("  - BAR%u: 0x%X Size: %ld (%s)\n", i, pciDevice->BaseAddresses[i].BaseAddress, pciDevice->BaseAddresses[i].Size, pciDevice->BaseAddresses[i].PortMapped ? "port-mapped" : "memory-mapped");
  80416107d9:	41 80 3c 24 00       	cmpb   $0x0,(%r12)
  80416107de:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
  80416107e3:	49 b8 65 3b 61 41 80 	movabs $0x8041613b65,%r8
  80416107ea:	00 00 00 
  80416107ed:	4d 0f 45 c7          	cmovne %r15,%r8
  80416107f1:	48 bf 78 3d 61 41 80 	movabs $0x8041613d78,%rdi
  80416107f8:	00 00 00 
  80416107fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610800:	41 ff d6             	call   *%r14
  8041610803:	eb bb                	jmp    80416107c0 <pci_print_info+0xa0>
	}
    // Interrupt info
    if(pciDevice->InterruptNo != 0) { 
  8041610805:	41 0f b6 b5 92 00 00 	movzbl 0x92(%r13),%esi
  804161080c:	00 
  804161080d:	40 84 f6             	test   %sil,%sil
  8041610810:	75 0f                	jne    8041610821 <pci_print_info+0x101>
        cprintf("  - Interrupt %u (Pin %u Line %u\e[0m\n", pciDevice->InterruptNo, pciDevice->InterruptPin, pciDevice->InterruptLine);
    }

}
  8041610812:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  8041610816:	5b                   	pop    %rbx
  8041610817:	41 5c                	pop    %r12
  8041610819:	41 5d                	pop    %r13
  804161081b:	41 5e                	pop    %r14
  804161081d:	41 5f                	pop    %r15
  804161081f:	5d                   	pop    %rbp
  8041610820:	c3                   	ret    
        cprintf("  - Interrupt %u (Pin %u Line %u\e[0m\n", pciDevice->InterruptNo, pciDevice->InterruptPin, pciDevice->InterruptLine);
  8041610821:	41 0f b6 8d 91 00 00 	movzbl 0x91(%r13),%ecx
  8041610828:	00 
  8041610829:	41 0f b6 95 90 00 00 	movzbl 0x90(%r13),%edx
  8041610830:	00 
  8041610831:	40 0f b6 f6          	movzbl %sil,%esi
  8041610835:	48 bf 98 3d 61 41 80 	movabs $0x8041613d98,%rdi
  804161083c:	00 00 00 
  804161083f:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610844:	49 b8 99 c8 60 41 80 	movabs $0x804160c899,%r8
  804161084b:	00 00 00 
  804161084e:	41 ff d0             	call   *%r8
}
  8041610851:	eb bf                	jmp    8041610812 <pci_print_info+0xf2>

0000008041610853 <pci_enable_palette_snoop>:



void pci_enable_palette_snoop(pci_device_t *pciDevice) {
  8041610853:	55                   	push   %rbp
  8041610854:	48 89 e5             	mov    %rsp,%rbp
  8041610857:	53                   	push   %rbx
  8041610858:	48 83 ec 08          	sub    $0x8,%rsp
  804161085c:	48 89 fb             	mov    %rdi,%rbx
    // Set palette snoop bit.
    if (pci_config_read_word(pciDevice, PCI_REG_COMMAND) & PCI_CMD_PALETTE_SNOOP)
  804161085f:	be 04 00 00 00       	mov    $0x4,%esi
  8041610864:	48 b8 94 05 61 41 80 	movabs $0x8041610594,%rax
  804161086b:	00 00 00 
  804161086e:	ff d0                	call   *%rax
  8041610870:	a8 20                	test   $0x20,%al
  8041610872:	75 34                	jne    80416108a8 <pci_enable_palette_snoop+0x55>
        cprintf("{{{already enable}d}}}\n");
    pci_config_write_word(pciDevice, PCI_REG_COMMAND, pci_config_read_word(pciDevice, PCI_REG_COMMAND) | PCI_CMD_PALETTE_SNOOP);
  8041610874:	be 04 00 00 00       	mov    $0x4,%esi
  8041610879:	48 89 df             	mov    %rbx,%rdi
  804161087c:	48 b8 94 05 61 41 80 	movabs $0x8041610594,%rax
  8041610883:	00 00 00 
  8041610886:	ff d0                	call   *%rax
  8041610888:	83 c8 20             	or     $0x20,%eax
  804161088b:	0f b7 d0             	movzwl %ax,%edx
  804161088e:	be 04 00 00 00       	mov    $0x4,%esi
  8041610893:	48 89 df             	mov    %rbx,%rdi
  8041610896:	48 b8 26 06 61 41 80 	movabs $0x8041610626,%rax
  804161089d:	00 00 00 
  80416108a0:	ff d0                	call   *%rax
}
  80416108a2:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80416108a6:	c9                   	leave  
  80416108a7:	c3                   	ret    
        cprintf("{{{already enable}d}}}\n");
  80416108a8:	48 bf 80 3b 61 41 80 	movabs $0x8041613b80,%rdi
  80416108af:	00 00 00 
  80416108b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80416108b7:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  80416108be:	00 00 00 
  80416108c1:	ff d2                	call   *%rdx
  80416108c3:	eb af                	jmp    8041610874 <pci_enable_palette_snoop+0x21>

00000080416108c5 <pci_get_device>:
 * @param  bus      PCI bus to read from
 * @param  device   PCI slot to read from
 * @param  function PCI card function to read from
 * @return          A PCIDevice struct with the info filled
 */
pci_device_t *pci_get_device(uint8_t bus, uint8_t device, uint8_t function/*, ACPI_BUFFER *routingBuffer*/) {
  80416108c5:	55                   	push   %rbp
  80416108c6:	48 89 e5             	mov    %rsp,%rbp
  80416108c9:	41 57                	push   %r15
  80416108cb:	41 56                	push   %r14
  80416108cd:	41 55                	push   %r13
  80416108cf:	41 54                	push   %r12
  80416108d1:	53                   	push   %rbx
  80416108d2:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
  80416108d9:	41 89 fe             	mov    %edi,%r14d
  80416108dc:	41 89 f5             	mov    %esi,%r13d
  80416108df:	41 89 d4             	mov    %edx,%r12d
    // Create temporary PCI device object.
    pci_device_t pciDeviceTemp = { };
  80416108e2:	48 8d bd 28 ff ff ff 	lea    -0xd8(%rbp),%rdi
  80416108e9:	b9 15 00 00 00       	mov    $0x15,%ecx
  80416108ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80416108f3:	f3 48 ab             	rep stos %rax,%es:(%rdi)

    // Set device address.
    pciDeviceTemp.Bus = bus;
  80416108f6:	44 88 b5 40 ff ff ff 	mov    %r14b,-0xc0(%rbp)
    pciDeviceTemp.Device = device;
  80416108fd:	40 88 b5 41 ff ff ff 	mov    %sil,-0xbf(%rbp)
    pciDeviceTemp.Function = function;
  8041610904:	88 95 42 ff ff ff    	mov    %dl,-0xbe(%rbp)

    // Get device vendor. If vendor is 0xFFFF, the device doesn't exist.
    pciDeviceTemp.VendorId = pci_config_read_word(&pciDeviceTemp, PCI_REG_VENDOR_ID);
  804161090a:	be 00 00 00 00       	mov    $0x0,%esi
  804161090f:	48 8d bd 28 ff ff ff 	lea    -0xd8(%rbp),%rdi
  8041610916:	48 b8 94 05 61 41 80 	movabs $0x8041610594,%rax
  804161091d:	00 00 00 
  8041610920:	ff d0                	call   *%rax
  8041610922:	66 89 85 44 ff ff ff 	mov    %ax,-0xbc(%rbp)
    if (pciDeviceTemp.VendorId == PCI_DEVICE_VENDOR_NONE)
  8041610929:	66 83 f8 ff          	cmp    $0xffff,%ax
  804161092d:	0f 84 2d 02 00 00    	je     8041610b60 <pci_get_device+0x29b>
        return NULL;

    // Create PCI device object
	if (PciDevicesArr == NULL) 
  8041610933:	48 b8 20 5b 40 42 80 	movabs $0x8042405b20,%rax
  804161093a:	00 00 00 
  804161093d:	48 83 38 00          	cmpq   $0x0,(%rax)
  8041610941:	0f 84 25 01 00 00    	je     8041610a6c <pci_get_device+0x1a7>
		PciDevicesArr = kzalloc_region(sizeof(pci_device_t) * PCI_NUM_DEVICES);
	
    if (cur_pci_idx >= PCI_NUM_DEVICES)
  8041610947:	48 b8 30 5b 40 42 80 	movabs $0x8042405b30,%rax
  804161094e:	00 00 00 
  8041610951:	8b 10                	mov    (%rax),%edx
  8041610953:	83 fa 1f             	cmp    $0x1f,%edx
  8041610956:	0f 8f 30 01 00 00    	jg     8041610a8c <pci_get_device+0x1c7>
		panic("Not enough space for PCI DEVICES");

    pci_device_t *pciDevice = &PciDevicesArr[cur_pci_idx++];
  804161095c:	8d 42 01             	lea    0x1(%rdx),%eax
  804161095f:	a3 30 5b 40 42 80 00 	movabs %eax,0x8042405b30
  8041610966:	00 00 
  8041610968:	48 63 d2             	movslq %edx,%rdx
  804161096b:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  804161096f:	48 8d 14 82          	lea    (%rdx,%rax,4),%rdx
  8041610973:	48 a1 20 5b 40 42 80 	movabs 0x8042405b20,%rax
  804161097a:	00 00 00 
  804161097d:	48 8d 1c d0          	lea    (%rax,%rdx,8),%rbx
    
	// Set device address.
    pciDevice->Bus = bus;
  8041610981:	44 88 73 18          	mov    %r14b,0x18(%rbx)
    pciDevice->Device = device;
  8041610985:	44 88 6b 19          	mov    %r13b,0x19(%rbx)
    pciDevice->Function = function;
  8041610989:	44 88 63 1a          	mov    %r12b,0x1a(%rbx)

    // Get PCI identification variables.
    pciDevice->VendorId = pci_config_read_word(pciDevice, PCI_REG_VENDOR_ID);
  804161098d:	be 00 00 00 00       	mov    $0x0,%esi
  8041610992:	48 89 df             	mov    %rbx,%rdi
  8041610995:	49 bc 94 05 61 41 80 	movabs $0x8041610594,%r12
  804161099c:	00 00 00 
  804161099f:	41 ff d4             	call   *%r12
  80416109a2:	66 89 43 1c          	mov    %ax,0x1c(%rbx)
    pciDevice->DeviceId = pci_config_read_word(pciDevice, PCI_REG_DEVICE_ID);
  80416109a6:	be 02 00 00 00       	mov    $0x2,%esi
  80416109ab:	48 89 df             	mov    %rbx,%rdi
  80416109ae:	41 ff d4             	call   *%r12
  80416109b1:	66 89 43 1e          	mov    %ax,0x1e(%rbx)
    pciDevice->SubVendorId = pci_config_read_word(pciDevice, PCI_REG_SUB_VENDOR_ID);
  80416109b5:	be 2c 00 00 00       	mov    $0x2c,%esi
  80416109ba:	48 89 df             	mov    %rbx,%rdi
  80416109bd:	41 ff d4             	call   *%r12
  80416109c0:	66 89 43 20          	mov    %ax,0x20(%rbx)
    pciDevice->SubDeviceId = pci_config_read_word(pciDevice, PCI_REG_SUB_DEVICE_ID);
  80416109c4:	be 2e 00 00 00       	mov    $0x2e,%esi
  80416109c9:	48 89 df             	mov    %rbx,%rdi
  80416109cc:	41 ff d4             	call   *%r12
  80416109cf:	66 89 43 22          	mov    %ax,0x22(%rbx)
    pciDevice->RevisionId = pci_config_read_byte(pciDevice, PCI_REG_REVISION_ID);
  80416109d3:	be 08 00 00 00       	mov    $0x8,%esi
  80416109d8:	48 89 df             	mov    %rbx,%rdi
  80416109db:	49 bc c1 05 61 41 80 	movabs $0x80416105c1,%r12
  80416109e2:	00 00 00 
  80416109e5:	41 ff d4             	call   *%r12
  80416109e8:	88 43 24             	mov    %al,0x24(%rbx)
    pciDevice->Class = pci_config_read_byte(pciDevice, PCI_REG_CLASS);
  80416109eb:	be 0b 00 00 00       	mov    $0xb,%esi
  80416109f0:	48 89 df             	mov    %rbx,%rdi
  80416109f3:	41 ff d4             	call   *%r12
  80416109f6:	88 43 25             	mov    %al,0x25(%rbx)
    pciDevice->Subclass = pci_config_read_byte(pciDevice, PCI_REG_SUBCLASS);
  80416109f9:	be 0a 00 00 00       	mov    $0xa,%esi
  80416109fe:	48 89 df             	mov    %rbx,%rdi
  8041610a01:	41 ff d4             	call   *%r12
  8041610a04:	88 43 26             	mov    %al,0x26(%rbx)
    pciDevice->Interface = pci_config_read_byte(pciDevice, PCI_REG_PROG_IF);
  8041610a07:	be 09 00 00 00       	mov    $0x9,%esi
  8041610a0c:	48 89 df             	mov    %rbx,%rdi
  8041610a0f:	41 ff d4             	call   *%r12
  8041610a12:	88 43 27             	mov    %al,0x27(%rbx)
    pciDevice->HeaderType = pci_config_read_byte(pciDevice, PCI_REG_HEADER_TYPE);
  8041610a15:	be 0e 00 00 00       	mov    $0xe,%esi
  8041610a1a:	48 89 df             	mov    %rbx,%rdi
  8041610a1d:	41 ff d4             	call   *%r12
  8041610a20:	88 43 28             	mov    %al,0x28(%rbx)

    // Get interrupt info.
    pciDevice->InterruptPin = pci_config_read_byte(pciDevice, PCI_REG_INTERRUPT_PIN);
  8041610a23:	be 3d 00 00 00       	mov    $0x3d,%esi
  8041610a28:	48 89 df             	mov    %rbx,%rdi
  8041610a2b:	41 ff d4             	call   *%r12
  8041610a2e:	88 83 90 00 00 00    	mov    %al,0x90(%rbx)
    pciDevice->InterruptLine = pci_config_read_byte(pciDevice, PCI_REG_INTERRUPT_LINE);
  8041610a34:	be 3c 00 00 00       	mov    $0x3c,%esi
  8041610a39:	48 89 df             	mov    %rbx,%rdi
  8041610a3c:	41 ff d4             	call   *%r12
  8041610a3f:	88 83 91 00 00 00    	mov    %al,0x91(%rbx)

    // Get base address registers.
    for (uint8_t i = 0; i < PCI_BAR_COUNT; i++) {
  8041610a45:	4c 8d 6b 30          	lea    0x30(%rbx),%r13
  8041610a49:	48 8d 83 90 00 00 00 	lea    0x90(%rbx),%rax
  8041610a50:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
    pciDevice->InterruptLine = pci_config_read_byte(pciDevice, PCI_REG_INTERRUPT_LINE);
  8041610a57:	41 be 10 00 00 00    	mov    $0x10,%r14d
        // Get BAR.
        uint8_t CurrentBarAddress = PCI_REG_BAR0 + (i * sizeof(uint32_t));

        uint32_t bar = pci_config_read_dword(pciDevice, CurrentBarAddress);
  8041610a5d:	49 bf 61 05 61 41 80 	movabs $0x8041610561,%r15
  8041610a64:	00 00 00 
  8041610a67:	e9 a6 00 00 00       	jmp    8041610b12 <pci_get_device+0x24d>
		PciDevicesArr = kzalloc_region(sizeof(pci_device_t) * PCI_NUM_DEVICES);
  8041610a6c:	bf 00 15 00 00       	mov    $0x1500,%edi
  8041610a71:	48 b8 5f a5 60 41 80 	movabs $0x804160a55f,%rax
  8041610a78:	00 00 00 
  8041610a7b:	ff d0                	call   *%rax
  8041610a7d:	48 a3 20 5b 40 42 80 	movabs %rax,0x8042405b20
  8041610a84:	00 00 00 
  8041610a87:	e9 bb fe ff ff       	jmp    8041610947 <pci_get_device+0x82>
		panic("Not enough space for PCI DEVICES");
  8041610a8c:	48 ba c0 3d 61 41 80 	movabs $0x8041613dc0,%rdx
  8041610a93:	00 00 00 
  8041610a96:	be 9f 00 00 00       	mov    $0x9f,%esi
  8041610a9b:	48 bf 98 3b 61 41 80 	movabs $0x8041613b98,%rdi
  8041610aa2:	00 00 00 
  8041610aa5:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610aaa:	48 b9 d9 02 60 41 80 	movabs $0x80416002d9,%rcx
  8041610ab1:	00 00 00 
  8041610ab4:	ff d1                	call   *%rcx
        if (pciDevice->BaseAddresses[i].PortMapped) {
            // Port I/O bar.
            pciDevice->BaseAddresses[i].BaseAddress = bar & PCI_BAR_PORT_MASK;
        }
        else {
            pciDevice->BaseAddresses[i].BaseAddress = bar & PCI_BAR_MEMORY_MASK;
  8041610ab6:	44 89 e2             	mov    %r12d,%edx
  8041610ab9:	83 e2 f0             	and    $0xfffffff0,%edx
  8041610abc:	41 89 55 04          	mov    %edx,0x4(%r13)
            pciDevice->BaseAddresses[i].Size = PCI_MAPREG_MEM_SIZE(bar_value);
  8041610ac0:	89 c2                	mov    %eax,%edx
  8041610ac2:	83 e2 f0             	and    $0xfffffff0,%edx
  8041610ac5:	f7 da                	neg    %edx
  8041610ac7:	21 d0                	and    %edx,%eax
  8041610ac9:	89 c0                	mov    %eax,%eax
  8041610acb:	49 89 45 08          	mov    %rax,0x8(%r13)
            pciDevice->BaseAddresses[i].AddressIs64bits = (bar & PCI_BAR_BITS64) != 0;
  8041610acf:	44 89 e0             	mov    %r12d,%eax
  8041610ad2:	c1 e8 02             	shr    $0x2,%eax
  8041610ad5:	83 e0 01             	and    $0x1,%eax
  8041610ad8:	41 88 45 01          	mov    %al,0x1(%r13)
            pciDevice->BaseAddresses[i].Prefetchable = (bar & PCI_BAR_PREFETCHABLE) != 0;
  8041610adc:	44 89 e0             	mov    %r12d,%eax
  8041610adf:	c1 e8 03             	shr    $0x3,%eax
  8041610ae2:	83 e0 01             	and    $0x1,%eax
  8041610ae5:	41 88 45 02          	mov    %al,0x2(%r13)
        }
        pci_config_write_dword(pciDevice, CurrentBarAddress, bar);
  8041610ae9:	44 89 e2             	mov    %r12d,%edx
  8041610aec:	8b b5 1c ff ff ff    	mov    -0xe4(%rbp),%esi
  8041610af2:	48 89 df             	mov    %rbx,%rdi
  8041610af5:	48 b8 ee 05 61 41 80 	movabs $0x80416105ee,%rax
  8041610afc:	00 00 00 
  8041610aff:	ff d0                	call   *%rax
    for (uint8_t i = 0; i < PCI_BAR_COUNT; i++) {
  8041610b01:	41 83 c6 04          	add    $0x4,%r14d
  8041610b05:	49 83 c5 10          	add    $0x10,%r13
  8041610b09:	4c 3b ad 10 ff ff ff 	cmp    -0xf0(%rbp),%r13
  8041610b10:	74 53                	je     8041610b65 <pci_get_device+0x2a0>
        uint32_t bar = pci_config_read_dword(pciDevice, CurrentBarAddress);
  8041610b12:	44 89 b5 1c ff ff ff 	mov    %r14d,-0xe4(%rbp)
  8041610b19:	44 89 f6             	mov    %r14d,%esi
  8041610b1c:	48 89 df             	mov    %rbx,%rdi
  8041610b1f:	41 ff d7             	call   *%r15
  8041610b22:	41 89 c4             	mov    %eax,%r12d
        pci_config_write_dword(pciDevice, CurrentBarAddress, 0xffffffff);
  8041610b25:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8041610b2a:	44 89 f6             	mov    %r14d,%esi
  8041610b2d:	48 89 df             	mov    %rbx,%rdi
  8041610b30:	48 b8 ee 05 61 41 80 	movabs $0x80416105ee,%rax
  8041610b37:	00 00 00 
  8041610b3a:	ff d0                	call   *%rax
        uint32_t bar_value = pci_config_read_dword(pciDevice, CurrentBarAddress);
  8041610b3c:	44 89 f6             	mov    %r14d,%esi
  8041610b3f:	48 89 df             	mov    %rbx,%rdi
  8041610b42:	41 ff d7             	call   *%r15
        pciDevice->BaseAddresses[i].PortMapped = (bar & PCI_BAR_TYPE_PORT) != 0;
  8041610b45:	41 f6 c4 01          	test   $0x1,%r12b
  8041610b49:	41 0f 95 45 00       	setne  0x0(%r13)
        if (pciDevice->BaseAddresses[i].PortMapped) {
  8041610b4e:	0f 84 62 ff ff ff    	je     8041610ab6 <pci_get_device+0x1f1>
            pciDevice->BaseAddresses[i].BaseAddress = bar & PCI_BAR_PORT_MASK;
  8041610b54:	44 89 e0             	mov    %r12d,%eax
  8041610b57:	83 e0 fc             	and    $0xfffffffc,%eax
  8041610b5a:	41 89 45 04          	mov    %eax,0x4(%r13)
  8041610b5e:	eb 89                	jmp    8041610ae9 <pci_get_device+0x224>
        return NULL;
  8041610b60:	bb 00 00 00 00       	mov    $0x0,%ebx

    }
    // Return the device.
    return pciDevice;
}
  8041610b65:	48 89 d8             	mov    %rbx,%rax
  8041610b68:	48 81 c4 c8 00 00 00 	add    $0xc8,%rsp
  8041610b6f:	5b                   	pop    %rbx
  8041610b70:	41 5c                	pop    %r12
  8041610b72:	41 5d                	pop    %r13
  8041610b74:	41 5e                	pop    %r14
  8041610b76:	41 5f                	pop    %r15
  8041610b78:	5d                   	pop    %rbp
  8041610b79:	c3                   	ret    

0000008041610b7a <pci_check_busses>:

/**
 * Check a bus for PCI devices
 * @param bus The bus number to scan
 */
static void pci_check_busses(uint8_t bus, pci_device_t *parentPciDevice) {
  8041610b7a:	55                   	push   %rbp
  8041610b7b:	48 89 e5             	mov    %rsp,%rbp
  8041610b7e:	41 57                	push   %r15
  8041610b80:	41 56                	push   %r14
  8041610b82:	41 55                	push   %r13
  8041610b84:	41 54                	push   %r12
  8041610b86:	53                   	push   %rbx
  8041610b87:	48 83 ec 18          	sub    $0x18,%rsp
  8041610b8b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    uint8_t parentDevice = 0;
  8041610b8f:	b8 00 00 00 00       	mov    $0x0,%eax
    if (parentPciDevice != NULL)
  8041610b94:	48 85 f6             	test   %rsi,%rsi
  8041610b97:	74 04                	je     8041610b9d <pci_check_busses+0x23>
        parentDevice = parentPciDevice->Device;
  8041610b99:	0f b6 46 19          	movzbl 0x19(%rsi),%eax
    cprintf("Getting _PRT for bus %u on device %u...\n", bus, parentDevice);
  8041610b9d:	40 0f b6 cf          	movzbl %dil,%ecx
  8041610ba1:	41 89 cf             	mov    %ecx,%r15d
  8041610ba4:	89 4d cc             	mov    %ecx,-0x34(%rbp)
  8041610ba7:	0f b6 d0             	movzbl %al,%edx
  8041610baa:	89 ce                	mov    %ecx,%esi
  8041610bac:	48 bf e8 3d 61 41 80 	movabs $0x8041613de8,%rdi
  8041610bb3:	00 00 00 
  8041610bb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610bbb:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  8041610bc2:	00 00 00 
  8041610bc5:	ff d3                	call   *%rbx
    // Check each device on bus
    cprintf("PCI: Enumerating devices on bus %u...\n", bus);
  8041610bc7:	44 89 fe             	mov    %r15d,%esi
  8041610bca:	48 bf 18 3e 61 41 80 	movabs $0x8041613e18,%rdi
  8041610bd1:	00 00 00 
  8041610bd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610bd9:	ff d3                	call   *%rbx
  8041610bdb:	41 bc 00 00 00 00    	mov    $0x0,%r12d
    for (uint8_t device = 0; device < PCI_NUM_DEVICES; device++) {
        // Get info on the device and print info
        pci_device_t *pciDevice = pci_get_device(bus, device, 0/*, &buffer*/);
  8041610be1:	49 bf c5 08 61 41 80 	movabs $0x80416108c5,%r15
  8041610be8:	00 00 00 
  8041610beb:	e9 f9 00 00 00       	jmp    8041610ce9 <pci_check_busses+0x16f>
        PciDevices = pciDevice;
  8041610bf0:	48 b8 28 5b 40 42 80 	movabs $0x8042405b28,%rax
  8041610bf7:	00 00 00 
  8041610bfa:	48 89 18             	mov    %rbx,(%rax)
  8041610bfd:	e9 3d 01 00 00       	jmp    8041610d3f <pci_check_busses+0x1c5>
        pci_print_info(pciDevice);
        pci_add_device(pciDevice, parentPciDevice);

        // If the card reports more than one function, let's scan those too.
        if ((pciDevice->HeaderType & PCI_HEADER_TYPE_MULTIFUNC) != 0) {
            cprintf("\e[32m  - Scanning other functions on multifunction device!\e[0m\n");
  8041610c02:	48 bf 40 3e 61 41 80 	movabs $0x8041613e40,%rdi
  8041610c09:	00 00 00 
  8041610c0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610c11:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610c18:	00 00 00 
  8041610c1b:	ff d2                	call   *%rdx
  8041610c1d:	41 be 01 00 00 00    	mov    $0x1,%r14d
  8041610c23:	eb 1e                	jmp    8041610c43 <pci_check_busses+0xc9>
        while (lastDevice->Next != NULL)
  8041610c25:	48 89 c2             	mov    %rax,%rdx
  8041610c28:	48 8b 40 08          	mov    0x8(%rax),%rax
  8041610c2c:	48 85 c0             	test   %rax,%rax
  8041610c2f:	75 f4                	jne    8041610c25 <pci_check_busses+0xab>
        lastDevice->Next = pciDevice;
  8041610c31:	4c 89 6a 08          	mov    %r13,0x8(%rdx)
            // Check each function on the device
            for (uint8_t func = 1; func < PCI_NUM_FUNCTIONS; func++) {
  8041610c35:	41 83 c6 01          	add    $0x1,%r14d
  8041610c39:	41 83 fe 08          	cmp    $0x8,%r14d
  8041610c3d:	0f 84 06 01 00 00    	je     8041610d49 <pci_check_busses+0x1cf>
                pci_device_t *funcDevice = pci_get_device(bus, device, func/*, &buffer*/);
  8041610c43:	44 89 f2             	mov    %r14d,%edx
  8041610c46:	8b 75 c8             	mov    -0x38(%rbp),%esi
  8041610c49:	8b 7d cc             	mov    -0x34(%rbp),%edi
  8041610c4c:	41 ff d7             	call   *%r15
  8041610c4f:	49 89 c5             	mov    %rax,%r13
                if (funcDevice == NULL)
  8041610c52:	48 85 c0             	test   %rax,%rax
  8041610c55:	74 de                	je     8041610c35 <pci_check_busses+0xbb>
                    continue;

                // Add device.
                pci_print_info(funcDevice);
  8041610c57:	48 89 c7             	mov    %rax,%rdi
  8041610c5a:	48 b8 20 07 61 41 80 	movabs $0x8041610720,%rax
  8041610c61:	00 00 00 
  8041610c64:	ff d0                	call   *%rax
    pciDevice->Parent = parentPciDevice;
  8041610c66:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8041610c6a:	49 89 45 00          	mov    %rax,0x0(%r13)
    if (PciDevices != NULL) {
  8041610c6e:	48 b8 28 5b 40 42 80 	movabs $0x8042405b28,%rax
  8041610c75:	00 00 00 
  8041610c78:	48 8b 00             	mov    (%rax),%rax
  8041610c7b:	48 85 c0             	test   %rax,%rax
  8041610c7e:	75 a5                	jne    8041610c25 <pci_check_busses+0xab>
        PciDevices = pciDevice;
  8041610c80:	48 b8 28 5b 40 42 80 	movabs $0x8042405b28,%rax
  8041610c87:	00 00 00 
  8041610c8a:	4c 89 28             	mov    %r13,(%rax)
  8041610c8d:	eb a6                	jmp    8041610c35 <pci_check_busses+0xbb>
            }
        }

        // Is the device a bridge?
        if (pciDevice->Class == PCI_CLASS_BRIDGE && pciDevice->Subclass == PCI_SUBCLASS_BRIDGE_PCI) {
            uint16_t secondaryBus = pci_config_read_word(pciDevice, PCI_REG_BAR2);
  8041610c8f:	be 18 00 00 00       	mov    $0x18,%esi
  8041610c94:	48 89 df             	mov    %rbx,%rdi
  8041610c97:	48 b8 94 05 61 41 80 	movabs $0x8041610594,%rax
  8041610c9e:	00 00 00 
  8041610ca1:	ff d0                	call   *%rax
            uint16_t primaryBus = (secondaryBus & ~0xFF00);
            secondaryBus = (secondaryBus & ~0x00FF) >> 8;
  8041610ca3:	0f b6 cc             	movzbl %ah,%ecx
  8041610ca6:	41 89 cd             	mov    %ecx,%r13d
            cprintf("\e[32m  - PCI bridge, Primary %X Secondary %X, scanning now.\e[0m\n", primaryBus, secondaryBus);
  8041610ca9:	0f b6 f0             	movzbl %al,%esi
  8041610cac:	89 ca                	mov    %ecx,%edx
  8041610cae:	48 bf 80 3e 61 41 80 	movabs $0x8041613e80,%rdi
  8041610cb5:	00 00 00 
  8041610cb8:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610cbd:	48 b9 99 c8 60 41 80 	movabs $0x804160c899,%rcx
  8041610cc4:	00 00 00 
  8041610cc7:	ff d1                	call   *%rcx
            pci_check_busses(secondaryBus, pciDevice);
  8041610cc9:	48 89 de             	mov    %rbx,%rsi
  8041610ccc:	44 89 ef             	mov    %r13d,%edi
  8041610ccf:	48 b8 7a 0b 61 41 80 	movabs $0x8041610b7a,%rax
  8041610cd6:	00 00 00 
  8041610cd9:	ff d0                	call   *%rax
    for (uint8_t device = 0; device < PCI_NUM_DEVICES; device++) {
  8041610cdb:	41 83 c4 01          	add    $0x1,%r12d
  8041610cdf:	41 83 fc 20          	cmp    $0x20,%r12d
  8041610ce3:	0f 84 9d 00 00 00    	je     8041610d86 <pci_check_busses+0x20c>
        pci_device_t *pciDevice = pci_get_device(bus, device, 0/*, &buffer*/);
  8041610ce9:	44 89 65 c8          	mov    %r12d,-0x38(%rbp)
  8041610ced:	ba 00 00 00 00       	mov    $0x0,%edx
  8041610cf2:	44 89 e6             	mov    %r12d,%esi
  8041610cf5:	8b 7d cc             	mov    -0x34(%rbp),%edi
  8041610cf8:	41 ff d7             	call   *%r15
  8041610cfb:	48 89 c3             	mov    %rax,%rbx
        if (pciDevice == NULL)
  8041610cfe:	48 85 c0             	test   %rax,%rax
  8041610d01:	74 d8                	je     8041610cdb <pci_check_busses+0x161>
        pci_print_info(pciDevice);
  8041610d03:	48 89 c7             	mov    %rax,%rdi
  8041610d06:	48 b8 20 07 61 41 80 	movabs $0x8041610720,%rax
  8041610d0d:	00 00 00 
  8041610d10:	ff d0                	call   *%rax
    pciDevice->Parent = parentPciDevice;
  8041610d12:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8041610d16:	48 89 03             	mov    %rax,(%rbx)
    if (PciDevices != NULL) {
  8041610d19:	48 b8 28 5b 40 42 80 	movabs $0x8042405b28,%rax
  8041610d20:	00 00 00 
  8041610d23:	48 8b 00             	mov    (%rax),%rax
  8041610d26:	48 85 c0             	test   %rax,%rax
  8041610d29:	0f 84 c1 fe ff ff    	je     8041610bf0 <pci_check_busses+0x76>
        while (lastDevice->Next != NULL)
  8041610d2f:	48 89 c2             	mov    %rax,%rdx
  8041610d32:	48 8b 40 08          	mov    0x8(%rax),%rax
  8041610d36:	48 85 c0             	test   %rax,%rax
  8041610d39:	75 f4                	jne    8041610d2f <pci_check_busses+0x1b5>
        lastDevice->Next = pciDevice;
  8041610d3b:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
        if ((pciDevice->HeaderType & PCI_HEADER_TYPE_MULTIFUNC) != 0) {
  8041610d3f:	80 7b 28 00          	cmpb   $0x0,0x28(%rbx)
  8041610d43:	0f 88 b9 fe ff ff    	js     8041610c02 <pci_check_busses+0x88>
        if (pciDevice->Class == PCI_CLASS_BRIDGE && pciDevice->Subclass == PCI_SUBCLASS_BRIDGE_PCI) {
  8041610d49:	8b 43 24             	mov    0x24(%rbx),%eax
  8041610d4c:	25 00 ff ff 00       	and    $0xffff00,%eax
  8041610d51:	3d 00 06 04 00       	cmp    $0x40600,%eax
  8041610d56:	0f 84 33 ff ff ff    	je     8041610c8f <pci_check_busses+0x115>

        // If device is a different kind of bridge
        } else if (pciDevice->Class == PCI_CLASS_BRIDGE) {
  8041610d5c:	80 7b 25 06          	cmpb   $0x6,0x25(%rbx)
  8041610d60:	0f 85 75 ff ff ff    	jne    8041610cdb <pci_check_busses+0x161>
            cprintf("\e[91m  - Ignoring non-PCI bridge\e[0m\n");
  8041610d66:	48 bf c8 3e 61 41 80 	movabs $0x8041613ec8,%rdi
  8041610d6d:	00 00 00 
  8041610d70:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610d75:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610d7c:	00 00 00 
  8041610d7f:	ff d2                	call   *%rdx
  8041610d81:	e9 55 ff ff ff       	jmp    8041610cdb <pci_check_busses+0x161>
        }
    }
}
  8041610d86:	48 83 c4 18          	add    $0x18,%rsp
  8041610d8a:	5b                   	pop    %rbx
  8041610d8b:	41 5c                	pop    %r12
  8041610d8d:	41 5d                	pop    %r13
  8041610d8f:	41 5e                	pop    %r14
  8041610d91:	41 5f                	pop    %r15
  8041610d93:	5d                   	pop    %rbp
  8041610d94:	c3                   	ret    

0000008041610d95 <pci_device_lookup>:
        pciDevice = pciDevice->Next;
    }
}

pci_device_t *pci_device_lookup(uint8_t Class) {
    pci_device_t *pciDevice = PciDevices;
  8041610d95:	48 a1 28 5b 40 42 80 	movabs 0x8042405b28,%rax
  8041610d9c:	00 00 00 

    while (pciDevice != NULL) {
  8041610d9f:	48 85 c0             	test   %rax,%rax
  8041610da2:	74 0f                	je     8041610db3 <pci_device_lookup+0x1e>
        if (pciDevice->Class == Class)
  8041610da4:	40 38 78 25          	cmp    %dil,0x25(%rax)
  8041610da8:	74 09                	je     8041610db3 <pci_device_lookup+0x1e>
            return pciDevice;
        pciDevice = pciDevice->Next;
  8041610daa:	48 8b 40 08          	mov    0x8(%rax),%rax
    while (pciDevice != NULL) {
  8041610dae:	48 85 c0             	test   %rax,%rax
  8041610db1:	75 f1                	jne    8041610da4 <pci_device_lookup+0xf>
    }
    
    return NULL;
}
  8041610db3:	c3                   	ret    

0000008041610db4 <pci_init>:

void pci_init(void) {
  8041610db4:	55                   	push   %rbp
  8041610db5:	48 89 e5             	mov    %rsp,%rbp
  8041610db8:	41 57                	push   %r15
  8041610dba:	41 56                	push   %r14
  8041610dbc:	41 55                	push   %r13
  8041610dbe:	41 54                	push   %r12
  8041610dc0:	53                   	push   %rbx
  8041610dc1:	48 83 ec 08          	sub    $0x8,%rsp
	pci_check_busses(0, NULL);
  8041610dc5:	be 00 00 00 00       	mov    $0x0,%esi
  8041610dca:	bf 00 00 00 00       	mov    $0x0,%edi
  8041610dcf:	48 b8 7a 0b 61 41 80 	movabs $0x8041610b7a,%rax
  8041610dd6:	00 00 00 
  8041610dd9:	ff d0                	call   *%rax
    cprintf("PCI: Loading drivers for devices...\n");
  8041610ddb:	48 bf f0 3e 61 41 80 	movabs $0x8041613ef0,%rdi
  8041610de2:	00 00 00 
  8041610de5:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610dea:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610df1:	00 00 00 
  8041610df4:	ff d2                	call   *%rdx
    pci_device_t *pciDevice = PciDevices;
  8041610df6:	48 b8 28 5b 40 42 80 	movabs $0x8042405b28,%rax
  8041610dfd:	00 00 00 
  8041610e00:	4c 8b 20             	mov    (%rax),%r12
    while (pciDevice != NULL) {
  8041610e03:	4d 85 e4             	test   %r12,%r12
  8041610e06:	74 57                	je     8041610e5f <pci_init+0xab>
        pci_print_info(pciDevice);
  8041610e08:	49 bf 20 07 61 41 80 	movabs $0x8041610720,%r15
  8041610e0f:	00 00 00 
        while (PciDrivers[driverIndex].Initialize != NULL) {
  8041610e12:	49 be 22 0f 61 41 80 	movabs $0x8041610f22,%r14
  8041610e19:	00 00 00 
  8041610e1c:	49 bd 40 3f 61 41 80 	movabs $0x8041613f40,%r13
  8041610e23:	00 00 00 
  8041610e26:	eb 0a                	jmp    8041610e32 <pci_init+0x7e>
        pciDevice = pciDevice->Next;
  8041610e28:	4d 8b 64 24 08       	mov    0x8(%r12),%r12
    while (pciDevice != NULL) {
  8041610e2d:	4d 85 e4             	test   %r12,%r12
  8041610e30:	74 2d                	je     8041610e5f <pci_init+0xab>
        pci_print_info(pciDevice);
  8041610e32:	4c 89 e7             	mov    %r12,%rdi
  8041610e35:	41 ff d7             	call   *%r15
        uint16_t driverIndex = 0;
  8041610e38:	bb 00 00 00 00       	mov    $0x0,%ebx
        while (PciDrivers[driverIndex].Initialize != NULL) {
  8041610e3d:	4c 89 f0             	mov    %r14,%rax
            if (PciDrivers[driverIndex].Initialize(pciDevice))
  8041610e40:	4c 89 e7             	mov    %r12,%rdi
  8041610e43:	ff d0                	call   *%rax
  8041610e45:	84 c0                	test   %al,%al
  8041610e47:	75 df                	jne    8041610e28 <pci_init+0x74>
            driverIndex++;
  8041610e49:	83 c3 01             	add    $0x1,%ebx
        while (PciDrivers[driverIndex].Initialize != NULL) {
  8041610e4c:	0f b7 c3             	movzwl %bx,%eax
  8041610e4f:	48 c1 e0 04          	shl    $0x4,%rax
  8041610e53:	49 8b 44 05 08       	mov    0x8(%r13,%rax,1),%rax
  8041610e58:	48 85 c0             	test   %rax,%rax
  8041610e5b:	75 e3                	jne    8041610e40 <pci_init+0x8c>
  8041610e5d:	eb c9                	jmp    8041610e28 <pci_init+0x74>
    pci_load_drivers();
	//resetting color scheme
	cprintf("\e[37m");
  8041610e5f:	48 bf a3 3b 61 41 80 	movabs $0x8041613ba3,%rdi
  8041610e66:	00 00 00 
  8041610e69:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610e6e:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610e75:	00 00 00 
  8041610e78:	ff d2                	call   *%rdx
}
  8041610e7a:	48 83 c4 08          	add    $0x8,%rsp
  8041610e7e:	5b                   	pop    %rbx
  8041610e7f:	41 5c                	pop    %r12
  8041610e81:	41 5d                	pop    %r13
  8041610e83:	41 5e                	pop    %r14
  8041610e85:	41 5f                	pop    %r15
  8041610e87:	5d                   	pop    %rbp
  8041610e88:	c3                   	ret    

0000008041610e89 <BgaWriteRegister>:
    asm volatile("outw %0,%w1" ::"a"(data), "d"(port));
  8041610e89:	ba ce 01 00 00       	mov    $0x1ce,%edx
  8041610e8e:	89 f8                	mov    %edi,%eax
  8041610e90:	66 ef                	out    %ax,(%dx)
  8041610e92:	ba cf 01 00 00       	mov    $0x1cf,%edx
  8041610e97:	89 f0                	mov    %esi,%eax
  8041610e99:	66 ef                	out    %ax,(%dx)
FRAMEBUFFER_CONTEXT context;

void BgaWriteRegister(uint16_t IndexValue, uint16_t DataValue) {
    outw(VBE_DISPI_IOPORT_INDEX, IndexValue);
    outw(VBE_DISPI_IOPORT_DATA, DataValue);
}
  8041610e9b:	c3                   	ret    

0000008041610e9c <BgaSetVideoMode>:
 
void BgaSetVideoMode(unsigned int Width, unsigned int Height, unsigned int BitDepth, int UseLinearFrameBuffer, int ClearVideoMemory) {
  8041610e9c:	41 89 fb             	mov    %edi,%r11d
  8041610e9f:	41 89 f2             	mov    %esi,%r10d
  8041610ea2:	41 89 d1             	mov    %edx,%r9d
  8041610ea5:	89 cf                	mov    %ecx,%edi
  8041610ea7:	be ce 01 00 00       	mov    $0x1ce,%esi
  8041610eac:	b8 04 00 00 00       	mov    $0x4,%eax
  8041610eb1:	89 f2                	mov    %esi,%edx
  8041610eb3:	66 ef                	out    %ax,(%dx)
  8041610eb5:	b9 cf 01 00 00       	mov    $0x1cf,%ecx
  8041610eba:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610ebf:	89 ca                	mov    %ecx,%edx
  8041610ec1:	66 ef                	out    %ax,(%dx)
  8041610ec3:	b8 01 00 00 00       	mov    $0x1,%eax
  8041610ec8:	89 f2                	mov    %esi,%edx
  8041610eca:	66 ef                	out    %ax,(%dx)
  8041610ecc:	44 89 d8             	mov    %r11d,%eax
  8041610ecf:	89 ca                	mov    %ecx,%edx
  8041610ed1:	66 ef                	out    %ax,(%dx)
  8041610ed3:	b8 02 00 00 00       	mov    $0x2,%eax
  8041610ed8:	89 f2                	mov    %esi,%edx
  8041610eda:	66 ef                	out    %ax,(%dx)
  8041610edc:	44 89 d0             	mov    %r10d,%eax
  8041610edf:	89 ca                	mov    %ecx,%edx
  8041610ee1:	66 ef                	out    %ax,(%dx)
  8041610ee3:	b8 03 00 00 00       	mov    $0x3,%eax
  8041610ee8:	89 f2                	mov    %esi,%edx
  8041610eea:	66 ef                	out    %ax,(%dx)
  8041610eec:	44 89 c8             	mov    %r9d,%eax
  8041610eef:	89 ca                	mov    %ecx,%edx
  8041610ef1:	66 ef                	out    %ax,(%dx)
    BgaWriteRegister(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_DISABLED);
    BgaWriteRegister(VBE_DISPI_INDEX_XRES, Width);
    BgaWriteRegister(VBE_DISPI_INDEX_YRES, Height);
    BgaWriteRegister(VBE_DISPI_INDEX_BPP, BitDepth);
    BgaWriteRegister(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED |
        (UseLinearFrameBuffer ? VBE_DISPI_LFB_ENABLED : 0) |
  8041610ef3:	83 ff 01             	cmp    $0x1,%edi
  8041610ef6:	19 c9                	sbb    %ecx,%ecx
  8041610ef8:	83 e1 c0             	and    $0xffffffc0,%ecx
  8041610efb:	83 c1 41             	add    $0x41,%ecx
  8041610efe:	45 85 c0             	test   %r8d,%r8d
  8041610f01:	0f 94 c0             	sete   %al
  8041610f04:	0f b6 f0             	movzbl %al,%esi
  8041610f07:	c1 e6 07             	shl    $0x7,%esi
  8041610f0a:	b8 04 00 00 00       	mov    $0x4,%eax
  8041610f0f:	ba ce 01 00 00       	mov    $0x1ce,%edx
  8041610f14:	66 ef                	out    %ax,(%dx)
  8041610f16:	89 c8                	mov    %ecx,%eax
  8041610f18:	09 f0                	or     %esi,%eax
  8041610f1a:	ba cf 01 00 00       	mov    $0x1cf,%edx
  8041610f1f:	66 ef                	out    %ax,(%dx)
        (ClearVideoMemory ? 0 : VBE_DISPI_NOCLEARMEM));
}
  8041610f21:	c3                   	ret    

0000008041610f22 <vga_init>:
 * sets up vsyscall for display paremetres
 *
 * maps size of 2 displays to user space (for double buffering)
 */
bool vga_init(pci_device_t *pciDevice) {
    if (pciDevice->Class != PCI_CLASS_DISPLAY || pciDevice->Subclass != PCI_SUBCLASS_DISPLAY_VGA)
  8041610f22:	8b 47 24             	mov    0x24(%rdi),%eax
  8041610f25:	25 00 ff ff 00       	and    $0xffff00,%eax
        return false;
  8041610f2a:	ba 00 00 00 00       	mov    $0x0,%edx
    if (pciDevice->Class != PCI_CLASS_DISPLAY || pciDevice->Subclass != PCI_SUBCLASS_DISPLAY_VGA)
  8041610f2f:	3d 00 03 00 00       	cmp    $0x300,%eax
  8041610f34:	74 03                	je     8041610f39 <vga_init+0x17>
    BgaSetVideoMode(context.width, context.height, context.bits_per_pixel, 1, 1); 
    
    display_is_initialized = true;
	cprintf("VGA Initialized\n"); 
    return display_is_initialized;
}
  8041610f36:	89 d0                	mov    %edx,%eax
  8041610f38:	c3                   	ret    
bool vga_init(pci_device_t *pciDevice) {
  8041610f39:	55                   	push   %rbp
  8041610f3a:	48 89 e5             	mov    %rsp,%rbp
  8041610f3d:	41 54                	push   %r12
  8041610f3f:	53                   	push   %rbx
  8041610f40:	48 89 fb             	mov    %rdi,%rbx
    cprintf("Initializing VGA...\n");
  8041610f43:	48 bf 60 3f 61 41 80 	movabs $0x8041613f60,%rdi
  8041610f4a:	00 00 00 
  8041610f4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610f52:	48 ba 99 c8 60 41 80 	movabs $0x804160c899,%rdx
  8041610f59:	00 00 00 
  8041610f5c:	ff d2                	call   *%rdx
    pci_enable_palette_snoop(pciDevice);
  8041610f5e:	48 89 df             	mov    %rbx,%rdi
  8041610f61:	48 b8 53 08 61 41 80 	movabs $0x8041610853,%rax
  8041610f68:	00 00 00 
  8041610f6b:	ff d0                	call   *%rax
    if (!display_addr) {
  8041610f6d:	48 b8 70 5b 40 42 80 	movabs $0x8042405b70,%rax
  8041610f74:	00 00 00 
  8041610f77:	48 83 38 00          	cmpq   $0x0,(%rax)
  8041610f7b:	0f 84 b3 00 00 00    	je     8041611034 <vga_init+0x112>
    cprintf("Display addr: %p\n", display_addr); 
  8041610f81:	49 bc 70 5b 40 42 80 	movabs $0x8042405b70,%r12
  8041610f88:	00 00 00 
  8041610f8b:	49 8b 34 24          	mov    (%r12),%rsi
  8041610f8f:	48 bf 75 3f 61 41 80 	movabs $0x8041613f75,%rdi
  8041610f96:	00 00 00 
  8041610f99:	b8 00 00 00 00       	mov    $0x0,%eax
  8041610f9e:	48 bb 99 c8 60 41 80 	movabs $0x804160c899,%rbx
  8041610fa5:	00 00 00 
  8041610fa8:	ff d3                	call   *%rbx
    context.width = uefi_lp->HorizontalResolution;
  8041610faa:	48 a1 00 40 63 41 80 	movabs 0x8041634000,%rax
  8041610fb1:	00 00 00 
  8041610fb4:	8b 78 54             	mov    0x54(%rax),%edi
  8041610fb7:	48 ba 40 5b 40 42 80 	movabs $0x8042405b40,%rdx
  8041610fbe:	00 00 00 
  8041610fc1:	89 3a                	mov    %edi,(%rdx)
    context.height = uefi_lp->VerticalResolution;
  8041610fc3:	8b 70 50             	mov    0x50(%rax),%esi
  8041610fc6:	89 72 04             	mov    %esi,0x4(%rdx)
    context.bits_per_pixel = 32;
  8041610fc9:	c7 42 0c 20 00 00 00 	movl   $0x20,0xc(%rdx)
    context.size = context.width * context.height * (context.bits_per_pixel / 8);
  8041610fd0:	89 f8                	mov    %edi,%eax
  8041610fd2:	0f af c6             	imul   %esi,%eax
  8041610fd5:	c1 e0 02             	shl    $0x2,%eax
  8041610fd8:	89 42 10             	mov    %eax,0x10(%rdx)
    context.front = display_addr;
  8041610fdb:	49 8b 0c 24          	mov    (%r12),%rcx
  8041610fdf:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
    context.back = context.front + context.size;
  8041610fe3:	89 c0                	mov    %eax,%eax
  8041610fe5:	48 01 c8             	add    %rcx,%rax
  8041610fe8:	48 89 42 20          	mov    %rax,0x20(%rdx)
    BgaSetVideoMode(context.width, context.height, context.bits_per_pixel, 1, 1); 
  8041610fec:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8041610ff2:	b9 01 00 00 00       	mov    $0x1,%ecx
  8041610ff7:	ba 20 00 00 00       	mov    $0x20,%edx
  8041610ffc:	48 b8 9c 0e 61 41 80 	movabs $0x8041610e9c,%rax
  8041611003:	00 00 00 
  8041611006:	ff d0                	call   *%rax
    display_is_initialized = true;
  8041611008:	49 bc 68 5b 40 42 80 	movabs $0x8042405b68,%r12
  804161100f:	00 00 00 
  8041611012:	41 c6 04 24 01       	movb   $0x1,(%r12)
	cprintf("VGA Initialized\n"); 
  8041611017:	48 bf 87 3f 61 41 80 	movabs $0x8041613f87,%rdi
  804161101e:	00 00 00 
  8041611021:	b8 00 00 00 00       	mov    $0x0,%eax
  8041611026:	ff d3                	call   *%rbx
    return display_is_initialized;
  8041611028:	41 0f b6 14 24       	movzbl (%r12),%edx
}
  804161102d:	89 d0                	mov    %edx,%eax
  804161102f:	5b                   	pop    %rbx
  8041611030:	41 5c                	pop    %r12
  8041611032:	5d                   	pop    %rbp
  8041611033:	c3                   	ret    
        display_addr = mmio_map_region(pciDevice->BaseAddresses[0].BaseAddress, pciDevice->BaseAddresses[0].Size);
  8041611034:	48 8b 73 38          	mov    0x38(%rbx),%rsi
  8041611038:	8b 7b 34             	mov    0x34(%rbx),%edi
  804161103b:	48 b8 72 a6 60 41 80 	movabs $0x804160a672,%rax
  8041611042:	00 00 00 
  8041611045:	ff d0                	call   *%rax
  8041611047:	48 a3 70 5b 40 42 80 	movabs %rax,0x8042405b70
  804161104e:	00 00 00 
  8041611051:	e9 2b ff ff ff       	jmp    8041610f81 <vga_init+0x5f>

0000008041611056 <vsyscall_init>:
#include <inc/vsyscall.h>
#include <kern/vsyscall.h>
#include <kern/vga.h>

void vsyscall_init(void) {
    vsys[VSYS_getframebuffer_width] = context.width;
  8041611056:	48 ba 40 44 40 42 80 	movabs $0x8042404440,%rdx
  804161105d:	00 00 00 
  8041611060:	48 8b 0a             	mov    (%rdx),%rcx
  8041611063:	48 b8 40 5b 40 42 80 	movabs $0x8042405b40,%rax
  804161106a:	00 00 00 
  804161106d:	8b 30                	mov    (%rax),%esi
  804161106f:	89 71 04             	mov    %esi,0x4(%rcx)
    vsys[VSYS_getframebuffer_height] = context.height;
  8041611072:	48 8b 12             	mov    (%rdx),%rdx
  8041611075:	8b 48 04             	mov    0x4(%rax),%ecx
  8041611078:	89 4a 08             	mov    %ecx,0x8(%rdx)
    vsys[VSYS_getframebuffer_bpp] = context.bits_per_pixel;
  804161107b:	8b 40 0c             	mov    0xc(%rax),%eax
  804161107e:	89 42 0c             	mov    %eax,0xc(%rdx)
}
  8041611081:	c3                   	ret    

0000008041611082 <__spin_initlock>:
}
#endif

void
__spin_initlock(struct spinlock *lk, char *name) {
    lk->locked = 0;
  8041611082:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
#if trace_spinlock
    lk->name = name;
#endif
}
  8041611088:	c3                   	ret    

0000008041611089 <spin_lock>:
    uint32_t result = __atomic_exchange_n(addr, newval, __ATOMIC_ACQ_REL);
  8041611089:	ba 01 00 00 00       	mov    $0x1,%edx
#endif

    /* The xchg is atomic.
     * It also serializes, so that reads after acquire are not
     * reordered before it. */
    while (xchg(&lk->locked, 1)) asm volatile("pause");
  804161108e:	eb 02                	jmp    8041611092 <spin_lock+0x9>
  8041611090:	f3 90                	pause  
  8041611092:	89 d0                	mov    %edx,%eax
  8041611094:	87 07                	xchg   %eax,(%rdi)
  8041611096:	85 c0                	test   %eax,%eax
  8041611098:	75 f6                	jne    8041611090 <spin_lock+0x7>

        /* Record info about lock acquisition for debugging. */
#if trace_spinlock
    get_caller_pcs(lk->pcs);
#endif
}
  804161109a:	c3                   	ret    

000000804161109b <spin_unlock>:
  804161109b:	b8 00 00 00 00       	mov    $0x0,%eax
  80416110a0:	87 07                	xchg   %eax,(%rdi)
     * Paper says that Intel 64 and IA-32 will not move a load
     * after a store. So lock->locked = 0 would work here.
     * The xchg being asm volatile ensures gcc emits it after
     * the above assignments (and after the critical section). */
    xchg(&lk->locked, 0);
}
  80416110a2:	c3                   	ret    
  80416110a3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000080416110a8 <__rodata_start>:
  80416110a8:	49 6e                	rex.WB outsb %ds:(%rsi),(%dx)
  80416110aa:	69 74 69 61 6c 69 7a 	imul   $0x657a696c,0x61(%rcx,%rbp,2),%esi
  80416110b1:	65 
  80416110b2:	64 20 74 69 6d       	and    %dh,%fs:0x6d(%rcx,%rbp,2)
  80416110b7:	65 72 20             	gs jb  80416110da <__rodata_start+0x32>
  80416110ba:	25 73 0a 00 6b       	and    $0x6b000a73,%eax
  80416110bf:	65 72 6e             	gs jb  8041611130 <__rodata_start+0x88>
  80416110c2:	65 6c                	gs insb (%dx),%es:(%rdi)
  80416110c4:	20 70 61             	and    %dh,0x61(%rax)
  80416110c7:	6e                   	outsb  %ds:(%rsi),(%dx)
  80416110c8:	69 63 20 61 74 20 25 	imul   $0x25207461,0x20(%rbx),%esp
  80416110cf:	73 3a                	jae    804161110b <__rodata_start+0x63>
  80416110d1:	25 64 3a 20 00       	and    $0x203a64,%eax
  80416110d6:	6b 65 72 6e          	imul   $0x6e,0x72(%rbp),%esp
  80416110da:	2f                   	(bad)  
  80416110db:	69 6e 69 74 2e 63 00 	imul   $0x632e74,0x69(%rsi),%ebp
  80416110e2:	54                   	push   %rsp
  80416110e3:	69 6d 65 72 20 25 73 	imul   $0x73252072,0x65(%rbp),%ebp
  80416110ea:	20 64 6f 65          	and    %ah,0x65(%rdi,%rbp,2)
  80416110ee:	73 20                	jae    8041611110 <__rodata_start+0x68>
  80416110f0:	6e                   	outsb  %ds:(%rsi),(%dx)
  80416110f1:	6f                   	outsl  %ds:(%rsi),(%dx)
  80416110f2:	74 20                	je     8041611114 <__rodata_start+0x6c>
  80416110f4:	65 78 69             	gs js  8041611160 <__rodata_start+0xb8>
  80416110f7:	73 74                	jae    804161116d <__rodata_start+0xc5>
  80416110f9:	0a 00                	or     (%rax),%al
  80416110fb:	36 38 32             	ss cmp %dh,(%rdx)
  80416110fe:	38 20                	cmp    %ah,(%rax)
  8041611100:	64 65 63 69 6d       	fs movsxd %gs:0x6d(%rcx),%ebp
  8041611105:	61                   	(bad)  
  8041611106:	6c                   	insb   (%dx),%es:(%rdi)
  8041611107:	20 69 73             	and    %ch,0x73(%rcx)
  804161110a:	20 25 6f 20 6f 63    	and    %ah,0x636f206f(%rip)        # 80a4d0317f <__bss_end+0x628fd17f>
  8041611110:	74 61                	je     8041611173 <__rodata_start+0xcb>
  8041611112:	6c                   	insb   (%dx),%es:(%rdi)
  8041611113:	21 0a                	and    %ecx,(%rdx)
  8041611115:	00 45 4e             	add    %al,0x4e(%rbp)
  8041611118:	44 3a 20             	cmp    (%rax),%r12b
  804161111b:	25 70 0a 00 46       	and    $0x46000a70,%eax
  8041611120:	72 61                	jb     8041611183 <__rodata_start+0xdb>
  8041611122:	6d                   	insl   (%dx),%es:(%rdi)
  8041611123:	65 62                	gs (bad) 
  8041611125:	75 66                	jne    804161118d <__rodata_start+0xe5>
  8041611127:	66 65 72 20          	data16 gs jb 804161114b <__rodata_start+0xa3>
  804161112b:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
  8041611132:	69 73 65 64 0a 00 68 	imul   $0x68000a64,0x65(%rbx),%esi
  8041611139:	70 65                	jo     80416111a0 <__rodata_start+0xf8>
  804161113b:	74 30                	je     804161116d <__rodata_start+0xc5>
  804161113d:	00 6b 65             	add    %ch,0x65(%rbx)
  8041611140:	72 6e                	jb     80416111b0 <__rodata_start+0x108>
  8041611142:	65 6c                	gs insb (%dx),%es:(%rdi)
  8041611144:	20 77 61             	and    %dh,0x61(%rdi)
  8041611147:	72 6e                	jb     80416111b7 <__rodata_start+0x10f>
  8041611149:	69 6e 67 20 61 74 20 	imul   $0x20746120,0x67(%rsi),%ebp
  8041611150:	25 73 3a 25 64       	and    $0x64253a73,%eax
  8041611155:	3a 20                	cmp    (%rax),%ah
  8041611157:	00 54 69 6d          	add    %dl,0x6d(%rcx,%rbp,2)
  804161115b:	65 72 20             	gs jb  804161117e <__rodata_start+0xd6>
  804161115e:	25 73 20 64 6f       	and    $0x6f642073,%eax
  8041611163:	65 73 20             	gs jae 8041611186 <__rodata_start+0xde>
  8041611166:	6e                   	outsb  %ds:(%rsi),(%dx)
  8041611167:	6f                   	outsl  %ds:(%rsi),(%dx)
  8041611168:	74 20                	je     804161118a <__rodata_start+0xe2>
  804161116a:	73 75                	jae    80416111e1 <togglecode+0x1>
  804161116c:	70 70                	jo     80416111de <charcode+0x1e>
  804161116e:	6f                   	outsl  %ds:(%rsi),(%dx)
  804161116f:	72 74                	jb     80416111e5 <togglecode+0x5>
  8041611171:	20 69 6e             	and    %ch,0x6e(%rcx)
  8041611174:	74 65                	je     80416111db <charcode+0x1b>
  8041611176:	72 72                	jb     80416111ea <togglecode+0xa>
  8041611178:	75 70                	jne    80416111ea <togglecode+0xa>
  804161117a:	74 73                	je     80416111ef <togglecode+0xf>
  804161117c:	0a 00                	or     (%rax),%al
  804161117e:	52                   	push   %rdx
  804161117f:	65 62                	gs (bad) 
  8041611181:	6f                   	outsl  %ds:(%rsi),(%dx)
  8041611182:	6f                   	outsl  %ds:(%rsi),(%dx)
  8041611183:	74 69                	je     80416111ee <togglecode+0xe>
  8041611185:	6e                   	outsb  %ds:(%rsi),(%dx)
  8041611186:	67 21 0a             	and    %ecx,(%edx)
  8041611189:	00 53 65             	add    %dl,0x65(%rbx)
  804161118c:	72 69                	jb     80416111f7 <togglecode+0x17>
  804161118e:	61                   	(bad)  
  804161118f:	6c                   	insb   (%dx),%es:(%rdi)
  8041611190:	20 70 6f             	and    %dh,0x6f(%rax)
  8041611193:	72 74                	jb     8041611209 <togglecode+0x29>
  8041611195:	20 64 6f 65          	and    %ah,0x65(%rdi,%rbp,2)
  8041611199:	73 20                	jae    80416111bb <__rodata_start+0x113>
  804161119b:	6e                   	outsb  %ds:(%rsi),(%dx)
  804161119c:	6f                   	outsl  %ds:(%rsi),(%dx)
  804161119d:	74 20                	je     80416111bf <__rodata_start+0x117>
  804161119f:	65 78 69             	gs js  804161120b <togglecode+0x2b>
  80416111a2:	73 74                	jae    8041611218 <togglecode+0x38>
  80416111a4:	21 0a                	and    %ecx,(%rdx)
  80416111a6:	00 66 2e             	add    %ah,0x2e(%rsi)
  80416111a9:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  80416111b0:	00 
  80416111b1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
  80416111b8:	00 00 00 
  80416111bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000080416111c0 <charcode>:
  80416111c0:	20 42 63 41 80 00 00 00 20 41 63 41 80 00 00 00      BcA.... AcA....
  80416111d0:	20 40 63 41 80 00 00 00 20 40 63 41 80 00 00 00      @cA.... @cA....

00000080416111e0 <togglecode>:
	...
  8041611218:	00 00 08 00 00 00 00 00 00 00 00 00 00 10 20 00     .............. .
	...

00000080416112e0 <shiftcode>:
	...
  80416112fc:	00 02 00 00 00 00 00 00 00 00 00 00 00 00 01 00     ................
	...
  8041611314:	00 00 01 00 04 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  804161137c:	00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  8041611398:	04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  80416113e0:	55 6e 6b 6e 6f 77 6e 20 44 57 41 52 46 20 65 78     Unknown DWARF ex
  80416113f0:	74 65 6e 73 69 6f 6e 0a 00 76 65 72 73 69 6f 6e     tension..version
  8041611400:	20 3d 3d 20 34 20 7c 7c 20 76 65 72 73 69 6f 6e      == 4 || version
  8041611410:	20 3d 3d 20 32 00 61 73 73 65 72 74 69 6f 6e 20      == 2.assertion 
  8041611420:	66 61 69 6c 65 64 3a 20 25 73 00 6b 65 72 6e 2f     failed: %s.kern/
  8041611430:	64 77 61 72 66 2e 63 00 61 62 62 72 65 76 5f 63     dwarf.c.abbrev_c
  8041611440:	6f 64 65 00 74 61 67 20 3d 3d 20 44 57 5f 54 41     ode.tag == DW_TA
  8041611450:	47 5f 63 6f 6d 70 69 6c 65 5f 75 6e 69 74 00 90     G_compile_unit..
  8041611460:	b4 17 60 41 80 00 00 00 76 0d 60 41 80 00 00 00     ..`A....v.`A....
  8041611470:	b4 17 60 41 80 00 00 00 cd 0d 60 41 80 00 00 00     ..`A......`A....
  8041611480:	22 0e 60 41 80 00 00 00 76 0e 60 41 80 00 00 00     ".`A....v.`A....
  8041611490:	cb 0e 60 41 80 00 00 00 20 0f 60 41 80 00 00 00     ..`A.... .`A....
  80416114a0:	75 0f 60 41 80 00 00 00 b1 0f 60 41 80 00 00 00     u.`A......`A....
  80416114b0:	42 10 60 41 80 00 00 00 97 10 60 41 80 00 00 00     B.`A......`A....
  80416114c0:	d4 10 60 41 80 00 00 00 14 11 60 41 80 00 00 00     ..`A......`A....
  80416114d0:	bb 11 60 41 80 00 00 00 79 12 60 41 80 00 00 00     ..`A....y.`A....
  80416114e0:	08 13 60 41 80 00 00 00 c6 13 60 41 80 00 00 00     ..`A......`A....
  80416114f0:	03 14 60 41 80 00 00 00 58 14 60 41 80 00 00 00     ..`A....X.`A....
  8041611500:	ad 14 60 41 80 00 00 00 02 15 60 41 80 00 00 00     ..`A......`A....
  8041611510:	91 15 60 41 80 00 00 00 11 16 60 41 80 00 00 00     ..`A......`A....
  8041611520:	cf 16 60 41 80 00 00 00 56 17 60 41 80 00 00 00     ..`A....V.`A....
  8041611530:	b4 17 60 41 80 00 00 00 b4 17 60 41 80 00 00 00     ..`A......`A....
  8041611540:	b4 17 60 41 80 00 00 00 b4 17 60 41 80 00 00 00     ..`A......`A....
  8041611550:	b4 17 60 41 80 00 00 00 b4 17 60 41 80 00 00 00     ..`A......`A....
  8041611560:	65 17 60 41 80 00 00 00 61 64 64 72 65 73 73 5f     e.`A....address_
  8041611570:	73 69 7a 65 20 3d 3d 20 73 69 7a 65 6f 66 28 75     size == sizeof(u
  8041611580:	69 6e 74 70 74 72 5f 74 29 00 00 00 00 00 00 00     intptr_t).......
  8041611590:	74 61 62 6c 65 5f 61 62 62 72 65 76 5f 63 6f 64     table_abbrev_cod
  80416115a0:	65 20 3d 3d 20 61 62 62 72 65 76 5f 63 6f 64 65     e == abbrev_code
  80416115b0:	00 6b 65 72 6e 2f 64 77 61 72 66 5f 6c 69 6e 65     .kern/dwarf_line
  80416115c0:	73 2e 63 00 55 6e 6b 6e 6f 77 6e 20 6f 70 63 6f     s.c.Unknown opco
  80416115d0:	64 65 3a 20 25 78 00 70 72 6f 67 72 61 6d 5f 61     de: %x.program_a
  80416115e0:	64 64 72 20 3d 3d 20 6f 70 63 6f 64 65 5f 65 6e     ddr == opcode_en
  80416115f0:	64 00 66 0f 1f 44 00 00 76 65 72 73 69 6f 6e 20     d.f..D..version 
  8041611600:	3d 3d 20 34 20 7c 7c 20 76 65 72 73 69 6f 6e 20     == 4 || version 
  8041611610:	3d 3d 20 33 20 7c 7c 20 76 65 72 73 69 6f 6e 20     == 3 || version 
  8041611620:	3d 3d 20 32 00 00 00 00 6d 69 6e 69 6d 75 6d 5f     == 2....minimum_
  8041611630:	69 6e 73 74 72 75 63 74 69 6f 6e 5f 6c 65 6e 67     instruction_leng
  8041611640:	74 68 20 3d 3d 20 31 00 6d 61 78 69 6d 75 6d 5f     th == 1.maximum_
  8041611650:	6f 70 65 72 61 74 69 6f 6e 73 5f 70 65 72 5f 69     operations_per_i
  8041611660:	6e 73 74 72 75 63 74 69 6f 6e 20 3d 3d 20 31 00     nstruction == 1.
  8041611670:	de 3e 60 41 80 00 00 00 b2 3c 60 41 80 00 00 00     .>`A.....<`A....
  8041611680:	de 3c 60 41 80 00 00 00 41 3d 60 41 80 00 00 00     .<`A....A=`A....
  8041611690:	bd 3d 60 41 80 00 00 00 0e 3e 60 41 80 00 00 00     .=`A.....>`A....
  80416116a0:	88 3f 60 41 80 00 00 00 88 3f 60 41 80 00 00 00     .?`A.....?`A....
  80416116b0:	5f 3e 60 41 80 00 00 00 74 3e 60 41 80 00 00 00     _>`A....t>`A....
  80416116c0:	88 3f 60 41 80 00 00 00 88 3f 60 41 80 00 00 00     .?`A.....?`A....
  80416116d0:	90 3e 60 41 80 00 00 00 50 72 69 6e 74 69 6e 67     .>`A....Printing
  80416116e0:	20 6a 75 6e 6b 0a 00 25 73 20 2d 20 25 73 0a 00      junk..%s - %s..
  80416116f0:	53 70 65 63 69 61 6c 20 6b 65 72 6e 65 6c 20 73     Special kernel s
  8041611700:	79 6d 62 6f 6c 73 3a 0a 00 53 74 61 63 6b 20 74     ymbols:..Stack t
  8041611710:	72 61 63 65 3a 0a 00 20 72 62 70 20 25 30 31 36     race:.. rbp %016
  8041611720:	6c 78 20 72 69 70 20 25 30 31 36 6c 78 0a 00 20     lx rip %016lx.. 
  8041611730:	20 20 25 73 3a 25 64 3a 20 25 73 2b 25 6c 64 0a       %s:%d: %s+%ld.
  8041611740:	00 25 30 32 78 3a 20 00 25 30 32 78 20 00 57 72     .%02x: .%02x .Wr
  8041611750:	6f 6e 67 20 6e 75 6d 62 65 72 20 6f 66 20 61 72     ong number of ar
  8041611760:	67 75 6d 65 6e 74 73 0a 00 4b 3e 20 00 09 0d 0a     guments..K> ....
  8041611770:	20 00 54 6f 6f 20 6d 61 6e 79 20 61 72 67 75 6d      .Too many argum
  8041611780:	65 6e 74 73 20 28 6d 61 78 20 25 64 29 0a 00 55     ents (max %d)..U
  8041611790:	6e 6b 6e 6f 77 6e 20 63 6f 6d 6d 61 6e 64 20 27     nknown command '
  80416117a0:	25 73 27 0a 00 68 65 6c 70 00 44 69 73 70 6c 61     %s'..help.Displa
  80416117b0:	79 20 74 68 69 73 20 6c 69 73 74 20 6f 66 20 63     y this list of c
  80416117c0:	6f 6d 6d 61 6e 64 73 00 6b 65 72 6e 69 6e 66 6f     ommands.kerninfo
  80416117d0:	00 50 72 69 6e 74 20 73 74 61 63 6b 20 62 61 63     .Print stack bac
  80416117e0:	6b 74 72 61 63 65 00 50 72 69 6e 74 20 6a 75 6e     ktrace.Print jun
  80416117f0:	6b 00 64 75 6d 70 63 6d 6f 73 00 50 72 69 6e 74     k.dumpcmos.Print
  8041611800:	20 43 4d 4f 53 20 63 6f 6e 74 65 6e 74 73 00 73      CMOS contents.s
  8041611810:	74 61 72 74 00 53 74 61 72 74 20 74 69 6d 65 72     tart.Start timer
  8041611820:	20 3c 68 70 65 74 2c 74 73 63 2e 3e 00 73 74 6f      <hpet,tsc.>.sto
  8041611830:	70 00 53 74 6f 70 20 74 69 6d 65 72 00 66 72 65     p.Stop timer.fre
  8041611840:	71 75 65 6e 63 79 00 44 75 6d 70 20 6d 65 6d 6f     quency.Dump memo
  8041611850:	72 79 20 6c 69 73 74 00 61 6c 6c 6f 63 5f 61 6c     ry list.alloc_al
  8041611860:	6c 00 66 72 65 65 5f 6c 61 73 74 00 54 65 73 74     l.free_last.Test
  8041611870:	20 74 68 61 74 20 66 72 65 65 73 20 6c 61 73 74      that frees last
  8041611880:	20 70 61 67 65 00 76 69 72 74 00 44 75 6d 70 20      page.virt.Dump 
  8041611890:	76 69 72 74 75 61 6c 20 74 72 65 65 00 70 61 67     virtual tree.pag
  80416118a0:	65 74 61 62 6c 65 00 44 75 6d 70 20 70 61 67 65     etable.Dump page
  80416118b0:	20 74 61 62 6c 65 00 90 20 20 5f 68 65 61 64 36      table..  _head6
  80416118c0:	34 20 25 31 36 6c 78 20 28 76 69 72 74 29 20 20     4 %16lx (virt)  
  80416118d0:	25 31 36 6c 78 20 28 70 68 79 73 29 0a 00 00 00     %16lx (phys)....
  80416118e0:	20 20 65 6e 74 72 79 20 20 20 25 31 36 6c 78 20       entry   %16lx 
  80416118f0:	28 76 69 72 74 29 20 20 25 31 36 6c 78 20 28 70     (virt)  %16lx (p
  8041611900:	68 79 73 29 0a 00 00 00 20 20 65 74 65 78 74 20     hys)....  etext 
  8041611910:	20 20 25 31 36 6c 78 20 28 76 69 72 74 29 20 20       %16lx (virt)  
  8041611920:	25 31 36 6c 78 20 28 70 68 79 73 29 0a 00 00 00     %16lx (phys)....
  8041611930:	20 20 65 64 61 74 61 20 20 20 25 31 36 6c 78 20       edata   %16lx 
  8041611940:	28 76 69 72 74 29 20 20 25 31 36 6c 78 20 28 70     (virt)  %16lx (p
  8041611950:	68 79 73 29 0a 00 00 00 20 20 65 6e 64 20 20 20     hys)....  end   
  8041611960:	20 20 25 31 36 6c 78 20 28 76 69 72 74 29 20 20       %16lx (virt)  
  8041611970:	25 31 36 6c 78 20 28 70 68 79 73 29 0a 00 00 00     %16lx (phys)....
  8041611980:	4b 65 72 6e 65 6c 20 65 78 65 63 75 74 61 62 6c     Kernel executabl
  8041611990:	65 20 6d 65 6d 6f 72 79 20 66 6f 6f 74 70 72 69     e memory footpri
  80416119a0:	6e 74 3a 20 25 6c 75 4b 42 0a 00 00 00 00 00 00     nt: %luKB.......
  80416119b0:	57 65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20 4a     Welcome to the J
  80416119c0:	4f 53 20 6b 65 72 6e 65 6c 20 6d 6f 6e 69 74 6f     OS kernel monito
  80416119d0:	72 21 0a 00 00 00 00 00 54 79 70 65 20 27 68 65     r!......Type 'he
  80416119e0:	6c 70 27 20 66 6f 72 20 61 20 6c 69 73 74 20 6f     lp' for a list o
  80416119f0:	66 20 63 6f 6d 6d 61 6e 64 73 2e 0a 00 00 00 00     f commands......
  8041611a00:	44 69 73 70 6c 61 79 20 69 6e 66 6f 72 6d 61 74     Display informat
  8041611a10:	69 6f 6e 20 61 62 6f 75 74 20 74 68 65 20 6b 65     ion about the ke
  8041611a20:	72 6e 65 6c 00 00 00 00 47 65 74 20 63 70 75 20     rnel....Get cpu 
  8041611a30:	66 72 65 71 75 65 6e 63 79 20 74 69 6d 65 72 20     frequency timer 
  8041611a40:	3c 68 70 65 74 2c 20 74 73 63 3e 00 00 00 00 00     <hpet, tsc>.....
  8041611a50:	54 65 73 74 20 74 68 65 74 20 61 6c 6c 6f 63 61     Test thet alloca
  8041611a60:	74 65 73 20 61 6c 6c 20 6d 65 6d 6f 72 79 2e 20     tes all memory. 
  8041611a70:	55 73 61 67 65 20 61 6c 6c 6f 63 20 3c 63 6c 61     Usage alloc <cla
  8041611a80:	73 73 3e 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ss>.f.........f.
  8041611a90:	0f 1f 84 00 00 00 00 00 0f 1f 84 00 00 00 00 00     ................

0000008041611aa0 <commands>:
  8041611aa0:	a5 17 61 41 80 00 00 00 aa 17 61 41 80 00 00 00     ..aA......aA....
  8041611ab0:	75 41 60 41 80 00 00 00 c8 17 61 41 80 00 00 00     uA`A......aA....
  8041611ac0:	00 1a 61 41 80 00 00 00 cf 41 60 41 80 00 00 00     ..aA.....A`A....
  8041611ad0:	dd 17 61 41 80 00 00 00 d1 17 61 41 80 00 00 00     ..aA......aA....
  8041611ae0:	e5 42 60 41 80 00 00 00 ed 17 61 41 80 00 00 00     .B`A......aA....
  8041611af0:	e7 17 61 41 80 00 00 00 4f 41 60 41 80 00 00 00     ..aA....OA`A....
  8041611b00:	f2 17 61 41 80 00 00 00 fb 17 61 41 80 00 00 00     ..aA......aA....
  8041611b10:	c0 43 60 41 80 00 00 00 0f 18 61 41 80 00 00 00     .C`A......aA....
  8041611b20:	15 18 61 41 80 00 00 00 79 44 60 41 80 00 00 00     ..aA....yD`A....
  8041611b30:	2d 18 61 41 80 00 00 00 32 18 61 41 80 00 00 00     -.aA....2.aA....
  8041611b40:	bb 44 60 41 80 00 00 00 3d 18 61 41 80 00 00 00     .D`A....=.aA....
  8041611b50:	28 1a 61 41 80 00 00 00 d2 44 60 41 80 00 00 00     (.aA.....D`A....
  8041611b60:	4c 36 61 41 80 00 00 00 47 18 61 41 80 00 00 00     L6aA....G.aA....
  8041611b70:	14 45 60 41 80 00 00 00 58 18 61 41 80 00 00 00     .E`A....X.aA....
  8041611b80:	50 1a 61 41 80 00 00 00 2b 45 60 41 80 00 00 00     P.aA....+E`A....
  8041611b90:	62 18 61 41 80 00 00 00 6c 18 61 41 80 00 00 00     b.aA....l.aA....
  8041611ba0:	4c 45 60 41 80 00 00 00 86 18 61 41 80 00 00 00     LE`A......aA....
  8041611bb0:	8b 18 61 41 80 00 00 00 87 45 60 41 80 00 00 00     ..aA.....E`A....
  8041611bc0:	9d 18 61 41 80 00 00 00 a7 18 61 41 80 00 00 00     ..aA......aA....
  8041611bd0:	63 45 60 41 80 00 00 00 21 70 2d 3e 72 65 66 63     cE`A....!p->refc
  8041611be0:	00 6b 65 72 6e 2f 70 6d 61 70 2e 63 00 21 6e 6f     .kern/pmap.c.!no
  8041611bf0:	64 65 2d 3e 6c 65 66 74 20 26 26 20 21 6e 6f 64     de->left && !nod
  8041611c00:	65 2d 3e 72 69 67 68 74 00 70 61 67 65 2d 3e 63     e->right.page->c
  8041611c10:	6c 61 73 73 20 3d 3d 20 4d 41 58 5f 43 4c 41 53     lass == MAX_CLAS
  8041611c20:	53 00 70 61 67 65 20 3d 3d 20 26 72 6f 6f 74 00     S.page == &root.
  8041611c30:	6e 20 21 3d 20 26 70 61 67 65 2d 3e 68 65 61 64     n != &page->head
  8041611c40:	00 76 2d 3e 70 68 79 20 3d 3d 20 70 61 67 65 00     .v->phy == page.
  8041611c50:	70 61 67 65 2d 3e 6c 65 66 74 2d 3e 70 61 72 65     page->left->pare
  8041611c60:	6e 74 20 3d 3d 20 70 61 67 65 00 70 61 67 65 2d     nt == page.page-
  8041611c70:	3e 72 69 67 68 74 2d 3e 70 61 72 65 6e 74 20 3d     >right->parent =
  8041611c80:	3d 20 70 61 67 65 00 63 6c 61 73 73 20 3e 3d 20     = page.class >= 
  8041611c90:	30 00 21 70 61 67 65 2d 3e 6c 65 66 74 20 26 26     0.!page->left &&
  8041611ca0:	20 21 70 61 67 65 2d 3e 72 69 67 68 74 00 25 64      !page->right.%d
  8041611cb0:	20 25 64 0a 00 70 61 67 65 2d 3e 70 68 79 2d 3e      %d..page->phy->
  8041611cc0:	63 6c 61 73 73 20 3d 3d 20 63 6c 61 73 73 00 21     class == class.!
  8041611cd0:	70 61 67 65 2d 3e 70 68 79 00 4f 75 74 20 6f 66     page->phy.Out of
  8041611ce0:	20 6d 65 6d 6f 72 79 0a 00 66 72 65 65 5f 64 65      memory..free_de
  8041611cf0:	73 63 5f 63 6f 75 6e 74 20 3e 3d 20 63 6f 75 6e     sc_count >= coun
  8041611d00:	74 00 21 28 61 64 64 72 20 26 20 43 4c 41 53 53     t.!(addr & CLASS
  8041611d10:	5f 4d 41 53 4b 28 63 6c 61 73 73 29 29 00 6e 6f     _MASK(class)).no
  8041611d20:	64 65 00 21 6e 6f 64 65 2d 3e 72 65 66 63 00 21     de.!node->refc.!
  8041611d30:	61 6c 6c 6f 63 61 74 69 6e 67 5f 70 6f 6f 6c 00     allocating_pool.
  8041611d40:	21 6e 65 77 2d 3e 72 65 66 63 00 69 30 20 21 3d     !new->refc.i0 !=
  8041611d50:	20 69 31 00 21 70 61 67 65 2d 3e 72 65 66 63 00      i1.!page->refc.
  8041611d60:	25 30 38 6c 58 20 25 30 38 6c 58 0a 00 6e 63 6c     %08lX %08lX..ncl
  8041611d70:	61 73 73 20 3d 3d 20 6e 6f 64 65 2d 3e 70 68 79     ass == node->phy
  8041611d80:	2d 3e 63 6c 61 73 73 00 2a 6e 65 78 74 00 21 72     ->class.*next.!r
  8041611d90:	65 73 00 70 61 67 65 20 26 26 20 73 70 63 00 21     es.page && spc.!
  8041611da0:	28 73 70 63 2d 3e 70 6d 6c 34 5b 70 6d 6c 34 69     (spc->pml4[pml4i
  8041611db0:	30 5d 20 26 20 50 54 45 5f 50 53 29 00 6e 6f 64     0] & PTE_PS).nod
  8041611dc0:	65 2d 3e 70 68 79 2d 3e 63 6c 61 73 73 20 3d 3d     e->phy->class ==
  8041611dd0:	20 63 6c 61 73 73 00 50 61 67 65 20 74 61 62 6c      class.Page tabl
  8041611de0:	65 3a 0a 00 20 3e 20 20 20 20 3e 20 20 20 20 3e     e:.. >    >    >
  8041611df0:	20 20 20 20 3e 00 63 75 72 72 65 6e 74 5f 73 70         >.current_sp
  8041611e00:	61 63 65 00 21 72 65 73 20 7c 7c 20 72 65 73 20     ace.!res || res 
  8041611e10:	3d 3d 20 2d 45 5f 46 41 55 4c 54 00 6e 65 77 76     == -E_FAULT.newv
  8041611e20:	20 26 26 20 6e 65 77 76 2d 3e 70 68 79 00 64 73      && newv->phy.ds
  8041611e30:	70 61 63 65 00 70 61 67 65 31 00 4b 65 72 6e 65     pace.page1.Kerne
  8041611e40:	6c 20 68 65 61 70 20 6f 76 65 72 66 6c 6f 77 0a     l heap overflow.
  8041611e50:	00 6b 7a 61 6c 6c 6f 63 5f 72 65 67 69 6f 6e 3a     .kzalloc_region:
  8041611e60:	20 25 69 0a 00 63 75 72 72 65 6e 74 5f 73 70 61      %i..current_spa
  8041611e70:	63 65 20 3d 3d 20 26 6b 73 70 61 63 65 00 7a 65     ce == &kspace.ze
  8041611e80:	72 6f 5f 70 61 67 65 20 26 26 20 6f 6e 65 5f 70     ro_page && one_p
  8041611e90:	61 67 65 00 43 61 6e 6e 6f 74 20 6d 61 70 20 6b     age.Cannot map k
  8041611ea0:	65 72 6e 65 6c 00 21 7a 65 72 6f 5f 70 61 67 65     ernel.!zero_page
  8041611eb0:	5f 72 61 77 5b 69 5d 00 28 28 70 61 67 65 29 2d     _raw[i].((page)-
  8041611ec0:	3e 73 74 61 74 65 20 26 20 4e 4f 44 45 5f 54 59     >state & NODE_TY
  8041611ed0:	50 45 5f 4d 41 53 4b 29 20 3e 3d 20 50 41 52 54     PE_MASK) >= PART
  8041611ee0:	49 41 4c 5f 4e 4f 44 45 00 00 00 00 00 00 00 00     IAL_NODE........
  8041611ef0:	28 28 70 61 72 29 2d 3e 73 74 61 74 65 20 26 20     ((par)->state & 
  8041611f00:	4e 4f 44 45 5f 54 59 50 45 5f 4d 41 53 4b 29 20     NODE_TYPE_MASK) 
  8041611f10:	3e 3d 20 50 41 52 54 49 41 4c 5f 4e 4f 44 45 00     >= PARTIAL_NODE.
  8041611f20:	6c 69 73 74 5f 65 6d 70 74 79 28 28 73 74 72 75     list_empty((stru
  8041611f30:	63 74 20 4c 69 73 74 20 2a 29 70 61 72 29 00 00     ct List *)par)..
  8041611f40:	28 28 6e 6f 64 65 29 2d 3e 73 74 61 74 65 20 26     ((node)->state &
  8041611f50:	20 4e 4f 44 45 5f 54 59 50 45 5f 4d 41 53 4b 29      NODE_TYPE_MASK)
  8041611f60:	20 3c 20 50 41 52 54 49 41 4c 5f 4e 4f 44 45 00      < PARTIAL_NODE.
  8041611f70:	28 6e 6f 64 65 2d 3e 73 74 61 74 65 20 26 20 4e     (node->state & N
  8041611f80:	4f 44 45 5f 54 59 50 45 5f 4d 41 53 4b 29 20 3d     ODE_TYPE_MASK) =
  8041611f90:	3d 20 4d 41 50 50 49 4e 47 5f 4e 4f 44 45 00 00     = MAPPING_NODE..
  8041611fa0:	28 6e 6f 64 65 2d 3e 73 74 61 74 65 20 26 20 4e     (node->state & N
  8041611fb0:	4f 44 45 5f 54 59 50 45 5f 4d 41 53 4b 29 20 3d     ODE_TYPE_MASK) =
  8041611fc0:	3d 20 49 4e 54 45 52 4d 45 44 49 41 54 45 5f 4e     = INTERMEDIATE_N
  8041611fd0:	4f 44 45 00 00 00 00 00 21 28 70 61 67 65 32 70     ODE.....!(page2p
  8041611fe0:	61 28 70 61 67 65 29 20 26 20 43 4c 41 53 53 5f     a(page) & CLASS_
  8041611ff0:	4d 41 53 4b 28 70 61 67 65 2d 3e 63 6c 61 73 73     MASK(page->class
  8041612000:	29 29 00 00 00 00 00 00 70 61 67 65 2d 3e 6c 65     ))......page->le
  8041612010:	66 74 2d 3e 73 74 61 74 65 20 3d 3d 20 70 61 67     ft->state == pag
  8041612020:	65 2d 3e 73 74 61 74 65 00 00 00 00 00 00 00 00     e->state........
  8041612030:	70 61 67 65 2d 3e 72 69 67 68 74 2d 3e 73 74 61     page->right->sta
  8041612040:	74 65 20 3d 3d 20 70 61 67 65 2d 3e 73 74 61 74     te == page->stat
  8041612050:	65 00 00 00 00 00 00 00 70 61 67 65 2d 3e 6c 65     e.......page->le
  8041612060:	66 74 2d 3e 63 6c 61 73 73 20 2b 20 31 20 3d 3d     ft->class + 1 ==
  8041612070:	20 70 61 67 65 2d 3e 63 6c 61 73 73 00 00 00 00      page->class....
  8041612080:	70 61 67 65 32 70 61 28 70 61 67 65 29 20 3d 3d     page2pa(page) ==
  8041612090:	20 70 61 67 65 32 70 61 28 70 61 67 65 2d 3e 6c      page2pa(page->l
  80416120a0:	65 66 74 29 00 00 00 00 70 61 67 65 2d 3e 72 69     eft)....page->ri
  80416120b0:	67 68 74 2d 3e 63 6c 61 73 73 20 2b 20 31 20 3d     ght->class + 1 =
  80416120c0:	3d 20 70 61 67 65 2d 3e 63 6c 61 73 73 00 00 00     = page->class...
  80416120d0:	70 61 67 65 2d 3e 61 64 64 72 20 2b 20 28 31 55     page->addr + (1U
  80416120e0:	4c 4c 20 3c 3c 20 28 70 61 67 65 2d 3e 63 6c 61     LL << (page->cla
  80416120f0:	73 73 20 2d 20 31 29 29 20 3d 3d 20 70 61 67 65     ss - 1)) == page
  8041612100:	2d 3e 72 69 67 68 74 2d 3e 61 64 64 72 00 00 00     ->right->addr...
  8041612110:	70 61 67 65 2d 3e 70 61 72 65 6e 74 2d 3e 63 6c     page->parent->cl
  8041612120:	61 73 73 20 2d 20 31 20 3d 3d 20 70 61 67 65 2d     ass - 1 == page-
  8041612130:	3e 63 6c 61 73 73 00 00 28 70 61 67 65 2d 3e 70     >class..(page->p
  8041612140:	61 72 65 6e 74 2d 3e 6c 65 66 74 20 3d 3d 20 70     arent->left == p
  8041612150:	61 67 65 29 20 5e 20 28 70 61 67 65 2d 3e 70 61     age) ^ (page->pa
  8041612160:	72 65 6e 74 2d 3e 72 69 67 68 74 20 3d 3d 20 70     rent->right == p
  8041612170:	61 67 65 29 00 00 00 00 70 61 67 65 2d 3e 68 65     age)....page->he
  8041612180:	61 64 2e 6e 65 78 74 20 26 26 20 70 61 67 65 2d     ad.next && page-
  8041612190:	3e 68 65 61 64 2e 70 72 65 76 00 00 00 00 00 00     >head.prev......
  80416121a0:	28 28 76 29 2d 3e 73 74 61 74 65 20 26 20 4e 4f     ((v)->state & NO
  80416121b0:	44 45 5f 54 59 50 45 5f 4d 41 53 4b 29 20 3c 20     DE_TYPE_MASK) < 
  80416121c0:	50 41 52 54 49 41 4c 5f 4e 4f 44 45 00 00 00 00     PARTIAL_NODE....
  80416121d0:	28 28 70 61 67 65 29 2d 3e 73 74 61 74 65 20 26     ((page)->state &
  80416121e0:	20 4e 4f 44 45 5f 54 59 50 45 5f 4d 41 53 4b 29      NODE_TYPE_MASK)
  80416121f0:	20 3c 20 50 41 52 54 49 41 4c 5f 4e 4f 44 45 00      < PARTIAL_NODE.
  8041612200:	21 28 70 61 67 65 2d 3e 73 74 61 74 65 20 26 20     !(page->state & 
  8041612210:	50 52 4f 54 5f 4c 41 5a 59 29 20 7c 7c 20 21 28     PROT_LAZY) || !(
  8041612220:	70 61 67 65 2d 3e 73 74 61 74 65 20 26 20 50 52     page->state & PR
  8041612230:	4f 54 5f 53 48 41 52 45 29 00 00 00 00 00 00 00     OT_SHARE).......
  8041612240:	70 61 67 65 2d 3e 73 74 61 74 65 20 3d 3d 20 49     page->state == I
  8041612250:	4e 54 45 52 4d 45 44 49 41 54 45 5f 4e 4f 44 45     NTERMEDIATE_NODE
	...
  8041612268:	21 6c 69 73 74 5f 65 6d 70 74 79 28 26 66 72 65     !list_empty(&fre
  8041612278:	65 5f 64 65 73 63 72 69 70 74 6f 72 73 29 00 00     e_descriptors)..
  8041612288:	28 28 70 61 72 65 6e 74 29 2d 3e 73 74 61 74 65     ((parent)->state
  8041612298:	20 26 20 4e 4f 44 45 5f 54 59 50 45 5f 4d 41 53      & NODE_TYPE_MAS
  80416122a8:	4b 29 20 3e 3d 20 50 41 52 54 49 41 4c 5f 4e 4f     K) >= PARTIAL_NO
  80416122b8:	44 45 00 00 00 00 00 00 28 28 68 69 6e 74 29 2d     DE......((hint)-
  80416122c8:	3e 73 74 61 74 65 20 26 20 4e 4f 44 45 5f 54 59     >state & NODE_TY
  80416122d8:	50 45 5f 4d 41 53 4b 29 20 3e 3d 20 50 41 52 54     PE_MASK) >= PART
  80416122e8:	49 41 4c 5f 4e 4f 44 45 00 00 00 00 00 00 00 00     IAL_NODE........
  80416122f8:	6f 74 68 65 72 2d 3e 73 74 61 74 65 20 3d 3d 20     other->state == 
  8041612308:	41 4c 4c 4f 43 41 54 41 42 4c 45 5f 4e 4f 44 45     ALLOCATABLE_NODE
	...
  8041612320:	28 6e 6f 64 65 2d 3e 6c 65 66 74 20 26 26 20 6e     (node->left && n
  8041612330:	6f 64 65 2d 3e 72 69 67 68 74 29 20 7c 7c 20 21     ode->right) || !
  8041612340:	61 6c 6c 6f 63 00 00 00 21 28 70 61 67 65 32 70     alloc...!(page2p
  8041612350:	61 28 6e 6f 64 65 29 20 26 20 43 4c 41 53 53 5f     a(node) & CLASS_
  8041612360:	4d 41 53 4b 28 6e 6f 64 65 2d 3e 63 6c 61 73 73     MASK(node->class
  8041612370:	29 29 00 00 00 00 00 00 70 65 65 72 2d 3e 73 74     ))......peer->st
  8041612380:	61 74 65 20 3d 3d 20 41 4c 4c 4f 43 41 54 41 42     ate == ALLOCATAB
  8041612390:	4c 45 5f 4e 4f 44 45 00 4b 41 44 44 52 20 63 61     LE_NODE.KADDR ca
  80416123a0:	6c 6c 65 64 20 77 69 74 68 20 69 6e 76 61 6c 69     lled with invali
  80416123b0:	64 20 70 61 20 25 70 20 77 69 74 68 20 6d 61 78     d pa %p with max
  80416123c0:	5f 6d 65 6d 6f 72 79 5f 6d 61 70 5f 61 64 64 72     _memory_map_addr
  80416123d0:	3d 25 70 00 00 00 00 00 4b 41 44 44 52 28 70 61     =%p.....KADDR(pa
  80416123e0:	67 65 32 70 61 28 6e 65 77 29 29 20 3d 3d 20 66     ge2pa(new)) == f
  80416123f0:	69 72 73 74 5f 70 6f 6f 6c 00 00 00 00 00 00 00     irst_pool.......
  8041612400:	50 41 44 44 52 20 63 61 6c 6c 65 64 20 77 69 74     PADDR called wit
  8041612410:	68 20 69 6e 76 61 6c 69 64 20 6b 76 61 20 25 70     h invalid kva %p
	...
  8041612428:	70 61 67 65 32 70 61 28 6e 65 77 29 20 3e 3d 20     page2pa(new) >= 
  8041612438:	50 41 44 44 52 28 65 6e 64 29 20 7c 7c 20 70 61     PADDR(end) || pa
  8041612448:	67 65 32 70 61 28 6e 65 77 29 20 2b 20 43 4c 41     ge2pa(new) + CLA
  8041612458:	53 53 5f 4d 41 53 4b 28 6e 65 77 2d 3e 63 6c 61     SS_MASK(new->cla
  8041612468:	73 73 29 20 3c 20 49 4f 50 48 59 53 4d 45 4d 00     ss) < IOPHYSMEM.
  8041612478:	21 28 50 54 45 5f 41 44 44 52 28 62 61 73 65 29     !(PTE_ADDR(base)
  8041612488:	20 26 20 28 73 74 65 70 20 2d 20 31 29 29 00 00      & (step - 1))..
  8041612498:	73 74 65 70 20 3d 3d 20 31 20 2a 20 47 42 20 7c     step == 1 * GB |
  80416124a8:	7c 20 73 74 65 70 20 3d 3d 20 32 20 2a 20 4d 42     | step == 2 * MB
  80416124b8:	20 7c 7c 20 73 74 65 70 20 3d 3d 20 34 20 2a 20      || step == 4 * 
  80416124c8:	4b 42 20 7c 7c 20 73 74 65 70 20 3d 3d 20 35 31     KB || step == 51
  80416124d8:	32 20 2a 20 47 42 00 00 21 28 70 74 5b 69 5d 20     2 * GB..!(pt[i] 
  80416124e8:	26 20 50 54 45 5f 50 53 29 20 7c 7c 20 28 73 74     & PTE_PS) || (st
  80416124f8:	65 70 20 3d 3d 20 31 20 2a 20 47 42 20 7c 7c 20     ep == 1 * GB || 
  8041612508:	73 74 65 70 20 3d 3d 20 32 20 2a 20 4d 42 29 00     step == 2 * MB).
  8041612518:	28 28 70 61 72 65 6e 74 29 2d 3e 73 74 61 74 65     ((parent)->state
  8041612528:	20 26 20 4e 4f 44 45 5f 54 59 50 45 5f 4d 41 53      & NODE_TYPE_MAS
  8041612538:	4b 29 20 3c 20 50 41 52 54 49 41 4c 5f 4e 4f 44     K) < PARTIAL_NOD
  8041612548:	45 00 00 00 00 00 00 00 70 61 72 65 6e 74 2d 3e     E.......parent->
  8041612558:	70 68 79 20 26 26 20 70 61 72 65 6e 74 2d 3e 70     phy && parent->p
  8041612568:	68 79 2d 3e 6c 65 66 74 20 26 26 20 70 61 72 65     hy->left && pare
  8041612578:	6e 74 2d 3e 70 68 79 2d 3e 72 69 67 68 74 00 00     nt->phy->right..
  8041612588:	6e 6f 64 65 2d 3e 70 68 79 2d 3e 6c 65 66 74 20     node->phy->left 
  8041612598:	26 26 20 6e 6f 64 65 2d 3e 70 68 79 2d 3e 72 69     && node->phy->ri
  80416125a8:	67 68 74 00 00 00 00 00 6e 6f 64 65 2d 3e 73 74     ght.....node->st
  80416125b8:	61 74 65 20 3d 3d 20 49 4e 54 45 52 4d 45 44 49     ate == INTERMEDI
  80416125c8:	41 54 45 5f 4e 4f 44 45 00 00 00 00 00 00 00 00     ATE_NODE........
  80416125d8:	21 28 66 6c 61 67 73 20 26 20 50 52 4f 54 5f 4c     !(flags & PROT_L
  80416125e8:	41 5a 59 29 20 7c 20 21 28 66 6c 61 67 73 20 26     AZY) | !(flags &
  80416125f8:	20 50 52 4f 54 5f 53 48 41 52 45 29 00 00 00 00      PROT_SHARE)....
  8041612608:	21 28 61 64 64 72 20 26 20 43 4c 41 53 53 5f 4d     !(addr & CLASS_M
  8041612618:	41 53 4b 28 70 61 67 65 2d 3e 63 6c 61 73 73 29     ASK(page->class)
  8041612628:	29 00 00 00 00 00 00 00 64 73 74 61 72 74 20 3e     ).......dstart >
  8041612638:	20 4d 41 58 5f 55 53 45 52 5f 41 44 44 52 45 53      MAX_USER_ADDRES
  8041612648:	53 20 7c 7c 20 64 73 74 20 3d 3d 20 26 6b 73 70     S || dst == &ksp
  8041612658:	61 63 65 00 00 00 00 00 21 28 28 61 64 64 72 31     ace.....!((addr1
  8041612668:	20 7c 20 61 64 64 72 32 29 20 26 20 43 4c 41 53      | addr2) & CLAS
  8041612678:	53 5f 4d 41 53 4b 28 30 29 29 00 00 00 00 00 00     S_MASK(0))......
  8041612688:	28 28 64 73 74 2d 3e 72 6f 6f 74 29 2d 3e 73 74     ((dst->root)->st
  8041612698:	61 74 65 20 26 20 4e 4f 44 45 5f 54 59 50 45 5f     ate & NODE_TYPE_
  80416126a8:	4d 41 53 4b 29 20 3c 20 50 41 52 54 49 41 4c 5f     MASK) < PARTIAL_
  80416126b8:	4e 4f 44 45 00 00 00 00 76 69 72 74 3a 20 5b 25     NODE....virt: [%
  80416126c8:	30 38 6c 58 2c 20 25 30 38 6c 58 5d 20 70 68 79     08lX, %08lX] phy
  80416126d8:	73 3a 20 5b 25 30 38 6c 58 2c 20 25 30 38 6c 78     s: [%08lX, %08lx
  80416126e8:	5d 20 63 6c 61 73 73 3a 20 5b 25 64 5d 0a 00 00     ] class: [%d]...
  80416126f8:	70 61 3a 20 5b 25 30 38 6c 58 2c 20 25 30 38 6c     pa: [%08lX, %08l
  8041612708:	58 5d 20 20 70 61 67 65 5f 63 6c 61 73 73 3a 20     X]  page_class: 
  8041612718:	5b 25 64 5d 20 72 65 66 63 3a 20 5b 25 64 5d 0a     [%d] refc: [%d].
	...
  8041612730:	25 73 5b 25 30 38 6c 6c 58 2c 20 25 30 38 6c 6c     %s[%08llX, %08ll
  8041612740:	58 5d 20 25 63 25 63 25 63 25 63 25 63 20 2d 2d     X] %c%c%c%c%c --
  8041612750:	20 73 74 65 70 3d 25 7a 78 0a 00 00 00 00 00 00      step=%zx.......
  8041612760:	21 28 6f 6c 64 66 6c 61 67 73 20 26 20 50 52 4f     !(oldflags & PRO
  8041612770:	54 5f 4c 41 5a 59 29 20 7c 20 21 28 6f 6c 64 66     T_LAZY) | !(oldf
  8041612780:	6c 61 67 73 20 26 20 50 52 4f 54 5f 53 48 41 52     lags & PROT_SHAR
  8041612790:	45 29 00 00 00 00 00 00 28 76 70 61 67 65 2d 3e     E)......(vpage->
  80416127a0:	73 74 61 74 65 20 26 20 4e 4f 44 45 5f 54 59 50     state & NODE_TYP
  80416127b0:	45 5f 4d 41 53 4b 29 20 3d 3d 20 4d 41 50 50 49     E_MASK) == MAPPI
  80416127c0:	4e 47 5f 4e 4f 44 45 00 76 70 61 67 65 2d 3e 73     NG_NODE.vpage->s
  80416127d0:	74 61 74 65 20 3d 3d 20 49 4e 54 45 52 4d 45 44     tate == INTERMED
  80416127e0:	49 41 54 45 5f 4e 4f 44 45 00 00 00 00 00 00 00     IATE_NODE.......
  80416127f0:	41 42 53 44 49 46 46 28 64 73 74 2c 20 73 72 63     ABSDIFF(dst, src
  8041612800:	29 20 3e 3d 20 43 4c 41 53 53 5f 53 49 5a 45 28     ) >= CLASS_SIZE(
  8041612810:	63 6c 61 73 73 29 00 00 43 4c 41 53 53 5f 53 49     class)..CLASS_SI
  8041612820:	5a 45 28 63 70 61 67 65 2d 3e 63 6c 61 73 73 29     ZE(cpage->class)
  8041612830:	20 3d 3d 20 73 69 7a 65 5f 69 6e 63 00 00 00 00      == size_inc....
  8041612840:	73 73 70 61 63 65 20 21 3d 20 64 73 70 61 63 65     sspace != dspace
  8041612850:	20 7c 7c 20 64 73 74 20 3c 3d 20 73 72 63 20 7c      || dst <= src |
  8041612860:	7c 20 41 42 53 44 49 46 46 28 73 72 63 2c 20 64     | ABSDIFF(src, d
  8041612870:	73 74 29 20 3e 3d 20 73 69 7a 65 00 00 00 00 00     st) >= size.....
  8041612880:	43 61 6e 6e 6f 74 20 6d 61 70 20 70 68 79 73 69     Cannot map physi
  8041612890:	63 61 6c 20 72 65 67 69 6f 6e 20 61 74 20 25 70     cal region at %p
  80416128a0:	20 6f 66 20 73 69 7a 65 20 25 7a 64 00 00 00 00      of size %zd....
  80416128b0:	54 72 79 69 6e 67 20 74 6f 20 72 65 6d 61 70 20     Trying to remap 
  80416128c0:	6e 6f 6e 2d 6c 61 73 74 20 4d 4d 49 4f 20 72 65     non-last MMIO re
  80416128d0:	67 69 6f 6e 21 0a 00 00 4d 65 6d 6f 72 79 20 61     gion!...Memory a
  80416128e0:	6c 6c 6f 63 61 74 6f 72 20 69 73 20 69 6e 69 74     llocator is init
  80416128f0:	69 61 6c 6c 69 7a 65 64 0a 00 00 00 00 00 00 00     iallized........
  8041612900:	50 68 79 73 69 63 61 6c 20 6d 65 6d 6f 72 79 3a     Physical memory:
  8041612910:	20 25 7a 75 4d 20 61 76 61 69 6c 61 62 6c 65 2c      %zuM available,
  8041612920:	20 62 61 73 65 20 3d 20 25 7a 75 4b 2c 20 65 78      base = %zuK, ex
  8041612930:	74 65 6e 64 65 64 20 3d 20 25 7a 75 4b 0a 00 00     tended = %zuK...
  8041612940:	50 68 79 73 69 63 61 6c 20 6d 65 6d 6f 72 79 20     Physical memory 
  8041612950:	74 72 65 65 20 69 73 20 63 6f 72 72 65 63 74 0a     tree is correct.
	...
  8041612968:	21 28 28 75 69 6e 74 70 74 72 5f 74 29 5f 5f 74     !((uintptr_t)__t
  8041612978:	65 78 74 5f 73 74 61 72 74 20 26 20 43 4c 41 53     ext_start & CLAS
  8041612988:	53 5f 4d 41 53 4b 28 30 29 29 00 00 00 00 00 00     S_MASK(0))......
  8041612998:	5f 5f 74 65 78 74 5f 65 6e 64 20 2d 20 5f 5f 74     __text_end - __t
  80416129a8:	65 78 74 5f 73 74 61 72 74 20 3c 20 4d 41 58 5f     ext_start < MAX_
  80416129b8:	4c 4f 57 5f 41 44 44 52 5f 4b 45 52 4e 5f 53 49     LOW_ADDR_KERN_SI
  80416129c8:	5a 45 00 00 00 00 00 00 28 75 69 6e 74 70 74 72     ZE......(uintptr
  80416129d8:	5f 74 29 28 65 6e 64 20 2d 20 4b 45 52 4e 5f 42     _t)(end - KERN_B
  80416129e8:	41 53 45 5f 41 44 44 52 29 20 3c 20 4d 49 4e 28     ASE_ADDR) < MIN(
  80416129f8:	42 4f 4f 54 5f 4d 45 4d 5f 53 49 5a 45 2c 20 6d     BOOT_MEM_SIZE, m
  8041612a08:	61 78 5f 6d 65 6d 6f 72 79 5f 6d 61 70 5f 61 64     ax_memory_map_ad
  8041612a18:	64 72 29 00 00 00 00 00 2a 28 76 6f 6c 61 74 69     dr).....*(volati
  8041612a28:	6c 65 20 69 6e 74 20 2a 29 6d 73 74 61 72 74 2d     le int *)mstart-
  8041612a38:	3e 56 69 72 74 75 61 6c 53 74 61 72 74 20 3d 3d     >VirtualStart ==
  8041612a48:	20 65 78 70 65 63 74 65 64 00 00 00 00 00 00 00      expected.......
  8041612a58:	50 68 79 73 69 63 61 6c 20 6d 65 6d 6f 72 79 20     Physical memory 
  8041612a68:	74 72 65 65 20 69 73 20 73 74 69 6c 20 63 6f 72     tree is stil cor
  8041612a78:	72 65 63 74 0a 00 00 00 4b 65 72 6e 65 6c 20 76     rect....Kernel v
  8041612a88:	69 72 75 74 61 6c 20 6d 65 6d 6f 72 79 20 74 72     irutal memory tr
  8041612a98:	65 65 20 69 73 20 63 6f 72 72 65 63 74 0a 00 00     ee is correct...
  8041612aa8:	5b 25 30 38 78 5d 20 75 73 65 72 5f 6d 65 6d 5f     [%08x] user_mem_
  8041612ab8:	63 68 65 63 6b 20 61 73 73 65 72 74 69 6f 6e 20     check assertion 
  8041612ac8:	66 61 69 6c 75 72 65 20 66 6f 72 20 76 61 3d 25     failure for va=%
  8041612ad8:	30 31 36 7a 78 20 69 70 3d 25 30 31 36 7a 78 0a     016zx ip=%016zx.
  8041612ae8:	00 6d 61 70 5f 72 65 67 69 6f 6e 3a 20 25 69 00     .map_region: %i.
  8041612af8:	6b 65 72 6e 2f 65 6e 76 2e 63 00 5b 25 30 38 78     kern/env.c.[%08x
  8041612b08:	5d 20 6e 65 77 20 65 6e 76 20 25 30 38 78 0a 00     ] new env %08x..
  8041612b18:	63 61 6e 74 20 61 6c 6c 6f 63 61 74 65 20 65 6e     cant allocate en
  8041612b28:	76 00 49 4e 56 41 4c 49 44 20 45 58 45 00 5b 25     v.INVALID EXE.[%
  8041612b38:	30 38 78 5d 20 66 72 65 65 20 65 6e 76 20 25 30     08x] free env %0
  8041612b48:	38 78 0a 00 69 6e 5f 70 61 67 65 5f 66 61 75 6c     8x..in_page_faul
  8041612b58:	74 0a 00 52 65 61 63 68 65 64 20 75 6e 72 65 61     t..Reached unrea
  8041612b68:	63 68 61 62 6c 65 0a 00 63 61 6e 27 74 20 6d 61     chable..can't ma
  8041612b78:	70 20 65 6e 76 73 20 74 6f 20 63 75 72 72 65 6e     p envs to curren
  8041612b88:	74 5f 73 70 61 63 65 00 72 74 63 00 65 6e 61 62     t_space.rtc.enab
  8041612b98:	6c 65 64 20 69 6e 74 65 72 72 75 70 74 73 3a 00     led interrupts:.
  8041612ba8:	20 20 72 31 35 20 20 30 78 25 30 38 6c 78 0a 00       r15  0x%08lx..
  8041612bb8:	20 20 72 31 34 20 20 30 78 25 30 38 6c 78 0a 00       r14  0x%08lx..
  8041612bc8:	20 20 72 31 33 20 20 30 78 25 30 38 6c 78 0a 00       r13  0x%08lx..
  8041612bd8:	20 20 72 31 32 20 20 30 78 25 30 38 6c 78 0a 00       r12  0x%08lx..
  8041612be8:	20 20 72 31 31 20 20 30 78 25 30 38 6c 78 0a 00       r11  0x%08lx..
  8041612bf8:	20 20 72 31 30 20 20 30 78 25 30 38 6c 78 0a 00       r10  0x%08lx..
  8041612c08:	20 20 72 39 20 20 20 30 78 25 30 38 6c 78 0a 00       r9   0x%08lx..
  8041612c18:	20 20 72 38 20 20 20 30 78 25 30 38 6c 78 0a 00       r8   0x%08lx..
  8041612c28:	20 20 72 64 69 20 20 30 78 25 30 38 6c 78 0a 00       rdi  0x%08lx..
  8041612c38:	20 20 72 73 69 20 20 30 78 25 30 38 6c 78 0a 00       rsi  0x%08lx..
  8041612c48:	20 20 72 62 70 20 20 30 78 25 30 38 6c 78 0a 00       rbp  0x%08lx..
  8041612c58:	20 20 72 62 78 20 20 30 78 25 30 38 6c 78 0a 00       rbx  0x%08lx..
  8041612c68:	20 20 72 64 78 20 20 30 78 25 30 38 6c 78 0a 00       rdx  0x%08lx..
  8041612c78:	20 20 72 63 78 20 20 30 78 25 30 38 6c 78 0a 00       rcx  0x%08lx..
  8041612c88:	20 20 72 61 78 20 20 30 78 25 30 38 6c 78 0a 00       rax  0x%08lx..
  8041612c98:	53 79 73 74 65 6d 20 63 61 6c 6c 00 28 75 6e 6b     System call.(unk
  8041612ca8:	6e 6f 77 6e 20 74 72 61 70 29 00 48 61 72 64 77     nown trap).Hardw
  8041612cb8:	61 72 65 20 49 6e 74 65 72 72 75 70 74 00 70 72     are Interrupt.pr
  8041612cc8:	6f 74 65 63 74 69 6f 6e 00 6e 6f 74 2d 70 72 65     otection.not-pre
  8041612cd8:	73 65 6e 74 00 77 72 69 74 65 00 65 78 65 63 75     sent.write.execu
  8041612ce8:	74 65 00 72 65 61 64 00 75 73 65 72 00 54 52 41     te.read.user.TRA
  8041612cf8:	50 20 66 72 61 6d 65 20 61 74 20 25 70 0a 00 20     P frame at %p.. 
  8041612d08:	20 65 73 20 20 20 30 78 2d 2d 2d 2d 25 30 34 78      es   0x----%04x
  8041612d18:	0a 00 20 20 64 73 20 20 20 30 78 2d 2d 2d 2d 25     ..  ds   0x----%
  8041612d28:	30 34 78 0a 00 20 20 74 72 61 70 20 30 78 25 30     04x..  trap 0x%0
  8041612d38:	38 6c 78 20 25 73 0a 00 20 20 63 72 32 20 20 30     8lx %s..  cr2  0
  8041612d48:	78 25 30 38 6c 78 0a 00 20 20 65 72 72 20 20 30     x%08lx..  err  0
  8041612d58:	78 25 30 38 6c 78 00 20 5b 25 73 2c 20 25 73 2c     x%08lx. [%s, %s,
  8041612d68:	20 25 73 5d 0a 00 20 20 72 69 70 20 20 30 78 25      %s]..  rip  0x%
  8041612d78:	30 38 6c 78 0a 00 20 20 63 73 20 20 20 30 78 2d     08lx..  cs   0x-
  8041612d88:	2d 2d 2d 25 30 34 78 0a 00 20 20 66 6c 61 67 20     ---%04x..  flag 
  8041612d98:	30 78 25 30 38 6c 78 0a 00 20 20 72 73 70 20 20     0x%08lx..  rsp  
  8041612da8:	30 78 25 30 38 6c 78 0a 00 20 20 73 73 20 20 20     0x%08lx..  ss   
  8041612db8:	30 78 2d 2d 2d 2d 25 30 34 78 0a 00 21 28 72 65     0x----%04x..!(re
  8041612dc8:	61 64 5f 72 66 6c 61 67 73 28 29 20 26 20 46 4c     ad_rflags() & FL
  8041612dd8:	5f 49 46 29 00 6b 65 72 6e 2f 74 72 61 70 2e 63     _IF).kern/trap.c
  8041612de8:	00 21 69 6e 5f 70 61 67 65 5f 66 61 75 6c 74 00     .!in_page_fault.
  8041612df8:	63 75 72 65 6e 76 00 4b 65 72 6e 65 6c 20 70 61     curenv.Kernel pa
  8041612e08:	67 65 66 61 75 6c 74 0a 00 55 6e 68 61 6e 64 6c     gefault..Unhandl
  8041612e18:	65 64 20 74 72 61 70 20 69 6e 20 6b 65 72 6e 65     ed trap in kerne
  8041612e28:	6c 00 44 69 76 69 64 65 20 65 72 72 6f 72 00 44     l.Divide error.D
  8041612e38:	65 62 75 67 00 4e 6f 6e 2d 4d 61 73 6b 61 62 6c     ebug.Non-Maskabl
  8041612e48:	65 20 49 6e 74 65 72 72 75 70 74 00 42 72 65 61     e Interrupt.Brea
  8041612e58:	6b 70 6f 69 6e 74 00 4f 76 65 72 66 6c 6f 77 00     kpoint.Overflow.
  8041612e68:	42 4f 55 4e 44 20 52 61 6e 67 65 20 45 78 63 65     BOUND Range Exce
  8041612e78:	65 64 65 64 00 49 6e 76 61 6c 69 64 20 4f 70 63     eded.Invalid Opc
  8041612e88:	6f 64 65 00 44 65 76 69 63 65 20 4e 6f 74 20 41     ode.Device Not A
  8041612e98:	76 61 69 6c 61 62 6c 65 00 44 6f 75 62 6c 65 20     vailable.Double 
  8041612ea8:	46 61 75 6c 74 00 43 6f 70 72 6f 63 65 73 73 6f     Fault.Coprocesso
  8041612eb8:	72 20 53 65 67 6d 65 6e 74 20 4f 76 65 72 72 75     r Segment Overru
  8041612ec8:	6e 00 49 6e 76 61 6c 69 64 20 54 53 53 00 53 65     n.Invalid TSS.Se
  8041612ed8:	67 6d 65 6e 74 20 4e 6f 74 20 50 72 65 73 65 6e     gment Not Presen
  8041612ee8:	74 00 53 74 61 63 6b 20 46 61 75 6c 74 00 47 65     t.Stack Fault.Ge
  8041612ef8:	6e 65 72 61 6c 20 50 72 6f 74 65 63 74 69 6f 6e     neral Protection
  8041612f08:	00 50 61 67 65 20 46 61 75 6c 74 00 78 38 37 20     .Page Fault.x87 
  8041612f18:	46 50 55 20 46 6c 6f 61 74 69 6e 67 2d 50 6f 69     FPU Floating-Poi
  8041612f28:	6e 74 20 45 72 72 6f 72 00 41 6c 69 67 6e 6d 65     nt Error.Alignme
  8041612f38:	6e 74 20 43 68 65 63 6b 00 4d 61 63 68 69 6e 65     nt Check.Machine
  8041612f48:	2d 43 68 65 63 6b 00 53 49 4d 44 20 46 6c 6f 61     -Check.SIMD Floa
  8041612f58:	74 69 6e 67 2d 50 6f 69 6e 74 20 45 78 63 65 70     ting-Point Excep
  8041612f68:	74 69 6f 6e 00 66 2e 0f 1f 84 00 00 00 00 00 66     tion.f.........f
  8041612f78:	0f 1f 84 00 00 00 00 00 5d d8 60 41 80 00 00 00     ........].`A....
  8041612f88:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041612f98:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041612fa8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041612fb8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041612fc8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041612fd8:	64 d6 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     d.`A......`A....
  8041612fe8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041612ff8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613008:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613018:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613028:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613038:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613048:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613058:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613068:	71 d8 60 41 80 00 00 00 a5 d8 60 41 80 00 00 00     q.`A......`A....
  8041613078:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613088:	bd d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  8041613098:	d5 d8 60 41 80 00 00 00 3c d6 60 41 80 00 00 00     ..`A....<.`A....
  80416130a8:	71 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     q.`A......`A....
  80416130b8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  80416130c8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  80416130d8:	d5 d8 60 41 80 00 00 00 d5 d8 60 41 80 00 00 00     ..`A......`A....
  80416130e8:	09 d6 60 41 80 00 00 00 00 00 00 00 00 00 00 00     ..`A............
	...

0000008041613100 <excnames.0>:
  8041613100:	2a 2e 61 41 80 00 00 00 37 2e 61 41 80 00 00 00     *.aA....7.aA....
  8041613110:	3d 2e 61 41 80 00 00 00 54 2e 61 41 80 00 00 00     =.aA....T.aA....
  8041613120:	5f 2e 61 41 80 00 00 00 68 2e 61 41 80 00 00 00     _.aA....h.aA....
  8041613130:	7d 2e 61 41 80 00 00 00 8c 2e 61 41 80 00 00 00     }.aA......aA....
  8041613140:	a1 2e 61 41 80 00 00 00 ae 2e 61 41 80 00 00 00     ..aA......aA....
  8041613150:	ca 2e 61 41 80 00 00 00 d6 2e 61 41 80 00 00 00     ..aA......aA....
  8041613160:	ea 2e 61 41 80 00 00 00 f6 2e 61 41 80 00 00 00     ..aA......aA....
  8041613170:	09 2f 61 41 80 00 00 00 a4 2c 61 41 80 00 00 00     ./aA.....,aA....
  8041613180:	14 2f 61 41 80 00 00 00 31 2f 61 41 80 00 00 00     ./aA....1/aA....
  8041613190:	41 2f 61 41 80 00 00 00 4f 2f 61 41 80 00 00 00     A/aA....O/aA....
  80416131a0:	46 41 43 50 00 48 50 45 54 00 68 70 65 74 20 69     FACP.HPET.hpet i
  80416131b0:	73 20 75 6e 61 76 61 69 6c 61 62 6c 65 0a 00 6b     s unavailable..k
  80416131c0:	65 72 6e 2f 74 69 6d 65 72 2e 63 00 68 70 65 74     ern/timer.c.hpet
  80416131d0:	46 65 6d 74 6f 20 3d 20 25 6c 75 0a 00 73 69 67     Femto = %lu..sig
  80416131e0:	6e 61 74 75 72 65 20 3d 20 25 73 0a 00 6c 65 6e     nature = %s..len
  80416131f0:	67 74 68 20 3d 20 25 30 38 78 0a 00 63 68 65 63     gth = %08x..chec
  8041613200:	6b 73 75 6d 20 3d 20 25 30 38 78 0a 00 6f 65 6d     ksum = %08x..oem
  8041613210:	5f 72 65 76 69 73 69 6f 6e 20 3d 20 25 30 38 78     _revision = %08x
  8041613220:	0a 00 63 72 65 61 74 6f 72 5f 69 64 20 3d 20 25     ..creator_id = %
  8041613230:	30 38 78 0a 00 63 72 65 61 74 6f 72 5f 72 65 76     08x..creator_rev
  8041613240:	69 73 69 6f 6e 20 3d 20 25 30 38 78 0a 00 68 61     ision = %08x..ha
  8041613250:	72 64 77 61 72 65 5f 72 65 76 5f 69 64 20 3d 20     rdware_rev_id = 
  8041613260:	25 30 38 78 0a 00 63 6f 6d 70 61 72 61 74 6f 72     %08x..comparator
  8041613270:	5f 63 6f 75 6e 74 20 3d 20 25 30 38 78 0a 00 63     _count = %08x..c
  8041613280:	6f 75 6e 74 65 72 5f 73 69 7a 65 20 3d 20 25 30     ounter_size = %0
  8041613290:	38 78 0a 00 72 65 73 65 72 76 65 64 20 3d 20 25     8x..reserved = %
  80416132a0:	30 38 78 0a 00 6c 65 67 61 63 79 5f 72 65 70 6c     08x..legacy_repl
  80416132b0:	61 63 65 6d 65 6e 74 20 3d 20 25 30 38 78 0a 00     acement = %08x..
  80416132c0:	70 63 69 5f 76 65 6e 64 6f 72 5f 69 64 20 3d 20     pci_vendor_id = 
  80416132d0:	25 30 38 78 0a 00 68 70 65 74 5f 6e 75 6d 62 65     %08x..hpet_numbe
  80416132e0:	72 20 3d 20 25 30 38 78 0a 00 6d 69 6e 69 6d 75     r = %08x..minimu
  80416132f0:	6d 5f 74 69 63 6b 20 3d 20 25 30 38 78 0a 00 61     m_tick = %08x..a
  8041613300:	64 64 72 65 73 73 5f 73 74 72 75 63 74 75 72 65     ddress_structure
  8041613310:	3a 0a 00 61 64 64 72 65 73 73 5f 73 70 61 63 65     :..address_space
  8041613320:	5f 69 64 20 3d 20 25 30 38 78 0a 00 72 65 67 69     _id = %08x..regi
  8041613330:	73 74 65 72 5f 62 69 74 5f 77 69 64 74 68 20 3d     ster_bit_width =
  8041613340:	20 25 30 38 78 0a 00 72 65 67 69 73 74 65 72 5f      %08x..register_
  8041613350:	62 69 74 5f 6f 66 66 73 65 74 20 3d 20 25 30 38     bit_offset = %08
  8041613360:	78 0a 00 61 64 64 72 65 73 73 20 3d 20 25 30 38     x..address = %08
  8041613370:	6c 78 0a 00 47 43 41 50 5f 49 44 20 3d 20 25 30     lx..GCAP_ID = %0
  8041613380:	31 36 6c 78 0a 00 47 45 4e 5f 43 4f 4e 46 20 3d     16lx..GEN_CONF =
  8041613390:	20 25 30 31 36 6c 78 0a 00 47 49 4e 54 52 5f 53      %016lx..GINTR_S
  80416133a0:	54 41 20 3d 20 25 30 31 36 6c 78 0a 00 4d 41 49     TA = %016lx..MAI
  80416133b0:	4e 5f 43 4e 54 20 3d 20 25 30 31 36 6c 78 0a 00     N_CNT = %016lx..
  80416133c0:	54 49 4d 30 5f 43 4f 4e 46 20 3d 20 25 30 31 36     TIM0_CONF = %016
  80416133d0:	6c 78 0a 00 54 49 4d 30 5f 43 4f 4d 50 20 3d 20     lx..TIM0_COMP = 
  80416133e0:	25 30 31 36 6c 78 0a 00 54 49 4d 30 5f 46 53 42     %016lx..TIM0_FSB
  80416133f0:	20 3d 20 25 30 31 36 6c 78 0a 00 54 49 4d 31 5f      = %016lx..TIM1_
  8041613400:	43 4f 4e 46 20 3d 20 25 30 31 36 6c 78 0a 00 54     CONF = %016lx..T
  8041613410:	49 4d 31 5f 43 4f 4d 50 20 3d 20 25 30 31 36 6c     IM1_COMP = %016l
  8041613420:	78 0a 00 54 49 4d 31 5f 46 53 42 20 3d 20 25 30     x..TIM1_FSB = %0
  8041613430:	31 36 6c 78 0a 00 54 49 4d 32 5f 43 4f 4e 46 20     16lx..TIM2_CONF 
  8041613440:	3d 20 25 30 31 36 6c 78 0a 00 54 49 4d 32 5f 43     = %016lx..TIM2_C
  8041613450:	4f 4d 50 20 3d 20 25 30 31 36 6c 78 0a 00 54 49     OMP = %016lx..TI
  8041613460:	4d 32 5f 46 53 42 20 3d 20 25 30 31 36 6c 78 0a     M2_FSB = %016lx.
  8041613470:	00 70 6d 00 68 70 65 74 31 00 66 0f 1f 44 00 00     .pm.hpet1.f..D..
  8041613480:	48 50 45 54 20 68 61 73 20 6e 6f 20 4c 65 67 61     HPET has no Lega
  8041613490:	63 79 52 65 70 6c 61 63 65 6d 65 6e 74 20 6d 6f     cyReplacement mo
  80416134a0:	64 65 00 00 00 00 00 00 48 50 45 54 3a 20 46 72     de......HPET: Fr
  80416134b0:	65 71 75 65 6e 63 79 20 3d 20 25 6c 64 2e 25 30     equency = %ld.%0
  80416134c0:	33 6c 64 4d 48 7a 0a 00 4e 6f 20 72 75 6e 6e 61     3ldMHz..No runna
  80416134d0:	62 6c 65 20 65 6e 76 69 72 6f 6e 6d 65 6e 74 73     ble environments
  80416134e0:	20 69 6e 20 74 68 65 20 73 79 73 74 65 6d 21 0a      in the system!.
  80416134f0:	00 48 61 6c 74 0a 00 5b 25 30 38 78 5d 20 65 78     .Halt..[%08x] ex
  8041613500:	69 74 69 6e 67 20 67 72 61 63 65 66 75 6c 6c 79     iting gracefully
  8041613510:	0a 00 5b 25 30 38 78 5d 20 64 65 73 74 72 6f 79     ..[%08x] destroy
  8041613520:	69 6e 67 20 25 30 38 78 0a 00 25 2e 2a 73 00 90     ing %08x..%.*s..
  8041613530:	3d e7 60 41 80 00 00 00 8e e7 60 41 80 00 00 00     =.`A......`A....
  8041613540:	9e e7 60 41 80 00 00 00 be e7 60 41 80 00 00 00     ..`A......`A....
  8041613550:	e9 e8 60 41 80 00 00 00 63 e9 60 41 80 00 00 00     ..`A....c.`A....
  8041613560:	01 ea 60 41 80 00 00 00 4b ec 60 41 80 00 00 00     ..`A....K.`A....
  8041613570:	3c e8 60 41 80 00 00 00 a4 e8 60 41 80 00 00 00     <.`A......`A....
  8041613580:	ac ec 60 41 80 00 00 00 65 ea 60 41 80 00 00 00     ..`A....e.`A....
  8041613590:	3f ec 60 41 80 00 00 00 98 ea 60 41 80 00 00 00     ?.`A......`A....
  80416135a0:	ba eb 60 41 80 00 00 00 51 ed 60 41 80 00 00 00     ..`A....Q.`A....
  80416135b0:	64 ed 60 41 80 00 00 00 6b 65 72 6e 2f 6b 64 65     d.`A....kern/kde
  80416135c0:	62 75 67 2e 63 00 63 75 72 65 6e 76 2d 3e 62 69     bug.c.curenv->bi
  80416135d0:	6e 61 72 79 00 3c 75 6e 6b 6e 6f 77 6e 3e 00 30     nary.<unknown>.0
  80416135e0:	31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 00     123456789ABCDEF.
  80416135f0:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
  8041613600:	00 28 6e 75 6c 6c 29 00 65 72 72 6f 72 20 25 64     .(null).error %d
  8041613610:	00 75 6e 73 70 65 63 69 66 69 65 64 20 65 72 72     .unspecified err
  8041613620:	6f 72 00 62 61 64 20 65 6e 76 69 72 6f 6e 6d 65     or.bad environme
  8041613630:	6e 74 00 69 6e 76 61 6c 69 64 20 70 61 72 61 6d     nt.invalid param
  8041613640:	65 74 65 72 00 6f 75 74 20 6f 66 20 6d 65 6d 6f     eter.out of memo
  8041613650:	72 79 00 6f 75 74 20 6f 66 20 65 6e 76 69 72 6f     ry.out of enviro
  8041613660:	6e 6d 65 6e 74 73 00 63 6f 72 72 75 70 74 65 64     nments.corrupted
  8041613670:	20 64 65 62 75 67 20 69 6e 66 6f 00 73 65 67 6d      debug info.segm
  8041613680:	65 6e 74 61 74 69 6f 6e 20 66 61 75 6c 74 00 69     entation fault.i
  8041613690:	6e 76 61 6c 69 64 20 45 4c 46 20 69 6d 61 67 65     nvalid ELF image
  80416136a0:	00 6e 6f 20 73 75 63 68 20 73 79 73 74 65 6d 20     .no such system 
  80416136b0:	63 61 6c 6c 00 65 6e 74 72 79 20 6e 6f 74 20 66     call.entry not f
  80416136c0:	6f 75 6e 64 00 65 6e 76 20 69 73 20 6e 6f 74 20     ound.env is not 
  80416136d0:	72 65 63 76 69 6e 67 00 75 6e 65 78 70 65 63 74     recving.unexpect
  80416136e0:	65 64 20 65 6e 64 20 6f 66 20 66 69 6c 65 00 6e     ed end of file.n
  80416136f0:	6f 20 66 72 65 65 20 73 70 61 63 65 20 6f 6e 20     o free space on 
  8041613700:	64 69 73 6b 00 74 6f 6f 20 6d 61 6e 79 20 66 69     disk.too many fi
  8041613710:	6c 65 73 20 61 72 65 20 6f 70 65 6e 00 66 69 6c     les are open.fil
  8041613720:	65 20 6f 72 20 62 6c 6f 63 6b 20 6e 6f 74 20 66     e or block not f
  8041613730:	6f 75 6e 64 00 69 6e 76 61 6c 69 64 20 70 61 74     ound.invalid pat
  8041613740:	68 00 66 69 6c 65 20 61 6c 72 65 61 64 79 20 65     h.file already e
  8041613750:	78 69 73 74 73 00 6f 70 65 72 61 74 69 6f 6e 20     xists.operation 
  8041613760:	6e 6f 74 20 73 75 70 70 6f 72 74 65 64 00 66 2e     not supported.f.
  8041613770:	0f 1f 84 00 00 00 00 00 0f 1f 84 00 00 00 00 00     ................
  8041613780:	d1 f3 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     ..`A....%.`A....
  8041613790:	15 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     ..`A....%.`A....
  80416137a0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416137b0:	25 fa 60 41 80 00 00 00 eb f3 60 41 80 00 00 00     %.`A......`A....
  80416137c0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416137d0:	e2 f3 60 41 80 00 00 00 58 f4 60 41 80 00 00 00     ..`A....X.`A....
  80416137e0:	25 fa 60 41 80 00 00 00 e2 f3 60 41 80 00 00 00     %.`A......`A....
  80416137f0:	25 f4 60 41 80 00 00 00 25 f4 60 41 80 00 00 00     %.`A....%.`A....
  8041613800:	25 f4 60 41 80 00 00 00 25 f4 60 41 80 00 00 00     %.`A....%.`A....
  8041613810:	25 f4 60 41 80 00 00 00 25 f4 60 41 80 00 00 00     %.`A....%.`A....
  8041613820:	25 f4 60 41 80 00 00 00 25 f4 60 41 80 00 00 00     %.`A....%.`A....
  8041613830:	25 f4 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613840:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613850:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613860:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613870:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613880:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613890:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416138a0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416138b0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416138c0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416138d0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416138e0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416138f0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613900:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613910:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613920:	25 fa 60 41 80 00 00 00 4a f9 60 41 80 00 00 00     %.`A....J.`A....
  8041613930:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613940:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613950:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613960:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613970:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613980:	76 f4 60 41 80 00 00 00 6c f6 60 41 80 00 00 00     v.`A....l.`A....
  8041613990:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416139a0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416139b0:	a4 f4 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     ..`A....%.`A....
  80416139c0:	25 fa 60 41 80 00 00 00 6b f4 60 41 80 00 00 00     %.`A....k.`A....
  80416139d0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  80416139e0:	0c f8 60 41 80 00 00 00 d4 f8 60 41 80 00 00 00     ..`A......`A....
  80416139f0:	25 fa 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     %.`A....%.`A....
  8041613a00:	3c f5 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     <.`A....%.`A....
  8041613a10:	3e f7 60 41 80 00 00 00 25 fa 60 41 80 00 00 00     >.`A....%.`A....
  8041613a20:	25 fa 60 41 80 00 00 00 4a f9 60 41 80 00 00 00     %.`A....J.`A....
  8041613a30:	25 fa 60 41 80 00 00 00 da f3 60 41 80 00 00 00     %.`A......`A....

0000008041613a40 <error_string>:
	...
  8041613a48:	11 36 61 41 80 00 00 00 23 36 61 41 80 00 00 00     .6aA....#6aA....
  8041613a58:	33 36 61 41 80 00 00 00 45 36 61 41 80 00 00 00     36aA....E6aA....
  8041613a68:	53 36 61 41 80 00 00 00 67 36 61 41 80 00 00 00     S6aA....g6aA....
  8041613a78:	7c 36 61 41 80 00 00 00 8f 36 61 41 80 00 00 00     |6aA.....6aA....
  8041613a88:	a1 36 61 41 80 00 00 00 b5 36 61 41 80 00 00 00     .6aA.....6aA....
  8041613a98:	c5 36 61 41 80 00 00 00 d8 36 61 41 80 00 00 00     .6aA.....6aA....
  8041613aa8:	ef 36 61 41 80 00 00 00 05 37 61 41 80 00 00 00     .6aA.....7aA....
  8041613ab8:	1d 37 61 41 80 00 00 00 35 37 61 41 80 00 00 00     .7aA....57aA....
  8041613ac8:	42 37 61 41 80 00 00 00 e0 3a 61 41 80 00 00 00     B7aA.....:aA....
  8041613ad8:	56 37 61 41 80 00 00 00 66 69 6c 65 20 69 73 20     V7aA....file is 
  8041613ae8:	6e 6f 74 20 61 20 76 61 6c 69 64 20 65 78 65 63     not a valid exec
  8041613af8:	75 74 61 62 6c 65 00 72 65 61 64 20 65 72 72 6f     utable.read erro
  8041613b08:	72 3a 20 25 69 0a 00 90 43 61 6e 27 74 20 63 61     r: %i...Can't ca
  8041613b18:	6c 69 62 72 61 74 65 20 70 69 74 20 74 69 6d 65     librate pit time
  8041613b28:	72 2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74     r. Using default
  8041613b38:	20 66 72 65 71 75 65 6e 63 79 0a 00 25 75 0a 00      frequency..%u..
  8041613b48:	54 69 6d 65 72 20 45 72 72 6f 72 0a 00 70 69 74     Timer Error..pit
  8041613b58:	00 70 6f 72 74 2d 6d 61 70 70 65 64 00 6d 65 6d     .port-mapped.mem
  8041613b68:	6f 72 79 2d 6d 61 70 70 65 64 00 1b 5b 39 36 6d     ory-mapped..[96m
  8041613b78:	20 20 2d 20 25 73 0a 00 7b 7b 7b 61 6c 72 65 61       - %s..{{{alrea
  8041613b88:	64 79 20 65 6e 61 62 6c 65 7d 64 7d 7d 7d 0a 00     dy enable}d}}}..
  8041613b98:	6b 65 72 6e 2f 70 63 69 2e 63 00 1b 5b 33 37 6d     kern/pci.c..[37m
  8041613ba8:	00 44 69 73 70 6c 61 79 00 55 6e 63 6c 61 73 73     .Display.Unclass
  8041613bb8:	69 66 69 65 64 20 64 65 76 69 63 65 00 4d 61 73     ified device.Mas
  8041613bc8:	73 20 73 74 6f 72 61 67 65 20 63 6f 6e 74 72 6f     s storage contro
  8041613bd8:	6c 6c 65 72 00 4e 65 74 77 6f 72 6b 20 63 6f 6e     ller.Network con
  8041613be8:	74 72 6f 6c 6c 65 72 00 44 69 73 70 6c 61 79 20     troller.Display 
  8041613bf8:	63 6f 6e 74 72 6f 6c 6c 65 72 00 4d 75 6c 74 69     controller.Multi
  8041613c08:	6d 65 64 69 61 20 63 6f 6e 74 72 6f 6c 6c 65 72     media controller
  8041613c18:	00 4d 65 6d 6f 72 79 20 63 6f 6e 74 72 6f 6c 6c     .Memory controll
  8041613c28:	65 72 00 42 72 69 64 67 65 00 43 6f 6d 6d 75 6e     er.Bridge.Commun
  8041613c38:	69 63 61 74 69 6f 6e 20 63 6f 6e 74 72 6f 6c 6c     ication controll
  8041613c48:	65 72 00 47 65 6e 65 72 69 63 20 73 79 73 74 65     er.Generic syste
  8041613c58:	6d 20 70 65 72 69 70 68 65 72 61 6c 00 49 6e 70     m peripheral.Inp
  8041613c68:	75 74 20 64 65 76 69 63 65 20 63 6f 6e 74 72 6f     ut device contro
  8041613c78:	6c 6c 65 72 00 44 6f 63 6b 69 6e 67 20 73 74 61     ller.Docking sta
  8041613c88:	74 69 6f 6e 00 50 72 6f 63 65 73 73 6f 72 00 53     tion.Processor.S
  8041613c98:	65 72 69 61 6c 20 62 75 73 20 63 6f 6e 74 72 6f     erial bus contro
  8041613ca8:	6c 6c 65 72 00 57 69 72 65 6c 65 73 73 20 63 6f     ller.Wireless co
  8041613cb8:	6e 74 72 6f 6c 6c 65 72 00 49 6e 74 65 6c 6c 69     ntroller.Intelli
  8041613cc8:	67 65 6e 74 20 63 6f 6e 74 72 6f 6c 6c 65 72 00     gent controller.
  8041613cd8:	45 6e 63 72 79 70 74 69 6f 6e 20 63 6f 6e 74 72     Encryption contr
  8041613ce8:	6f 6c 6c 65 72 00 53 69 67 6e 61 6c 20 70 72 6f     oller.Signal pro
  8041613cf8:	63 65 73 73 69 6e 67 20 63 6f 6e 74 72 6f 6c 6c     cessing controll
  8041613d08:	65 72 00 55 6e 61 73 73 69 67 6e 65 64 20 63 6c     er.Unassigned cl
  8041613d18:	61 73 73 00 0f 1f 40 00 1b 5b 39 34 6d 50 43 49     ass...@..[94mPCI
  8041613d28:	20 64 65 76 69 63 65 3a 20 25 34 58 3a 25 34 58      device: %4X:%4X
  8041613d38:	20 28 25 34 58 3a 25 34 58 29 20 7c 20 43 6c 61      (%4X:%4X) | Cla
  8041613d48:	73 73 20 25 58 20 53 75 62 20 25 58 20 7c 20 42     ss %X Sub %X | B
  8041613d58:	75 73 20 25 64 20 44 65 76 69 63 65 20 25 64 20     us %d Device %d 
  8041613d68:	46 75 6e 63 74 69 6f 6e 20 25 64 0a 00 00 00 00     Function %d.....
  8041613d78:	20 20 2d 20 42 41 52 25 75 3a 20 30 78 25 58 20       - BAR%u: 0x%X 
  8041613d88:	53 69 7a 65 3a 20 25 6c 64 20 28 25 73 29 0a 00     Size: %ld (%s)..
  8041613d98:	20 20 2d 20 49 6e 74 65 72 72 75 70 74 20 25 75       - Interrupt %u
  8041613da8:	20 28 50 69 6e 20 25 75 20 4c 69 6e 65 20 25 75      (Pin %u Line %u
  8041613db8:	1b 5b 30 6d 0a 00 00 00 4e 6f 74 20 65 6e 6f 75     .[0m....Not enou
  8041613dc8:	67 68 20 73 70 61 63 65 20 66 6f 72 20 50 43 49     gh space for PCI
  8041613dd8:	20 44 45 56 49 43 45 53 00 00 00 00 00 00 00 00      DEVICES........
  8041613de8:	47 65 74 74 69 6e 67 20 5f 50 52 54 20 66 6f 72     Getting _PRT for
  8041613df8:	20 62 75 73 20 25 75 20 6f 6e 20 64 65 76 69 63      bus %u on devic
  8041613e08:	65 20 25 75 2e 2e 2e 0a 00 00 00 00 00 00 00 00     e %u............
  8041613e18:	50 43 49 3a 20 45 6e 75 6d 65 72 61 74 69 6e 67     PCI: Enumerating
  8041613e28:	20 64 65 76 69 63 65 73 20 6f 6e 20 62 75 73 20      devices on bus 
  8041613e38:	25 75 2e 2e 2e 0a 00 00 1b 5b 33 32 6d 20 20 2d     %u.......[32m  -
  8041613e48:	20 53 63 61 6e 6e 69 6e 67 20 6f 74 68 65 72 20      Scanning other 
  8041613e58:	66 75 6e 63 74 69 6f 6e 73 20 6f 6e 20 6d 75 6c     functions on mul
  8041613e68:	74 69 66 75 6e 63 74 69 6f 6e 20 64 65 76 69 63     tifunction devic
  8041613e78:	65 21 1b 5b 30 6d 0a 00 1b 5b 33 32 6d 20 20 2d     e!.[0m...[32m  -
  8041613e88:	20 50 43 49 20 62 72 69 64 67 65 2c 20 50 72 69      PCI bridge, Pri
  8041613e98:	6d 61 72 79 20 25 58 20 53 65 63 6f 6e 64 61 72     mary %X Secondar
  8041613ea8:	79 20 25 58 2c 20 73 63 61 6e 6e 69 6e 67 20 6e     y %X, scanning n
  8041613eb8:	6f 77 2e 1b 5b 30 6d 0a 00 00 00 00 00 00 00 00     ow..[0m.........
  8041613ec8:	1b 5b 39 31 6d 20 20 2d 20 49 67 6e 6f 72 69 6e     .[91m  - Ignorin
  8041613ed8:	67 20 6e 6f 6e 2d 50 43 49 20 62 72 69 64 67 65     g non-PCI bridge
  8041613ee8:	1b 5b 30 6d 0a 00 00 00 50 43 49 3a 20 4c 6f 61     .[0m....PCI: Loa
  8041613ef8:	64 69 6e 67 20 64 72 69 76 65 72 73 20 66 6f 72     ding drivers for
  8041613f08:	20 64 65 76 69 63 65 73 2e 2e 2e 0a 00 00 00 00      devices........
  8041613f18:	53 61 74 65 6c 6c 69 74 65 20 63 6f 6d 6d 75 6e     Satellite commun
  8041613f28:	69 63 61 74 69 6f 6e 73 20 63 6f 6e 74 72 6f 6c     ications control
  8041613f38:	6c 65 72 00 0f 1f 40 00                             ler...@.

0000008041613f40 <PciDrivers>:
  8041613f40:	a9 3b 61 41 80 00 00 00 22 0f 61 41 80 00 00 00     .;aA....".aA....
	...
  8041613f60:	49 6e 69 74 69 61 6c 69 7a 69 6e 67 20 56 47 41     Initializing VGA
  8041613f70:	2e 2e 2e 0a 00 44 69 73 70 6c 61 79 20 61 64 64     .....Display add
  8041613f80:	72 3a 20 25 70 0a 00 56 47 41 20 49 6e 69 74 69     r: %p..VGA Initi
  8041613f90:	61 6c 69 7a 65 64 0a 00                             alized..
